
/*
* Description: Check a object, when it's avaiable exec the function, etc:
  $ready("CompanyNamespace.Package.FunctionName", function(){ 
      //do something with CompanyNamespace.Package.FunctionName;
  });
* Author: ChunLiang Zhang
*/


(function(window){

  window.$ready = function(tag, func) {
    var syncId, count = 200,
        tagAry = tag.split('.'), len = tagAry.length;

    var verify = function(){
      var i = 0, obj = window;

      do {
        obj = obj[tagAry[i]]
        if(!obj) return false;
      } while(++i < len);

      func();
      return true;
    };

    !verify() && (syncId = window.setInterval(function() {
      if (verify() || !count--) {
        window.clearInterval(syncId);
      }
    }, 150));

  };

})(window);

/*!
 * Project Name: Ford 2010/2011
 * File Build Date: Wed Aug 31 2016 15:36:40 GMT+0800 (CST)
 * Project Contribution: gbaker, isader, dbui, rqin, ltao 
 */

/*!
 * jQuery JavaScript Library v1.7.1
 * http://jquery.com/
 *
 * Copyright 2011, John Resig
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 * Copyright 2011, The Dojo Foundation
 * Released under the MIT, BSD, and GPL Licenses.
 *
 * Date: Mon Nov 21 21:11:03 2011 -0500
 */
(function( window, undefined ) {

// Use the correct document accordingly with window argument (sandbox)
var document = window.document,
	navigator = window.navigator,
	location = window.location;
var jQuery = (function() {

// Define a local copy of jQuery
var jQuery = function( selector, context ) {
		// The jQuery object is actually just the init constructor 'enhanced'
		return new jQuery.fn.init( selector, context, rootjQuery );
	},

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$,

	// A central reference to the root jQuery(document)
	rootjQuery,

	// A simple way to check for HTML strings or ID strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	quickExpr = /^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,

	// Check if a string has a non-whitespace character in it
	rnotwhite = /\S/,

	// Used for trimming whitespace
	trimLeft = /^\s+/,
	trimRight = /\s+$/,

	// Match a standalone tag
	rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>)?$/,

	// JSON RegExp
	rvalidchars = /^[\],:{}\s]*$/,
	rvalidescape = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
	rvalidtokens = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
	rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g,

	// Useragent RegExp
	rwebkit = /(webkit)[ \/]([\w.]+)/,
	ropera = /(opera)(?:.*version)?[ \/]([\w.]+)/,
	rmsie = /(msie) ([\w.]+)/,
	rmozilla = /(mozilla)(?:.*? rv:([\w.]+))?/,

	// Matches dashed string for camelizing
	rdashAlpha = /-([a-z]|[0-9])/ig,
	rmsPrefix = /^-ms-/,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return ( letter + "" ).toUpperCase();
	},

	// Keep a UserAgent string for use with jQuery.browser
	userAgent = navigator.userAgent,

	// For matching the engine and version of the browser
	browserMatch,

	// The deferred used on DOM ready
	readyList,

	// The ready event handler
	DOMContentLoaded,

	// Save a reference to some core methods
	toString = Object.prototype.toString,
	hasOwn = Object.prototype.hasOwnProperty,
	push = Array.prototype.push,
	slice = Array.prototype.slice,
	trim = String.prototype.trim,
	indexOf = Array.prototype.indexOf,

	// [[Class]] -> type pairs
	class2type = {};

jQuery.fn = jQuery.prototype = {
	constructor: jQuery,
	init: function( selector, context, rootjQuery ) {
		var match, elem, ret, doc;

		// Handle $(""), $(null), or $(undefined)
		if ( !selector ) {
			return this;
		}

		// Handle $(DOMElement)
		if ( selector.nodeType ) {
			this.context = this[0] = selector;
			this.length = 1;
			return this;
		}

		// The body element only exists once, optimize finding it
		if ( selector === "body" && !context && document.body ) {
			this.context = document;
			this[0] = document.body;
			this.selector = selector;
			this.length = 1;
			return this;
		}

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			// Are we dealing with HTML string or an ID?
			if ( selector.charAt(0) === "<" && selector.charAt( selector.length - 1 ) === ">" && selector.length >= 3 ) {
				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = quickExpr.exec( selector );
			}

			// Verify a match, and that no context was specified for #id
			if ( match && (match[1] || !context) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[1] ) {
					context = context instanceof jQuery ? context[0] : context;
					doc = ( context ? context.ownerDocument || context : document );

					// If a single string is passed in and it's a single tag
					// just do a createElement and skip the rest
					ret = rsingleTag.exec( selector );

					if ( ret ) {
						if ( jQuery.isPlainObject( context ) ) {
							selector = [ document.createElement( ret[1] ) ];
							jQuery.fn.attr.call( selector, context, true );

						} else {
							selector = [ doc.createElement( ret[1] ) ];
						}

					} else {
						ret = jQuery.buildFragment( [ match[1] ], [ doc ] );
						selector = ( ret.cacheable ? jQuery.clone(ret.fragment) : ret.fragment ).childNodes;
					}

					return jQuery.merge( this, selector );

				// HANDLE: $("#id")
				} else {
					elem = document.getElementById( match[2] );

					// Check parentNode to catch when Blackberry 4.6 returns
					// nodes that are no longer in the document #6963
					if ( elem && elem.parentNode ) {
						// Handle the case where IE and Opera return items
						// by name instead of ID
						if ( elem.id !== match[2] ) {
							return rootjQuery.find( selector );
						}

						// Otherwise, we inject the element directly into the jQuery object
						this.length = 1;
						this[0] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || rootjQuery ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return rootjQuery.ready( selector );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	},

	// Start with an empty selector
	selector: "",

	// The current version of jQuery being used
	jquery: "1.7.1",

	// The default length of a jQuery object is 0
	length: 0,

	// The number of elements contained in the matched element set
	size: function() {
		return this.length;
	},

	toArray: function() {
		return slice.call( this, 0 );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num == null ?

			// Return a 'clean' array
			this.toArray() :

			// Return just the object
			( num < 0 ? this[ this.length + num ] : this[ num ] );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems, name, selector ) {
		// Build a new jQuery matched element set
		var ret = this.constructor();

		if ( jQuery.isArray( elems ) ) {
			push.apply( ret, elems );

		} else {
			jQuery.merge( ret, elems );
		}

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		ret.context = this.context;

		if ( name === "find" ) {
			ret.selector = this.selector + ( this.selector ? " " : "" ) + selector;
		} else if ( name ) {
			ret.selector = this.selector + "." + name + "(" + selector + ")";
		}

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	// (You can seed the arguments with an array of args, but this is
	// only used internally.)
	each: function( callback, args ) {
		return jQuery.each( this, callback, args );
	},

	ready: function( fn ) {
		// Attach the listeners
		jQuery.bindReady();

		// Add the callback
		readyList.add( fn );

		return this;
	},

	eq: function( i ) {
		i = +i;
		return i === -1 ?
			this.slice( i ) :
			this.slice( i, i + 1 );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ),
			"slice", slice.call(arguments).join(",") );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map(this, function( elem, i ) {
			return callback.call( elem, i, elem );
		}));
	},

	end: function() {
		return this.prevObject || this.constructor(null);
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: [].sort,
	splice: [].splice
};

// Give the init function the jQuery prototype for later instantiation
jQuery.fn.init.prototype = jQuery.fn;

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction(target) ) {
		target = {};
	}

	// extend jQuery itself if only one argument is passed
	if ( length === i ) {
		target = this;
		--i;
	}

	for ( ; i < length; i++ ) {
		// Only deal with non-null/undefined values
		if ( (options = arguments[ i ]) != null ) {
			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {
					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray(src) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend({
	noConflict: function( deep ) {
		if ( window.$ === jQuery ) {
			window.$ = _$;
		}

		if ( deep && window.jQuery === jQuery ) {
			window.jQuery = _jQuery;
		}

		return jQuery;
	},

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {
		// Either a released hold or an DOMready/load event and not yet ready
		if ( (wait === true && !--jQuery.readyWait) || (wait !== true && !jQuery.isReady) ) {
			// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
			if ( !document.body ) {
				return setTimeout( jQuery.ready, 1 );
			}

			// Remember that the DOM is ready
			jQuery.isReady = true;

			// If a normal DOM Ready event fired, decrement, and wait if need be
			if ( wait !== true && --jQuery.readyWait > 0 ) {
				return;
			}

			// If there are functions bound, to execute
			readyList.fireWith( document, [ jQuery ] );

			// Trigger any bound ready events
			if ( jQuery.fn.trigger ) {
				jQuery( document ).trigger( "ready" ).off( "ready" );
			}
		}
	},

	bindReady: function() {
		if ( readyList ) {
			return;
		}

		readyList = jQuery.Callbacks( "once memory" );

		// Catch cases where $(document).ready() is called after the
		// browser event has already occurred.
		if ( document.readyState === "complete" ) {
			// Handle it asynchronously to allow scripts the opportunity to delay ready
			return setTimeout( jQuery.ready, 1 );
		}

		// Mozilla, Opera and webkit nightlies currently support this event
		if ( document.addEventListener ) {
			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", DOMContentLoaded, false );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", jQuery.ready, false );

		// If IE event model is used
		} else if ( document.attachEvent ) {
			// ensure firing before onload,
			// maybe late but safe also for iframes
			document.attachEvent( "onreadystatechange", DOMContentLoaded );

			// A fallback to window.onload, that will always work
			window.attachEvent( "onload", jQuery.ready );

			// If IE and not a frame
			// continually check to see if the document is ready
			var toplevel = false;

			try {
				toplevel = window.frameElement == null;
			} catch(e) {}

			if ( document.documentElement.doScroll && toplevel ) {
				doScrollCheck();
			}
		}
	},

	// See test/unit/core.js for details concerning isFunction.
	// Since version 1.3, DOM methods and functions like alert
	// aren't supported. They return false on IE (#2968).
	isFunction: function( obj ) {
		return jQuery.type(obj) === "function";
	},

	isArray: Array.isArray || function( obj ) {
		return jQuery.type(obj) === "array";
	},

	// A crude way of determining if an object is a window
	isWindow: function( obj ) {
		return obj && typeof obj === "object" && "setInterval" in obj;
	},

	isNumeric: function( obj ) {
		return !isNaN( parseFloat(obj) ) && isFinite( obj );
	},

	type: function( obj ) {
		return obj == null ?
			String( obj ) :
			class2type[ toString.call(obj) ] || "object";
	},

	isPlainObject: function( obj ) {
		// Must be an Object.
		// Because of IE, we also have to check the presence of the constructor property.
		// Make sure that DOM nodes and window objects don't pass through, as well
		if ( !obj || jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		try {
			// Not own constructor property must be Object
			if ( obj.constructor &&
				!hasOwn.call(obj, "constructor") &&
				!hasOwn.call(obj.constructor.prototype, "isPrototypeOf") ) {
				return false;
			}
		} catch ( e ) {
			// IE8,9 Will throw exceptions on certain host objects #9897
			return false;
		}

		// Own properties are enumerated firstly, so to speed up,
		// if last one is own, then all properties are own.

		var key;
		for ( key in obj ) {}

		return key === undefined || hasOwn.call( obj, key );
	},

	isEmptyObject: function( obj ) {
		for ( var name in obj ) {
			return false;
		}
		return true;
	},

	error: function( msg ) {
		throw new Error( msg );
	},

	parseJSON: function( data ) {
		if ( typeof data !== "string" || !data ) {
			return null;
		}

		// Make sure leading/trailing whitespace is removed (IE can't handle it)
		data = jQuery.trim( data );

		// Attempt to parse using the native JSON parser first
		if ( window.JSON && window.JSON.parse ) {
			return window.JSON.parse( data );
		}

		// Make sure the incoming data is actual JSON
		// Logic borrowed from http://json.org/json2.js
		if ( rvalidchars.test( data.replace( rvalidescape, "@" )
			.replace( rvalidtokens, "]" )
			.replace( rvalidbraces, "")) ) {

			return ( new Function( "return " + data ) )();

		}
		jQuery.error( "Invalid JSON: " + data );
	},

	// Cross-browser xml parsing
	parseXML: function( data ) {
		var xml, tmp;
		try {
			if ( window.DOMParser ) { // Standard
				tmp = new DOMParser();
				xml = tmp.parseFromString( data , "text/xml" );
			} else { // IE
				xml = new ActiveXObject( "Microsoft.XMLDOM" );
				xml.async = "false";
				xml.loadXML( data );
			}
		} catch( e ) {
			xml = undefined;
		}
		if ( !xml || !xml.documentElement || xml.getElementsByTagName( "parsererror" ).length ) {
			jQuery.error( "Invalid XML: " + data );
		}
		return xml;
	},

	noop: function() {},

	// Evaluates a script in a global context
	// Workarounds based on findings by Jim Driscoll
	// http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context
	globalEval: function( data ) {
		if ( data && rnotwhite.test( data ) ) {
			// We use execScript on Internet Explorer
			// We use an anonymous function so that context is window
			// rather than jQuery in Firefox
			( window.execScript || function( data ) {
				window[ "eval" ].call( window, data );
			} )( data );
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toUpperCase() === name.toUpperCase();
	},

	// args is for internal usage only
	each: function( object, callback, args ) {
		var name, i = 0,
			length = object.length,
			isObj = length === undefined || jQuery.isFunction( object );

		if ( args ) {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.apply( object[ name ], args ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.apply( object[ i++ ], args ) === false ) {
						break;
					}
				}
			}

		// A special, fast, case for the most common use of each
		} else {
			if ( isObj ) {
				for ( name in object ) {
					if ( callback.call( object[ name ], name, object[ name ] ) === false ) {
						break;
					}
				}
			} else {
				for ( ; i < length; ) {
					if ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {
						break;
					}
				}
			}
		}

		return object;
	},

	// Use native String.trim function wherever possible
	trim: trim ?
		function( text ) {
			return text == null ?
				"" :
				trim.call( text );
		} :

		// Otherwise use our own trimming functionality
		function( text ) {
			return text == null ?
				"" :
				text.toString().replace( trimLeft, "" ).replace( trimRight, "" );
		},

	// results is for internal usage only
	makeArray: function( array, results ) {
		var ret = results || [];

		if ( array != null ) {
			// The window, strings (and functions) also have 'length'
			// Tweaked logic slightly to handle Blackberry 4.7 RegExp issues #6930
			var type = jQuery.type( array );

			if ( array.length == null || type === "string" || type === "function" || type === "regexp" || jQuery.isWindow( array ) ) {
				push.call( ret, array );
			} else {
				jQuery.merge( ret, array );
			}
		}

		return ret;
	},

	inArray: function( elem, array, i ) {
		var len;

		if ( array ) {
			if ( indexOf ) {
				return indexOf.call( array, elem, i );
			}

			len = array.length;
			i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;

			for ( ; i < len; i++ ) {
				// Skip accessing in sparse arrays
				if ( i in array && array[ i ] === elem ) {
					return i;
				}
			}
		}

		return -1;
	},

	merge: function( first, second ) {
		var i = first.length,
			j = 0;

		if ( typeof second.length === "number" ) {
			for ( var l = second.length; j < l; j++ ) {
				first[ i++ ] = second[ j ];
			}

		} else {
			while ( second[j] !== undefined ) {
				first[ i++ ] = second[ j++ ];
			}
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, inv ) {
		var ret = [], retVal;
		inv = !!inv;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( var i = 0, length = elems.length; i < length; i++ ) {
			retVal = !!callback( elems[ i ], i );
			if ( inv !== retVal ) {
				ret.push( elems[ i ] );
			}
		}

		return ret;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var value, key, ret = [],
			i = 0,
			length = elems.length,
			// jquery objects are treated as arrays
			isArray = elems instanceof jQuery || length !== undefined && typeof length === "number" && ( ( length > 0 && elems[ 0 ] && elems[ length -1 ] ) || length === 0 || jQuery.isArray( elems ) ) ;

		// Go through the array, translating each of the items to their
		if ( isArray ) {
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}

		// Go through every key on the object,
		} else {
			for ( key in elems ) {
				value = callback( elems[ key ], key, arg );

				if ( value != null ) {
					ret[ ret.length ] = value;
				}
			}
		}

		// Flatten any nested arrays
		return ret.concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		if ( typeof context === "string" ) {
			var tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		var args = slice.call( arguments, 2 ),
			proxy = function() {
				return fn.apply( context, args.concat( slice.call( arguments ) ) );
			};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || proxy.guid || jQuery.guid++;

		return proxy;
	},

	// Mutifunctional method to get and set values to a collection
	// The value/s can optionally be executed if it's a function
	access: function( elems, key, value, exec, fn, pass ) {
		var length = elems.length;

		// Setting many attributes
		if ( typeof key === "object" ) {
			for ( var k in key ) {
				jQuery.access( elems, k, key[k], exec, fn, value );
			}
			return elems;
		}

		// Setting one attribute
		if ( value !== undefined ) {
			// Optionally, function values get executed if exec is true
			exec = !pass && exec && jQuery.isFunction(value);

			for ( var i = 0; i < length; i++ ) {
				fn( elems[i], key, exec ? value.call( elems[i], i, fn( elems[i], key ) ) : value, pass );
			}

			return elems;
		}

		// Getting an attribute
		return length ? fn( elems[0], key ) : undefined;
	},

	now: function() {
		return ( new Date() ).getTime();
	},

	// Use of jQuery.browser is frowned upon.
	// More details: http://docs.jquery.com/Utilities/jQuery.browser
	uaMatch: function( ua ) {
		ua = ua.toLowerCase();

		var match = rwebkit.exec( ua ) ||
			ropera.exec( ua ) ||
			rmsie.exec( ua ) ||
			ua.indexOf("compatible") < 0 && rmozilla.exec( ua ) ||
			[];

		return { browser: match[1] || "", version: match[2] || "0" };
	},

	sub: function() {
		function jQuerySub( selector, context ) {
			return new jQuerySub.fn.init( selector, context );
		}
		jQuery.extend( true, jQuerySub, this );
		jQuerySub.superclass = this;
		jQuerySub.fn = jQuerySub.prototype = this();
		jQuerySub.fn.constructor = jQuerySub;
		jQuerySub.sub = this.sub;
		jQuerySub.fn.init = function init( selector, context ) {
			if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
				context = jQuerySub( context );
			}

			return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
		};
		jQuerySub.fn.init.prototype = jQuerySub.fn;
		var rootjQuerySub = jQuerySub(document);
		return jQuerySub;
	},

	browser: {}
});

// Populate the class2type map
jQuery.each("Boolean Number String Function Array Date RegExp Object".split(" "), function(i, name) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
});

browserMatch = jQuery.uaMatch( userAgent );
if ( browserMatch.browser ) {
	jQuery.browser[ browserMatch.browser ] = true;
	jQuery.browser.version = browserMatch.version;
}

// Deprecated, use jQuery.browser.webkit instead
if ( jQuery.browser.webkit ) {
	jQuery.browser.safari = true;
}

// IE doesn't match non-breaking spaces with \s
if ( rnotwhite.test( "\xA0" ) ) {
	trimLeft = /^[\s\xA0]+/;
	trimRight = /[\s\xA0]+$/;
}

// All jQuery objects should point back to these
rootjQuery = jQuery(document);

// Cleanup functions for the document ready method
if ( document.addEventListener ) {
	DOMContentLoaded = function() {
		document.removeEventListener( "DOMContentLoaded", DOMContentLoaded, false );
		jQuery.ready();
	};

} else if ( document.attachEvent ) {
	DOMContentLoaded = function() {
		// Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
		if ( document.readyState === "complete" ) {
			document.detachEvent( "onreadystatechange", DOMContentLoaded );
			jQuery.ready();
		}
	};
}

// The DOM ready check for Internet Explorer
function doScrollCheck() {
	if ( jQuery.isReady ) {
		return;
	}

	try {
		// If IE is used, use the trick by Diego Perini
		// http://javascript.nwbox.com/IEContentLoaded/
		document.documentElement.doScroll("left");
	} catch(e) {
		setTimeout( doScrollCheck, 1 );
		return;
	}

	// and execute any waiting functions
	jQuery.ready();
}

return jQuery;

})();


// String to Object flags format cache
var flagsCache = {};

// Convert String-formatted flags into Object-formatted ones and store in cache
function createFlags( flags ) {
	var object = flagsCache[ flags ] = {},
		i, length;
	flags = flags.split( /\s+/ );
	for ( i = 0, length = flags.length; i < length; i++ ) {
		object[ flags[i] ] = true;
	}
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	flags:	an optional list of space-separated flags that will change how
 *			the callback list behaves
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible flags:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( flags ) {

	// Convert flags from String-formatted to Object-formatted
	// (we check in cache first)
	flags = flags ? ( flagsCache[ flags ] || createFlags( flags ) ) : {};

	var // Actual callback list
		list = [],
		// Stack of fire calls for repeatable lists
		stack = [],
		// Last fire value (for non-forgettable lists)
		memory,
		// Flag to know if list is currently firing
		firing,
		// First callback to fire (used internally by add and fireWith)
		firingStart,
		// End of the loop when firing
		firingLength,
		// Index of currently firing callback (modified by remove if needed)
		firingIndex,
		// Add one or several callbacks to the list
		add = function( args ) {
			var i,
				length,
				elem,
				type,
				actual;
			for ( i = 0, length = args.length; i < length; i++ ) {
				elem = args[ i ];
				type = jQuery.type( elem );
				if ( type === "array" ) {
					// Inspect recursively
					add( elem );
				} else if ( type === "function" ) {
					// Add if not in unique mode and callback is not in
					if ( !flags.unique || !self.has( elem ) ) {
						list.push( elem );
					}
				}
			}
		},
		// Fire callbacks
		fire = function( context, args ) {
			args = args || [];
			memory = !flags.memory || [ context, args ];
			firing = true;
			firingIndex = firingStart || 0;
			firingStart = 0;
			firingLength = list.length;
			for ( ; list && firingIndex < firingLength; firingIndex++ ) {
				if ( list[ firingIndex ].apply( context, args ) === false && flags.stopOnFalse ) {
					memory = true; // Mark as halted
					break;
				}
			}
			firing = false;
			if ( list ) {
				if ( !flags.once ) {
					if ( stack && stack.length ) {
						memory = stack.shift();
						self.fireWith( memory[ 0 ], memory[ 1 ] );
					}
				} else if ( memory === true ) {
					self.disable();
				} else {
					list = [];
				}
			}
		},
		// Actual Callbacks object
		self = {
			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {
					var length = list.length;
					add( arguments );
					// Do we need to add the callbacks to the
					// current firing batch?
					if ( firing ) {
						firingLength = list.length;
					// With memory, if we're not firing then
					// we should call right away, unless previous
					// firing was halted (stopOnFalse)
					} else if ( memory && memory !== true ) {
						firingStart = length;
						fire( memory[ 0 ], memory[ 1 ] );
					}
				}
				return this;
			},
			// Remove a callback from the list
			remove: function() {
				if ( list ) {
					var args = arguments,
						argIndex = 0,
						argLength = args.length;
					for ( ; argIndex < argLength ; argIndex++ ) {
						for ( var i = 0; i < list.length; i++ ) {
							if ( args[ argIndex ] === list[ i ] ) {
								// Handle firingIndex and firingLength
								if ( firing ) {
									if ( i <= firingLength ) {
										firingLength--;
										if ( i <= firingIndex ) {
											firingIndex--;
										}
									}
								}
								// Remove the element
								list.splice( i--, 1 );
								// If we have some unicity property then
								// we only need to do this once
								if ( flags.unique ) {
									break;
								}
							}
						}
					}
				}
				return this;
			},
			// Control if a given callback is in the list
			has: function( fn ) {
				if ( list ) {
					var i = 0,
						length = list.length;
					for ( ; i < length; i++ ) {
						if ( fn === list[ i ] ) {
							return true;
						}
					}
				}
				return false;
			},
			// Remove all callbacks from the list
			empty: function() {
				list = [];
				return this;
			},
			// Have the list do nothing anymore
			disable: function() {
				list = stack = memory = undefined;
				return this;
			},
			// Is it disabled?
			disabled: function() {
				return !list;
			},
			// Lock the list in its current state
			lock: function() {
				stack = undefined;
				if ( !memory || memory === true ) {
					self.disable();
				}
				return this;
			},
			// Is it locked?
			locked: function() {
				return !stack;
			},
			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( stack ) {
					if ( firing ) {
						if ( !flags.once ) {
							stack.push( [ context, args ] );
						}
					} else if ( !( flags.once && memory ) ) {
						fire( context, args );
					}
				}
				return this;
			},
			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},
			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!memory;
			}
		};

	return self;
};




var // Static reference to slice
	sliceDeferred = [].slice;

jQuery.extend({

	Deferred: function( func ) {
		var doneList = jQuery.Callbacks( "once memory" ),
			failList = jQuery.Callbacks( "once memory" ),
			progressList = jQuery.Callbacks( "memory" ),
			state = "pending",
			lists = {
				resolve: doneList,
				reject: failList,
				notify: progressList
			},
			promise = {
				done: doneList.add,
				fail: failList.add,
				progress: progressList.add,

				state: function() {
					return state;
				},

				// Deprecated
				isResolved: doneList.fired,
				isRejected: failList.fired,

				then: function( doneCallbacks, failCallbacks, progressCallbacks ) {
					deferred.done( doneCallbacks ).fail( failCallbacks ).progress( progressCallbacks );
					return this;
				},
				always: function() {
					deferred.done.apply( deferred, arguments ).fail.apply( deferred, arguments );
					return this;
				},
				pipe: function( fnDone, fnFail, fnProgress ) {
					return jQuery.Deferred(function( newDefer ) {
						jQuery.each( {
							done: [ fnDone, "resolve" ],
							fail: [ fnFail, "reject" ],
							progress: [ fnProgress, "notify" ]
						}, function( handler, data ) {
							var fn = data[ 0 ],
								action = data[ 1 ],
								returned;
							if ( jQuery.isFunction( fn ) ) {
								deferred[ handler ](function() {
									returned = fn.apply( this, arguments );
									if ( returned && jQuery.isFunction( returned.promise ) ) {
										returned.promise().then( newDefer.resolve, newDefer.reject, newDefer.notify );
									} else {
										newDefer[ action + "With" ]( this === deferred ? newDefer : this, [ returned ] );
									}
								});
							} else {
								deferred[ handler ]( newDefer[ action ] );
							}
						});
					}).promise();
				},
				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					if ( obj == null ) {
						obj = promise;
					} else {
						for ( var key in promise ) {
							obj[ key ] = promise[ key ];
						}
					}
					return obj;
				}
			},
			deferred = promise.promise({}),
			key;

		for ( key in lists ) {
			deferred[ key ] = lists[ key ].fire;
			deferred[ key + "With" ] = lists[ key ].fireWith;
		}

		// Handle state
		deferred.done( function() {
			state = "resolved";
		}, failList.disable, progressList.lock ).fail( function() {
			state = "rejected";
		}, doneList.disable, progressList.lock );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( firstParam ) {
		var args = sliceDeferred.call( arguments, 0 ),
			i = 0,
			length = args.length,
			pValues = new Array( length ),
			count = length,
			pCount = length,
			deferred = length <= 1 && firstParam && jQuery.isFunction( firstParam.promise ) ?
				firstParam :
				jQuery.Deferred(),
			promise = deferred.promise();
		function resolveFunc( i ) {
			return function( value ) {
				args[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				if ( !( --count ) ) {
					deferred.resolveWith( deferred, args );
				}
			};
		}
		function progressFunc( i ) {
			return function( value ) {
				pValues[ i ] = arguments.length > 1 ? sliceDeferred.call( arguments, 0 ) : value;
				deferred.notifyWith( promise, pValues );
			};
		}
		if ( length > 1 ) {
			for ( ; i < length; i++ ) {
				if ( args[ i ] && args[ i ].promise && jQuery.isFunction( args[ i ].promise ) ) {
					args[ i ].promise().then( resolveFunc(i), deferred.reject, progressFunc(i) );
				} else {
					--count;
				}
			}
			if ( !count ) {
				deferred.resolveWith( deferred, args );
			}
		} else if ( deferred !== firstParam ) {
			deferred.resolveWith( deferred, length ? [ firstParam ] : [] );
		}
		return promise;
	}
});




jQuery.support = (function() {

	var support,
		all,
		a,
		select,
		opt,
		input,
		marginDiv,
		fragment,
		tds,
		events,
		eventName,
		i,
		isSupported,
		div = document.createElement( "div" ),
		documentElement = document.documentElement;

	// Preliminary tests
	div.setAttribute("className", "t");
	div.innerHTML = "   <link/><table></table><a href='/a' style='top:1px;float:left;opacity:.55;'>a</a><input type='checkbox'/>";

	all = div.getElementsByTagName( "*" );
	a = div.getElementsByTagName( "a" )[ 0 ];

	// Can't get basic test support
	if ( !all || !all.length || !a ) {
		return {};
	}

	// First batch of supports tests
	select = document.createElement( "select" );
	opt = select.appendChild( document.createElement("option") );
	input = div.getElementsByTagName( "input" )[ 0 ];

	support = {
		// IE strips leading whitespace when .innerHTML is used
		leadingWhitespace: ( div.firstChild.nodeType === 3 ),

		// Make sure that tbody elements aren't automatically inserted
		// IE will insert them into empty tables
		tbody: !div.getElementsByTagName("tbody").length,

		// Make sure that link elements get serialized correctly by innerHTML
		// This requires a wrapper element in IE
		htmlSerialize: !!div.getElementsByTagName("link").length,

		// Get the style information from getAttribute
		// (IE uses .cssText instead)
		style: /top/.test( a.getAttribute("style") ),

		// Make sure that URLs aren't manipulated
		// (IE normalizes it by default)
		hrefNormalized: ( a.getAttribute("href") === "/a" ),

		// Make sure that element opacity exists
		// (IE uses filter instead)
		// Use a regex to work around a WebKit issue. See #5145
		opacity: /^0.55/.test( a.style.opacity ),

		// Verify style float existence
		// (IE uses styleFloat instead of cssFloat)
		cssFloat: !!a.style.cssFloat,

		// Make sure that if no value is specified for a checkbox
		// that it defaults to "on".
		// (WebKit defaults to "" instead)
		checkOn: ( input.value === "on" ),

		// Make sure that a selected-by-default option has a working selected property.
		// (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
		optSelected: opt.selected,

		// Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
		getSetAttribute: div.className !== "t",

		// Tests for enctype support on a form(#6743)
		enctype: !!document.createElement("form").enctype,

		// Makes sure cloning an html5 element does not cause problems
		// Where outerHTML is undefined, this still works
		html5Clone: document.createElement("nav").cloneNode( true ).outerHTML !== "<:nav></:nav>",

		// Will be defined later
		submitBubbles: true,
		changeBubbles: true,
		focusinBubbles: false,
		deleteExpando: true,
		noCloneEvent: true,
		inlineBlockNeedsLayout: false,
		shrinkWrapBlocks: false,
		reliableMarginRight: true
	};

	// Make sure checked status is properly cloned
	input.checked = true;
	support.noCloneChecked = input.cloneNode( true ).checked;

	// Make sure that the options inside disabled selects aren't marked as disabled
	// (WebKit marks them as disabled)
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Test to see if it's possible to delete an expando from an element
	// Fails in Internet Explorer
	try {
		delete div.test;
	} catch( e ) {
		support.deleteExpando = false;
	}

	if ( !div.addEventListener && div.attachEvent && div.fireEvent ) {
		div.attachEvent( "onclick", function() {
			// Cloning a node shouldn't copy over any
			// bound event handlers (IE does this)
			support.noCloneEvent = false;
		});
		div.cloneNode( true ).fireEvent( "onclick" );
	}

	// Check if a radio maintains its value
	// after being appended to the DOM
	input = document.createElement("input");
	input.value = "t";
	input.setAttribute("type", "radio");
	support.radioValue = input.value === "t";

	input.setAttribute("checked", "checked");
	div.appendChild( input );
	fragment = document.createDocumentFragment();
	fragment.appendChild( div.lastChild );

	// WebKit doesn't clone checked state correctly in fragments
	support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Check if a disconnected checkbox will retain its checked
	// value of true after appended to the DOM (IE6/7)
	support.appendChecked = input.checked;

	fragment.removeChild( input );
	fragment.appendChild( div );

	div.innerHTML = "";

	// Check if div with explicit width and no margin-right incorrectly
	// gets computed margin-right based on width of container. For more
	// info see bug #3333
	// Fails in WebKit before Feb 2011 nightlies
	// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
	if ( window.getComputedStyle ) {
		marginDiv = document.createElement( "div" );
		marginDiv.style.width = "0";
		marginDiv.style.marginRight = "0";
		div.style.width = "2px";
		div.appendChild( marginDiv );
		support.reliableMarginRight =
			( parseInt( ( window.getComputedStyle( marginDiv, null ) || { marginRight: 0 } ).marginRight, 10 ) || 0 ) === 0;
	}

	// Technique from Juriy Zaytsev
	// http://perfectionkills.com/detecting-event-support-without-browser-sniffing/
	// We only care about the case where non-standard event systems
	// are used, namely in IE. Short-circuiting here helps us to
	// avoid an eval call (in setAttribute) which can cause CSP
	// to go haywire. See: https://developer.mozilla.org/en/Security/CSP
	if ( div.attachEvent ) {
		for( i in {
			submit: 1,
			change: 1,
			focusin: 1
		}) {
			eventName = "on" + i;
			isSupported = ( eventName in div );
			if ( !isSupported ) {
				div.setAttribute( eventName, "return;" );
				isSupported = ( typeof div[ eventName ] === "function" );
			}
			support[ i + "Bubbles" ] = isSupported;
		}
	}

	fragment.removeChild( div );

	// Null elements to avoid leaks in IE
	fragment = select = opt = marginDiv = div = input = null;

	// Run tests that need a body at doc ready
	jQuery(function() {
		var container, outer, inner, table, td, offsetSupport,
			conMarginTop, ptlm, vb, style, html,
			body = document.getElementsByTagName("body")[0];

		if ( !body ) {
			// Return for frameset docs that don't have a body
			return;
		}

		conMarginTop = 1;
		ptlm = "position:absolute;top:0;left:0;width:1px;height:1px;margin:0;";
		vb = "visibility:hidden;border:0;";
		style = "style='" + ptlm + "border:5px solid #000;padding:0;'";
		html = "<div " + style + "><div></div></div>" +
			"<table " + style + " cellpadding='0' cellspacing='0'>" +
			"<tr><td></td></tr></table>";

		container = document.createElement("div");
		container.style.cssText = vb + "width:0;height:0;position:static;top:0;margin-top:" + conMarginTop + "px";
		body.insertBefore( container, body.firstChild );

		// Construct the test element
		div = document.createElement("div");
		container.appendChild( div );

		// Check if table cells still have offsetWidth/Height when they are set
		// to display:none and there are still other visible table cells in a
		// table row; if so, offsetWidth/Height are not reliable for use when
		// determining if an element has been hidden directly using
		// display:none (it is still safe to use offsets if a parent element is
		// hidden; don safety goggles and see bug #4512 for more information).
		// (only IE 8 fails this test)
		div.innerHTML = "<table><tr><td style='padding:0;border:0;display:none'></td><td>t</td></tr></table>";
		tds = div.getElementsByTagName( "td" );
		isSupported = ( tds[ 0 ].offsetHeight === 0 );

		tds[ 0 ].style.display = "";
		tds[ 1 ].style.display = "none";

		// Check if empty table cells still have offsetWidth/Height
		// (IE <= 8 fail this test)
		support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );

		// Figure out if the W3C box model works as expected
		div.innerHTML = "";
		div.style.width = div.style.paddingLeft = "1px";
		jQuery.boxModel = support.boxModel = div.offsetWidth === 2;

		if ( typeof div.style.zoom !== "undefined" ) {
			// Check if natively block-level elements act like inline-block
			// elements when setting their display to 'inline' and giving
			// them layout
			// (IE < 8 does this)
			div.style.display = "inline";
			div.style.zoom = 1;
			support.inlineBlockNeedsLayout = ( div.offsetWidth === 2 );

			// Check if elements with layout shrink-wrap their children
			// (IE 6 does this)
			div.style.display = "";
			div.innerHTML = "<div style='width:4px;'></div>";
			support.shrinkWrapBlocks = ( div.offsetWidth !== 2 );
		}

		div.style.cssText = ptlm + vb;
		div.innerHTML = html;

		outer = div.firstChild;
		inner = outer.firstChild;
		td = outer.nextSibling.firstChild.firstChild;

		offsetSupport = {
			doesNotAddBorder: ( inner.offsetTop !== 5 ),
			doesAddBorderForTableAndCells: ( td.offsetTop === 5 )
		};

		inner.style.position = "fixed";
		inner.style.top = "20px";

		// safari subtracts parent border width here which is 5px
		offsetSupport.fixedPosition = ( inner.offsetTop === 20 || inner.offsetTop === 15 );
		inner.style.position = inner.style.top = "";

		outer.style.overflow = "hidden";
		outer.style.position = "relative";

		offsetSupport.subtractsBorderForOverflowNotVisible = ( inner.offsetTop === -5 );
		offsetSupport.doesNotIncludeMarginInBodyOffset = ( body.offsetTop !== conMarginTop );

		body.removeChild( container );
		div  = container = null;

		jQuery.extend( support, offsetSupport );
	});

	return support;
})();




var rbrace = /^(?:\{.*\}|\[.*\])$/,
	rmultiDash = /([A-Z])/g;

jQuery.extend({
	cache: {},

	// Please use with caution
	uuid: 0,

	// Unique for each copy of jQuery on the page
	// Non-digits removed to match rinlinejQuery
	expando: "jQuery" + ( jQuery.fn.jquery + Math.random() ).replace( /\D/g, "" ),

	// The following elements throw uncatchable exceptions if you
	// attempt to add expando properties to them.
	noData: {
		"embed": true,
		// Ban all objects except for Flash (which handle expandos)
		"object": "clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",
		"applet": true
	},

	hasData: function( elem ) {
		elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];
		return !!elem && !isEmptyDataObject( elem );
	},

	data: function( elem, name, data, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var privateCache, thisCache, ret,
			internalKey = jQuery.expando,
			getByName = typeof name === "string",

			// We have to handle DOM nodes and JS objects differently because IE6-7
			// can't GC object references properly across the DOM-JS boundary
			isNode = elem.nodeType,

			// Only DOM nodes need the global jQuery cache; JS object data is
			// attached directly to the object so GC can occur automatically
			cache = isNode ? jQuery.cache : elem,

			// Only defining an ID for JS objects if its cache already exists allows
			// the code to shortcut on the same path as a DOM node with no cache
			id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey,
			isEvents = name === "events";

		// Avoid doing any more work than we need to when trying to get data on an
		// object that has no data at all
		if ( (!id || !cache[id] || (!isEvents && !pvt && !cache[id].data)) && getByName && data === undefined ) {
			return;
		}

		if ( !id ) {
			// Only DOM nodes need a new unique ID for each element since their data
			// ends up in the global cache
			if ( isNode ) {
				elem[ internalKey ] = id = ++jQuery.uuid;
			} else {
				id = internalKey;
			}
		}

		if ( !cache[ id ] ) {
			cache[ id ] = {};

			// Avoids exposing jQuery metadata on plain JS objects when the object
			// is serialized using JSON.stringify
			if ( !isNode ) {
				cache[ id ].toJSON = jQuery.noop;
			}
		}

		// An object can be passed to jQuery.data instead of a key/value pair; this gets
		// shallow copied over onto the existing cache
		if ( typeof name === "object" || typeof name === "function" ) {
			if ( pvt ) {
				cache[ id ] = jQuery.extend( cache[ id ], name );
			} else {
				cache[ id ].data = jQuery.extend( cache[ id ].data, name );
			}
		}

		privateCache = thisCache = cache[ id ];

		// jQuery data() is stored in a separate object inside the object's internal data
		// cache in order to avoid key collisions between internal data and user-defined
		// data.
		if ( !pvt ) {
			if ( !thisCache.data ) {
				thisCache.data = {};
			}

			thisCache = thisCache.data;
		}

		if ( data !== undefined ) {
			thisCache[ jQuery.camelCase( name ) ] = data;
		}

		// Users should not attempt to inspect the internal events object using jQuery.data,
		// it is undocumented and subject to change. But does anyone listen? No.
		if ( isEvents && !thisCache[ name ] ) {
			return privateCache.events;
		}

		// Check for both converted-to-camel and non-converted data property names
		// If a data property was specified
		if ( getByName ) {

			// First Try to find as-is property data
			ret = thisCache[ name ];

			// Test for null|undefined property data
			if ( ret == null ) {

				// Try to find the camelCased property
				ret = thisCache[ jQuery.camelCase( name ) ];
			}
		} else {
			ret = thisCache;
		}

		return ret;
	},

	removeData: function( elem, name, pvt /* Internal Use Only */ ) {
		if ( !jQuery.acceptData( elem ) ) {
			return;
		}

		var thisCache, i, l,

			// Reference to internal data cache key
			internalKey = jQuery.expando,

			isNode = elem.nodeType,

			// See jQuery.data for more information
			cache = isNode ? jQuery.cache : elem,

			// See jQuery.data for more information
			id = isNode ? elem[ internalKey ] : internalKey;

		// If there is already no cache entry for this object, there is no
		// purpose in continuing
		if ( !cache[ id ] ) {
			return;
		}

		if ( name ) {

			thisCache = pvt ? cache[ id ] : cache[ id ].data;

			if ( thisCache ) {

				// Support array or space separated string names for data keys
				if ( !jQuery.isArray( name ) ) {

					// try the string as a key before any manipulation
					if ( name in thisCache ) {
						name = [ name ];
					} else {

						// split the camel cased version by spaces unless a key with the spaces exists
						name = jQuery.camelCase( name );
						if ( name in thisCache ) {
							name = [ name ];
						} else {
							name = name.split( " " );
						}
					}
				}

				for ( i = 0, l = name.length; i < l; i++ ) {
					delete thisCache[ name[i] ];
				}

				// If there is no data left in the cache, we want to continue
				// and let the cache object itself get destroyed
				if ( !( pvt ? isEmptyDataObject : jQuery.isEmptyObject )( thisCache ) ) {
					return;
				}
			}
		}

		// See jQuery.data for more information
		if ( !pvt ) {
			delete cache[ id ].data;

			// Don't destroy the parent cache unless the internal data object
			// had been the only thing left in it
			if ( !isEmptyDataObject(cache[ id ]) ) {
				return;
			}
		}

		// Browsers that fail expando deletion also refuse to delete expandos on
		// the window, but it will allow it on all other JS objects; other browsers
		// don't care
		// Ensure that `cache` is not a window object #10080
		if ( jQuery.support.deleteExpando || !cache.setInterval ) {
			delete cache[ id ];
		} else {
			cache[ id ] = null;
		}

		// We destroyed the cache and need to eliminate the expando on the node to avoid
		// false lookups in the cache for entries that no longer exist
		if ( isNode ) {
			// IE does not allow us to delete expando properties from nodes,
			// nor does it have a removeAttribute function on Document nodes;
			// we must handle all of these cases
			if ( jQuery.support.deleteExpando ) {
				delete elem[ internalKey ];
			} else if ( elem.removeAttribute ) {
				elem.removeAttribute( internalKey );
			} else {
				elem[ internalKey ] = null;
			}
		}
	},

	// For internal use only.
	_data: function( elem, name, data ) {
		return jQuery.data( elem, name, data, true );
	},

	// A method for determining if a DOM node can handle the data expando
	acceptData: function( elem ) {
		if ( elem.nodeName ) {
			var match = jQuery.noData[ elem.nodeName.toLowerCase() ];

			if ( match ) {
				return !(match === true || elem.getAttribute("classid") !== match);
			}
		}

		return true;
	}
});

jQuery.fn.extend({
	data: function( key, value ) {
		var parts, attr, name,
			data = null;

		if ( typeof key === "undefined" ) {
			if ( this.length ) {
				data = jQuery.data( this[0] );

				if ( this[0].nodeType === 1 && !jQuery._data( this[0], "parsedAttrs" ) ) {
					attr = this[0].attributes;
					for ( var i = 0, l = attr.length; i < l; i++ ) {
						name = attr[i].name;

						if ( name.indexOf( "data-" ) === 0 ) {
							name = jQuery.camelCase( name.substring(5) );

							dataAttr( this[0], name, data[ name ] );
						}
					}
					jQuery._data( this[0], "parsedAttrs", true );
				}
			}

			return data;

		} else if ( typeof key === "object" ) {
			return this.each(function() {
				jQuery.data( this, key );
			});
		}

		parts = key.split(".");
		parts[1] = parts[1] ? "." + parts[1] : "";

		if ( value === undefined ) {
			data = this.triggerHandler("getData" + parts[1] + "!", [parts[0]]);

			// Try to fetch any internally stored data first
			if ( data === undefined && this.length ) {
				data = jQuery.data( this[0], key );
				data = dataAttr( this[0], key, data );
			}

			return data === undefined && parts[1] ?
				this.data( parts[0] ) :
				data;

		} else {
			return this.each(function() {
				var self = jQuery( this ),
					args = [ parts[0], value ];

				self.triggerHandler( "setData" + parts[1] + "!", args );
				jQuery.data( this, key, value );
				self.triggerHandler( "changeData" + parts[1] + "!", args );
			});
		}
	},

	removeData: function( key ) {
		return this.each(function() {
			jQuery.removeData( this, key );
		});
	}
});

function dataAttr( elem, key, data ) {
	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {

		var name = "data-" + key.replace( rmultiDash, "-$1" ).toLowerCase();

		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
				data === "false" ? false :
				data === "null" ? null :
				jQuery.isNumeric( data ) ? parseFloat( data ) :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch( e ) {}

			// Make sure we set the data so it isn't changed later
			jQuery.data( elem, key, data );

		} else {
			data = undefined;
		}
	}

	return data;
}

// checks a cache object for emptiness
function isEmptyDataObject( obj ) {
	for ( var name in obj ) {

		// if the public data object is empty, the private is still empty
		if ( name === "data" && jQuery.isEmptyObject( obj[name] ) ) {
			continue;
		}
		if ( name !== "toJSON" ) {
			return false;
		}
	}

	return true;
}




function handleQueueMarkDefer( elem, type, src ) {
	var deferDataKey = type + "defer",
		queueDataKey = type + "queue",
		markDataKey = type + "mark",
		defer = jQuery._data( elem, deferDataKey );
	if ( defer &&
		( src === "queue" || !jQuery._data(elem, queueDataKey) ) &&
		( src === "mark" || !jQuery._data(elem, markDataKey) ) ) {
		// Give room for hard-coded callbacks to fire first
		// and eventually mark/queue something else on the element
		setTimeout( function() {
			if ( !jQuery._data( elem, queueDataKey ) &&
				!jQuery._data( elem, markDataKey ) ) {
				jQuery.removeData( elem, deferDataKey, true );
				defer.fire();
			}
		}, 0 );
	}
}

jQuery.extend({

	_mark: function( elem, type ) {
		if ( elem ) {
			type = ( type || "fx" ) + "mark";
			jQuery._data( elem, type, (jQuery._data( elem, type ) || 0) + 1 );
		}
	},

	_unmark: function( force, elem, type ) {
		if ( force !== true ) {
			type = elem;
			elem = force;
			force = false;
		}
		if ( elem ) {
			type = type || "fx";
			var key = type + "mark",
				count = force ? 0 : ( (jQuery._data( elem, key ) || 1) - 1 );
			if ( count ) {
				jQuery._data( elem, key, count );
			} else {
				jQuery.removeData( elem, key, true );
				handleQueueMarkDefer( elem, type, "mark" );
			}
		}
	},

	queue: function( elem, type, data ) {
		var q;
		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			q = jQuery._data( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !q || jQuery.isArray(data) ) {
					q = jQuery._data( elem, type, jQuery.makeArray(data) );
				} else {
					q.push( data );
				}
			}
			return q || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			fn = queue.shift(),
			hooks = {};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
		}

		if ( fn ) {
			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			jQuery._data( elem, type + ".run", hooks );
			fn.call( elem, function() {
				jQuery.dequeue( elem, type );
			}, hooks );
		}

		if ( !queue.length ) {
			jQuery.removeData( elem, type + "queue " + type + ".run", true );
			handleQueueMarkDefer( elem, type, "queue" );
		}
	}
});

jQuery.fn.extend({
	queue: function( type, data ) {
		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
		}

		if ( data === undefined ) {
			return jQuery.queue( this[0], type );
		}
		return this.each(function() {
			var queue = jQuery.queue( this, type, data );

			if ( type === "fx" && queue[0] !== "inprogress" ) {
				jQuery.dequeue( this, type );
			}
		});
	},
	dequeue: function( type ) {
		return this.each(function() {
			jQuery.dequeue( this, type );
		});
	},
	// Based off of the plugin by Clint Helfers, with permission.
	// http://blindsignals.com/index.php/2009/07/jquery-delay/
	delay: function( time, type ) {
		time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
		type = type || "fx";

		return this.queue( type, function( next, hooks ) {
			var timeout = setTimeout( next, time );
			hooks.stop = function() {
				clearTimeout( timeout );
			};
		});
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},
	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, object ) {
		if ( typeof type !== "string" ) {
			object = type;
			type = undefined;
		}
		type = type || "fx";
		var defer = jQuery.Deferred(),
			elements = this,
			i = elements.length,
			count = 1,
			deferDataKey = type + "defer",
			queueDataKey = type + "queue",
			markDataKey = type + "mark",
			tmp;
		function resolve() {
			if ( !( --count ) ) {
				defer.resolveWith( elements, [ elements ] );
			}
		}
		while( i-- ) {
			if (( tmp = jQuery.data( elements[ i ], deferDataKey, undefined, true ) ||
					( jQuery.data( elements[ i ], queueDataKey, undefined, true ) ||
						jQuery.data( elements[ i ], markDataKey, undefined, true ) ) &&
					jQuery.data( elements[ i ], deferDataKey, jQuery.Callbacks( "once memory" ), true ) )) {
				count++;
				tmp.add( resolve );
			}
		}
		resolve();
		return defer.promise();
	}
});




var rclass = /[\n\t\r]/g,
	rspace = /\s+/,
	rreturn = /\r/g,
	rtype = /^(?:button|input)$/i,
	rfocusable = /^(?:button|input|object|select|textarea)$/i,
	rclickable = /^a(?:rea)?$/i,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	getSetAttribute = jQuery.support.getSetAttribute,
	nodeHook, boolHook, fixSpecified;

jQuery.fn.extend({
	attr: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.attr );
	},

	removeAttr: function( name ) {
		return this.each(function() {
			jQuery.removeAttr( this, name );
		});
	},

	prop: function( name, value ) {
		return jQuery.access( this, name, value, true, jQuery.prop );
	},

	removeProp: function( name ) {
		name = jQuery.propFix[ name ] || name;
		return this.each(function() {
			// try/catch handles cases where IE balks (such as removing a property on window)
			try {
				this[ name ] = undefined;
				delete this[ name ];
			} catch( e ) {}
		});
	},

	addClass: function( value ) {
		var classNames, i, l, elem,
			setClass, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).addClass( value.call(this, j, this.className) );
			});
		}

		if ( value && typeof value === "string" ) {
			classNames = value.split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 ) {
					if ( !elem.className && classNames.length === 1 ) {
						elem.className = value;

					} else {
						setClass = " " + elem.className + " ";

						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							if ( !~setClass.indexOf( " " + classNames[ c ] + " " ) ) {
								setClass += classNames[ c ] + " ";
							}
						}
						elem.className = jQuery.trim( setClass );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classNames, i, l, elem, className, c, cl;

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( j ) {
				jQuery( this ).removeClass( value.call(this, j, this.className) );
			});
		}

		if ( (value && typeof value === "string") || value === undefined ) {
			classNames = ( value || "" ).split( rspace );

			for ( i = 0, l = this.length; i < l; i++ ) {
				elem = this[ i ];

				if ( elem.nodeType === 1 && elem.className ) {
					if ( value ) {
						className = (" " + elem.className + " ").replace( rclass, " " );
						for ( c = 0, cl = classNames.length; c < cl; c++ ) {
							className = className.replace(" " + classNames[ c ] + " ", " ");
						}
						elem.className = jQuery.trim( className );

					} else {
						elem.className = "";
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isBool = typeof stateVal === "boolean";

		if ( jQuery.isFunction( value ) ) {
			return this.each(function( i ) {
				jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );
			});
		}

		return this.each(function() {
			if ( type === "string" ) {
				// toggle individual class names
				var className,
					i = 0,
					self = jQuery( this ),
					state = stateVal,
					classNames = value.split( rspace );

				while ( (className = classNames[ i++ ]) ) {
					// check each className given, space seperated list
					state = isBool ? state : !self.hasClass( className );
					self[ state ? "addClass" : "removeClass" ]( className );
				}

			} else if ( type === "undefined" || type === "boolean" ) {
				if ( this.className ) {
					// store className if set
					jQuery._data( this, "__className__", this.className );
				}

				// toggle whole className
				this.className = this.className || value === false ? "" : jQuery._data( this, "__className__" ) || "";
			}
		});
	},

	hasClass: function( selector ) {
		var className = " " + selector + " ",
			i = 0,
			l = this.length;
		for ( ; i < l; i++ ) {
			if ( this[i].nodeType === 1 && (" " + this[i].className + " ").replace(rclass, " ").indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	},

	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[0];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.nodeName.toLowerCase() ] || jQuery.valHooks[ elem.type ];

				if ( hooks && "get" in hooks && (ret = hooks.get( elem, "value" )) !== undefined ) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?
					// handle most common string cases
					ret.replace(rreturn, "") :
					// handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each(function( i ) {
			var self = jQuery(this), val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, self.val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";
			} else if ( typeof val === "number" ) {
				val += "";
			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map(val, function ( value ) {
					return value == null ? "" : value + "";
				});
			}

			hooks = jQuery.valHooks[ this.nodeName.toLowerCase() ] || jQuery.valHooks[ this.type ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !("set" in hooks) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		});
	}
});

jQuery.extend({
	valHooks: {
		option: {
			get: function( elem ) {
				// attributes.value is undefined in Blackberry 4.7 but
				// uses .value. See #6932
				var val = elem.attributes.value;
				return !val || val.specified ? elem.value : elem.text;
			}
		},
		select: {
			get: function( elem ) {
				var value, i, max, option,
					index = elem.selectedIndex,
					values = [],
					options = elem.options,
					one = elem.type === "select-one";

				// Nothing was selected
				if ( index < 0 ) {
					return null;
				}

				// Loop through all the selected options
				i = one ? index : 0;
				max = one ? index + 1 : options.length;
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Don't return options that are disabled or in a disabled optgroup
					if ( option.selected && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) &&
							(!option.parentNode.disabled || !jQuery.nodeName( option.parentNode, "optgroup" )) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				// Fixes Bug #2551 -- select.val() broken in IE after form.reset()
				if ( one && !values.length && options.length ) {
					return jQuery( options[ index ] ).val();
				}

				return values;
			},

			set: function( elem, value ) {
				var values = jQuery.makeArray( value );

				jQuery(elem).find("option").each(function() {
					this.selected = jQuery.inArray( jQuery(this).val(), values ) >= 0;
				});

				if ( !values.length ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	},

	attrFn: {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true
	},

	attr: function( elem, name, value, pass ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set attributes on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( pass && name in jQuery.attrFn ) {
			return jQuery( elem )[ name ]( value );
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( notxml ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] || ( rboolean.test( name ) ? boolHook : nodeHook );
		}

		if ( value !== undefined ) {

			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;

			} else if ( hooks && "set" in hooks && notxml && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				elem.setAttribute( name, "" + value );
				return value;
			}

		} else if ( hooks && "get" in hooks && notxml && (ret = hooks.get( elem, name )) !== null ) {
			return ret;

		} else {

			ret = elem.getAttribute( name );

			// Non-existent attributes return null, we normalize to undefined
			return ret === null ?
				undefined :
				ret;
		}
	},

	removeAttr: function( elem, value ) {
		var propName, attrNames, name, l,
			i = 0;

		if ( value && elem.nodeType === 1 ) {
			attrNames = value.toLowerCase().split( rspace );
			l = attrNames.length;

			for ( ; i < l; i++ ) {
				name = attrNames[ i ];

				if ( name ) {
					propName = jQuery.propFix[ name ] || name;

					// See #9699 for explanation of this approach (setting first, then removal)
					jQuery.attr( elem, name, "" );
					elem.removeAttribute( getSetAttribute ? name : propName );

					// Set corresponding property to false for boolean attributes
					if ( rboolean.test( name ) && propName in elem ) {
						elem[ propName ] = false;
					}
				}
			}
		}
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				// We can't allow the type property to be changed (since it causes problems in IE)
				if ( rtype.test( elem.nodeName ) && elem.parentNode ) {
					jQuery.error( "type property can't be changed" );
				} else if ( !jQuery.support.radioValue && value === "radio" && jQuery.nodeName(elem, "input") ) {
					// Setting the type on a radio button after the value resets the value in IE6-9
					// Reset value to it's default in case type is set after value
					// This is for element creation
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		},
		// Use the value property for back compat
		// Use the nodeHook for button elements in IE6/7 (#1954)
		value: {
			get: function( elem, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.get( elem, name );
				}
				return name in elem ?
					elem.value :
					null;
			},
			set: function( elem, value, name ) {
				if ( nodeHook && jQuery.nodeName( elem, "button" ) ) {
					return nodeHook.set( elem, value, name );
				}
				// Does not return so that setAttribute is also used
				elem.value = value;
			}
		}
	},

	propFix: {
		tabindex: "tabIndex",
		readonly: "readOnly",
		"for": "htmlFor",
		"class": "className",
		maxlength: "maxLength",
		cellspacing: "cellSpacing",
		cellpadding: "cellPadding",
		rowspan: "rowSpan",
		colspan: "colSpan",
		usemap: "useMap",
		frameborder: "frameBorder",
		contenteditable: "contentEditable"
	},

	prop: function( elem, name, value ) {
		var ret, hooks, notxml,
			nType = elem.nodeType;

		// don't get/set properties on text, comment and attribute nodes
		if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		notxml = nType !== 1 || !jQuery.isXMLDoc( elem );

		if ( notxml ) {
			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {
				return ret;

			} else {
				return ( elem[ name ] = value );
			}

		} else {
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, name )) !== null ) {
				return ret;

			} else {
				return elem[ name ];
			}
		}
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {
				// elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				var attributeNode = elem.getAttributeNode("tabindex");

				return attributeNode && attributeNode.specified ?
					parseInt( attributeNode.value, 10 ) :
					rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?
						0 :
						undefined;
			}
		}
	}
});

// Add the tabIndex propHook to attrHooks for back-compat (different case is intentional)
jQuery.attrHooks.tabindex = jQuery.propHooks.tabIndex;

// Hook for boolean attributes
boolHook = {
	get: function( elem, name ) {
		// Align boolean attributes with corresponding properties
		// Fall back to attribute presence where some booleans are not supported
		var attrNode,
			property = jQuery.prop( elem, name );
		return property === true || typeof property !== "boolean" && ( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?
			name.toLowerCase() :
			undefined;
	},
	set: function( elem, value, name ) {
		var propName;
		if ( value === false ) {
			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			// value is true since we know at this point it's type boolean and not false
			// Set boolean attributes to the same name and set the DOM property
			propName = jQuery.propFix[ name ] || name;
			if ( propName in elem ) {
				// Only set the IDL specifically if it already exists on the element
				elem[ propName ] = true;
			}

			elem.setAttribute( name, name.toLowerCase() );
		}
		return name;
	}
};

// IE6/7 do not support getting/setting some attributes with get/setAttribute
if ( !getSetAttribute ) {

	fixSpecified = {
		name: true,
		id: true
	};

	// Use this for any attribute in IE6/7
	// This fixes almost every IE6/7 issue
	nodeHook = jQuery.valHooks.button = {
		get: function( elem, name ) {
			var ret;
			ret = elem.getAttributeNode( name );
			return ret && ( fixSpecified[ name ] ? ret.nodeValue !== "" : ret.specified ) ?
				ret.nodeValue :
				undefined;
		},
		set: function( elem, value, name ) {
			// Set the existing or create a new attribute node
			var ret = elem.getAttributeNode( name );
			if ( !ret ) {
				ret = document.createAttribute( name );
				elem.setAttributeNode( ret );
			}
			return ( ret.nodeValue = value + "" );
		}
	};

	// Apply the nodeHook to tabindex
	jQuery.attrHooks.tabindex.set = nodeHook.set;

	// Set width and height to auto instead of 0 on empty string( Bug #8150 )
	// This is for removals
	jQuery.each([ "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			set: function( elem, value ) {
				if ( value === "" ) {
					elem.setAttribute( name, "auto" );
					return value;
				}
			}
		});
	});

	// Set contenteditable to false on removals(#10429)
	// Setting to empty string throws an error as an invalid value
	jQuery.attrHooks.contenteditable = {
		get: nodeHook.get,
		set: function( elem, value, name ) {
			if ( value === "" ) {
				value = "false";
			}
			nodeHook.set( elem, value, name );
		}
	};
}


// Some attributes require a special call on IE
if ( !jQuery.support.hrefNormalized ) {
	jQuery.each([ "href", "src", "width", "height" ], function( i, name ) {
		jQuery.attrHooks[ name ] = jQuery.extend( jQuery.attrHooks[ name ], {
			get: function( elem ) {
				var ret = elem.getAttribute( name, 2 );
				return ret === null ? undefined : ret;
			}
		});
	});
}

if ( !jQuery.support.style ) {
	jQuery.attrHooks.style = {
		get: function( elem ) {
			// Return undefined in the case of empty string
			// Normalize to lowercase since IE uppercases css property names
			return elem.style.cssText.toLowerCase() || undefined;
		},
		set: function( elem, value ) {
			return ( elem.style.cssText = "" + value );
		}
	};
}

// Safari mis-reports the default selected property of an option
// Accessing the parent's selectedIndex property fixes it
if ( !jQuery.support.optSelected ) {
	jQuery.propHooks.selected = jQuery.extend( jQuery.propHooks.selected, {
		get: function( elem ) {
			var parent = elem.parentNode;

			if ( parent ) {
				parent.selectedIndex;

				// Make sure that it also works with optgroups, see #5701
				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
			return null;
		}
	});
}

// IE6/7 call enctype encoding
if ( !jQuery.support.enctype ) {
	jQuery.propFix.enctype = "encoding";
}

// Radios and checkboxes getter/setter
if ( !jQuery.support.checkOn ) {
	jQuery.each([ "radio", "checkbox" ], function() {
		jQuery.valHooks[ this ] = {
			get: function( elem ) {
				// Handle the case where in Webkit "" is returned instead of "on" if a value isn't specified
				return elem.getAttribute("value") === null ? "on" : elem.value;
			}
		};
	});
}
jQuery.each([ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = jQuery.extend( jQuery.valHooks[ this ], {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );
			}
		}
	});
});




var rformElems = /^(?:textarea|input|select)$/i,
	rtypenamespace = /^([^\.]*)?(?:\.(.+))?$/,
	rhoverHack = /\bhover(\.\S+)?\b/,
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|contextmenu)|click/,
	rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	rquickIs = /^(\w*)(?:#([\w\-]+))?(?:\.([\w\-]+))?$/,
	quickParse = function( selector ) {
		var quick = rquickIs.exec( selector );
		if ( quick ) {
			//   0  1    2   3
			// [ _, tag, id, class ]
			quick[1] = ( quick[1] || "" ).toLowerCase();
			quick[3] = quick[3] && new RegExp( "(?:^|\\s)" + quick[3] + "(?:\\s|$)" );
		}
		return quick;
	},
	quickIs = function( elem, m ) {
		var attrs = elem.attributes || {};
		return (
			(!m[1] || elem.nodeName.toLowerCase() === m[1]) &&
			(!m[2] || (attrs.id || {}).value === m[2]) &&
			(!m[3] || m[3].test( (attrs[ "class" ] || {}).value ))
		);
	},
	hoverHack = function( events ) {
		return jQuery.event.special.hover ? events : events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	add: function( elem, types, handler, data, selector ) {

		var elemData, eventHandle, events,
			t, tns, type, namespaces, handleObj,
			handleObjIn, quick, handlers, special;

		// Don't attach events to noData or text/comment nodes (allow plain objects tho)
		if ( elem.nodeType === 3 || elem.nodeType === 8 || !types || !handler || !(elemData = jQuery._data( elem )) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		events = elemData.events;
		if ( !events ) {
			elemData.events = events = {};
		}
		eventHandle = elemData.handle;
		if ( !eventHandle ) {
			elemData.handle = eventHandle = function( e ) {
				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && (!e || jQuery.event.triggered !== e.type) ?
					jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :
					undefined;
			};
			// Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
			eventHandle.elem = elem;
		}

		// Handle multiple events separated by a space
		// jQuery(...).bind("mouseover mouseout", fn);
		types = jQuery.trim( hoverHack(types) ).split( " " );
		for ( t = 0; t < types.length; t++ ) {

			tns = rtypenamespace.exec( types[t] ) || [];
			type = tns[1];
			namespaces = ( tns[2] || "" ).split( "." ).sort();

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend({
				type: type,
				origType: tns[1],
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				quick: quickParse( selector ),
				namespace: namespaces.join(".")
			}, handleObjIn );

			// Init the event handler queue if we're the first
			handlers = events[ type ];
			if ( !handlers ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener/attachEvent if the special events handler returns false
				if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {
					// Bind the global event handler to the element
					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle, false );

					} else if ( elem.attachEvent ) {
						elem.attachEvent( "on" + type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

		// Nullify elem to prevent memory leaks in IE
		elem = null;
	},

	global: {},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var elemData = jQuery.hasData( elem ) && jQuery._data( elem ),
			t, tns, type, origType, namespaces, origCount,
			j, events, special, handle, eventType, handleObj;

		if ( !elemData || !(events = elemData.events) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = jQuery.trim( hoverHack( types || "" ) ).split(" ");
		for ( t = 0; t < types.length; t++ ) {
			tns = rtypenamespace.exec( types[t] ) || [];
			type = origType = tns[1];
			namespaces = tns[2];

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector? special.delegateType : special.bindType ) || type;
			eventType = events[ type ] || [];
			origCount = eventType.length;
			namespaces = namespaces ? new RegExp("(^|\\.)" + namespaces.split(".").sort().join("\\.(?:.*\\.)?") + "(\\.|$)") : null;

			// Remove matching events
			for ( j = 0; j < eventType.length; j++ ) {
				handleObj = eventType[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					 ( !handler || handler.guid === handleObj.guid ) &&
					 ( !namespaces || namespaces.test( handleObj.namespace ) ) &&
					 ( !selector || selector === handleObj.selector || selector === "**" && handleObj.selector ) ) {
					eventType.splice( j--, 1 );

					if ( handleObj.selector ) {
						eventType.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( eventType.length === 0 && origCount !== eventType.length ) {
				if ( !special.teardown || special.teardown.call( elem, namespaces ) === false ) {
					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			handle = elemData.handle;
			if ( handle ) {
				handle.elem = null;
			}

			// removeData also checks for emptiness and clears the expando if empty
			// so use it instead of delete
			jQuery.removeData( elem, [ "events", "handle" ], true );
		}
	},

	// Events that are safe to short-circuit if no handlers are attached.
	// Native DOM events should not be added, they may have inline handlers.
	customEvent: {
		"getData": true,
		"setData": true,
		"changeData": true
	},

	trigger: function( event, data, elem, onlyHandlers ) {
		// Don't do events on text and comment nodes
		if ( elem && (elem.nodeType === 3 || elem.nodeType === 8) ) {
			return;
		}

		// Event object or event type
		var type = event.type || event,
			namespaces = [],
			cache, exclusive, i, cur, old, ontype, special, handle, eventPath, bubbleType;

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "!" ) >= 0 ) {
			// Exclusive events trigger only for the exact event (no namespaces)
			type = type.slice(0, -1);
			exclusive = true;
		}

		if ( type.indexOf( "." ) >= 0 ) {
			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split(".");
			type = namespaces.shift();
			namespaces.sort();
		}

		if ( (!elem || jQuery.event.customEvent[ type ]) && !jQuery.event.global[ type ] ) {
			// No jQuery handlers for this event type, and it can't have inline handlers
			return;
		}

		// Caller can pass in an Event, Object, or just an event type string
		event = typeof event === "object" ?
			// jQuery.Event object
			event[ jQuery.expando ] ? event :
			// Object literal
			new jQuery.Event( type, event ) :
			// Just the event type (string)
			new jQuery.Event( type );

		event.type = type;
		event.isTrigger = true;
		event.exclusive = exclusive;
		event.namespace = namespaces.join( "." );
		event.namespace_re = event.namespace? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.)?") + "(\\.|$)") : null;
		ontype = type.indexOf( ":" ) < 0 ? "on" + type : "";

		// Handle a global trigger
		if ( !elem ) {

			// TODO: Stop taunting the data cache; remove global events and always attach to document
			cache = jQuery.cache;
			for ( i in cache ) {
				if ( cache[ i ].events && cache[ i ].events[ type ] ) {
					jQuery.event.trigger( event, data, cache[ i ].handle.elem, true );
				}
			}
			return;
		}

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data != null ? jQuery.makeArray( data ) : [];
		data.unshift( event );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		eventPath = [[ elem, special.bindType || type ]];
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			cur = rfocusMorph.test( bubbleType + type ) ? elem : elem.parentNode;
			old = null;
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push([ cur, bubbleType ]);
				old = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( old && old === elem.ownerDocument ) {
				eventPath.push([ old.defaultView || old.parentWindow || window, bubbleType ]);
			}
		}

		// Fire handlers on the event path
		for ( i = 0; i < eventPath.length && !event.isPropagationStopped(); i++ ) {

			cur = eventPath[i][0];
			event.type = eventPath[i][1];

			handle = ( jQuery._data( cur, "events" ) || {} )[ event.type ] && jQuery._data( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}
			// Note that this is a bare JS function and not a jQuery handler
			handle = ontype && cur[ ontype ];
			if ( handle && jQuery.acceptData( cur ) && handle.apply( cur, data ) === false ) {
				event.preventDefault();
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( (!special._default || special._default.apply( elem.ownerDocument, data ) === false) &&
				!(type === "click" && jQuery.nodeName( elem, "a" )) && jQuery.acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Can't use an .isFunction() check here because IE6/7 fails that test.
				// Don't do default actions on window, that's where global variables be (#6170)
				// IE<9 dies on focus/blur to hidden element (#1486)
				if ( ontype && elem[ type ] && ((type !== "focus" && type !== "blur") || event.target.offsetWidth !== 0) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					old = elem[ ontype ];

					if ( old ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( old ) {
						elem[ ontype ] = old;
					}
				}
			}
		}

		return event.result;
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event || window.event );

		var handlers = ( (jQuery._data( this, "events" ) || {} )[ event.type ] || []),
			delegateCount = handlers.delegateCount,
			args = [].slice.call( arguments, 0 ),
			run_all = !event.exclusive && !event.namespace,
			handlerQueue = [],
			i, j, cur, jqcur, ret, selMatch, matched, matches, handleObj, sel, related;

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[0] = event;
		event.delegateTarget = this;

		// Determine handlers that should run if there are delegated events
		// Avoid disabled elements in IE (#6911) and non-left-click bubbling in Firefox (#3861)
		if ( delegateCount && !event.target.disabled && !(event.button && event.type === "click") ) {

			// Pregenerate a single jQuery object for reuse with .is()
			jqcur = jQuery(this);
			jqcur.context = this.ownerDocument || this;

			for ( cur = event.target; cur != this; cur = cur.parentNode || this ) {
				selMatch = {};
				matches = [];
				jqcur[0] = cur;
				for ( i = 0; i < delegateCount; i++ ) {
					handleObj = handlers[ i ];
					sel = handleObj.selector;

					if ( selMatch[ sel ] === undefined ) {
						selMatch[ sel ] = (
							handleObj.quick ? quickIs( cur, handleObj.quick ) : jqcur.is( sel )
						);
					}
					if ( selMatch[ sel ] ) {
						matches.push( handleObj );
					}
				}
				if ( matches.length ) {
					handlerQueue.push({ elem: cur, matches: matches });
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( handlers.length > delegateCount ) {
			handlerQueue.push({ elem: this, matches: handlers.slice( delegateCount ) });
		}

		// Run delegates first; they may want to stop propagation beneath us
		for ( i = 0; i < handlerQueue.length && !event.isPropagationStopped(); i++ ) {
			matched = handlerQueue[ i ];
			event.currentTarget = matched.elem;

			for ( j = 0; j < matched.matches.length && !event.isImmediatePropagationStopped(); j++ ) {
				handleObj = matched.matches[ j ];

				// Triggered event must either 1) be non-exclusive and have no namespace, or
				// 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
				if ( run_all || (!event.namespace && !handleObj.namespace) || event.namespace_re && event.namespace_re.test( handleObj.namespace ) ) {

					event.data = handleObj.data;
					event.handleObj = handleObj;

					ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )
							.apply( matched.elem, args );

					if ( ret !== undefined ) {
						event.result = ret;
						if ( ret === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		return event.result;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	// *** attrChange attrName relatedNode srcElement  are not normalized, non-W3C, deprecated, will be removed in 1.8 ***
	props: "attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split(" "),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: "button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button,
				fromElement = original.fromElement;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add relatedTarget, if necessary
			if ( !event.relatedTarget && fromElement ) {
				event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop,
			originalEvent = event,
			fixHook = jQuery.event.fixHooks[ event.type ] || {},
			copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = jQuery.Event( originalEvent );

		for ( i = copy.length; i; ) {
			prop = copy[ --i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Fix target property, if necessary (#1925, IE 6/7/8 & Safari2)
		if ( !event.target ) {
			event.target = originalEvent.srcElement || document;
		}

		// Target should not be a text node (#504, Safari)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		// For mouse/key events; add metaKey if it's not there (#3368, IE6/7/8)
		if ( event.metaKey === undefined ) {
			event.metaKey = event.ctrlKey;
		}

		return fixHook.filter? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		ready: {
			// Make sure the ready event is setup
			setup: jQuery.bindReady
		},

		load: {
			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},

		focus: {
			delegateType: "focusin"
		},
		blur: {
			delegateType: "focusout"
		},

		beforeunload: {
			setup: function( data, namespaces, eventHandle ) {
				// We only want to do this special case on windows
				if ( jQuery.isWindow( this ) ) {
					this.onbeforeunload = eventHandle;
				}
			},

			teardown: function( namespaces, eventHandle ) {
				if ( this.onbeforeunload === eventHandle ) {
					this.onbeforeunload = null;
				}
			}
		}
	},

	simulate: function( type, elem, event, bubble ) {
		// Piggyback on a donor event to simulate a different one.
		// Fake originalEvent to avoid donor's stopPropagation, but if the
		// simulated event prevents default then we do the same on the donor.
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{ type: type,
				isSimulated: true,
				originalEvent: {}
			}
		);
		if ( bubble ) {
			jQuery.event.trigger( e, null, elem );
		} else {
			jQuery.event.dispatch.call( elem, e );
		}
		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}
};

// Some plugins are using, but it's undocumented/deprecated and will be removed.
// The 1.7 special event interface should provide all the hooks needed now.
jQuery.event.handle = jQuery.event.dispatch;

jQuery.removeEvent = document.removeEventListener ?
	function( elem, type, handle ) {
		if ( elem.removeEventListener ) {
			elem.removeEventListener( type, handle, false );
		}
	} :
	function( elem, type, handle ) {
		if ( elem.detachEvent ) {
			elem.detachEvent( "on" + type, handle );
		}
	};

jQuery.Event = function( src, props ) {
	// Allow instantiation without the 'new' keyword
	if ( !(this instanceof jQuery.Event) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||
			src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

function returnFalse() {
	return false;
}
function returnTrue() {
	return true;
}

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	preventDefault: function() {
		this.isDefaultPrevented = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}

		// if preventDefault exists run it on the original event
		if ( e.preventDefault ) {
			e.preventDefault();

		// otherwise set the returnValue property of the original event to false (IE)
		} else {
			e.returnValue = false;
		}
	},
	stopPropagation: function() {
		this.isPropagationStopped = returnTrue;

		var e = this.originalEvent;
		if ( !e ) {
			return;
		}
		// if stopPropagation exists run it on the original event
		if ( e.stopPropagation ) {
			e.stopPropagation();
		}
		// otherwise set the cancelBubble property of the original event to true (IE)
		e.cancelBubble = true;
	},
	stopImmediatePropagation: function() {
		this.isImmediatePropagationStopped = returnTrue;
		this.stopPropagation();
	},
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse
};

// Create mouseenter/leave events using mouseover/out and event-time checks
jQuery.each({
	mouseenter: "mouseover",
	mouseleave: "mouseout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj,
				selector = handleObj.selector,
				ret;

			// For mousenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || (related !== target && !jQuery.contains( target, related )) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
});

// IE submit delegation
if ( !jQuery.support.submitBubbles ) {

	jQuery.event.special.submit = {
		setup: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Lazy-add a submit handler when a descendant form may potentially be submitted
			jQuery.event.add( this, "click._submit keypress._submit", function( e ) {
				// Node name check avoids a VML-related crash in IE (#9807)
				var elem = e.target,
					form = jQuery.nodeName( elem, "input" ) || jQuery.nodeName( elem, "button" ) ? elem.form : undefined;
				if ( form && !form._submit_attached ) {
					jQuery.event.add( form, "submit._submit", function( event ) {
						// If form was submitted by the user, bubble the event up the tree
						if ( this.parentNode && !event.isTrigger ) {
							jQuery.event.simulate( "submit", this.parentNode, event, true );
						}
					});
					form._submit_attached = true;
				}
			});
			// return undefined since we don't need an event listener
		},

		teardown: function() {
			// Only need this for delegated form submit events
			if ( jQuery.nodeName( this, "form" ) ) {
				return false;
			}

			// Remove delegated handlers; cleanData eventually reaps submit handlers attached above
			jQuery.event.remove( this, "._submit" );
		}
	};
}

// IE change delegation and checkbox/radio fix
if ( !jQuery.support.changeBubbles ) {

	jQuery.event.special.change = {

		setup: function() {

			if ( rformElems.test( this.nodeName ) ) {
				// IE doesn't fire change on a check/radio until blur; trigger it on click
				// after a propertychange. Eat the blur-change in special.change.handle.
				// This still fires onchange a second time for check/radio after blur.
				if ( this.type === "checkbox" || this.type === "radio" ) {
					jQuery.event.add( this, "propertychange._change", function( event ) {
						if ( event.originalEvent.propertyName === "checked" ) {
							this._just_changed = true;
						}
					});
					jQuery.event.add( this, "click._change", function( event ) {
						if ( this._just_changed && !event.isTrigger ) {
							this._just_changed = false;
							jQuery.event.simulate( "change", this, event, true );
						}
					});
				}
				return false;
			}
			// Delegated event; lazy-add a change handler on descendant inputs
			jQuery.event.add( this, "beforeactivate._change", function( e ) {
				var elem = e.target;

				if ( rformElems.test( elem.nodeName ) && !elem._change_attached ) {
					jQuery.event.add( elem, "change._change", function( event ) {
						if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {
							jQuery.event.simulate( "change", this.parentNode, event, true );
						}
					});
					elem._change_attached = true;
				}
			});
		},

		handle: function( event ) {
			var elem = event.target;

			// Swallow native change events from checkbox/radio, we already triggered them above
			if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== "radio" && elem.type !== "checkbox") ) {
				return event.handleObj.handler.apply( this, arguments );
			}
		},

		teardown: function() {
			jQuery.event.remove( this, "._change" );

			return rformElems.test( this.nodeName );
		}
	};
}

// Create "bubbling" focus and blur events
if ( !jQuery.support.focusinBubbles ) {
	jQuery.each({ focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler while someone wants focusin/focusout
		var attaches = 0,
			handler = function( event ) {
				jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );
			};

		jQuery.event.special[ fix ] = {
			setup: function() {
				if ( attaches++ === 0 ) {
					document.addEventListener( orig, handler, true );
				}
			},
			teardown: function() {
				if ( --attaches === 0 ) {
					document.removeEventListener( orig, handler, true );
				}
			}
		};
	});
}

jQuery.fn.extend({

	on: function( types, selector, data, fn, /*INTERNAL*/ one ) {
		var origFn, type;

		// Types can be a map of types/handlers
		if ( typeof types === "object" ) {
			// ( types-Object, selector, data )
			if ( typeof selector !== "string" ) {
				// ( types-Object, data )
				data = selector;
				selector = undefined;
			}
			for ( type in types ) {
				this.on( type, selector, data, types[ type ], one );
			}
			return this;
		}

		if ( data == null && fn == null ) {
			// ( types, fn )
			fn = selector;
			data = selector = undefined;
		} else if ( fn == null ) {
			if ( typeof selector === "string" ) {
				// ( types, selector, fn )
				fn = data;
				data = undefined;
			} else {
				// ( types, data, fn )
				fn = data;
				data = selector;
				selector = undefined;
			}
		}
		if ( fn === false ) {
			fn = returnFalse;
		} else if ( !fn ) {
			return this;
		}

		if ( one === 1 ) {
			origFn = fn;
			fn = function( event ) {
				// Can use an empty set, since event contains the info
				jQuery().off( event );
				return origFn.apply( this, arguments );
			};
			// Use same guid so caller can remove using origFn
			fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
		}
		return this.each( function() {
			jQuery.event.add( this, types, fn, data, selector );
		});
	},
	one: function( types, selector, data, fn ) {
		return this.on.call( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		if ( types && types.preventDefault && types.handleObj ) {
			// ( event )  dispatched jQuery.Event
			var handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace? handleObj.type + "." + handleObj.namespace : handleObj.type,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {
			// ( types-object [, selector] )
			for ( var type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {
			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each(function() {
			jQuery.event.remove( this, types, fn, selector );
		});
	},

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	live: function( types, data, fn ) {
		jQuery( this.context ).on( types, this.selector, data, fn );
		return this;
	},
	die: function( types, fn ) {
		jQuery( this.context ).off( types, this.selector || "**", fn );
		return this;
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {
		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length == 1? this.off( selector, "**" ) : this.off( types, selector, fn );
	},

	trigger: function( type, data ) {
		return this.each(function() {
			jQuery.event.trigger( type, data, this );
		});
	},
	triggerHandler: function( type, data ) {
		if ( this[0] ) {
			return jQuery.event.trigger( type, data, this[0], true );
		}
	},

	toggle: function( fn ) {
		// Save reference to arguments for access in closure
		var args = arguments,
			guid = fn.guid || jQuery.guid++,
			i = 0,
			toggler = function( event ) {
				// Figure out which function to execute
				var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
				jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

				// Make sure that clicks stop
				event.preventDefault();

				// and execute the function
				return args[ lastToggle ].apply( this, arguments ) || false;
			};

		// link all the functions, so any of them can unbind this click handler
		toggler.guid = guid;
		while ( i < args.length ) {
			args[ i++ ].guid = guid;
		}

		return this.click( toggler );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
});

jQuery.each( ("blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu").split(" "), function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		if ( fn == null ) {
			fn = data;
			data = null;
		}

		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};

	if ( jQuery.attrFn ) {
		jQuery.attrFn[ name ] = true;
	}

	if ( rkeyEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.keyHooks;
	}

	if ( rmouseEvent.test( name ) ) {
		jQuery.event.fixHooks[ name ] = jQuery.event.mouseHooks;
	}
});



/*!
 * Sizzle CSS Selector Engine
 *  Copyright 2011, The Dojo Foundation
 *  Released under the MIT, BSD, and GPL Licenses.
 *  More information: http://sizzlejs.com/
 */
(function(){

var chunker = /((?:\((?:\([^()]+\)|[^()]+)+\)|\[(?:\[[^\[\]]*\]|['"][^'"]*['"]|[^\[\]'"]+)+\]|\\.|[^ >+~,(\[\\]+)+|[>+~])(\s*,\s*)?((?:.|\r|\n)*)/g,
	expando = "sizcache" + (Math.random() + '').replace('.', ''),
	done = 0,
	toString = Object.prototype.toString,
	hasDuplicate = false,
	baseHasDuplicate = true,
	rBackslash = /\\/g,
	rReturn = /\r\n/g,
	rNonWord = /\W/;

// Here we check if the JavaScript engine is using some sort of
// optimization where it does not always call our comparision
// function. If that is the case, discard the hasDuplicate value.
//   Thus far that includes Google Chrome.
[0, 0].sort(function() {
	baseHasDuplicate = false;
	return 0;
});

var Sizzle = function( selector, context, results, seed ) {
	results = results || [];
	context = context || document;

	var origContext = context;

	if ( context.nodeType !== 1 && context.nodeType !== 9 ) {
		return [];
	}
	
	if ( !selector || typeof selector !== "string" ) {
		return results;
	}

	var m, set, checkSet, extra, ret, cur, pop, i,
		prune = true,
		contextXML = Sizzle.isXML( context ),
		parts = [],
		soFar = selector;
	
	// Reset the position of the chunker regexp (start from head)
	do {
		chunker.exec( "" );
		m = chunker.exec( soFar );

		if ( m ) {
			soFar = m[3];
		
			parts.push( m[1] );
		
			if ( m[2] ) {
				extra = m[3];
				break;
			}
		}
	} while ( m );

	if ( parts.length > 1 && origPOS.exec( selector ) ) {

		if ( parts.length === 2 && Expr.relative[ parts[0] ] ) {
			set = posProcess( parts[0] + parts[1], context, seed );

		} else {
			set = Expr.relative[ parts[0] ] ?
				[ context ] :
				Sizzle( parts.shift(), context );

			while ( parts.length ) {
				selector = parts.shift();

				if ( Expr.relative[ selector ] ) {
					selector += parts.shift();
				}
				
				set = posProcess( selector, set, seed );
			}
		}

	} else {
		// Take a shortcut and set the context if the root selector is an ID
		// (but not if it'll be faster if the inner selector is an ID)
		if ( !seed && parts.length > 1 && context.nodeType === 9 && !contextXML &&
				Expr.match.ID.test(parts[0]) && !Expr.match.ID.test(parts[parts.length - 1]) ) {

			ret = Sizzle.find( parts.shift(), context, contextXML );
			context = ret.expr ?
				Sizzle.filter( ret.expr, ret.set )[0] :
				ret.set[0];
		}

		if ( context ) {
			ret = seed ?
				{ expr: parts.pop(), set: makeArray(seed) } :
				Sizzle.find( parts.pop(), parts.length === 1 && (parts[0] === "~" || parts[0] === "+") && context.parentNode ? context.parentNode : context, contextXML );

			set = ret.expr ?
				Sizzle.filter( ret.expr, ret.set ) :
				ret.set;

			if ( parts.length > 0 ) {
				checkSet = makeArray( set );

			} else {
				prune = false;
			}

			while ( parts.length ) {
				cur = parts.pop();
				pop = cur;

				if ( !Expr.relative[ cur ] ) {
					cur = "";
				} else {
					pop = parts.pop();
				}

				if ( pop == null ) {
					pop = context;
				}

				Expr.relative[ cur ]( checkSet, pop, contextXML );
			}

		} else {
			checkSet = parts = [];
		}
	}

	if ( !checkSet ) {
		checkSet = set;
	}

	if ( !checkSet ) {
		Sizzle.error( cur || selector );
	}

	if ( toString.call(checkSet) === "[object Array]" ) {
		if ( !prune ) {
			results.push.apply( results, checkSet );

		} else if ( context && context.nodeType === 1 ) {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && (checkSet[i] === true || checkSet[i].nodeType === 1 && Sizzle.contains(context, checkSet[i])) ) {
					results.push( set[i] );
				}
			}

		} else {
			for ( i = 0; checkSet[i] != null; i++ ) {
				if ( checkSet[i] && checkSet[i].nodeType === 1 ) {
					results.push( set[i] );
				}
			}
		}

	} else {
		makeArray( checkSet, results );
	}

	if ( extra ) {
		Sizzle( extra, origContext, results, seed );
		Sizzle.uniqueSort( results );
	}

	return results;
};

Sizzle.uniqueSort = function( results ) {
	if ( sortOrder ) {
		hasDuplicate = baseHasDuplicate;
		results.sort( sortOrder );

		if ( hasDuplicate ) {
			for ( var i = 1; i < results.length; i++ ) {
				if ( results[i] === results[ i - 1 ] ) {
					results.splice( i--, 1 );
				}
			}
		}
	}

	return results;
};

Sizzle.matches = function( expr, set ) {
	return Sizzle( expr, null, null, set );
};

Sizzle.matchesSelector = function( node, expr ) {
	return Sizzle( expr, null, null, [node] ).length > 0;
};

Sizzle.find = function( expr, context, isXML ) {
	var set, i, len, match, type, left;

	if ( !expr ) {
		return [];
	}

	for ( i = 0, len = Expr.order.length; i < len; i++ ) {
		type = Expr.order[i];
		
		if ( (match = Expr.leftMatch[ type ].exec( expr )) ) {
			left = match[1];
			match.splice( 1, 1 );

			if ( left.substr( left.length - 1 ) !== "\\" ) {
				match[1] = (match[1] || "").replace( rBackslash, "" );
				set = Expr.find[ type ]( match, context, isXML );

				if ( set != null ) {
					expr = expr.replace( Expr.match[ type ], "" );
					break;
				}
			}
		}
	}

	if ( !set ) {
		set = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( "*" ) :
			[];
	}

	return { set: set, expr: expr };
};

Sizzle.filter = function( expr, set, inplace, not ) {
	var match, anyFound,
		type, found, item, filter, left,
		i, pass,
		old = expr,
		result = [],
		curLoop = set,
		isXMLFilter = set && set[0] && Sizzle.isXML( set[0] );

	while ( expr && set.length ) {
		for ( type in Expr.filter ) {
			if ( (match = Expr.leftMatch[ type ].exec( expr )) != null && match[2] ) {
				filter = Expr.filter[ type ];
				left = match[1];

				anyFound = false;

				match.splice(1,1);

				if ( left.substr( left.length - 1 ) === "\\" ) {
					continue;
				}

				if ( curLoop === result ) {
					result = [];
				}

				if ( Expr.preFilter[ type ] ) {
					match = Expr.preFilter[ type ]( match, curLoop, inplace, result, not, isXMLFilter );

					if ( !match ) {
						anyFound = found = true;

					} else if ( match === true ) {
						continue;
					}
				}

				if ( match ) {
					for ( i = 0; (item = curLoop[i]) != null; i++ ) {
						if ( item ) {
							found = filter( item, match, i, curLoop );
							pass = not ^ found;

							if ( inplace && found != null ) {
								if ( pass ) {
									anyFound = true;

								} else {
									curLoop[i] = false;
								}

							} else if ( pass ) {
								result.push( item );
								anyFound = true;
							}
						}
					}
				}

				if ( found !== undefined ) {
					if ( !inplace ) {
						curLoop = result;
					}

					expr = expr.replace( Expr.match[ type ], "" );

					if ( !anyFound ) {
						return [];
					}

					break;
				}
			}
		}

		// Improper expression
		if ( expr === old ) {
			if ( anyFound == null ) {
				Sizzle.error( expr );

			} else {
				break;
			}
		}

		old = expr;
	}

	return curLoop;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Utility function for retreiving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
var getText = Sizzle.getText = function( elem ) {
    var i, node,
		nodeType = elem.nodeType,
		ret = "";

	if ( nodeType ) {
		if ( nodeType === 1 || nodeType === 9 ) {
			// Use textContent || innerText for elements
			if ( typeof elem.textContent === 'string' ) {
				return elem.textContent;
			} else if ( typeof elem.innerText === 'string' ) {
				// Replace IE's carriage returns
				return elem.innerText.replace( rReturn, '' );
			} else {
				// Traverse it's children
				for ( elem = elem.firstChild; elem; elem = elem.nextSibling) {
					ret += getText( elem );
				}
			}
		} else if ( nodeType === 3 || nodeType === 4 ) {
			return elem.nodeValue;
		}
	} else {

		// If no nodeType, this is expected to be an array
		for ( i = 0; (node = elem[i]); i++ ) {
			// Do not traverse comment nodes
			if ( node.nodeType !== 8 ) {
				ret += getText( node );
			}
		}
	}
	return ret;
};

var Expr = Sizzle.selectors = {
	order: [ "ID", "NAME", "TAG" ],

	match: {
		ID: /#((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		CLASS: /\.((?:[\w\u00c0-\uFFFF\-]|\\.)+)/,
		NAME: /\[name=['"]*((?:[\w\u00c0-\uFFFF\-]|\\.)+)['"]*\]/,
		ATTR: /\[\s*((?:[\w\u00c0-\uFFFF\-]|\\.)+)\s*(?:(\S?=)\s*(?:(['"])(.*?)\3|(#?(?:[\w\u00c0-\uFFFF\-]|\\.)*)|)|)\s*\]/,
		TAG: /^((?:[\w\u00c0-\uFFFF\*\-]|\\.)+)/,
		CHILD: /:(only|nth|last|first)-child(?:\(\s*(even|odd|(?:[+\-]?\d+|(?:[+\-]?\d*)?n\s*(?:[+\-]\s*\d+)?))\s*\))?/,
		POS: /:(nth|eq|gt|lt|first|last|even|odd)(?:\((\d*)\))?(?=[^\-]|$)/,
		PSEUDO: /:((?:[\w\u00c0-\uFFFF\-]|\\.)+)(?:\((['"]?)((?:\([^\)]+\)|[^\(\)]*)+)\2\))?/
	},

	leftMatch: {},

	attrMap: {
		"class": "className",
		"for": "htmlFor"
	},

	attrHandle: {
		href: function( elem ) {
			return elem.getAttribute( "href" );
		},
		type: function( elem ) {
			return elem.getAttribute( "type" );
		}
	},

	relative: {
		"+": function(checkSet, part){
			var isPartStr = typeof part === "string",
				isTag = isPartStr && !rNonWord.test( part ),
				isPartStrNotTag = isPartStr && !isTag;

			if ( isTag ) {
				part = part.toLowerCase();
			}

			for ( var i = 0, l = checkSet.length, elem; i < l; i++ ) {
				if ( (elem = checkSet[i]) ) {
					while ( (elem = elem.previousSibling) && elem.nodeType !== 1 ) {}

					checkSet[i] = isPartStrNotTag || elem && elem.nodeName.toLowerCase() === part ?
						elem || false :
						elem === part;
				}
			}

			if ( isPartStrNotTag ) {
				Sizzle.filter( part, checkSet, true );
			}
		},

		">": function( checkSet, part ) {
			var elem,
				isPartStr = typeof part === "string",
				i = 0,
				l = checkSet.length;

			if ( isPartStr && !rNonWord.test( part ) ) {
				part = part.toLowerCase();

				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						var parent = elem.parentNode;
						checkSet[i] = parent.nodeName.toLowerCase() === part ? parent : false;
					}
				}

			} else {
				for ( ; i < l; i++ ) {
					elem = checkSet[i];

					if ( elem ) {
						checkSet[i] = isPartStr ?
							elem.parentNode :
							elem.parentNode === part;
					}
				}

				if ( isPartStr ) {
					Sizzle.filter( part, checkSet, true );
				}
			}
		},

		"": function(checkSet, part, isXML){
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "parentNode", part, doneName, checkSet, nodeCheck, isXML );
		},

		"~": function( checkSet, part, isXML ) {
			var nodeCheck,
				doneName = done++,
				checkFn = dirCheck;

			if ( typeof part === "string" && !rNonWord.test( part ) ) {
				part = part.toLowerCase();
				nodeCheck = part;
				checkFn = dirNodeCheck;
			}

			checkFn( "previousSibling", part, doneName, checkSet, nodeCheck, isXML );
		}
	},

	find: {
		ID: function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);
				// Check parentNode to catch when Blackberry 4.6 returns
				// nodes that are no longer in the document #6963
				return m && m.parentNode ? [m] : [];
			}
		},

		NAME: function( match, context ) {
			if ( typeof context.getElementsByName !== "undefined" ) {
				var ret = [],
					results = context.getElementsByName( match[1] );

				for ( var i = 0, l = results.length; i < l; i++ ) {
					if ( results[i].getAttribute("name") === match[1] ) {
						ret.push( results[i] );
					}
				}

				return ret.length === 0 ? null : ret;
			}
		},

		TAG: function( match, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( match[1] );
			}
		}
	},
	preFilter: {
		CLASS: function( match, curLoop, inplace, result, not, isXML ) {
			match = " " + match[1].replace( rBackslash, "" ) + " ";

			if ( isXML ) {
				return match;
			}

			for ( var i = 0, elem; (elem = curLoop[i]) != null; i++ ) {
				if ( elem ) {
					if ( not ^ (elem.className && (" " + elem.className + " ").replace(/[\t\n\r]/g, " ").indexOf(match) >= 0) ) {
						if ( !inplace ) {
							result.push( elem );
						}

					} else if ( inplace ) {
						curLoop[i] = false;
					}
				}
			}

			return false;
		},

		ID: function( match ) {
			return match[1].replace( rBackslash, "" );
		},

		TAG: function( match, curLoop ) {
			return match[1].replace( rBackslash, "" ).toLowerCase();
		},

		CHILD: function( match ) {
			if ( match[1] === "nth" ) {
				if ( !match[2] ) {
					Sizzle.error( match[0] );
				}

				match[2] = match[2].replace(/^\+|\s*/g, '');

				// parse equations like 'even', 'odd', '5', '2n', '3n+2', '4n-1', '-n+6'
				var test = /(-?)(\d*)(?:n([+\-]?\d*))?/.exec(
					match[2] === "even" && "2n" || match[2] === "odd" && "2n+1" ||
					!/\D/.test( match[2] ) && "0n+" + match[2] || match[2]);

				// calculate the numbers (first)n+(last) including if they are negative
				match[2] = (test[1] + (test[2] || 1)) - 0;
				match[3] = test[3] - 0;
			}
			else if ( match[2] ) {
				Sizzle.error( match[0] );
			}

			// TODO: Move to normal caching system
			match[0] = done++;

			return match;
		},

		ATTR: function( match, curLoop, inplace, result, not, isXML ) {
			var name = match[1] = match[1].replace( rBackslash, "" );
			
			if ( !isXML && Expr.attrMap[name] ) {
				match[1] = Expr.attrMap[name];
			}

			// Handle if an un-quoted value was used
			match[4] = ( match[4] || match[5] || "" ).replace( rBackslash, "" );

			if ( match[2] === "~=" ) {
				match[4] = " " + match[4] + " ";
			}

			return match;
		},

		PSEUDO: function( match, curLoop, inplace, result, not ) {
			if ( match[1] === "not" ) {
				// If we're dealing with a complex expression, or a simple one
				if ( ( chunker.exec(match[3]) || "" ).length > 1 || /^\w/.test(match[3]) ) {
					match[3] = Sizzle(match[3], null, null, curLoop);

				} else {
					var ret = Sizzle.filter(match[3], curLoop, inplace, true ^ not);

					if ( !inplace ) {
						result.push.apply( result, ret );
					}

					return false;
				}

			} else if ( Expr.match.POS.test( match[0] ) || Expr.match.CHILD.test( match[0] ) ) {
				return true;
			}
			
			return match;
		},

		POS: function( match ) {
			match.unshift( true );

			return match;
		}
	},
	
	filters: {
		enabled: function( elem ) {
			return elem.disabled === false && elem.type !== "hidden";
		},

		disabled: function( elem ) {
			return elem.disabled === true;
		},

		checked: function( elem ) {
			return elem.checked === true;
		},
		
		selected: function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}
			
			return elem.selected === true;
		},

		parent: function( elem ) {
			return !!elem.firstChild;
		},

		empty: function( elem ) {
			return !elem.firstChild;
		},

		has: function( elem, i, match ) {
			return !!Sizzle( match[3], elem ).length;
		},

		header: function( elem ) {
			return (/h\d/i).test( elem.nodeName );
		},

		text: function( elem ) {
			var attr = elem.getAttribute( "type" ), type = elem.type;
			// IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc) 
			// use getAttribute instead to test this case
			return elem.nodeName.toLowerCase() === "input" && "text" === type && ( attr === type || attr === null );
		},

		radio: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "radio" === elem.type;
		},

		checkbox: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "checkbox" === elem.type;
		},

		file: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "file" === elem.type;
		},

		password: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "password" === elem.type;
		},

		submit: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "submit" === elem.type;
		},

		image: function( elem ) {
			return elem.nodeName.toLowerCase() === "input" && "image" === elem.type;
		},

		reset: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return (name === "input" || name === "button") && "reset" === elem.type;
		},

		button: function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && "button" === elem.type || name === "button";
		},

		input: function( elem ) {
			return (/input|select|textarea|button/i).test( elem.nodeName );
		},

		focus: function( elem ) {
			return elem === elem.ownerDocument.activeElement;
		}
	},
	setFilters: {
		first: function( elem, i ) {
			return i === 0;
		},

		last: function( elem, i, match, array ) {
			return i === array.length - 1;
		},

		even: function( elem, i ) {
			return i % 2 === 0;
		},

		odd: function( elem, i ) {
			return i % 2 === 1;
		},

		lt: function( elem, i, match ) {
			return i < match[3] - 0;
		},

		gt: function( elem, i, match ) {
			return i > match[3] - 0;
		},

		nth: function( elem, i, match ) {
			return match[3] - 0 === i;
		},

		eq: function( elem, i, match ) {
			return match[3] - 0 === i;
		}
	},
	filter: {
		PSEUDO: function( elem, match, i, array ) {
			var name = match[1],
				filter = Expr.filters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );

			} else if ( name === "contains" ) {
				return (elem.textContent || elem.innerText || getText([ elem ]) || "").indexOf(match[3]) >= 0;

			} else if ( name === "not" ) {
				var not = match[3];

				for ( var j = 0, l = not.length; j < l; j++ ) {
					if ( not[j] === elem ) {
						return false;
					}
				}

				return true;

			} else {
				Sizzle.error( name );
			}
		},

		CHILD: function( elem, match ) {
			var first, last,
				doneName, parent, cache,
				count, diff,
				type = match[1],
				node = elem;

			switch ( type ) {
				case "only":
				case "first":
					while ( (node = node.previousSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					if ( type === "first" ) { 
						return true; 
					}

					node = elem;

				case "last":
					while ( (node = node.nextSibling) )	 {
						if ( node.nodeType === 1 ) { 
							return false; 
						}
					}

					return true;

				case "nth":
					first = match[2];
					last = match[3];

					if ( first === 1 && last === 0 ) {
						return true;
					}
					
					doneName = match[0];
					parent = elem.parentNode;
	
					if ( parent && (parent[ expando ] !== doneName || !elem.nodeIndex) ) {
						count = 0;
						
						for ( node = parent.firstChild; node; node = node.nextSibling ) {
							if ( node.nodeType === 1 ) {
								node.nodeIndex = ++count;
							}
						} 

						parent[ expando ] = doneName;
					}
					
					diff = elem.nodeIndex - last;

					if ( first === 0 ) {
						return diff === 0;

					} else {
						return ( diff % first === 0 && diff / first >= 0 );
					}
			}
		},

		ID: function( elem, match ) {
			return elem.nodeType === 1 && elem.getAttribute("id") === match;
		},

		TAG: function( elem, match ) {
			return (match === "*" && elem.nodeType === 1) || !!elem.nodeName && elem.nodeName.toLowerCase() === match;
		},
		
		CLASS: function( elem, match ) {
			return (" " + (elem.className || elem.getAttribute("class")) + " ")
				.indexOf( match ) > -1;
		},

		ATTR: function( elem, match ) {
			var name = match[1],
				result = Sizzle.attr ?
					Sizzle.attr( elem, name ) :
					Expr.attrHandle[ name ] ?
					Expr.attrHandle[ name ]( elem ) :
					elem[ name ] != null ?
						elem[ name ] :
						elem.getAttribute( name ),
				value = result + "",
				type = match[2],
				check = match[4];

			return result == null ?
				type === "!=" :
				!type && Sizzle.attr ?
				result != null :
				type === "=" ?
				value === check :
				type === "*=" ?
				value.indexOf(check) >= 0 :
				type === "~=" ?
				(" " + value + " ").indexOf(check) >= 0 :
				!check ?
				value && result !== false :
				type === "!=" ?
				value !== check :
				type === "^=" ?
				value.indexOf(check) === 0 :
				type === "$=" ?
				value.substr(value.length - check.length) === check :
				type === "|=" ?
				value === check || value.substr(0, check.length + 1) === check + "-" :
				false;
		},

		POS: function( elem, match, i, array ) {
			var name = match[2],
				filter = Expr.setFilters[ name ];

			if ( filter ) {
				return filter( elem, i, match, array );
			}
		}
	}
};

var origPOS = Expr.match.POS,
	fescape = function(all, num){
		return "\\" + (num - 0 + 1);
	};

for ( var type in Expr.match ) {
	Expr.match[ type ] = new RegExp( Expr.match[ type ].source + (/(?![^\[]*\])(?![^\(]*\))/.source) );
	Expr.leftMatch[ type ] = new RegExp( /(^(?:.|\r|\n)*?)/.source + Expr.match[ type ].source.replace(/\\(\d+)/g, fescape) );
}

var makeArray = function( array, results ) {
	array = Array.prototype.slice.call( array, 0 );

	if ( results ) {
		results.push.apply( results, array );
		return results;
	}
	
	return array;
};

// Perform a simple check to determine if the browser is capable of
// converting a NodeList to an array using builtin methods.
// Also verifies that the returned array holds DOM nodes
// (which is not the case in the Blackberry browser)
try {
	Array.prototype.slice.call( document.documentElement.childNodes, 0 )[0].nodeType;

// Provide a fallback method if it does not work
} catch( e ) {
	makeArray = function( array, results ) {
		var i = 0,
			ret = results || [];

		if ( toString.call(array) === "[object Array]" ) {
			Array.prototype.push.apply( ret, array );

		} else {
			if ( typeof array.length === "number" ) {
				for ( var l = array.length; i < l; i++ ) {
					ret.push( array[i] );
				}

			} else {
				for ( ; array[i]; i++ ) {
					ret.push( array[i] );
				}
			}
		}

		return ret;
	};
}

var sortOrder, siblingCheck;

if ( document.documentElement.compareDocumentPosition ) {
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		if ( !a.compareDocumentPosition || !b.compareDocumentPosition ) {
			return a.compareDocumentPosition ? -1 : 1;
		}

		return a.compareDocumentPosition(b) & 4 ? -1 : 1;
	};

} else {
	sortOrder = function( a, b ) {
		// The nodes are identical, we can exit early
		if ( a === b ) {
			hasDuplicate = true;
			return 0;

		// Fallback to using sourceIndex (in IE) if it's available on both nodes
		} else if ( a.sourceIndex && b.sourceIndex ) {
			return a.sourceIndex - b.sourceIndex;
		}

		var al, bl,
			ap = [],
			bp = [],
			aup = a.parentNode,
			bup = b.parentNode,
			cur = aup;

		// If the nodes are siblings (or identical) we can do a quick check
		if ( aup === bup ) {
			return siblingCheck( a, b );

		// If no parents were found then the nodes are disconnected
		} else if ( !aup ) {
			return -1;

		} else if ( !bup ) {
			return 1;
		}

		// Otherwise they're somewhere else in the tree so we need
		// to build up a full list of the parentNodes for comparison
		while ( cur ) {
			ap.unshift( cur );
			cur = cur.parentNode;
		}

		cur = bup;

		while ( cur ) {
			bp.unshift( cur );
			cur = cur.parentNode;
		}

		al = ap.length;
		bl = bp.length;

		// Start walking down the tree looking for a discrepancy
		for ( var i = 0; i < al && i < bl; i++ ) {
			if ( ap[i] !== bp[i] ) {
				return siblingCheck( ap[i], bp[i] );
			}
		}

		// We ended someplace up the tree so do a sibling check
		return i === al ?
			siblingCheck( a, bp[i], -1 ) :
			siblingCheck( ap[i], b, 1 );
	};

	siblingCheck = function( a, b, ret ) {
		if ( a === b ) {
			return ret;
		}

		var cur = a.nextSibling;

		while ( cur ) {
			if ( cur === b ) {
				return -1;
			}

			cur = cur.nextSibling;
		}

		return 1;
	};
}

// Check to see if the browser returns elements by name when
// querying by getElementById (and provide a workaround)
(function(){
	// We're going to inject a fake input element with a specified name
	var form = document.createElement("div"),
		id = "script" + (new Date()).getTime(),
		root = document.documentElement;

	form.innerHTML = "<a name='" + id + "'/>";

	// Inject it into the root element, check its status, and remove it quickly
	root.insertBefore( form, root.firstChild );

	// The workaround has to do additional checks after a getElementById
	// Which slows things down for other browsers (hence the branching)
	if ( document.getElementById( id ) ) {
		Expr.find.ID = function( match, context, isXML ) {
			if ( typeof context.getElementById !== "undefined" && !isXML ) {
				var m = context.getElementById(match[1]);

				return m ?
					m.id === match[1] || typeof m.getAttributeNode !== "undefined" && m.getAttributeNode("id").nodeValue === match[1] ?
						[m] :
						undefined :
					[];
			}
		};

		Expr.filter.ID = function( elem, match ) {
			var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");

			return elem.nodeType === 1 && node && node.nodeValue === match;
		};
	}

	root.removeChild( form );

	// release memory in IE
	root = form = null;
})();

(function(){
	// Check to see if the browser returns only elements
	// when doing getElementsByTagName("*")

	// Create a fake element
	var div = document.createElement("div");
	div.appendChild( document.createComment("") );

	// Make sure no comments are found
	if ( div.getElementsByTagName("*").length > 0 ) {
		Expr.find.TAG = function( match, context ) {
			var results = context.getElementsByTagName( match[1] );

			// Filter out possible comments
			if ( match[1] === "*" ) {
				var tmp = [];

				for ( var i = 0; results[i]; i++ ) {
					if ( results[i].nodeType === 1 ) {
						tmp.push( results[i] );
					}
				}

				results = tmp;
			}

			return results;
		};
	}

	// Check to see if an attribute returns normalized href attributes
	div.innerHTML = "<a href='#'></a>";

	if ( div.firstChild && typeof div.firstChild.getAttribute !== "undefined" &&
			div.firstChild.getAttribute("href") !== "#" ) {

		Expr.attrHandle.href = function( elem ) {
			return elem.getAttribute( "href", 2 );
		};
	}

	// release memory in IE
	div = null;
})();

if ( document.querySelectorAll ) {
	(function(){
		var oldSizzle = Sizzle,
			div = document.createElement("div"),
			id = "__sizzle__";

		div.innerHTML = "<p class='TEST'></p>";

		// Safari can't handle uppercase or unicode characters when
		// in quirks mode.
		if ( div.querySelectorAll && div.querySelectorAll(".TEST").length === 0 ) {
			return;
		}
	
		Sizzle = function( query, context, extra, seed ) {
			context = context || document;

			// Only use querySelectorAll on non-XML documents
			// (ID selectors don't work in non-HTML documents)
			if ( !seed && !Sizzle.isXML(context) ) {
				// See if we find a selector to speed up
				var match = /^(\w+$)|^\.([\w\-]+$)|^#([\w\-]+$)/.exec( query );
				
				if ( match && (context.nodeType === 1 || context.nodeType === 9) ) {
					// Speed-up: Sizzle("TAG")
					if ( match[1] ) {
						return makeArray( context.getElementsByTagName( query ), extra );
					
					// Speed-up: Sizzle(".CLASS")
					} else if ( match[2] && Expr.find.CLASS && context.getElementsByClassName ) {
						return makeArray( context.getElementsByClassName( match[2] ), extra );
					}
				}
				
				if ( context.nodeType === 9 ) {
					// Speed-up: Sizzle("body")
					// The body element only exists once, optimize finding it
					if ( query === "body" && context.body ) {
						return makeArray( [ context.body ], extra );
						
					// Speed-up: Sizzle("#ID")
					} else if ( match && match[3] ) {
						var elem = context.getElementById( match[3] );

						// Check parentNode to catch when Blackberry 4.6 returns
						// nodes that are no longer in the document #6963
						if ( elem && elem.parentNode ) {
							// Handle the case where IE and Opera return items
							// by name instead of ID
							if ( elem.id === match[3] ) {
								return makeArray( [ elem ], extra );
							}
							
						} else {
							return makeArray( [], extra );
						}
					}
					
					try {
						return makeArray( context.querySelectorAll(query), extra );
					} catch(qsaError) {}

				// qSA works strangely on Element-rooted queries
				// We can work around this by specifying an extra ID on the root
				// and working up from there (Thanks to Andrew Dupont for the technique)
				// IE 8 doesn't work on object elements
				} else if ( context.nodeType === 1 && context.nodeName.toLowerCase() !== "object" ) {
					var oldContext = context,
						old = context.getAttribute( "id" ),
						nid = old || id,
						hasParent = context.parentNode,
						relativeHierarchySelector = /^\s*[+~]/.test( query );

					if ( !old ) {
						context.setAttribute( "id", nid );
					} else {
						nid = nid.replace( /'/g, "\\$&" );
					}
					if ( relativeHierarchySelector && hasParent ) {
						context = context.parentNode;
					}

					try {
						if ( !relativeHierarchySelector || hasParent ) {
							return makeArray( context.querySelectorAll( "[id='" + nid + "'] " + query ), extra );
						}

					} catch(pseudoError) {
					} finally {
						if ( !old ) {
							oldContext.removeAttribute( "id" );
						}
					}
				}
			}
		
			return oldSizzle(query, context, extra, seed);
		};

		for ( var prop in oldSizzle ) {
			Sizzle[ prop ] = oldSizzle[ prop ];
		}

		// release memory in IE
		div = null;
	})();
}

(function(){
	var html = document.documentElement,
		matches = html.matchesSelector || html.mozMatchesSelector || html.webkitMatchesSelector || html.msMatchesSelector;

	if ( matches ) {
		// Check to see if it's possible to do matchesSelector
		// on a disconnected node (IE 9 fails this)
		var disconnectedMatch = !matches.call( document.createElement( "div" ), "div" ),
			pseudoWorks = false;

		try {
			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( document.documentElement, "[test!='']:sizzle" );
	
		} catch( pseudoError ) {
			pseudoWorks = true;
		}

		Sizzle.matchesSelector = function( node, expr ) {
			// Make sure that attribute selectors are quoted
			expr = expr.replace(/\=\s*([^'"\]]*)\s*\]/g, "='$1']");

			if ( !Sizzle.isXML( node ) ) {
				try { 
					if ( pseudoWorks || !Expr.match.PSEUDO.test( expr ) && !/!=/.test( expr ) ) {
						var ret = matches.call( node, expr );

						// IE 9's matchesSelector returns false on disconnected nodes
						if ( ret || !disconnectedMatch ||
								// As well, disconnected nodes are said to be in a document
								// fragment in IE 9, so check for that
								node.document && node.document.nodeType !== 11 ) {
							return ret;
						}
					}
				} catch(e) {}
			}

			return Sizzle(expr, null, null, [node]).length > 0;
		};
	}
})();

(function(){
	var div = document.createElement("div");

	div.innerHTML = "<div class='test e'></div><div class='test'></div>";

	// Opera can't find a second classname (in 9.6)
	// Also, make sure that getElementsByClassName actually exists
	if ( !div.getElementsByClassName || div.getElementsByClassName("e").length === 0 ) {
		return;
	}

	// Safari caches class attributes, doesn't catch changes (in 3.2)
	div.lastChild.className = "e";

	if ( div.getElementsByClassName("e").length === 1 ) {
		return;
	}
	
	Expr.order.splice(1, 0, "CLASS");
	Expr.find.CLASS = function( match, context, isXML ) {
		if ( typeof context.getElementsByClassName !== "undefined" && !isXML ) {
			return context.getElementsByClassName(match[1]);
		}
	};

	// release memory in IE
	div = null;
})();

function dirNodeCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;

			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 && !isXML ){
					elem[ expando ] = doneName;
					elem.sizset = i;
				}

				if ( elem.nodeName.toLowerCase() === cur ) {
					match = elem;
					break;
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

function dirCheck( dir, cur, doneName, checkSet, nodeCheck, isXML ) {
	for ( var i = 0, l = checkSet.length; i < l; i++ ) {
		var elem = checkSet[i];

		if ( elem ) {
			var match = false;
			
			elem = elem[dir];

			while ( elem ) {
				if ( elem[ expando ] === doneName ) {
					match = checkSet[elem.sizset];
					break;
				}

				if ( elem.nodeType === 1 ) {
					if ( !isXML ) {
						elem[ expando ] = doneName;
						elem.sizset = i;
					}

					if ( typeof cur !== "string" ) {
						if ( elem === cur ) {
							match = true;
							break;
						}

					} else if ( Sizzle.filter( cur, [elem] ).length > 0 ) {
						match = elem;
						break;
					}
				}

				elem = elem[dir];
			}

			checkSet[i] = match;
		}
	}
}

if ( document.documentElement.contains ) {
	Sizzle.contains = function( a, b ) {
		return a !== b && (a.contains ? a.contains(b) : true);
	};

} else if ( document.documentElement.compareDocumentPosition ) {
	Sizzle.contains = function( a, b ) {
		return !!(a.compareDocumentPosition(b) & 16);
	};

} else {
	Sizzle.contains = function() {
		return false;
	};
}

Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833) 
	var documentElement = (elem ? elem.ownerDocument || elem : 0).documentElement;

	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

var posProcess = function( selector, context, seed ) {
	var match,
		tmpSet = [],
		later = "",
		root = context.nodeType ? [context] : context;

	// Position selectors must be done after the filter
	// And so must :not(positional) so we move all PSEUDOs to the end
	while ( (match = Expr.match.PSEUDO.exec( selector )) ) {
		later += match[0];
		selector = selector.replace( Expr.match.PSEUDO, "" );
	}

	selector = Expr.relative[selector] ? selector + "*" : selector;

	for ( var i = 0, l = root.length; i < l; i++ ) {
		Sizzle( selector, root[i], tmpSet, seed );
	}

	return Sizzle.filter( later, tmpSet );
};

// EXPOSE
// Override sizzle attribute retrieval
Sizzle.attr = jQuery.attr;
Sizzle.selectors.attrMap = {};
jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[":"] = jQuery.expr.filters;
jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;


})();


var runtil = /Until$/,
	rparentsprev = /^(?:parents|prevUntil|prevAll)/,
	// Note: This RegExp should be improved, or likely pulled from Sizzle
	rmultiselector = /,/,
	isSimple = /^.[^:#\[\.,]*$/,
	slice = Array.prototype.slice,
	POS = jQuery.expr.match.POS,
	// methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend({
	find: function( selector ) {
		var self = this,
			i, l;

		if ( typeof selector !== "string" ) {
			return jQuery( selector ).filter(function() {
				for ( i = 0, l = self.length; i < l; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			});
		}

		var ret = this.pushStack( "", "find", selector ),
			length, n, r;

		for ( i = 0, l = this.length; i < l; i++ ) {
			length = ret.length;
			jQuery.find( selector, this[i], ret );

			if ( i > 0 ) {
				// Make sure that the results are unique
				for ( n = length; n < ret.length; n++ ) {
					for ( r = 0; r < length; r++ ) {
						if ( ret[r] === ret[n] ) {
							ret.splice(n--, 1);
							break;
						}
					}
				}
			}
		}

		return ret;
	},

	has: function( target ) {
		var targets = jQuery( target );
		return this.filter(function() {
			for ( var i = 0, l = targets.length; i < l; i++ ) {
				if ( jQuery.contains( this, targets[i] ) ) {
					return true;
				}
			}
		});
	},

	not: function( selector ) {
		return this.pushStack( winnow(this, selector, false), "not", selector);
	},

	filter: function( selector ) {
		return this.pushStack( winnow(this, selector, true), "filter", selector );
	},

	is: function( selector ) {
		return !!selector && ( 
			typeof selector === "string" ?
				// If this is a positional selector, check membership in the returned set
				// so $("p:first").is("p:last") won't return true for a doc with two "p".
				POS.test( selector ) ? 
					jQuery( selector, this.context ).index( this[0] ) >= 0 :
					jQuery.filter( selector, this ).length > 0 :
				this.filter( selector ).length > 0 );
	},

	closest: function( selectors, context ) {
		var ret = [], i, l, cur = this[0];
		
		// Array (deprecated as of jQuery 1.7)
		if ( jQuery.isArray( selectors ) ) {
			var level = 1;

			while ( cur && cur.ownerDocument && cur !== context ) {
				for ( i = 0; i < selectors.length; i++ ) {

					if ( jQuery( cur ).is( selectors[ i ] ) ) {
						ret.push({ selector: selectors[ i ], elem: cur, level: level });
					}
				}

				cur = cur.parentNode;
				level++;
			}

			return ret;
		}

		// String
		var pos = POS.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( i = 0, l = this.length; i < l; i++ ) {
			cur = this[i];

			while ( cur ) {
				if ( pos ? pos.index(cur) > -1 : jQuery.find.matchesSelector(cur, selectors) ) {
					ret.push( cur );
					break;

				} else {
					cur = cur.parentNode;
					if ( !cur || !cur.ownerDocument || cur === context || cur.nodeType === 11 ) {
						break;
					}
				}
			}
		}

		ret = ret.length > 1 ? jQuery.unique( ret ) : ret;

		return this.pushStack( ret, "closest", selectors );
	},

	// Determine the position of an element within
	// the matched set of elements
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[0] && this[0].parentNode ) ? this.prevAll().length : -1;
		}

		// index in selector
		if ( typeof elem === "string" ) {
			return jQuery.inArray( this[0], jQuery( elem ) );
		}

		// Locate the position of the desired element
		return jQuery.inArray(
			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[0] : elem, this );
	},

	add: function( selector, context ) {
		var set = typeof selector === "string" ?
				jQuery( selector, context ) :
				jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),
			all = jQuery.merge( this.get(), set );

		return this.pushStack( isDisconnected( set[0] ) || isDisconnected( all[0] ) ?
			all :
			jQuery.unique( all ) );
	},

	andSelf: function() {
		return this.add( this.prevObject );
	}
});

// A painfully simple check to see if an element is disconnected
// from a document (should be improved, where feasible).
function isDisconnected( node ) {
	return !node || !node.parentNode || node.parentNode.nodeType === 11;
}

jQuery.each({
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return jQuery.dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return jQuery.nth( elem, 2, "nextSibling" );
	},
	prev: function( elem ) {
		return jQuery.nth( elem, 2, "previousSibling" );
	},
	nextAll: function( elem ) {
		return jQuery.dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return jQuery.dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return jQuery.dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return jQuery.sibling( elem.parentNode.firstChild, elem );
	},
	children: function( elem ) {
		return jQuery.sibling( elem.firstChild );
	},
	contents: function( elem ) {
		return jQuery.nodeName( elem, "iframe" ) ?
			elem.contentDocument || elem.contentWindow.document :
			jQuery.makeArray( elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var ret = jQuery.map( this, fn, until );

		if ( !runtil.test( name ) ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			ret = jQuery.filter( selector, ret );
		}

		ret = this.length > 1 && !guaranteedUnique[ name ] ? jQuery.unique( ret ) : ret;

		if ( (this.length > 1 || rmultiselector.test( selector )) && rparentsprev.test( name ) ) {
			ret = ret.reverse();
		}

		return this.pushStack( ret, name, slice.call( arguments ).join(",") );
	};
});

jQuery.extend({
	filter: function( expr, elems, not ) {
		if ( not ) {
			expr = ":not(" + expr + ")";
		}

		return elems.length === 1 ?
			jQuery.find.matchesSelector(elems[0], expr) ? [ elems[0] ] : [] :
			jQuery.find.matches(expr, elems);
	},

	dir: function( elem, dir, until ) {
		var matched = [],
			cur = elem[ dir ];

		while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {
			if ( cur.nodeType === 1 ) {
				matched.push( cur );
			}
			cur = cur[dir];
		}
		return matched;
	},

	nth: function( cur, result, dir, elem ) {
		result = result || 1;
		var num = 0;

		for ( ; cur; cur = cur[dir] ) {
			if ( cur.nodeType === 1 && ++num === result ) {
				break;
			}
		}

		return cur;
	},

	sibling: function( n, elem ) {
		var r = [];

		for ( ; n; n = n.nextSibling ) {
			if ( n.nodeType === 1 && n !== elem ) {
				r.push( n );
			}
		}

		return r;
	}
});

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, keep ) {

	// Can't pass null or undefined to indexOf in Firefox 4
	// Set to 0 to skip string check
	qualifier = qualifier || 0;

	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep(elements, function( elem, i ) {
			var retVal = !!qualifier.call( elem, i, elem );
			return retVal === keep;
		});

	} else if ( qualifier.nodeType ) {
		return jQuery.grep(elements, function( elem, i ) {
			return ( elem === qualifier ) === keep;
		});

	} else if ( typeof qualifier === "string" ) {
		var filtered = jQuery.grep(elements, function( elem ) {
			return elem.nodeType === 1;
		});

		if ( isSimple.test( qualifier ) ) {
			return jQuery.filter(qualifier, filtered, !keep);
		} else {
			qualifier = jQuery.filter( qualifier, filtered );
		}
	}

	return jQuery.grep(elements, function( elem, i ) {
		return ( jQuery.inArray( elem, qualifier ) >= 0 ) === keep;
	});
}




function createSafeFragment( document ) {
	var list = nodeNames.split( "|" ),
	safeFrag = document.createDocumentFragment();

	if ( safeFrag.createElement ) {
		while ( list.length ) {
			safeFrag.createElement(
				list.pop()
			);
		}
	}
	return safeFrag;
}

var nodeNames = "abbr|article|aside|audio|canvas|datalist|details|figcaption|figure|footer|" +
		"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",
	rinlinejQuery = / jQuery\d+="(?:\d+|null)"/g,
	rleadingWhitespace = /^\s+/,
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/ig,
	rtagName = /<([\w:]+)/,
	rtbody = /<tbody/i,
	rhtml = /<|&#?\w+;/,
	rnoInnerhtml = /<(?:script|style)/i,
	rnocache = /<(?:script|object|embed|option|style)/i,
	rnoshimcache = new RegExp("<(?:" + nodeNames + ")", "i"),
	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptType = /\/(java|ecma)script/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|\-\-)/,
	wrapMap = {
		option: [ 1, "<select multiple='multiple'>", "</select>" ],
		legend: [ 1, "<fieldset>", "</fieldset>" ],
		thead: [ 1, "<table>", "</table>" ],
		tr: [ 2, "<table><tbody>", "</tbody></table>" ],
		td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
		col: [ 2, "<table><tbody></tbody><colgroup>", "</colgroup></table>" ],
		area: [ 1, "<map>", "</map>" ],
		_default: [ 0, "", "" ]
	},
	safeFragment = createSafeFragment( document );

wrapMap.optgroup = wrapMap.option;
wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// IE can't serialize <link> and <script> tags normally
if ( !jQuery.support.htmlSerialize ) {
	wrapMap._default = [ 1, "div<div>", "</div>" ];
}

jQuery.fn.extend({
	text: function( text ) {
		if ( jQuery.isFunction(text) ) {
			return this.each(function(i) {
				var self = jQuery( this );

				self.text( text.call(this, i, self.text()) );
			});
		}

		if ( typeof text !== "object" && text !== undefined ) {
			return this.empty().append( (this[0] && this[0].ownerDocument || document).createTextNode( text ) );
		}

		return jQuery.text( this );
	},

	wrapAll: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapAll( html.call(this, i) );
			});
		}

		if ( this[0] ) {
			// The elements to wrap the target around
			var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);

			if ( this[0].parentNode ) {
				wrap.insertBefore( this[0] );
			}

			wrap.map(function() {
				var elem = this;

				while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {
					elem = elem.firstChild;
				}

				return elem;
			}).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each(function(i) {
				jQuery(this).wrapInner( html.call(this, i) );
			});
		}

		return this.each(function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		});
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each(function(i) {
			jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );
		});
	},

	unwrap: function() {
		return this.parent().each(function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		}).end();
	},

	append: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.appendChild( elem );
			}
		});
	},

	prepend: function() {
		return this.domManip(arguments, true, function( elem ) {
			if ( this.nodeType === 1 ) {
				this.insertBefore( elem, this.firstChild );
			}
		});
	},

	before: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this );
			});
		} else if ( arguments.length ) {
			var set = jQuery.clean( arguments );
			set.push.apply( set, this.toArray() );
			return this.pushStack( set, "before", arguments );
		}
	},

	after: function() {
		if ( this[0] && this[0].parentNode ) {
			return this.domManip(arguments, false, function( elem ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			});
		} else if ( arguments.length ) {
			var set = this.pushStack( this, "after", arguments );
			set.push.apply( set, jQuery.clean(arguments) );
			return set;
		}
	},

	// keepData is for internal use only--do not document
	remove: function( selector, keepData ) {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			if ( !selector || jQuery.filter( selector, [ elem ] ).length ) {
				if ( !keepData && elem.nodeType === 1 ) {
					jQuery.cleanData( elem.getElementsByTagName("*") );
					jQuery.cleanData( [ elem ] );
				}

				if ( elem.parentNode ) {
					elem.parentNode.removeChild( elem );
				}
			}
		}

		return this;
	},

	empty: function() {
		for ( var i = 0, elem; (elem = this[i]) != null; i++ ) {
			// Remove element nodes and prevent memory leaks
			if ( elem.nodeType === 1 ) {
				jQuery.cleanData( elem.getElementsByTagName("*") );
			}

			// Remove any remaining nodes
			while ( elem.firstChild ) {
				elem.removeChild( elem.firstChild );
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function () {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		});
	},

	html: function( value ) {
		if ( value === undefined ) {
			return this[0] && this[0].nodeType === 1 ?
				this[0].innerHTML.replace(rinlinejQuery, "") :
				null;

		// See if we can take a shortcut and just use innerHTML
		} else if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
			(jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value )) &&
			!wrapMap[ (rtagName.exec( value ) || ["", ""])[1].toLowerCase() ] ) {

			value = value.replace(rxhtmlTag, "<$1></$2>");

			try {
				for ( var i = 0, l = this.length; i < l; i++ ) {
					// Remove element nodes and prevent memory leaks
					if ( this[i].nodeType === 1 ) {
						jQuery.cleanData( this[i].getElementsByTagName("*") );
						this[i].innerHTML = value;
					}
				}

			// If using innerHTML throws an exception, use the fallback method
			} catch(e) {
				this.empty().append( value );
			}

		} else if ( jQuery.isFunction( value ) ) {
			this.each(function(i){
				var self = jQuery( this );

				self.html( value.call(this, i, self.html()) );
			});

		} else {
			this.empty().append( value );
		}

		return this;
	},

	replaceWith: function( value ) {
		if ( this[0] && this[0].parentNode ) {
			// Make sure that the elements are removed from the DOM before they are inserted
			// this can help fix replacing a parent with child elements
			if ( jQuery.isFunction( value ) ) {
				return this.each(function(i) {
					var self = jQuery(this), old = self.html();
					self.replaceWith( value.call( this, i, old ) );
				});
			}

			if ( typeof value !== "string" ) {
				value = jQuery( value ).detach();
			}

			return this.each(function() {
				var next = this.nextSibling,
					parent = this.parentNode;

				jQuery( this ).remove();

				if ( next ) {
					jQuery(next).before( value );
				} else {
					jQuery(parent).append( value );
				}
			});
		} else {
			return this.length ?
				this.pushStack( jQuery(jQuery.isFunction(value) ? value() : value), "replaceWith", value ) :
				this;
		}
	},

	detach: function( selector ) {
		return this.remove( selector, true );
	},

	domManip: function( args, table, callback ) {
		var results, first, fragment, parent,
			value = args[0],
			scripts = [];

		// We can't cloneNode fragments that contain checked, in WebKit
		if ( !jQuery.support.checkClone && arguments.length === 3 && typeof value === "string" && rchecked.test( value ) ) {
			return this.each(function() {
				jQuery(this).domManip( args, table, callback, true );
			});
		}

		if ( jQuery.isFunction(value) ) {
			return this.each(function(i) {
				var self = jQuery(this);
				args[0] = value.call(this, i, table ? self.html() : undefined);
				self.domManip( args, table, callback );
			});
		}

		if ( this[0] ) {
			parent = value && value.parentNode;

			// If we're in a fragment, just use that instead of building a new one
			if ( jQuery.support.parentNode && parent && parent.nodeType === 11 && parent.childNodes.length === this.length ) {
				results = { fragment: parent };

			} else {
				results = jQuery.buildFragment( args, this, scripts );
			}

			fragment = results.fragment;

			if ( fragment.childNodes.length === 1 ) {
				first = fragment = fragment.firstChild;
			} else {
				first = fragment.firstChild;
			}

			if ( first ) {
				table = table && jQuery.nodeName( first, "tr" );

				for ( var i = 0, l = this.length, lastIndex = l - 1; i < l; i++ ) {
					callback.call(
						table ?
							root(this[i], first) :
							this[i],
						// Make sure that we do not leak memory by inadvertently discarding
						// the original fragment (which might have attached data) instead of
						// using it; in addition, use the original fragment object for the last
						// item instead of first because it can end up being emptied incorrectly
						// in certain situations (Bug #8070).
						// Fragments from the fragment cache must always be cloned and never used
						// in place.
						results.cacheable || ( l > 1 && i < lastIndex ) ?
							jQuery.clone( fragment, true, true ) :
							fragment
					);
				}
			}

			if ( scripts.length ) {
				jQuery.each( scripts, evalScript );
			}
		}

		return this;
	}
});

function root( elem, cur ) {
	return jQuery.nodeName(elem, "table") ?
		(elem.getElementsByTagName("tbody")[0] ||
		elem.appendChild(elem.ownerDocument.createElement("tbody"))) :
		elem;
}

function cloneCopyEvent( src, dest ) {

	if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {
		return;
	}

	var type, i, l,
		oldData = jQuery._data( src ),
		curData = jQuery._data( dest, oldData ),
		events = oldData.events;

	if ( events ) {
		delete curData.handle;
		curData.events = {};

		for ( type in events ) {
			for ( i = 0, l = events[ type ].length; i < l; i++ ) {
				jQuery.event.add( dest, type + ( events[ type ][ i ].namespace ? "." : "" ) + events[ type ][ i ].namespace, events[ type ][ i ], events[ type ][ i ].data );
			}
		}
	}

	// make the cloned public data object a copy from the original
	if ( curData.data ) {
		curData.data = jQuery.extend( {}, curData.data );
	}
}

function cloneFixAttributes( src, dest ) {
	var nodeName;

	// We do not need to do anything for non-Elements
	if ( dest.nodeType !== 1 ) {
		return;
	}

	// clearAttributes removes the attributes, which we don't want,
	// but also removes the attachEvent events, which we *do* want
	if ( dest.clearAttributes ) {
		dest.clearAttributes();
	}

	// mergeAttributes, in contrast, only merges back on the
	// original attributes, not the events
	if ( dest.mergeAttributes ) {
		dest.mergeAttributes( src );
	}

	nodeName = dest.nodeName.toLowerCase();

	// IE6-8 fail to clone children inside object elements that use
	// the proprietary classid attribute value (rather than the type
	// attribute) to identify the type of content to display
	if ( nodeName === "object" ) {
		dest.outerHTML = src.outerHTML;

	} else if ( nodeName === "input" && (src.type === "checkbox" || src.type === "radio") ) {
		// IE6-8 fails to persist the checked state of a cloned checkbox
		// or radio button. Worse, IE6-7 fail to give the cloned element
		// a checked appearance if the defaultChecked value isn't also set
		if ( src.checked ) {
			dest.defaultChecked = dest.checked = src.checked;
		}

		// IE6-7 get confused and end up setting the value of a cloned
		// checkbox/radio button to an empty string instead of "on"
		if ( dest.value !== src.value ) {
			dest.value = src.value;
		}

	// IE6-8 fails to return the selected option to the default selected
	// state when cloning options
	} else if ( nodeName === "option" ) {
		dest.selected = src.defaultSelected;

	// IE6-8 fails to set the defaultValue to the correct value when
	// cloning other types of input fields
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}

	// Event data gets referenced instead of copied if the expando
	// gets copied too
	dest.removeAttribute( jQuery.expando );
}

jQuery.buildFragment = function( args, nodes, scripts ) {
	var fragment, cacheable, cacheresults, doc,
	first = args[ 0 ];

	// nodes may contain either an explicit document object,
	// a jQuery collection or context object.
	// If nodes[0] contains a valid object to assign to doc
	if ( nodes && nodes[0] ) {
		doc = nodes[0].ownerDocument || nodes[0];
	}

	// Ensure that an attr object doesn't incorrectly stand in as a document object
	// Chrome and Firefox seem to allow this to occur and will throw exception
	// Fixes #8950
	if ( !doc.createDocumentFragment ) {
		doc = document;
	}

	// Only cache "small" (1/2 KB) HTML strings that are associated with the main document
	// Cloning options loses the selected state, so don't cache them
	// IE 6 doesn't like it when you put <object> or <embed> elements in a fragment
	// Also, WebKit does not clone 'checked' attributes on cloneNode, so don't cache
	// Lastly, IE6,7,8 will not correctly reuse cached fragments that were created from unknown elems #10501
	if ( args.length === 1 && typeof first === "string" && first.length < 512 && doc === document &&
		first.charAt(0) === "<" && !rnocache.test( first ) &&
		(jQuery.support.checkClone || !rchecked.test( first )) &&
		(jQuery.support.html5Clone || !rnoshimcache.test( first )) ) {

		cacheable = true;

		cacheresults = jQuery.fragments[ first ];
		if ( cacheresults && cacheresults !== 1 ) {
			fragment = cacheresults;
		}
	}

	if ( !fragment ) {
		fragment = doc.createDocumentFragment();
		jQuery.clean( args, doc, fragment, scripts );
	}

	if ( cacheable ) {
		jQuery.fragments[ first ] = cacheresults ? fragment : 1;
	}

	return { fragment: fragment, cacheable: cacheable };
};

jQuery.fragments = {};

jQuery.each({
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var ret = [],
			insert = jQuery( selector ),
			parent = this.length === 1 && this[0].parentNode;

		if ( parent && parent.nodeType === 11 && parent.childNodes.length === 1 && insert.length === 1 ) {
			insert[ original ]( this[0] );
			return this;

		} else {
			for ( var i = 0, l = insert.length; i < l; i++ ) {
				var elems = ( i > 0 ? this.clone(true) : this ).get();
				jQuery( insert[i] )[ original ]( elems );
				ret = ret.concat( elems );
			}

			return this.pushStack( ret, name, insert.selector );
		}
	};
});

function getAll( elem ) {
	if ( typeof elem.getElementsByTagName !== "undefined" ) {
		return elem.getElementsByTagName( "*" );

	} else if ( typeof elem.querySelectorAll !== "undefined" ) {
		return elem.querySelectorAll( "*" );

	} else {
		return [];
	}
}

// Used in clean, fixes the defaultChecked property
function fixDefaultChecked( elem ) {
	if ( elem.type === "checkbox" || elem.type === "radio" ) {
		elem.defaultChecked = elem.checked;
	}
}
// Finds all inputs and passes them to fixDefaultChecked
function findInputs( elem ) {
	var nodeName = ( elem.nodeName || "" ).toLowerCase();
	if ( nodeName === "input" ) {
		fixDefaultChecked( elem );
	// Skip scripts, get other children
	} else if ( nodeName !== "script" && typeof elem.getElementsByTagName !== "undefined" ) {
		jQuery.grep( elem.getElementsByTagName("input"), fixDefaultChecked );
	}
}

// Derived From: http://www.iecss.com/shimprove/javascript/shimprove.1-0-1.js
function shimCloneNode( elem ) {
	var div = document.createElement( "div" );
	safeFragment.appendChild( div );

	div.innerHTML = elem.outerHTML;
	return div.firstChild;
}

jQuery.extend({
	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var srcElements,
			destElements,
			i,
			// IE<=8 does not properly clone detached, unknown element nodes
			clone = jQuery.support.html5Clone || !rnoshimcache.test( "<" + elem.nodeName ) ?
				elem.cloneNode( true ) :
				shimCloneNode( elem );

		if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&
				(elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {
			// IE copies events bound via attachEvent when using cloneNode.
			// Calling detachEvent on the clone will also remove the events
			// from the original. In order to get around this, we use some
			// proprietary methods to clear the events. Thanks to MooTools
			// guys for this hotness.

			cloneFixAttributes( elem, clone );

			// Using Sizzle here is crazy slow, so we use getElementsByTagName instead
			srcElements = getAll( elem );
			destElements = getAll( clone );

			// Weird iteration because IE will replace the length property
			// with an element if you are cloning the body and one of the
			// elements on the page has a name or id of "length"
			for ( i = 0; srcElements[i]; ++i ) {
				// Ensure that the destination node is not null; Fixes #9587
				if ( destElements[i] ) {
					cloneFixAttributes( srcElements[i], destElements[i] );
				}
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			cloneCopyEvent( elem, clone );

			if ( deepDataAndEvents ) {
				srcElements = getAll( elem );
				destElements = getAll( clone );

				for ( i = 0; srcElements[i]; ++i ) {
					cloneCopyEvent( srcElements[i], destElements[i] );
				}
			}
		}

		srcElements = destElements = null;

		// Return the cloned set
		return clone;
	},

	clean: function( elems, context, fragment, scripts ) {
		var checkScriptType;

		context = context || document;

		// !context.createElement fails in IE with an error but returns typeof 'object'
		if ( typeof context.createElement === "undefined" ) {
			context = context.ownerDocument || context[0] && context[0].ownerDocument || document;
		}

		var ret = [], j;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( typeof elem === "number" ) {
				elem += "";
			}

			if ( !elem ) {
				continue;
			}

			// Convert html string into DOM nodes
			if ( typeof elem === "string" ) {
				if ( !rhtml.test( elem ) ) {
					elem = context.createTextNode( elem );
				} else {
					// Fix "XHTML"-style tags in all browsers
					elem = elem.replace(rxhtmlTag, "<$1></$2>");

					// Trim whitespace, otherwise indexOf won't work as expected
					var tag = ( rtagName.exec( elem ) || ["", ""] )[1].toLowerCase(),
						wrap = wrapMap[ tag ] || wrapMap._default,
						depth = wrap[0],
						div = context.createElement("div");

					// Append wrapper element to unknown element safe doc fragment
					if ( context === document ) {
						// Use the fragment we've already created for this document
						safeFragment.appendChild( div );
					} else {
						// Use a fragment created with the owner document
						createSafeFragment( context ).appendChild( div );
					}

					// Go to html and back, then peel off extra wrappers
					div.innerHTML = wrap[1] + elem + wrap[2];

					// Move to the right depth
					while ( depth-- ) {
						div = div.lastChild;
					}

					// Remove IE's autoinserted <tbody> from table fragments
					if ( !jQuery.support.tbody ) {

						// String was a <table>, *may* have spurious <tbody>
						var hasBody = rtbody.test(elem),
							tbody = tag === "table" && !hasBody ?
								div.firstChild && div.firstChild.childNodes :

								// String was a bare <thead> or <tfoot>
								wrap[1] === "<table>" && !hasBody ?
									div.childNodes :
									[];

						for ( j = tbody.length - 1; j >= 0 ; --j ) {
							if ( jQuery.nodeName( tbody[ j ], "tbody" ) && !tbody[ j ].childNodes.length ) {
								tbody[ j ].parentNode.removeChild( tbody[ j ] );
							}
						}
					}

					// IE completely kills leading whitespace when innerHTML is used
					if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {
						div.insertBefore( context.createTextNode( rleadingWhitespace.exec(elem)[0] ), div.firstChild );
					}

					elem = div.childNodes;
				}
			}

			// Resets defaultChecked for any radios and checkboxes
			// about to be appended to the DOM in IE 6/7 (#8060)
			var len;
			if ( !jQuery.support.appendChecked ) {
				if ( elem[0] && typeof (len = elem.length) === "number" ) {
					for ( j = 0; j < len; j++ ) {
						findInputs( elem[j] );
					}
				} else {
					findInputs( elem );
				}
			}

			if ( elem.nodeType ) {
				ret.push( elem );
			} else {
				ret = jQuery.merge( ret, elem );
			}
		}

		if ( fragment ) {
			checkScriptType = function( elem ) {
				return !elem.type || rscriptType.test( elem.type );
			};
			for ( i = 0; ret[i]; i++ ) {
				if ( scripts && jQuery.nodeName( ret[i], "script" ) && (!ret[i].type || ret[i].type.toLowerCase() === "text/javascript") ) {
					scripts.push( ret[i].parentNode ? ret[i].parentNode.removeChild( ret[i] ) : ret[i] );

				} else {
					if ( ret[i].nodeType === 1 ) {
						var jsTags = jQuery.grep( ret[i].getElementsByTagName( "script" ), checkScriptType );

						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
					}
					fragment.appendChild( ret[i] );
				}
			}
		}

		return ret;
	},

	cleanData: function( elems ) {
		var data, id,
			cache = jQuery.cache,
			special = jQuery.event.special,
			deleteExpando = jQuery.support.deleteExpando;

		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			if ( elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()] ) {
				continue;
			}

			id = elem[ jQuery.expando ];

			if ( id ) {
				data = cache[ id ];

				if ( data && data.events ) {
					for ( var type in data.events ) {
						if ( special[ type ] ) {
							jQuery.event.remove( elem, type );

						// This is a shortcut to avoid jQuery.event.remove's overhead
						} else {
							jQuery.removeEvent( elem, type, data.handle );
						}
					}

					// Null the DOM reference to avoid IE6/7/8 leak (#7054)
					if ( data.handle ) {
						data.handle.elem = null;
					}
				}

				if ( deleteExpando ) {
					delete elem[ jQuery.expando ];

				} else if ( elem.removeAttribute ) {
					elem.removeAttribute( jQuery.expando );
				}

				delete cache[ id ];
			}
		}
	}
});

function evalScript( i, elem ) {
	if ( elem.src ) {
		jQuery.ajax({
			url: elem.src,
			async: false,
			dataType: "script"
		});
	} else {
		jQuery.globalEval( ( elem.text || elem.textContent || elem.innerHTML || "" ).replace( rcleanScript, "/*$0*/" ) );
	}

	if ( elem.parentNode ) {
		elem.parentNode.removeChild( elem );
	}
}




var ralpha = /alpha\([^)]*\)/i,
	ropacity = /opacity=([^)]*)/,
	// fixed for IE9, see #8346
	rupper = /([A-Z]|^ms)/g,
	rnumpx = /^-?\d+(?:px)?$/i,
	rnum = /^-?\d/,
	rrelNum = /^([\-+])=([\-+.\de]+)/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssWidth = [ "Left", "Right" ],
	cssHeight = [ "Top", "Bottom" ],
	curCSS,

	getComputedStyle,
	currentStyle;

jQuery.fn.css = function( name, value ) {
	// Setting 'undefined' is a no-op
	if ( arguments.length === 2 && value === undefined ) {
		return this;
	}

	return jQuery.access( this, name, value, true, function( elem, name, value ) {
		return value !== undefined ?
			jQuery.style( elem, name, value ) :
			jQuery.css( elem, name );
	});
};

jQuery.extend({
	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {
					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity", "opacity" );
					return ret === "" ? "1" : ret;

				} else {
					return elem.style.opacity;
				}
			}
		}
	},

	// Exclude the following css properties to add px
	cssNumber: {
		"fillOpacity": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		// normalize float css property
		"float": jQuery.support.cssFloat ? "cssFloat" : "styleFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {
		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, origName = jQuery.camelCase( name ),
			style = elem.style, hooks = jQuery.cssHooks[ origName ];

		name = jQuery.cssProps[ origName ] || origName;

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// convert relative number strings (+= or -=) to relative numbers. #7345
			if ( type === "string" && (ret = rrelNum.exec( value )) ) {
				value = ( +( ret[1] + 1) * +ret[2] ) + parseFloat( jQuery.css( elem, name ) );
				// Fixes bug #9237
				type = "number";
			}

			// Make sure that NaN and null values aren't set. See: #7116
			if ( value == null || type === "number" && isNaN( value ) ) {
				return;
			}

			// If a number was passed in, add 'px' to the (except for certain CSS properties)
			if ( type === "number" && !jQuery.cssNumber[ origName ] ) {
				value += "px";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !("set" in hooks) || (value = hooks.set( elem, value )) !== undefined ) {
				// Wrapped to prevent IE from throwing errors when 'invalid' values are provided
				// Fixes bug #5509
				try {
					style[ name ] = value;
				} catch(e) {}
			}

		} else {
			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {
				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra ) {
		var ret, hooks;

		// Make sure that we're working with the right name
		name = jQuery.camelCase( name );
		hooks = jQuery.cssHooks[ name ];
		name = jQuery.cssProps[ name ] || name;

		// cssFloat needs a special treatment
		if ( name === "cssFloat" ) {
			name = "float";
		}

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks && (ret = hooks.get( elem, true, extra )) !== undefined ) {
			return ret;

		// Otherwise, if a way to get the computed value exists, use that
		} else if ( curCSS ) {
			return curCSS( elem, name );
		}
	},

	// A method for quickly swapping in/out CSS properties to get correct calculations
	swap: function( elem, options, callback ) {
		var old = {};

		// Remember the old values, and insert the new ones
		for ( var name in options ) {
			old[ name ] = elem.style[ name ];
			elem.style[ name ] = options[ name ];
		}

		callback.call( elem );

		// Revert the old values
		for ( name in options ) {
			elem.style[ name ] = old[ name ];
		}
	}
});

// DEPRECATED, Use jQuery.css() instead
jQuery.curCSS = jQuery.css;

jQuery.each(["height", "width"], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			var val;

			if ( computed ) {
				if ( elem.offsetWidth !== 0 ) {
					return getWH( elem, name, extra );
				} else {
					jQuery.swap( elem, cssShow, function() {
						val = getWH( elem, name, extra );
					});
				}

				return val;
			}
		},

		set: function( elem, value ) {
			if ( rnumpx.test( value ) ) {
				// ignore negative width and height values #1599
				value = parseFloat( value );

				if ( value >= 0 ) {
					return value + "px";
				}

			} else {
				return value;
			}
		}
	};
});

if ( !jQuery.support.opacity ) {
	jQuery.cssHooks.opacity = {
		get: function( elem, computed ) {
			// IE uses filters for opacity
			return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || "" ) ?
				( parseFloat( RegExp.$1 ) / 100 ) + "" :
				computed ? "1" : "";
		},

		set: function( elem, value ) {
			var style = elem.style,
				currentStyle = elem.currentStyle,
				opacity = jQuery.isNumeric( value ) ? "alpha(opacity=" + value * 100 + ")" : "",
				filter = currentStyle && currentStyle.filter || style.filter || "";

			// IE has trouble with opacity if it does not have layout
			// Force it by setting the zoom level
			style.zoom = 1;

			// if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
			if ( value >= 1 && jQuery.trim( filter.replace( ralpha, "" ) ) === "" ) {

				// Setting style.filter to null, "" & " " still leave "filter:" in the cssText
				// if "filter:" is present at all, clearType is disabled, we want to avoid this
				// style.removeAttribute is IE Only, but so apparently is this code path...
				style.removeAttribute( "filter" );

				// if there there is no filter style applied in a css rule, we are done
				if ( currentStyle && !currentStyle.filter ) {
					return;
				}
			}

			// otherwise, set new filter values
			style.filter = ralpha.test( filter ) ?
				filter.replace( ralpha, opacity ) :
				filter + " " + opacity;
		}
	};
}

jQuery(function() {
	// This hook cannot be added until DOM ready because the support test
	// for it is not run until after DOM ready
	if ( !jQuery.support.reliableMarginRight ) {
		jQuery.cssHooks.marginRight = {
			get: function( elem, computed ) {
				// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
				// Work around by temporarily setting element display to inline-block
				var ret;
				jQuery.swap( elem, { "display": "inline-block" }, function() {
					if ( computed ) {
						ret = curCSS( elem, "margin-right", "marginRight" );
					} else {
						ret = elem.style.marginRight;
					}
				});
				return ret;
			}
		};
	}
});

if ( document.defaultView && document.defaultView.getComputedStyle ) {
	getComputedStyle = function( elem, name ) {
		var ret, defaultView, computedStyle;

		name = name.replace( rupper, "-$1" ).toLowerCase();

		if ( (defaultView = elem.ownerDocument.defaultView) &&
				(computedStyle = defaultView.getComputedStyle( elem, null )) ) {
			ret = computedStyle.getPropertyValue( name );
			if ( ret === "" && !jQuery.contains( elem.ownerDocument.documentElement, elem ) ) {
				ret = jQuery.style( elem, name );
			}
		}

		return ret;
	};
}

if ( document.documentElement.currentStyle ) {
	currentStyle = function( elem, name ) {
		var left, rsLeft, uncomputed,
			ret = elem.currentStyle && elem.currentStyle[ name ],
			style = elem.style;

		// Avoid setting ret to empty string here
		// so we don't default to auto
		if ( ret === null && style && (uncomputed = style[ name ]) ) {
			ret = uncomputed;
		}

		// From the awesome hack by Dean Edwards
		// http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291

		// If we're not dealing with a regular pixel number
		// but a number that has a weird ending, we need to convert it to pixels
		if ( !rnumpx.test( ret ) && rnum.test( ret ) ) {

			// Remember the original values
			left = style.left;
			rsLeft = elem.runtimeStyle && elem.runtimeStyle.left;

			// Put in the new values to get a computed value out
			if ( rsLeft ) {
				elem.runtimeStyle.left = elem.currentStyle.left;
			}
			style.left = name === "fontSize" ? "1em" : ( ret || 0 );
			ret = style.pixelLeft + "px";

			// Revert the changed values
			style.left = left;
			if ( rsLeft ) {
				elem.runtimeStyle.left = rsLeft;
			}
		}

		return ret === "" ? "auto" : ret;
	};
}

curCSS = getComputedStyle || currentStyle;

function getWH( elem, name, extra ) {

	// Start with offset property
	var val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		which = name === "width" ? cssWidth : cssHeight,
		i = 0,
		len = which.length;

	if ( val > 0 ) {
		if ( extra !== "border" ) {
			for ( ; i < len; i++ ) {
				if ( !extra ) {
					val -= parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
				}
				if ( extra === "margin" ) {
					val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
				} else {
					val -= parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
				}
			}
		}

		return val + "px";
	}

	// Fall back to computed then uncomputed css if necessary
	val = curCSS( elem, name, name );
	if ( val < 0 || val == null ) {
		val = elem.style[ name ] || 0;
	}
	// Normalize "", auto, and prepare for extra
	val = parseFloat( val ) || 0;

	// Add padding, border, margin
	if ( extra ) {
		for ( ; i < len; i++ ) {
			val += parseFloat( jQuery.css( elem, "padding" + which[ i ] ) ) || 0;
			if ( extra !== "padding" ) {
				val += parseFloat( jQuery.css( elem, "border" + which[ i ] + "Width" ) ) || 0;
			}
			if ( extra === "margin" ) {
				val += parseFloat( jQuery.css( elem, extra + which[ i ] ) ) || 0;
			}
		}
	}

	return val + "px";
}

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.hidden = function( elem ) {
		var width = elem.offsetWidth,
			height = elem.offsetHeight;

		return ( width === 0 && height === 0 ) || (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, "display" )) === "none");
	};

	jQuery.expr.filters.visible = function( elem ) {
		return !jQuery.expr.filters.hidden( elem );
	};
}




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rhash = /#.*$/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, // IE leaves an \r character at EOL
	rinput = /^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,
	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app\-storage|.+\-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,
	rquery = /\?/,
	rscript = /<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi,
	rselectTextarea = /^(?:select|textarea)/i,
	rspacesAjax = /\s+/,
	rts = /([?&])_=[^&]*/,
	rurl = /^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/,

	// Keep a copy of the old load method
	_load = jQuery.fn.load,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Document location
	ajaxLocation,

	// Document location segments
	ajaxLocParts,

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = ["*/"] + ["*"];

// #8138, IE may throw an exception when accessing
// a field from window.location if document.domain has been set
try {
	ajaxLocation = location.href;
} catch( e ) {
	// Use the href attribute of an A element
	// since IE will modify it given document.location
	ajaxLocation = document.createElement( "a" );
	ajaxLocation.href = "";
	ajaxLocation = ajaxLocation.href;
}

// Segment location into parts
ajaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		if ( jQuery.isFunction( func ) ) {
			var dataTypes = dataTypeExpression.toLowerCase().split( rspacesAjax ),
				i = 0,
				length = dataTypes.length,
				dataType,
				list,
				placeBefore;

			// For each dataType in the dataTypeExpression
			for ( ; i < length; i++ ) {
				dataType = dataTypes[ i ];
				// We control if we're asked to add before
				// any existing element
				placeBefore = /^\+/.test( dataType );
				if ( placeBefore ) {
					dataType = dataType.substr( 1 ) || "*";
				}
				list = structure[ dataType ] = structure[ dataType ] || [];
				// then we add to the structure accordingly
				list[ placeBefore ? "unshift" : "push" ]( func );
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR,
		dataType /* internal */, inspected /* internal */ ) {

	dataType = dataType || options.dataTypes[ 0 ];
	inspected = inspected || {};

	inspected[ dataType ] = true;

	var list = structure[ dataType ],
		i = 0,
		length = list ? list.length : 0,
		executeOnly = ( structure === prefilters ),
		selection;

	for ( ; i < length && ( executeOnly || !selection ); i++ ) {
		selection = list[ i ]( options, originalOptions, jqXHR );
		// If we got redirected to another dataType
		// we try there if executing only and not done already
		if ( typeof selection === "string" ) {
			if ( !executeOnly || inspected[ selection ] ) {
				selection = undefined;
			} else {
				options.dataTypes.unshift( selection );
				selection = inspectPrefiltersOrTransports(
						structure, options, originalOptions, jqXHR, selection, inspected );
			}
		}
	}
	// If we're only executing or nothing was selected
	// we try the catchall dataType if not done already
	if ( ( executeOnly || !selection ) && !inspected[ "*" ] ) {
		selection = inspectPrefiltersOrTransports(
				structure, options, originalOptions, jqXHR, "*", inspected );
	}
	// unnecessary when only executing (prefilters)
	// but it'll be ignored by the caller in that case
	return selection;
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};
	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}
}

jQuery.fn.extend({
	load: function( url, params, callback ) {
		if ( typeof url !== "string" && _load ) {
			return _load.apply( this, arguments );

		// Don't do a request if no elements are being requested
		} else if ( !this.length ) {
			return this;
		}

		var off = url.indexOf( " " );
		if ( off >= 0 ) {
			var selector = url.slice( off, url.length );
			url = url.slice( 0, off );
		}

		// Default to a GET request
		var type = "GET";

		// If the second parameter was provided
		if ( params ) {
			// If it's a function
			if ( jQuery.isFunction( params ) ) {
				// We assume that it's the callback
				callback = params;
				params = undefined;

			// Otherwise, build a param string
			} else if ( typeof params === "object" ) {
				params = jQuery.param( params, jQuery.ajaxSettings.traditional );
				type = "POST";
			}
		}

		var self = this;

		// Request the remote document
		jQuery.ajax({
			url: url,
			type: type,
			dataType: "html",
			data: params,
			// Complete callback (responseText is used internally)
			complete: function( jqXHR, status, responseText ) {
				// Store the response as specified by the jqXHR object
				responseText = jqXHR.responseText;
				// If successful, inject the HTML into all the matched elements
				if ( jqXHR.isResolved() ) {
					// #4825: Get the actual response in case
					// a dataFilter is present in ajaxSettings
					jqXHR.done(function( r ) {
						responseText = r;
					});
					// See if a selector was specified
					self.html( selector ?
						// Create a dummy div to hold the results
						jQuery("<div>")
							// inject the contents of the document in, removing the scripts
							// to avoid any 'Permission Denied' errors in IE
							.append(responseText.replace(rscript, ""))

							// Locate the specified elements
							.find(selector) :

						// If not, just inject the full result
						responseText );
				}

				if ( callback ) {
					self.each( callback, [ responseText, status, jqXHR ] );
				}
			}
		});

		return this;
	},

	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},

	serializeArray: function() {
		return this.map(function(){
			return this.elements ? jQuery.makeArray( this.elements ) : this;
		})
		.filter(function(){
			return this.name && !this.disabled &&
				( this.checked || rselectTextarea.test( this.nodeName ) ||
					rinput.test( this.type ) );
		})
		.map(function( i, elem ){
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val, i ){
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					}) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		}).get();
	}
});

// Attach a bunch of functions for handling common AJAX events
jQuery.each( "ajaxStart ajaxStop ajaxComplete ajaxError ajaxSuccess ajaxSend".split( " " ), function( i, o ){
	jQuery.fn[ o ] = function( f ){
		return this.on( o, f );
	};
});

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {
		// shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		return jQuery.ajax({
			type: method,
			url: url,
			data: data,
			success: callback,
			dataType: type
		});
	};
});

jQuery.extend({

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		if ( settings ) {
			// Building a settings object
			ajaxExtend( target, jQuery.ajaxSettings );
		} else {
			// Extending ajaxSettings
			settings = target;
			target = jQuery.ajaxSettings;
		}
		ajaxExtend( target, settings );
		return target;
	},

	ajaxSettings: {
		url: ajaxLocation,
		isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),
		global: true,
		type: "GET",
		contentType: "application/x-www-form-urlencoded",
		processData: true,
		async: true,
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		traditional: false,
		headers: {},
		*/

		accepts: {
			xml: "application/xml, text/xml",
			html: "text/html",
			text: "text/plain",
			json: "application/json, text/javascript",
			"*": allTypes
		},

		contents: {
			xml: /xml/,
			html: /html/,
			json: /json/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText"
		},

		// List of data converters
		// 1) key format is "source_type destination_type" (a single space in-between)
		// 2) the catchall symbol "*" can be used for source_type
		converters: {

			// Convert anything to text
			"* text": window.String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			context: true,
			url: true
		}
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var // Create the final options object
			s = jQuery.ajaxSetup( {}, options ),
			// Callbacks context
			callbackContext = s.context || s,
			// Context for global events
			// It's the callbackContext if one was provided in the options
			// and if it's a DOM node or a jQuery collection
			globalEventContext = callbackContext !== s &&
				( callbackContext.nodeType || callbackContext instanceof jQuery ) ?
						jQuery( callbackContext ) : jQuery.event,
			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),
			// Status-dependent callbacks
			statusCode = s.statusCode || {},
			// ifModified key
			ifModifiedKey,
			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},
			// Response headers
			responseHeadersString,
			responseHeaders,
			// transport
			transport,
			// timeout handle
			timeoutTimer,
			// Cross-domain detection vars
			parts,
			// The jqXHR state
			state = 0,
			// To know if global events are to be dispatched
			fireGlobals,
			// Loop variable
			i,
			// Fake xhr
			jqXHR = {

				readyState: 0,

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( !state ) {
						var lname = name.toLowerCase();
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match === undefined ? null : match;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					statusText = statusText || "abort";
					if ( transport ) {
						transport.abort( statusText );
					}
					done( 0, statusText );
					return this;
				}
			};

		// Callback for when everything is done
		// It is defined here because jslint complains if it is declared
		// at the end of the function (which would be more logical and readable)
		function done( status, nativeStatusText, responses, headers ) {

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			var isSuccess,
				success,
				error,
				statusText = nativeStatusText,
				response = responses ? ajaxHandleResponses( s, jqXHR, responses ) : undefined,
				lastModified,
				etag;

			// If successful, handle type chaining
			if ( status >= 200 && status < 300 || status === 304 ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {

					if ( ( lastModified = jqXHR.getResponseHeader( "Last-Modified" ) ) ) {
						jQuery.lastModified[ ifModifiedKey ] = lastModified;
					}
					if ( ( etag = jqXHR.getResponseHeader( "Etag" ) ) ) {
						jQuery.etag[ ifModifiedKey ] = etag;
					}
				}

				// If not modified
				if ( status === 304 ) {

					statusText = "notmodified";
					isSuccess = true;

				// If we have data
				} else {

					try {
						success = ajaxConvert( s, response );
						statusText = "success";
						isSuccess = true;
					} catch(e) {
						// We have a parsererror
						statusText = "parsererror";
						error = e;
					}
				}
			} else {
				// We extract error from statusText
				// then normalize statusText and status for non-aborts
				error = statusText;
				if ( !statusText || status ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = "" + ( nativeStatusText || statusText );

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajax" + ( isSuccess ? "Success" : "Error" ),
						[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );
				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		// Attach deferreds
		deferred.promise( jqXHR );
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;
		jqXHR.complete = completeDeferred.add;

		// Status-dependent callbacks
		jqXHR.statusCode = function( map ) {
			if ( map ) {
				var tmp;
				if ( state < 2 ) {
					for ( tmp in map ) {
						statusCode[ tmp ] = [ statusCode[tmp], map[tmp] ];
					}
				} else {
					tmp = map[ jqXHR.status ];
					jqXHR.then( tmp, tmp );
				}
			}
			return this;
		};

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
		// We also use the url parameter if available
		s.url = ( ( url || s.url ) + "" ).replace( rhash, "" ).replace( rprotocol, ajaxLocParts[ 1 ] + "//" );

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().split( rspacesAjax );

		// Determine if a cross-domain request is in order
		if ( s.crossDomain == null ) {
			parts = rurl.exec( s.url.toLowerCase() );
			s.crossDomain = !!( parts &&
				( parts[ 1 ] != ajaxLocParts[ 1 ] || parts[ 2 ] != ajaxLocParts[ 2 ] ||
					( parts[ 3 ] || ( parts[ 1 ] === "http:" ? 80 : 443 ) ) !=
						( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === "http:" ? 80 : 443 ) ) )
			);
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefiler, stop there
		if ( state === 2 ) {
			return false;
		}

		// We can fire global events as of now if asked to
		fireGlobals = s.global;

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.data;
				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Get ifModifiedKey before adding the anti-cache parameter
			ifModifiedKey = s.url;

			// Add anti-cache in url if needed
			if ( s.cache === false ) {

				var ts = jQuery.now(),
					// try replacing _= if it is there
					ret = s.url.replace( rts, "$1_=" + ts );

				// if nothing was replaced, add timestamp to the end
				s.url = ret + ( ( ret === s.url ) ? ( rquery.test( s.url ) ? "&" : "?" ) + "_=" + ts : "" );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			ifModifiedKey = ifModifiedKey || s.url;
			if ( jQuery.lastModified[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ ifModifiedKey ] );
			}
			if ( jQuery.etag[ ifModifiedKey ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ ifModifiedKey ] );
			}
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?
				s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {
				// Abort if not done already
				jqXHR.abort();
				return false;

		}

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;
			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}
			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = setTimeout( function(){
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch (e) {
				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );
				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		return jqXHR;
	},

	// Serialize an array of form elements or a set of
	// key/values into a query string
	param: function( a, traditional ) {
		var s = [],
			add = function( key, value ) {
				// If value is a function, invoke it and return its value
				value = jQuery.isFunction( value ) ? value() : value;
				s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
			};

		// Set traditional to true for jQuery <= 1.3.2 behavior.
		if ( traditional === undefined ) {
			traditional = jQuery.ajaxSettings.traditional;
		}

		// If an array was passed in, assume that it is an array of form elements.
		if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {
			// Serialize the form elements
			jQuery.each( a, function() {
				add( this.name, this.value );
			});

		} else {
			// If traditional, encode the "old" way (the way 1.3.2 or older
			// did it), otherwise encode params recursively.
			for ( var prefix in a ) {
				buildParams( prefix, a[ prefix ], traditional, add );
			}
		}

		// Return the resulting serialization
		return s.join( "&" ).replace( r20, "+" );
	}
});

function buildParams( prefix, obj, traditional, add ) {
	if ( jQuery.isArray( obj ) ) {
		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {
				// Treat each array item as a scalar.
				add( prefix, v );

			} else {
				// If array item is non-scalar (array or object), encode its
				// numeric index to resolve deserialization ambiguity issues.
				// Note that rack (as of 1.0.0) can't currently deserialize
				// nested arrays properly, and attempting to do so may cause
				// a server error. Possible fixes are to modify rack's
				// deserialization algorithm or to provide an option or flag
				// to force array serialization to be shallow.
				buildParams( prefix + "[" + ( typeof v === "object" || jQuery.isArray(v) ? i : "" ) + "]", v, traditional, add );
			}
		});

	} else if ( !traditional && obj != null && typeof obj === "object" ) {
		// Serialize object item.
		for ( var name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {
		// Serialize scalar item.
		add( prefix, obj );
	}
}

// This is still on the jQuery object... for now
// Want to move this to jQuery.ajax some day
jQuery.extend({

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {}

});

/* Handles responses to an ajax request:
 * - sets all responseXXX fields accordingly
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var contents = s.contents,
		dataTypes = s.dataTypes,
		responseFields = s.responseFields,
		ct,
		type,
		finalDataType,
		firstDataType;

	// Fill responseXXX fields
	for ( type in responseFields ) {
		if ( type in responses ) {
			jqXHR[ responseFields[type] ] = responses[ type ];
		}
	}

	// Remove auto dataType and get content-type in the process
	while( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "content-type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {
		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[0] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}
		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

// Chain conversions given the request and the original response
function ajaxConvert( s, response ) {

	// Apply the dataFilter if provided
	if ( s.dataFilter ) {
		response = s.dataFilter( response, s.dataType );
	}

	var dataTypes = s.dataTypes,
		converters = {},
		i,
		key,
		length = dataTypes.length,
		tmp,
		// Current and previous dataTypes
		current = dataTypes[ 0 ],
		prev,
		// Conversion expression
		conversion,
		// Conversion function
		conv,
		// Conversion functions (transitive conversion)
		conv1,
		conv2;

	// For each dataType in the chain
	for ( i = 1; i < length; i++ ) {

		// Create converters map
		// with lowercased keys
		if ( i === 1 ) {
			for ( key in s.converters ) {
				if ( typeof key === "string" ) {
					converters[ key.toLowerCase() ] = s.converters[ key ];
				}
			}
		}

		// Get the dataTypes
		prev = current;
		current = dataTypes[ i ];

		// If current is auto dataType, update it to prev
		if ( current === "*" ) {
			current = prev;
		// If no auto and dataTypes are actually different
		} else if ( prev !== "*" && prev !== current ) {

			// Get the converter
			conversion = prev + " " + current;
			conv = converters[ conversion ] || converters[ "* " + current ];

			// If there is no direct converter, search transitively
			if ( !conv ) {
				conv2 = undefined;
				for ( conv1 in converters ) {
					tmp = conv1.split( " " );
					if ( tmp[ 0 ] === prev || tmp[ 0 ] === "*" ) {
						conv2 = converters[ tmp[1] + " " + current ];
						if ( conv2 ) {
							conv1 = converters[ conv1 ];
							if ( conv1 === true ) {
								conv = conv2;
							} else if ( conv2 === true ) {
								conv = conv1;
							}
							break;
						}
					}
				}
			}
			// If we found no converter, dispatch an error
			if ( !( conv || conv2 ) ) {
				jQuery.error( "No conversion from " + conversion.replace(" "," to ") );
			}
			// If found converter is not an equivalence
			if ( conv !== true ) {
				// Convert with 1 or 2 converters accordingly
				response = conv ? conv( response ) : conv2( conv1(response) );
			}
		}
	}
	return response;
}




var jsc = jQuery.now(),
	jsre = /(\=)\?(&|$)|\?\?/i;

// Default jsonp settings
jQuery.ajaxSetup({
	jsonp: "callback",
	jsonpCallback: function() {
		return jQuery.expando + "_" + ( jsc++ );
	}
});

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var inspectData = s.contentType === "application/x-www-form-urlencoded" &&
		( typeof s.data === "string" );

	if ( s.dataTypes[ 0 ] === "jsonp" ||
		s.jsonp !== false && ( jsre.test( s.url ) ||
				inspectData && jsre.test( s.data ) ) ) {

		var responseContainer,
			jsonpCallback = s.jsonpCallback =
				jQuery.isFunction( s.jsonpCallback ) ? s.jsonpCallback() : s.jsonpCallback,
			previous = window[ jsonpCallback ],
			url = s.url,
			data = s.data,
			replace = "$1" + jsonpCallback + "$2";

		if ( s.jsonp !== false ) {
			url = url.replace( jsre, replace );
			if ( s.url === url ) {
				if ( inspectData ) {
					data = data.replace( jsre, replace );
				}
				if ( s.data === data ) {
					// Add callback manually
					url += (/\?/.test( url ) ? "&" : "?") + s.jsonp + "=" + jsonpCallback;
				}
			}
		}

		s.url = url;
		s.data = data;

		// Install callback
		window[ jsonpCallback ] = function( response ) {
			responseContainer = [ response ];
		};

		// Clean-up function
		jqXHR.always(function() {
			// Set callback back to previous value
			window[ jsonpCallback ] = previous;
			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( previous ) ) {
				window[ jsonpCallback ]( responseContainer[ 0 ] );
			}
		});

		// Use data converter to retrieve json after script execution
		s.converters["script json"] = function() {
			if ( !responseContainer ) {
				jQuery.error( jsonpCallback + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// force json dataType
		s.dataTypes[ 0 ] = "json";

		// Delegate to script
		return "script";
	}
});




// Install script dataType
jQuery.ajaxSetup({
	accepts: {
		script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /javascript|ecmascript/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
});

// Handle cache's special case and global
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
		s.global = false;
	}
});

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function(s) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {

		var script,
			head = document.head || document.getElementsByTagName( "head" )[0] || document.documentElement;

		return {

			send: function( _, callback ) {

				script = document.createElement( "script" );

				script.async = "async";

				if ( s.scriptCharset ) {
					script.charset = s.scriptCharset;
				}

				script.src = s.url;

				// Attach handlers for all browsers
				script.onload = script.onreadystatechange = function( _, isAbort ) {

					if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {

						// Handle memory leak in IE
						script.onload = script.onreadystatechange = null;

						// Remove the script
						if ( head && script.parentNode ) {
							head.removeChild( script );
						}

						// Dereference the script
						script = undefined;

						// Callback if not abort
						if ( !isAbort ) {
							callback( 200, "success" );
						}
					}
				};
				// Use insertBefore instead of appendChild  to circumvent an IE6 bug.
				// This arises when a base node is used (#2709 and #4378).
				head.insertBefore( script, head.firstChild );
			},

			abort: function() {
				if ( script ) {
					script.onload( 0, 1 );
				}
			}
		};
	}
});




var // #5280: Internet Explorer will keep connections alive if we don't abort on unload
	xhrOnUnloadAbort = window.ActiveXObject ? function() {
		// Abort all pending requests
		for ( var key in xhrCallbacks ) {
			xhrCallbacks[ key ]( 0, 1 );
		}
	} : false,
	xhrId = 0,
	xhrCallbacks;

// Functions to create xhrs
function createStandardXHR() {
	try {
		return new window.XMLHttpRequest();
	} catch( e ) {}
}

function createActiveXHR() {
	try {
		return new window.ActiveXObject( "Microsoft.XMLHTTP" );
	} catch( e ) {}
}

// Create the request object
// (This is still attached to ajaxSettings for backward compatibility)
jQuery.ajaxSettings.xhr = window.ActiveXObject ?
	/* Microsoft failed to properly
	 * implement the XMLHttpRequest in IE7 (can't request local files),
	 * so we use the ActiveXObject when it is available
	 * Additionally XMLHttpRequest can be disabled in IE7/IE8 so
	 * we need a fallback.
	 */
	function() {
		return !this.isLocal && createStandardXHR() || createActiveXHR();
	} :
	// For all other browsers, use the standard XMLHttpRequest object
	createStandardXHR;

// Determine support properties
(function( xhr ) {
	jQuery.extend( jQuery.support, {
		ajax: !!xhr,
		cors: !!xhr && ( "withCredentials" in xhr )
	});
})( jQuery.ajaxSettings.xhr() );

// Create transport if the browser can provide an xhr
if ( jQuery.support.ajax ) {

	jQuery.ajaxTransport(function( s ) {
		// Cross domain only allowed if supported through XMLHttpRequest
		if ( !s.crossDomain || jQuery.support.cors ) {

			var callback;

			return {
				send: function( headers, complete ) {

					// Get a new xhr
					var xhr = s.xhr(),
						handle,
						i;

					// Open the socket
					// Passing null username, generates a login popup on Opera (#2865)
					if ( s.username ) {
						xhr.open( s.type, s.url, s.async, s.username, s.password );
					} else {
						xhr.open( s.type, s.url, s.async );
					}

					// Apply custom fields if provided
					if ( s.xhrFields ) {
						for ( i in s.xhrFields ) {
							xhr[ i ] = s.xhrFields[ i ];
						}
					}

					// Override mime type if needed
					if ( s.mimeType && xhr.overrideMimeType ) {
						xhr.overrideMimeType( s.mimeType );
					}

					// X-Requested-With header
					// For cross-domain requests, seeing as conditions for a preflight are
					// akin to a jigsaw puzzle, we simply never set it to be sure.
					// (it can always be set on a per-request basis or even using ajaxSetup)
					// For same-domain requests, won't change header if already provided.
					if ( !s.crossDomain && !headers["X-Requested-With"] ) {
						headers[ "X-Requested-With" ] = "XMLHttpRequest";
					}

					// Need an extra try/catch for cross domain requests in Firefox 3
					try {
						for ( i in headers ) {
							xhr.setRequestHeader( i, headers[ i ] );
						}
					} catch( _ ) {}

					// Do send the request
					// This may raise an exception which is actually
					// handled in jQuery.ajax (so no try/catch here)
					xhr.send( ( s.hasContent && s.data ) || null );

					// Listener
					callback = function( _, isAbort ) {

						var status,
							statusText,
							responseHeaders,
							responses,
							xml;

						// Firefox throws exceptions when accessing properties
						// of an xhr when a network error occured
						// http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
						try {

							// Was never called and is aborted or complete
							if ( callback && ( isAbort || xhr.readyState === 4 ) ) {

								// Only called once
								callback = undefined;

								// Do not keep as active anymore
								if ( handle ) {
									xhr.onreadystatechange = jQuery.noop;
									if ( xhrOnUnloadAbort ) {
										delete xhrCallbacks[ handle ];
									}
								}

								// If it's an abort
								if ( isAbort ) {
									// Abort it manually if needed
									if ( xhr.readyState !== 4 ) {
										xhr.abort();
									}
								} else {
									status = xhr.status;
									responseHeaders = xhr.getAllResponseHeaders();
									responses = {};
									xml = xhr.responseXML;

									// Construct response list
									if ( xml && xml.documentElement /* #4958 */ ) {
										responses.xml = xml;
									}
									responses.text = xhr.responseText;

									// Firefox throws an exception when accessing
									// statusText for faulty cross-domain requests
									try {
										statusText = xhr.statusText;
									} catch( e ) {
										// We normalize with Webkit giving an empty statusText
										statusText = "";
									}

									// Filter status for non standard behaviors

									// If the request is local and we have data: assume a success
									// (success with no data won't get notified, that's the best we
									// can do given current implementations)
									if ( !status && s.isLocal && !s.crossDomain ) {
										status = responses.text ? 200 : 404;
									// IE - #1450: sometimes returns 1223 when it should be 204
									} else if ( status === 1223 ) {
										status = 204;
									}
								}
							}
						} catch( firefoxAccessException ) {
							if ( !isAbort ) {
								complete( -1, firefoxAccessException );
							}
						}

						// Call complete if needed
						if ( responses ) {
							complete( status, statusText, responses, responseHeaders );
						}
					};

					// if we're in sync mode or it's in cache
					// and has been retrieved directly (IE6 & IE7)
					// we need to manually fire the callback
					if ( !s.async || xhr.readyState === 4 ) {
						callback();
					} else {
						handle = ++xhrId;
						if ( xhrOnUnloadAbort ) {
							// Create the active xhrs callbacks list if needed
							// and attach the unload handler
							if ( !xhrCallbacks ) {
								xhrCallbacks = {};
								jQuery( window ).unload( xhrOnUnloadAbort );
							}
							// Add to list of active xhrs callbacks
							xhrCallbacks[ handle ] = callback;
						}
						xhr.onreadystatechange = callback;
					}
				},

				abort: function() {
					if ( callback ) {
						callback(0,1);
					}
				}
			};
		}
	});
}




var elemdisplay = {},
	iframe, iframeDoc,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rfxnum = /^([+\-]=)?([\d+.\-]+)([a-z%]*)$/i,
	timerId,
	fxAttrs = [
		// height animations
		[ "height", "marginTop", "marginBottom", "paddingTop", "paddingBottom" ],
		// width animations
		[ "width", "marginLeft", "marginRight", "paddingLeft", "paddingRight" ],
		// opacity animations
		[ "opacity" ]
	],
	fxNow;

jQuery.fn.extend({
	show: function( speed, easing, callback ) {
		var elem, display;

		if ( speed || speed === 0 ) {
			return this.animate( genFx("show", 3), speed, easing, callback );

		} else {
			for ( var i = 0, j = this.length; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					// Reset the inline display of this element to learn if it is
					// being hidden by cascaded rules or not
					if ( !jQuery._data(elem, "olddisplay") && display === "none" ) {
						display = elem.style.display = "";
					}

					// Set elements which have been overridden with display: none
					// in a stylesheet to whatever the default browser style is
					// for such an element
					if ( display === "" && jQuery.css(elem, "display") === "none" ) {
						jQuery._data( elem, "olddisplay", defaultDisplay(elem.nodeName) );
					}
				}
			}

			// Set the display of most of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				elem = this[ i ];

				if ( elem.style ) {
					display = elem.style.display;

					if ( display === "" || display === "none" ) {
						elem.style.display = jQuery._data( elem, "olddisplay" ) || "";
					}
				}
			}

			return this;
		}
	},

	hide: function( speed, easing, callback ) {
		if ( speed || speed === 0 ) {
			return this.animate( genFx("hide", 3), speed, easing, callback);

		} else {
			var elem, display,
				i = 0,
				j = this.length;

			for ( ; i < j; i++ ) {
				elem = this[i];
				if ( elem.style ) {
					display = jQuery.css( elem, "display" );

					if ( display !== "none" && !jQuery._data( elem, "olddisplay" ) ) {
						jQuery._data( elem, "olddisplay", display );
					}
				}
			}

			// Set the display of the elements in a second loop
			// to avoid the constant reflow
			for ( i = 0; i < j; i++ ) {
				if ( this[i].style ) {
					this[i].style.display = "none";
				}
			}

			return this;
		}
	},

	// Save the old toggle function
	_toggle: jQuery.fn.toggle,

	toggle: function( fn, fn2, callback ) {
		var bool = typeof fn === "boolean";

		if ( jQuery.isFunction(fn) && jQuery.isFunction(fn2) ) {
			this._toggle.apply( this, arguments );

		} else if ( fn == null || bool ) {
			this.each(function() {
				var state = bool ? fn : jQuery(this).is(":hidden");
				jQuery(this)[ state ? "show" : "hide" ]();
			});

		} else {
			this.animate(genFx("toggle", 3), fn, fn2, callback);
		}

		return this;
	},

	fadeTo: function( speed, to, easing, callback ) {
		return this.filter(":hidden").css("opacity", 0).show().end()
					.animate({opacity: to}, speed, easing, callback);
	},

	animate: function( prop, speed, easing, callback ) {
		var optall = jQuery.speed( speed, easing, callback );

		if ( jQuery.isEmptyObject( prop ) ) {
			return this.each( optall.complete, [ false ] );
		}

		// Do not change referenced properties as per-property easing will be lost
		prop = jQuery.extend( {}, prop );

		function doAnimation() {
			// XXX 'this' does not always have a nodeName when running the
			// test suite

			if ( optall.queue === false ) {
				jQuery._mark( this );
			}

			var opt = jQuery.extend( {}, optall ),
				isElement = this.nodeType === 1,
				hidden = isElement && jQuery(this).is(":hidden"),
				name, val, p, e,
				parts, start, end, unit,
				method;

			// will store per property easing and be used to determine when an animation is complete
			opt.animatedProperties = {};

			for ( p in prop ) {

				// property name normalization
				name = jQuery.camelCase( p );
				if ( p !== name ) {
					prop[ name ] = prop[ p ];
					delete prop[ p ];
				}

				val = prop[ name ];

				// easing resolution: per property > opt.specialEasing > opt.easing > 'swing' (default)
				if ( jQuery.isArray( val ) ) {
					opt.animatedProperties[ name ] = val[ 1 ];
					val = prop[ name ] = val[ 0 ];
				} else {
					opt.animatedProperties[ name ] = opt.specialEasing && opt.specialEasing[ name ] || opt.easing || 'swing';
				}

				if ( val === "hide" && hidden || val === "show" && !hidden ) {
					return opt.complete.call( this );
				}

				if ( isElement && ( name === "height" || name === "width" ) ) {
					// Make sure that nothing sneaks out
					// Record all 3 overflow attributes because IE does not
					// change the overflow attribute when overflowX and
					// overflowY are set to the same value
					opt.overflow = [ this.style.overflow, this.style.overflowX, this.style.overflowY ];

					// Set display property to inline-block for height/width
					// animations on inline elements that are having width/height animated
					if ( jQuery.css( this, "display" ) === "inline" &&
							jQuery.css( this, "float" ) === "none" ) {

						// inline-level elements accept inline-block;
						// block-level elements need to be inline with layout
						if ( !jQuery.support.inlineBlockNeedsLayout || defaultDisplay( this.nodeName ) === "inline" ) {
							this.style.display = "inline-block";

						} else {
							this.style.zoom = 1;
						}
					}
				}
			}

			if ( opt.overflow != null ) {
				this.style.overflow = "hidden";
			}

			for ( p in prop ) {
				e = new jQuery.fx( this, opt, p );
				val = prop[ p ];

				if ( rfxtypes.test( val ) ) {

					// Tracks whether to show or hide based on private
					// data attached to the element
					method = jQuery._data( this, "toggle" + p ) || ( val === "toggle" ? hidden ? "show" : "hide" : 0 );
					if ( method ) {
						jQuery._data( this, "toggle" + p, method === "show" ? "hide" : "show" );
						e[ method ]();
					} else {
						e[ val ]();
					}

				} else {
					parts = rfxnum.exec( val );
					start = e.cur();

					if ( parts ) {
						end = parseFloat( parts[2] );
						unit = parts[3] || ( jQuery.cssNumber[ p ] ? "" : "px" );

						// We need to compute starting value
						if ( unit !== "px" ) {
							jQuery.style( this, p, (end || 1) + unit);
							start = ( (end || 1) / e.cur() ) * start;
							jQuery.style( this, p, start + unit);
						}

						// If a +=/-= token was provided, we're doing a relative animation
						if ( parts[1] ) {
							end = ( (parts[ 1 ] === "-=" ? -1 : 1) * end ) + start;
						}

						e.custom( start, end, unit );

					} else {
						e.custom( start, val, "" );
					}
				}
			}

			// For JS strict compliance
			return true;
		}

		return optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},

	stop: function( type, clearQueue, gotoEnd ) {
		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each(function() {
			var index,
				hadTimers = false,
				timers = jQuery.timers,
				data = jQuery._data( this );

			// clear marker counters if we know they won't be
			if ( !gotoEnd ) {
				jQuery._unmark( true, this );
			}

			function stopQueue( elem, data, index ) {
				var hooks = data[ index ];
				jQuery.removeData( elem, index, true );
				hooks.stop( gotoEnd );
			}

			if ( type == null ) {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && index.indexOf(".run") === index.length - 4 ) {
						stopQueue( this, data, index );
					}
				}
			} else if ( data[ index = type + ".run" ] && data[ index ].stop ){
				stopQueue( this, data, index );
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {
					if ( gotoEnd ) {

						// force the next step to be the last
						timers[ index ]( true );
					} else {
						timers[ index ].saveState();
					}
					hadTimers = true;
					timers.splice( index, 1 );
				}
			}

			// start the next in the queue if the last step wasn't forced
			// timers currently will call their complete callbacks, which will dequeue
			// but only if they were gotoEnd
			if ( !( gotoEnd && hadTimers ) ) {
				jQuery.dequeue( this, type );
			}
		});
	}

});

// Animations created synchronously will run synchronously
function createFxNow() {
	setTimeout( clearFxNow, 0 );
	return ( fxNow = jQuery.now() );
}

function clearFxNow() {
	fxNow = undefined;
}

// Generate parameters to create a standard animation
function genFx( type, num ) {
	var obj = {};

	jQuery.each( fxAttrs.concat.apply([], fxAttrs.slice( 0, num )), function() {
		obj[ this ] = type;
	});

	return obj;
}

// Generate shortcuts for custom animations
jQuery.each({
	slideDown: genFx( "show", 1 ),
	slideUp: genFx( "hide", 1 ),
	slideToggle: genFx( "toggle", 1 ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
});

jQuery.extend({
	speed: function( speed, easing, fn ) {
		var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
			complete: fn || !fn && easing ||
				jQuery.isFunction( speed ) && speed,
			duration: speed,
			easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
		};

		opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration :
			opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

		// normalize opt.queue - true/undefined/null -> "fx"
		if ( opt.queue == null || opt.queue === true ) {
			opt.queue = "fx";
		}

		// Queueing
		opt.old = opt.complete;

		opt.complete = function( noUnmark ) {
			if ( jQuery.isFunction( opt.old ) ) {
				opt.old.call( this );
			}

			if ( opt.queue ) {
				jQuery.dequeue( this, opt.queue );
			} else if ( noUnmark !== false ) {
				jQuery._unmark( this );
			}
		};

		return opt;
	},

	easing: {
		linear: function( p, n, firstNum, diff ) {
			return firstNum + diff * p;
		},
		swing: function( p, n, firstNum, diff ) {
			return ( ( -Math.cos( p*Math.PI ) / 2 ) + 0.5 ) * diff + firstNum;
		}
	},

	timers: [],

	fx: function( elem, options, prop ) {
		this.options = options;
		this.elem = elem;
		this.prop = prop;

		options.orig = options.orig || {};
	}

});

jQuery.fx.prototype = {
	// Simple function for setting a style value
	update: function() {
		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		( jQuery.fx.step[ this.prop ] || jQuery.fx.step._default )( this );
	},

	// Get the current size
	cur: function() {
		if ( this.elem[ this.prop ] != null && (!this.elem.style || this.elem.style[ this.prop ] == null) ) {
			return this.elem[ this.prop ];
		}

		var parsed,
			r = jQuery.css( this.elem, this.prop );
		// Empty strings, null, undefined and "auto" are converted to 0,
		// complex values such as "rotate(1rad)" are returned as is,
		// simple values such as "10px" are parsed to Float.
		return isNaN( parsed = parseFloat( r ) ) ? !r || r === "auto" ? 0 : r : parsed;
	},

	// Start an animation from one number to another
	custom: function( from, to, unit ) {
		var self = this,
			fx = jQuery.fx;

		this.startTime = fxNow || createFxNow();
		this.end = to;
		this.now = this.start = from;
		this.pos = this.state = 0;
		this.unit = unit || this.unit || ( jQuery.cssNumber[ this.prop ] ? "" : "px" );

		function t( gotoEnd ) {
			return self.step( gotoEnd );
		}

		t.queue = this.options.queue;
		t.elem = this.elem;
		t.saveState = function() {
			if ( self.options.hide && jQuery._data( self.elem, "fxshow" + self.prop ) === undefined ) {
				jQuery._data( self.elem, "fxshow" + self.prop, self.start );
			}
		};

		if ( t() && jQuery.timers.push(t) && !timerId ) {
			timerId = setInterval( fx.tick, fx.interval );
		}
	},

	// Simple 'show' function
	show: function() {
		var dataShow = jQuery._data( this.elem, "fxshow" + this.prop );

		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = dataShow || jQuery.style( this.elem, this.prop );
		this.options.show = true;

		// Begin the animation
		// Make sure that we start at a small width/height to avoid any flash of content
		if ( dataShow !== undefined ) {
			// This show is picking up where a previous hide or show left off
			this.custom( this.cur(), dataShow );
		} else {
			this.custom( this.prop === "width" || this.prop === "height" ? 1 : 0, this.cur() );
		}

		// Start by showing the element
		jQuery( this.elem ).show();
	},

	// Simple 'hide' function
	hide: function() {
		// Remember where we started, so that we can go back to it later
		this.options.orig[ this.prop ] = jQuery._data( this.elem, "fxshow" + this.prop ) || jQuery.style( this.elem, this.prop );
		this.options.hide = true;

		// Begin the animation
		this.custom( this.cur(), 0 );
	},

	// Each step of an animation
	step: function( gotoEnd ) {
		var p, n, complete,
			t = fxNow || createFxNow(),
			done = true,
			elem = this.elem,
			options = this.options;

		if ( gotoEnd || t >= options.duration + this.startTime ) {
			this.now = this.end;
			this.pos = this.state = 1;
			this.update();

			options.animatedProperties[ this.prop ] = true;

			for ( p in options.animatedProperties ) {
				if ( options.animatedProperties[ p ] !== true ) {
					done = false;
				}
			}

			if ( done ) {
				// Reset the overflow
				if ( options.overflow != null && !jQuery.support.shrinkWrapBlocks ) {

					jQuery.each( [ "", "X", "Y" ], function( index, value ) {
						elem.style[ "overflow" + value ] = options.overflow[ index ];
					});
				}

				// Hide the element if the "hide" operation was done
				if ( options.hide ) {
					jQuery( elem ).hide();
				}

				// Reset the properties, if the item has been hidden or shown
				if ( options.hide || options.show ) {
					for ( p in options.animatedProperties ) {
						jQuery.style( elem, p, options.orig[ p ] );
						jQuery.removeData( elem, "fxshow" + p, true );
						// Toggle data is no longer needed
						jQuery.removeData( elem, "toggle" + p, true );
					}
				}

				// Execute the complete function
				// in the event that the complete function throws an exception
				// we must ensure it won't be called twice. #5684

				complete = options.complete;
				if ( complete ) {

					options.complete = false;
					complete.call( elem );
				}
			}

			return false;

		} else {
			// classical easing cannot be used with an Infinity duration
			if ( options.duration == Infinity ) {
				this.now = t;
			} else {
				n = t - this.startTime;
				this.state = n / options.duration;

				// Perform the easing function, defaults to swing
				this.pos = jQuery.easing[ options.animatedProperties[this.prop] ]( this.state, n, 0, 1, options.duration );
				this.now = this.start + ( (this.end - this.start) * this.pos );
			}
			// Perform the next step of the animation
			this.update();
		}

		return true;
	}
};

jQuery.extend( jQuery.fx, {
	tick: function() {
		var timer,
			timers = jQuery.timers,
			i = 0;

		for ( ; i < timers.length; i++ ) {
			timer = timers[ i ];
			// Checks the timer has not already been removed
			if ( !timer() && timers[ i ] === timer ) {
				timers.splice( i--, 1 );
			}
		}

		if ( !timers.length ) {
			jQuery.fx.stop();
		}
	},

	interval: 13,

	stop: function() {
		clearInterval( timerId );
		timerId = null;
	},

	speeds: {
		slow: 600,
		fast: 200,
		// Default speed
		_default: 400
	},

	step: {
		opacity: function( fx ) {
			jQuery.style( fx.elem, "opacity", fx.now );
		},

		_default: function( fx ) {
			if ( fx.elem.style && fx.elem.style[ fx.prop ] != null ) {
				fx.elem.style[ fx.prop ] = fx.now + fx.unit;
			} else {
				fx.elem[ fx.prop ] = fx.now;
			}
		}
	}
});

// Adds width/height step functions
// Do not set anything below 0
jQuery.each([ "width", "height" ], function( i, prop ) {
	jQuery.fx.step[ prop ] = function( fx ) {
		jQuery.style( fx.elem, prop, Math.max(0, fx.now) + fx.unit );
	};
});

if ( jQuery.expr && jQuery.expr.filters ) {
	jQuery.expr.filters.animated = function( elem ) {
		return jQuery.grep(jQuery.timers, function( fn ) {
			return elem === fn.elem;
		}).length;
	};
}

// Try to restore the default display value of an element
function defaultDisplay( nodeName ) {

	if ( !elemdisplay[ nodeName ] ) {

		var body = document.body,
			elem = jQuery( "<" + nodeName + ">" ).appendTo( body ),
			display = elem.css( "display" );
		elem.remove();

		// If the simple way fails,
		// get element's real default display by attaching it to a temp iframe
		if ( display === "none" || display === "" ) {
			// No iframe to use yet, so create it
			if ( !iframe ) {
				iframe = document.createElement( "iframe" );
				iframe.frameBorder = iframe.width = iframe.height = 0;
			}

			body.appendChild( iframe );

			// Create a cacheable copy of the iframe document on first call.
			// IE and Opera will allow us to reuse the iframeDoc without re-writing the fake HTML
			// document to it; WebKit & Firefox won't allow reusing the iframe document.
			if ( !iframeDoc || !iframe.createElement ) {
				iframeDoc = ( iframe.contentWindow || iframe.contentDocument ).document;
				iframeDoc.write( ( document.compatMode === "CSS1Compat" ? "<!doctype html>" : "" ) + "<html><body>" );
				iframeDoc.close();
			}

			elem = iframeDoc.createElement( nodeName );

			iframeDoc.body.appendChild( elem );

			display = jQuery.css( elem, "display" );
			body.removeChild( iframe );
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return elemdisplay[ nodeName ];
}




var rtable = /^t(?:able|d|h)$/i,
	rroot = /^(?:body|html)$/i;

if ( "getBoundingClientRect" in document.documentElement ) {
	jQuery.fn.offset = function( options ) {
		var elem = this[0], box;

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		try {
			box = elem.getBoundingClientRect();
		} catch(e) {}

		var doc = elem.ownerDocument,
			docElem = doc.documentElement;

		// Make sure we're not dealing with a disconnected DOM node
		if ( !box || !jQuery.contains( docElem, elem ) ) {
			return box ? { top: box.top, left: box.left } : { top: 0, left: 0 };
		}

		var body = doc.body,
			win = getWindow(doc),
			clientTop  = docElem.clientTop  || body.clientTop  || 0,
			clientLeft = docElem.clientLeft || body.clientLeft || 0,
			scrollTop  = win.pageYOffset || jQuery.support.boxModel && docElem.scrollTop  || body.scrollTop,
			scrollLeft = win.pageXOffset || jQuery.support.boxModel && docElem.scrollLeft || body.scrollLeft,
			top  = box.top  + scrollTop  - clientTop,
			left = box.left + scrollLeft - clientLeft;

		return { top: top, left: left };
	};

} else {
	jQuery.fn.offset = function( options ) {
		var elem = this[0];

		if ( options ) {
			return this.each(function( i ) {
				jQuery.offset.setOffset( this, options, i );
			});
		}

		if ( !elem || !elem.ownerDocument ) {
			return null;
		}

		if ( elem === elem.ownerDocument.body ) {
			return jQuery.offset.bodyOffset( elem );
		}

		var computedStyle,
			offsetParent = elem.offsetParent,
			prevOffsetParent = elem,
			doc = elem.ownerDocument,
			docElem = doc.documentElement,
			body = doc.body,
			defaultView = doc.defaultView,
			prevComputedStyle = defaultView ? defaultView.getComputedStyle( elem, null ) : elem.currentStyle,
			top = elem.offsetTop,
			left = elem.offsetLeft;

		while ( (elem = elem.parentNode) && elem !== body && elem !== docElem ) {
			if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
				break;
			}

			computedStyle = defaultView ? defaultView.getComputedStyle(elem, null) : elem.currentStyle;
			top  -= elem.scrollTop;
			left -= elem.scrollLeft;

			if ( elem === offsetParent ) {
				top  += elem.offsetTop;
				left += elem.offsetLeft;

				if ( jQuery.support.doesNotAddBorder && !(jQuery.support.doesAddBorderForTableAndCells && rtable.test(elem.nodeName)) ) {
					top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
					left += parseFloat( computedStyle.borderLeftWidth ) || 0;
				}

				prevOffsetParent = offsetParent;
				offsetParent = elem.offsetParent;
			}

			if ( jQuery.support.subtractsBorderForOverflowNotVisible && computedStyle.overflow !== "visible" ) {
				top  += parseFloat( computedStyle.borderTopWidth  ) || 0;
				left += parseFloat( computedStyle.borderLeftWidth ) || 0;
			}

			prevComputedStyle = computedStyle;
		}

		if ( prevComputedStyle.position === "relative" || prevComputedStyle.position === "static" ) {
			top  += body.offsetTop;
			left += body.offsetLeft;
		}

		if ( jQuery.support.fixedPosition && prevComputedStyle.position === "fixed" ) {
			top  += Math.max( docElem.scrollTop, body.scrollTop );
			left += Math.max( docElem.scrollLeft, body.scrollLeft );
		}

		return { top: top, left: left };
	};
}

jQuery.offset = {

	bodyOffset: function( body ) {
		var top = body.offsetTop,
			left = body.offsetLeft;

		if ( jQuery.support.doesNotIncludeMarginInBodyOffset ) {
			top  += parseFloat( jQuery.css(body, "marginTop") ) || 0;
			left += parseFloat( jQuery.css(body, "marginLeft") ) || 0;
		}

		return { top: top, left: left };
	},

	setOffset: function( elem, options, i ) {
		var position = jQuery.css( elem, "position" );

		// set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		var curElem = jQuery( elem ),
			curOffset = curElem.offset(),
			curCSSTop = jQuery.css( elem, "top" ),
			curCSSLeft = jQuery.css( elem, "left" ),
			calculatePosition = ( position === "absolute" || position === "fixed" ) && jQuery.inArray("auto", [curCSSTop, curCSSLeft]) > -1,
			props = {}, curPosition = {}, curTop, curLeft;

		// need to be able to calculate position if either top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;
		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {
			options = options.call( elem, i, curOffset );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	}
};


jQuery.fn.extend({

	position: function() {
		if ( !this[0] ) {
			return null;
		}

		var elem = this[0],

		// Get *real* offsetParent
		offsetParent = this.offsetParent(),

		// Get correct offsets
		offset       = this.offset(),
		parentOffset = rroot.test(offsetParent[0].nodeName) ? { top: 0, left: 0 } : offsetParent.offset();

		// Subtract element margins
		// note: when an element has margin: auto the offsetLeft and marginLeft
		// are the same in Safari causing offset.left to incorrectly be 0
		offset.top  -= parseFloat( jQuery.css(elem, "marginTop") ) || 0;
		offset.left -= parseFloat( jQuery.css(elem, "marginLeft") ) || 0;

		// Add offsetParent borders
		parentOffset.top  += parseFloat( jQuery.css(offsetParent[0], "borderTopWidth") ) || 0;
		parentOffset.left += parseFloat( jQuery.css(offsetParent[0], "borderLeftWidth") ) || 0;

		// Subtract the two offsets
		return {
			top:  offset.top  - parentOffset.top,
			left: offset.left - parentOffset.left
		};
	},

	offsetParent: function() {
		return this.map(function() {
			var offsetParent = this.offsetParent || document.body;
			while ( offsetParent && (!rroot.test(offsetParent.nodeName) && jQuery.css(offsetParent, "position") === "static") ) {
				offsetParent = offsetParent.offsetParent;
			}
			return offsetParent;
		});
	}
});


// Create scrollLeft and scrollTop methods
jQuery.each( ["Left", "Top"], function( i, name ) {
	var method = "scroll" + name;

	jQuery.fn[ method ] = function( val ) {
		var elem, win;

		if ( val === undefined ) {
			elem = this[ 0 ];

			if ( !elem ) {
				return null;
			}

			win = getWindow( elem );

			// Return the scroll offset
			return win ? ("pageXOffset" in win) ? win[ i ? "pageYOffset" : "pageXOffset" ] :
				jQuery.support.boxModel && win.document.documentElement[ method ] ||
					win.document.body[ method ] :
				elem[ method ];
		}

		// Set the scroll offset
		return this.each(function() {
			win = getWindow( this );

			if ( win ) {
				win.scrollTo(
					!i ? val : jQuery( win ).scrollLeft(),
					 i ? val : jQuery( win ).scrollTop()
				);

			} else {
				this[ method ] = val;
			}
		});
	};
});

function getWindow( elem ) {
	return jQuery.isWindow( elem ) ?
		elem :
		elem.nodeType === 9 ?
			elem.defaultView || elem.parentWindow :
			false;
}




// Create width, height, innerHeight, innerWidth, outerHeight and outerWidth methods
jQuery.each([ "Height", "Width" ], function( i, name ) {

	var type = name.toLowerCase();

	// innerHeight and innerWidth
	jQuery.fn[ "inner" + name ] = function() {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, "padding" ) ) :
			this[ type ]() :
			null;
	};

	// outerHeight and outerWidth
	jQuery.fn[ "outer" + name ] = function( margin ) {
		var elem = this[0];
		return elem ?
			elem.style ?
			parseFloat( jQuery.css( elem, type, margin ? "margin" : "border" ) ) :
			this[ type ]() :
			null;
	};

	jQuery.fn[ type ] = function( size ) {
		// Get window width or height
		var elem = this[0];
		if ( !elem ) {
			return size == null ? null : this;
		}

		if ( jQuery.isFunction( size ) ) {
			return this.each(function( i ) {
				var self = jQuery( this );
				self[ type ]( size.call( this, i, self[ type ]() ) );
			});
		}

		if ( jQuery.isWindow( elem ) ) {
			// Everyone else use document.documentElement or document.body depending on Quirks vs Standards mode
			// 3rd condition allows Nokia support, as it supports the docElem prop but not CSS1Compat
			var docElemProp = elem.document.documentElement[ "client" + name ],
				body = elem.document.body;
			return elem.document.compatMode === "CSS1Compat" && docElemProp ||
				body && body[ "client" + name ] || docElemProp;

		// Get document width or height
		} else if ( elem.nodeType === 9 ) {
			// Either scroll[Width/Height] or offset[Width/Height], whichever is greater
			return Math.max(
				elem.documentElement["client" + name],
				elem.body["scroll" + name], elem.documentElement["scroll" + name],
				elem.body["offset" + name], elem.documentElement["offset" + name]
			);

		// Get or set width or height on the element
		} else if ( size === undefined ) {
			var orig = jQuery.css( elem, type ),
				ret = parseFloat( orig );

			return jQuery.isNumeric( ret ) ? ret : orig;

		// Set the width or height on the element (default to pixels if value is unitless)
		} else {
			return this.css( type, typeof size === "string" ? size : size + "px" );
		}
	};

});




// Expose jQuery to the global object
window.jQuery = window.$ = jQuery;

// Expose jQuery as an AMD module, but only for AMD loaders that
// understand the issues with loading multiple versions of jQuery
// in a page that all might call define(). The loader will indicate
// they have special allowances for multiple jQuery versions by
// specifying define.amd.jQuery = true. Register as a named module,
// since jQuery can be concatenated with other files that may use define,
// but not use a proper concatenation script that understands anonymous
// AMD modules. A named AMD is safest and most robust way to register.
// Lowercase jquery is used because AMD module names are derived from
// file names, and jQuery is normally delivered in a lowercase file name.
// Do this after creating the global so that if an AMD module wants to call
// noConflict to hide this version of jQuery, it will work.
if ( typeof define === "function" && define.amd && define.amd.jQuery ) {
	define( "jquery", [], function () { return jQuery; } );
}



})( window );


// ES5 15.2.3.5 
if (!Object.create) {
    Object.create = function(prototype, properties) {
        var object;
        if (prototype === null) {
            object = {"__proto__": null};
        } else {
            if (typeof prototype != "object")
                throw new TypeError("typeof prototype["+(typeof prototype)+"] != 'object'");
            var Type = function () {};
            Type.prototype = prototype;
            object = new Type();
        }
        if (typeof properties !== "undefined")
            Object.defineProperties(object, properties);
        return object;
    };
}


/*! hasflash.js version 1.0 gbaker 
*/
(function(window, Plugin){
	if(window['hasflashjs']){return;}
	else {window['hasflashjs']=1;}
	try {
		var flashVersion = Plugin.description || (function () {
			return (
				new Plugin('ShockwaveFlash.ShockwaveFlash')
			).GetVariable('$version');
		}())
	}
	catch (e) {
		flashVersion = 'Unavailable';
	}	
	var flashVersionMatchVersionNumbers = flashVersion.match(/\d+/g) || [0],
		fv = parseInt(flashVersionMatchVersionNumbers[0], 10) || 0,
		t = "has-js js", 
		de = document.documentElement,
		setDE = function(s){
			de.className += (de.className == "" ? "" : " ") + s;
		};
	if(!isNaN(fv) && fv > 1 && fv < 100) {
		t += " has-flash";
		for(var x = fv; x >= 8; x--) {
			t += " flash-gt-eq-" + x;
		}
	}
	setDE(t);
})(window, navigator.plugins['Shockwave Flash'] || window.ActiveXObject);


/* Modernizr 2.5.3 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-fontface-backgroundsize-borderimage-borderradius-boxshadow-flexbox-flexbox_legacy-hsla-multiplebgs-opacity-rgba-textshadow-cssanimations-csscolumns-generatedcontent-cssgradients-cssreflections-csstransforms-csstransforms3d-csstransitions-applicationcache-canvas-canvastext-draganddrop-hashchange-history-audio-video-indexeddb-input-inputtypes-localstorage-postmessage-sessionstorage-geolocation-touch-cssclasses-prefixed-teststyles-testprop-testallprops-hasevent-prefixes-domprefixes
 */
;window.Modernizr=function(a,b,c){function B(a){j.cssText=a}function C(a,b){return B(n.join(a+";")+(b||""))}function D(a,b){return typeof a===b}function E(a,b){return!!~(""+a).indexOf(b)}function F(a,b){for(var d in a)if(j[a[d]]!==c)return b=="pfx"?a[d]:!0;return!1}function G(a,b,d){for(var e in a){var f=b[a[e]];if(f!==c)return d===!1?a[e]:D(f,"function")?f.bind(d||b):f}return!1}function H(a,b,c){var d=a.charAt(0).toUpperCase()+a.substr(1),e=(a+" "+p.join(d+" ")+d).split(" ");return D(b,"string")||D(b,"undefined")?F(e,b):(e=(a+" "+q.join(d+" ")+d).split(" "),G(e,b,c))}function J(){e.input=function(c){for(var d=0,e=c.length;d<e;d++)t[c[d]]=c[d]in k;return t.list&&(t.list=!!b.createElement("datalist")&&!!a.HTMLDataListElement),t}("autocomplete autofocus list placeholder max min multiple pattern required step".split(" ")),e.inputtypes=function(a){for(var d=0,e,f,h,i=a.length;d<i;d++)k.setAttribute("type",f=a[d]),e=k.type!=="text",e&&(k.value=l,k.style.cssText="position:absolute;visibility:hidden;",/^range$/.test(f)&&k.style.WebkitAppearance!==c?(g.appendChild(k),h=b.defaultView,e=h.getComputedStyle&&h.getComputedStyle(k,null).WebkitAppearance!=="textfield"&&k.offsetHeight!==0,g.removeChild(k)):/^(search|tel)$/.test(f)||(/^(url|email)$/.test(f)?e=k.checkValidity&&k.checkValidity()===!1:/^color$/.test(f)?(g.appendChild(k),g.offsetWidth,e=k.value!=l,g.removeChild(k)):e=k.value!=l)),s[a[d]]=!!e;return s}("search tel url email datetime date month week time datetime-local number range color".split(" "))}var d="2.5.3",e={},f=!0,g=b.documentElement,h="modernizr",i=b.createElement(h),j=i.style,k=b.createElement("input"),l=":)",m={}.toString,n=" -webkit- -moz- -o- -ms- ".split(" "),o="Webkit Moz O ms",p=o.split(" "),q=o.toLowerCase().split(" "),r={},s={},t={},u=[],v=u.slice,w,x=function(a,c,d,e){var f,i,j,k=b.createElement("div"),l=b.body,m=l?l:b.createElement("body");if(parseInt(d,10))while(d--)j=b.createElement("div"),j.id=e?e[d]:h+(d+1),k.appendChild(j);return f=["&#173;","<style>",a,"</style>"].join(""),k.id=h,(l?k:m).innerHTML+=f,m.appendChild(k),l||(m.style.background="",g.appendChild(m)),i=c(k,a),l?k.parentNode.removeChild(k):m.parentNode.removeChild(m),!!i},y=function(){function d(d,e){e=e||b.createElement(a[d]||"div"),d="on"+d;var f=d in e;return f||(e.setAttribute||(e=b.createElement("div")),e.setAttribute&&e.removeAttribute&&(e.setAttribute(d,""),f=D(e[d],"function"),D(e[d],"undefined")||(e[d]=c),e.removeAttribute(d))),e=null,f}var a={select:"input",change:"input",submit:"form",reset:"form",error:"img",load:"img",abort:"img"};return d}(),z={}.hasOwnProperty,A;!D(z,"undefined")&&!D(z.call,"undefined")?A=function(a,b){return z.call(a,b)}:A=function(a,b){return b in a&&D(a.constructor.prototype[b],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(b){var c=this;if(typeof c!="function")throw new TypeError;var d=v.call(arguments,1),e=function(){if(this instanceof e){var a=function(){};a.prototype=c.prototype;var f=new a,g=c.apply(f,d.concat(v.call(arguments)));return Object(g)===g?g:f}return c.apply(b,d.concat(v.call(arguments)))};return e});var I=function(c,d){var f=c.join(""),g=d.length;x(f,function(c,d){var f=b.styleSheets[b.styleSheets.length-1],h=f?f.cssRules&&f.cssRules[0]?f.cssRules[0].cssText:f.cssText||"":"",i=c.childNodes,j={};while(g--)j[i[g].id]=i[g];e.touch="ontouchstart"in a||a.DocumentTouch&&b instanceof DocumentTouch||(j.touch&&j.touch.offsetTop)===9,e.csstransforms3d=(j.csstransforms3d&&j.csstransforms3d.offsetLeft)===9&&j.csstransforms3d.offsetHeight===3,e.generatedcontent=(j.generatedcontent&&j.generatedcontent.offsetHeight)>=1,e.fontface=/src/i.test(h)&&h.indexOf(d.split(" ")[0])===0},g,d)}(['@font-face {font-family:"font";src:url("https://")}',["@media (",n.join("touch-enabled),("),h,")","{#touch{top:9px;position:absolute}}"].join(""),["@media (",n.join("transform-3d),("),h,")","{#csstransforms3d{left:9px;position:absolute;height:3px;}}"].join(""),['#generatedcontent:after{content:"',l,'";visibility:hidden}'].join("")],["fontface","touch","csstransforms3d","generatedcontent"]);r.flexbox=function(){return H("flexOrder")},r["flexbox-legacy"]=function(){return H("boxDirection")},r.canvas=function(){var a=b.createElement("canvas");return!!a.getContext&&!!a.getContext("2d")},r.canvastext=function(){return!!e.canvas&&!!D(b.createElement("canvas").getContext("2d").fillText,"function")},r.touch=function(){return e.touch},r.geolocation=function(){return!!navigator.geolocation},r.postmessage=function(){return!!a.postMessage},r.indexedDB=function(){return!!H("indexedDB",a)},r.hashchange=function(){return y("hashchange",a)&&(b.documentMode===c||b.documentMode>7)},r.history=function(){return!!a.history&&!!history.pushState},r.draganddrop=function(){var a=b.createElement("div");return"draggable"in a||"ondragstart"in a&&"ondrop"in a},r.rgba=function(){return B("background-color:rgba(150,255,150,.5)"),E(j.backgroundColor,"rgba")},r.hsla=function(){return B("background-color:hsla(120,40%,100%,.5)"),E(j.backgroundColor,"rgba")||E(j.backgroundColor,"hsla")},r.multiplebgs=function(){return B("background:url(https://),url(https://),red url(https://)"),/(url\s*\(.*?){3}/.test(j.background)},r.backgroundsize=function(){return H("backgroundSize")},r.borderimage=function(){return H("borderImage")},r.borderradius=function(){return H("borderRadius")},r.boxshadow=function(){return H("boxShadow")},r.textshadow=function(){return b.createElement("div").style.textShadow===""},r.opacity=function(){return C("opacity:.55"),/^0.55$/.test(j.opacity)},r.cssanimations=function(){return H("animationName")},r.csscolumns=function(){return H("columnCount")},r.cssgradients=function(){var a="background-image:",b="gradient(linear,left top,right bottom,from(#9f9),to(white));",c="linear-gradient(left top,#9f9, white);";return B((a+"-webkit- ".split(" ").join(b+a)+n.join(c+a)).slice(0,-a.length)),E(j.backgroundImage,"gradient")},r.cssreflections=function(){return H("boxReflect")},r.csstransforms=function(){return!!H("transform")},r.csstransforms3d=function(){var a=!!H("perspective");return a&&"webkitPerspective"in g.style&&(a=e.csstransforms3d),a},r.csstransitions=function(){return H("transition")},r.fontface=function(){return e.fontface},r.generatedcontent=function(){return e.generatedcontent},r.video=function(){var a=b.createElement("video"),c=!1;try{if(c=!!a.canPlayType)c=new Boolean(c),c.ogg=a.canPlayType('video/ogg; codecs="theora"').replace(/^no$/,""),c.h264=a.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/,""),c.webm=a.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/,"")}catch(d){}return c},r.audio=function(){var a=b.createElement("audio"),c=!1;try{if(c=!!a.canPlayType)c=new Boolean(c),c.ogg=a.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),c.mp3=a.canPlayType("audio/mpeg;").replace(/^no$/,""),c.wav=a.canPlayType('audio/wav; codecs="1"').replace(/^no$/,""),c.m4a=(a.canPlayType("audio/x-m4a;")||a.canPlayType("audio/aac;")).replace(/^no$/,"")}catch(d){}return c},r.localstorage=function(){try{return localStorage.setItem(h,h),localStorage.removeItem(h),!0}catch(a){return!1}},r.sessionstorage=function(){try{return sessionStorage.setItem(h,h),sessionStorage.removeItem(h),!0}catch(a){return!1}},r.applicationcache=function(){return!!a.applicationCache};for(var K in r)A(r,K)&&(w=K.toLowerCase(),e[w]=r[K](),u.push((e[w]?"":"no-")+w));return e.input||J(),B(""),i=k=null,e._version=d,e._prefixes=n,e._domPrefixes=q,e._cssomPrefixes=p,e.hasEvent=y,e.testProp=function(a){return F([a])},e.testAllProps=H,e.testStyles=x,e.prefixed=function(a,b,c){return b?H(a,b,c):H(a,"pfx")},g.className=g.className.replace(/(^|\s)no-js(\s|$)/,"$1$2")+(f?" js "+u.join(" "):""),e}(this,this.document);


// WebTrends SmartSource Data Collector Tag
// Version: 9.4.0     
// Tag Builder Version: 3.2
// Created: 9/7/2011 1:58:01 AM

/* Dragonfly Changes.
 * Patched by gbaker 26/09/2011 
 *	- document.write can't be used with LABjs script loader.
 * 	- remove the inbuilt dcsid, timezone and fpcdom.
 */

function WebTrends(){
	var that=this;
	// begin: user modifiable
	//this.dcsid="dcs3e9phnuz5bdfu8tzlamfrh_8n7o";
	this.domain="statse.webtrendslive.com";
	//this.timezone=10;
	//this.fpcdom=".intpublish.dragonfly.ford.com";
	this.onsitedoms="";
	this.downloadtypes="xls,doc,pdf,txt,csv,zip,docx,xlsx";
	this.navigationtag="div,table";
	this.trackevents=true;
	this.trimoffsiteparams=true;
	this.enabled=true;
	this.i18n=true;
	this.fpc="WT_FPC";
	this.paidsearchparams="gclid";
	this.splitvalue="";
	this.preserve=true;
	// end: user modifiable
	this.DCS={};
	this.WT={};
	this.DCSext={};
	this.images=[];
	this.index=0;
	this.exre=(function(){return(window.RegExp?new RegExp("dcs(uri)|(ref)|(aut)|(met)|(sta)|(sip)|(pro)|(byt)|(dat)|(p3p)|(cfg)|(redirect)|(cip)","i"):"");})();
	this.re=(function(){return(window.RegExp?(that.i18n?{"%25":/\%/g,"%26":/\&/g}:{"%09":/\t/g,"%20":/ /g,"%23":/\#/g,"%26":/\&/g,"%2B":/\+/g,"%3F":/\?/g,"%5C":/\\/g,"%22":/\"/g,"%7F":/\x7F/g,"%A0":/\xA0/g}):"");})();
}
WebTrends.prototype.dcsGetId=function(){
	if (this.enabled&&(document.cookie.indexOf(this.fpc+"=")==-1)&&(document.cookie.indexOf("WTLOPTOUT=")==-1)){
		// document.write("<scr"+"ipt type='text/javascript' src='"+"http"+(window.location.protocol.indexOf('https:')==0?'s':'')+"://"+this.domain+"/"+this.dcsid+"/wtid.js"+"'><\/scr"+"ipt>");
		// 26/09/2011 Patch
		var wtid = document.createElement('script'); 
		wtid.type = 'text/javascript';
		wtid.async = true;
		wtid.src = "http"+(window.location.protocol.indexOf('https:')==0?'s':'')+"://"+this.domain+"/"+this.dcsid+"/wtid.js";
		var sibling = document.getElementsByTagName('script')[0]; 
		sibling.parentNode.insertBefore(wtid, sibling);
	}
}
WebTrends.prototype.dcsGetCookie=function(name){
	var cookies=document.cookie.split("; ");
	var cmatch=[];
	var idx=0;
	var i=0;
	var namelen=name.length;
	var clen=cookies.length;
	for (i=0;i<clen;i++){
		var c=cookies[i];
		if ((c.substring(0,namelen+1))==(name+"=")){
			cmatch[idx++]=c;
		}
	}
	var cmatchCount=cmatch.length;
	if (cmatchCount>0){
		idx=0;
		if ((cmatchCount>1)&&(name==this.fpc)){
			var dLatest=new Date(0);
			for (i=0;i<cmatchCount;i++){
				var lv=parseInt(this.dcsGetCrumb(cmatch[i],"lv"));
				var dLst=new Date(lv);
				if (dLst>dLatest){
					dLatest.setTime(dLst.getTime());
					idx=i;
				}
			}
		}
		return unescape(cmatch[idx].substring(namelen+1));
	}
	else{
		return null;
	}
}
WebTrends.prototype.dcsGetCrumb=function(cval,crumb,sep){
	var aCookie=cval.split(sep||":");
	for (var i=0;i<aCookie.length;i++){
		var aCrumb=aCookie[i].split("=");
		if (crumb==aCrumb[0]){
			return aCrumb[1];
		}
	}
	return null;
}
WebTrends.prototype.dcsGetIdCrumb=function(cval,crumb){
	var id=cval.substring(0,cval.indexOf(":lv="));
	var aCrumb=id.split("=");
	for (var i=0;i<aCrumb.length;i++){
		if (crumb==aCrumb[0]){
			return aCrumb[1];
		}
	}
	return null;
}
WebTrends.prototype.dcsIsFpcSet=function(name,id,lv,ss){
	var c=this.dcsGetCookie(name);
	if (c){
		return ((id==this.dcsGetIdCrumb(c,"id"))&&(lv==this.dcsGetCrumb(c,"lv"))&&(ss==this.dcsGetCrumb(c,"ss")))?0:3;
	}
	return 2;
}
WebTrends.prototype.dcsFPC=function(){
	if (document.cookie.indexOf("WTLOPTOUT=")!=-1){
		return;
	}
	var WT=this.WT;
	var name=this.fpc;
	var dCur=new Date();
	var adj=(dCur.getTimezoneOffset()*60000)+(this.timezone*3600000);
	dCur.setTime(dCur.getTime()+adj);
	var dExp=new Date(dCur.getTime()+315360000000);
	var dSes=new Date(dCur.getTime());
	WT.co_f=WT.vtid=WT.vtvs=WT.vt_f=WT.vt_f_a=WT.vt_f_s=WT.vt_f_d=WT.vt_f_tlh=WT.vt_f_tlv="";
	if (document.cookie.indexOf(name+"=")==-1){
		if ((typeof(gWtId)!="undefined")&&(gWtId!="")){
			WT.co_f=gWtId;
		}
		else if ((typeof(gTempWtId)!="undefined")&&(gTempWtId!="")){
			WT.co_f=gTempWtId;
			WT.vt_f="1";
		}
		else{
			WT.co_f="2";
			var curt=dCur.getTime().toString();
			for (var i=2;i<=(32-curt.length);i++){
				WT.co_f+=Math.floor(Math.random()*16.0).toString(16);
			}
			WT.co_f+=curt;
			WT.vt_f="1";
		}
		if (typeof(gWtAccountRollup)=="undefined"){
			WT.vt_f_a="1";
		}
		WT.vt_f_s=WT.vt_f_d="1";
		WT.vt_f_tlh=WT.vt_f_tlv="0";
	}
	else{
		var c=this.dcsGetCookie(name);
		var id=this.dcsGetIdCrumb(c,"id");
		var lv=parseInt(this.dcsGetCrumb(c,"lv"));
		var ss=parseInt(this.dcsGetCrumb(c,"ss"));
		if ((id==null)||(id=="null")||isNaN(lv)||isNaN(ss)){
			return;
		}
		WT.co_f=id;
		var dLst=new Date(lv);
		WT.vt_f_tlh=Math.floor((dLst.getTime()-adj)/1000);
		dSes.setTime(ss);
		if ((dCur.getTime()>(dLst.getTime()+1800000))||(dCur.getTime()>(dSes.getTime()+28800000))){
			WT.vt_f_tlv=Math.floor((dSes.getTime()-adj)/1000);
			dSes.setTime(dCur.getTime());
			WT.vt_f_s="1";
		}
		if ((dCur.getDay()!=dLst.getDay())||(dCur.getMonth()!=dLst.getMonth())||(dCur.getYear()!=dLst.getYear())){
			WT.vt_f_d="1";
		}
	}
	WT.co_f=escape(WT.co_f);
	WT.vtid=(typeof(this.vtid)=="undefined")?WT.co_f:(this.vtid||"");
	WT.vtvs=(dSes.getTime()-adj).toString();
	var expiry="; expires="+dExp.toGMTString();
	var cur=dCur.getTime().toString();
	var ses=dSes.getTime().toString();
	document.cookie=name+"="+"id="+WT.co_f+":lv="+cur+":ss="+ses+expiry+"; path=/"+(((this.fpcdom!=""))?("; domain="+this.fpcdom):(""));
	var rc=this.dcsIsFpcSet(name,WT.co_f,cur,ses);
	if (rc!=0){
		WT.co_f=WT.vtvs=WT.vt_f_s=WT.vt_f_d=WT.vt_f_tlh=WT.vt_f_tlv="";
		if (typeof(this.vtid)=="undefined"){
			WT.vtid="";
		}
		WT.vt_f=WT.vt_f_a=rc;
    }
}
// Code section for Enable SmartView Transition Page tracking
WebTrends.prototype.dcsTP = function() {
    if (document.cookie.indexOf("WTLOPTOUT=") != -1) {
        return;
    }
    var name = "WT_DC";
    var expiry = "; expires=Thu, 31-Dec-2020 08:00:00 GMT";
    var pth = "; path=/";
    var domain = "";
    if (document.cookie.indexOf(name + "=tsp=1") != -1) {
        this.WT.ttp = "1";
    }
    if (this.dcsGetMeta("SmartView_Page") == "1") {
        this.WT.tsp = "1";
        document.cookie = name + "=tsp=1" + expiry + pth + domain;
    }
    else {
        document.cookie = name + "=; expires=Sun, 1-Jan-1995 00:00:00 GMT;" + pth + domain;
    }
}
WebTrends.prototype.dcsGetMeta = function(name) {
    var elems;
    if (document.documentElement) {
        elems = document.getElementsByTagName("meta");
    }
    else if (document.all) {
        elems = document.all.tags("meta");
    }
    if (typeof (elems) != "undefined") {
        for (var i = 1; i <= elems.length; i++) {
            var meta = elems.item(i - 1);
            if (meta.name && (meta.name.indexOf(name) == 0)) {
                return meta.content;
                break;
            }
        }
    }
    return null;
}
WebTrends.prototype.dcsIsOnsite=function(host){
	if (host.length>0){
	    host=host.toLowerCase();
	    if (host==window.location.hostname.toLowerCase()){
		    return true;
	    }
	    if (typeof(this.onsitedoms.test)=="function"){
		    return this.onsitedoms.test(host);
	    }
	    else if (this.onsitedoms.length>0){
		    var doms=this.dcsSplit(this.onsitedoms);
		    var len=doms.length;
		    for (var i=0;i<len;i++){
			    if (host==doms[i]){
			        return true;
			    }
		    }
	    }
	}
	return false;
}
WebTrends.prototype.dcsTypeMatch=function(pth, typelist){
	var type=pth.toLowerCase().substring(pth.lastIndexOf(".")+1,pth.length);
	var types=this.dcsSplit(typelist);
	var tlen=types.length;	
	for (var i=0;i<tlen;i++){
		if (type==types[i]){
			return true;
		}
	}
	return false;
}
WebTrends.prototype.dcsEvt=function(evt,tag){
	var e=evt.target||evt.srcElement;
	while (e&&e.tagName&&(e.tagName.toLowerCase()!=tag.toLowerCase())){
		e=e.parentElement||e.parentNode;
	}
	return e;
}
WebTrends.prototype.dcsNavigation=function(evt){
	var id="";
	var cname="";
	var elems=this.dcsSplit(this.navigationtag);
	var elen=elems.length;	
	var i,e,elem;
	for (i=0;i<elen;i++){
		elem=elems[i];
		if (elem.length){
			e=this.dcsEvt(evt,elem);
			id=(e.getAttribute&&e.getAttribute("id"))?e.getAttribute("id"):"";
			cname=e.className||"";
			if (id.length||cname.length){
				break;
			}
		}
	}
	return id.length?id:cname;
}
WebTrends.prototype.dcsBind=function(event,func){
	if ((typeof(func)=="function")&&document.body){
		if (document.body.addEventListener){
			document.body.addEventListener(event, func.wtbind(this), true);
		}
		else if(document.body.attachEvent){
			document.body.attachEvent("on"+event, func.wtbind(this));
		}
	}
}
WebTrends.prototype.dcsET=function(){
	var e=(navigator.appVersion.indexOf("MSIE")!=-1)?"click":"mousedown";
	this.dcsBind(e,this.dcsDownload);
	this.dcsBind(e,this.dcsJavaScript);
	this.dcsBind(e,this.dcsMailTo);
	this.dcsBind(e,this.dcsFormButton);
	this.dcsBind(e,this.dcsOffsite);
	this.dcsBind(e,this.dcsAnchor);
	this.dcsBind("contextmenu",this.dcsRightClick);
	this.dcsBind(e,this.dcsImageMap);
}
WebTrends.prototype.dcsMultiTrack=function(){
	var args=dcsMultiTrack.arguments?dcsMultiTrack.arguments:arguments;
	if (args.length%2==0){
	    this.dcsSaveProps(args);
		this.dcsSetProps(args);
		var dCurrent=new Date();
		this.DCS.dcsdat=dCurrent.getTime();
		this.dcsFPC();
		this.dcsTag();
		this.dcsRestoreProps();
	}
}

WebTrends.prototype.dcsCleanUp=function(){
	this.DCS={};
	this.WT={};
	this.DCSext={};
	if (arguments.length%2==0){
		this.dcsSetProps(arguments);
	}
}
WebTrends.prototype.dcsSetProps=function(args){
	for (var i=0;i<args.length;i+=2){
		if (args[i].indexOf('WT.')==0){
			this.WT[args[i].substring(3)]=args[i+1];
		}
		else if (args[i].indexOf('DCS.')==0){
			this.DCS[args[i].substring(4)]=args[i+1];
		}
		else if (args[i].indexOf('DCSext.')==0){
			this.DCSext[args[i].substring(7)]=args[i+1];
		}
	}
}
WebTrends.prototype.dcsSaveProps=function(args){
	var i,x,key,param;
	if (this.preserve){
		this.args=[];
		for (i=0,x=0;i<args.length;i+=2){
			param=args[i];
			if (param.indexOf('WT.')==0){
				key=param.substring(3);
				this.args[x]=param;
				this.args[x+1]=this.WT[key]||"";
				x+=2;
			}
			else if (param.indexOf('DCS.')==0){
				key=param.substring(4);
				this.args[x]=param;
				this.args[x+1]=this.DCS[key]||"";
				x+=2;
			}
			else if (param.indexOf('DCSext.')==0){
				key=param.substring(7);
				this.args[x]=param;
				this.args[x+1]=this.DCSext[key]||"";
				x+=2;
			}
		}
	}
}
WebTrends.prototype.dcsRestoreProps=function(){
	if (this.preserve){
		this.dcsSetProps(this.args);
		this.args=[];
	}
}
WebTrends.prototype.dcsSplit=function(list){
	var items=list.toLowerCase().split(",");
	var len=items.length;
	for (var i=0;i<len;i++){
		items[i]=items[i].replace(/^\s*/,"").replace(/\s*$/,"");
	}
	return items;
}
// Code section for Track clicks to download links.
WebTrends.prototype.dcsDownload=function(evt){
	evt=evt||(window.event||"");
	if (evt&&((typeof(evt.which)!="number")||(evt.which==1))){
		var e=this.dcsEvt(evt,"A");
		if (e.href){
		    var hn=e.hostname?(e.hostname.split(":")[0]):"";
		    if (this.dcsIsOnsite(hn)&&this.dcsTypeMatch(e.pathname,this.downloadtypes)){
		        var qry=e.search?e.search.substring(e.search.indexOf("?")+1,e.search.length):"";
		        var pth=e.pathname?((e.pathname.indexOf("/")!=0)?"/"+e.pathname:e.pathname):"/";
		        var ttl="";
		        var text=document.all?e.innerText:e.text;
		        var img=this.dcsEvt(evt,"IMG");
		        if (img.alt){
			        ttl=img.alt;
		        }
		        else if (text){
			        ttl=text;
		        }
		        else if (e.innerHTML){
			        ttl=e.innerHTML;
		        }
		        this.dcsMultiTrack("DCS.dcssip",hn,"DCS.dcsuri",pth,"DCS.dcsqry",e.search||"","WT.ti","Download:"+ttl,"WT.dl","20","WT.nv",this.dcsNavigation(evt));
		    }
		}
	}
}
// Code section for Track right clicks to download links.
WebTrends.prototype.dcsRightClick=function(evt){
	evt=evt||(window.event||"");
	if (evt){
		var btn=evt.which||evt.button;
		if ((btn!=1)||(navigator.userAgent.indexOf("Safari")!=-1)){
			var e=this.dcsEvt(evt,"A");
			if ((typeof(e.href)!="undefined")&&e.href){
				if ((typeof(e.protocol)!="undefined")&&e.protocol&&(e.protocol.indexOf("http")!=-1)){
					if ((typeof(e.pathname)!="undefined")&&this.dcsTypeMatch(e.pathname,this.downloadtypes)){
						var pth=e.pathname?((e.pathname.indexOf("/")!=0)?"/"+e.pathname:e.pathname):"/";
						var hn=e.hostname?(e.hostname.split(":")[0]):"";
						this.dcsMultiTrack("DCS.dcssip",hn,"DCS.dcsuri",pth,"DCS.dcsqry","","WT.ti","RightClick:"+pth,"WT.dl","25");
					}
				}
			}
		}
	}
}
// Code section for Track clicks to MailTo links.
WebTrends.prototype.dcsMailTo = function(evt) {
    evt = evt || (window.event || "");
    if (evt && ((typeof (evt.which) != "number") || (evt.which == 1))) {
        var e = this.dcsEvt(evt, "A");
        if (e.href && e.protocol) {
            var qry = e.search ? e.search.substring(e.search.indexOf("?") + 1, e.search.length) : "";
            if (e.protocol.toLowerCase() == "mailto:") {
                this.dcsMultiTrack("DCS.dcssip", window.location.hostname, "DCS.dcsuri", e.href, "WT.ti", "MailTo:" + e.innerHTML, "WT.dl", "23", "WT.nv", this.dcsNavigation(evt));
            }
        }
    }
}
// Code section for Track clicks to JavaScript links.
WebTrends.prototype.dcsJavaScript = function(evt) {
    evt = evt || (window.event || "");
    if (evt && ((typeof (evt.which) != "number") || (evt.which == 1))) {
        var e = this.dcsEvt(evt, "A");
        if (e.href && e.protocol) {
            var qry = e.search ? e.search.substring(e.search.indexOf("?") + 1, e.search.length) : "";
            if (e.protocol.toLowerCase() == "javascript:") {
                this.dcsMultiTrack("DCS.dcssip", window.location.hostname, "DCS.dcsuri", e.href, "WT.ti", "JavaScript:" + e.innerHTML, "WT.dl", "22", "WT.nv", this.dcsNavigation(evt));
            }
        }
    }
}
// Code section for Track form button clicks.
WebTrends.prototype.dcsFormButton=function(evt){
	evt=evt||(window.event||"");
	if (evt&&((typeof(evt.which)!="number")||(evt.which==1))){
		var tags=["INPUT","BUTTON"];
		for (var j=0;j<tags.length;j++){
			var e=this.dcsEvt(evt,tags[j]);
			var type=e.type||"";
			if (type&&((type=="submit")||(type=="image")||(type=="button")||(type=="reset"))||((type=="text")&&((evt.which||evt.keyCode)==13))){
				var uri="";
				var ttl="";
				var id=0;
				if (e.form){
					// begin: field capture
					// end: field capture
					uri=e.form.action||window.location.pathname;
					ttl=e.form.id||e.form.name||e.form.className||"Unknown";
					id=(e.form.method&&(e.form.method.toLowerCase()=="post"))?"27":"26";
				}
				else{
					uri=window.location.pathname;
					ttl=e.name||e.id||"Unknown";
					id=(tags[j].toLowerCase()=="input")?"28":"29";
				}
				if (uri&&ttl&&(evt.keyCode!=9)){
					this.dcsMultiTrack("DCS.dcsuri",uri,"WT.ti","FormButton:"+ttl,"WT.dl",id,"WT.nv",this.dcsNavigation(evt));
				}
				break;
			}
		}
	}
}
// Code section for Track clicks to links leading offsite.
WebTrends.prototype.dcsOffsite=function(evt){
	evt=evt||(window.event||"");
	if (evt&&((typeof(evt.which)!="number")||(evt.which==1))){
		var e=this.dcsEvt(evt,"A");
		if (e.href){
		    var hn=e.hostname?(e.hostname.split(":")[0]):"";
		    var pr=e.protocol||"";
		    if ((hn.length>0)&&(pr.indexOf("http")==0)&&!this.dcsIsOnsite(hn)){
			    var qry=e.search?e.search.substring(e.search.indexOf("?")+1,e.search.length):"";
			    var pth=e.pathname?((e.pathname.indexOf("/")!=0)?"/"+e.pathname:e.pathname):"/";
			    this.dcsMultiTrack("DCS.dcssip", hn, "DCS.dcsuri", pth, "DCS.dcsqry", this.trimoffsiteparams ? "" : qry, "DCS.dcsref", window.location, "WT.ti", "Offsite:" + hn + pth + (qry.length ? ("?" + qry) : ""), "WT.dl", "24", "WT.nv", this.dcsNavigation(evt));
		    }
		}
	}
}

// Code section for Track clicks to links that contain anchors.
WebTrends.prototype.dcsAnchor=function(evt){
	evt=evt||(window.event||"");
	if (evt&&((typeof(evt.which)!="number")||(evt.which==1))){
		var e=this.dcsEvt(evt,"A");
		if (e.href){
		    var hn=e.hostname?(e.hostname.split(":")[0]):"";
		    if (this.dcsIsOnsite(hn)&&e.hash&&(e.hash!="")&&(e.hash!="#")){
		        var qry=e.search?e.search.substring(e.search.indexOf("?")+1,e.search.length):"";
			    var pth=e.pathname?((e.pathname.indexOf("/")!=0)?"/"+e.pathname:e.pathname):"/";
			    this.dcsMultiTrack("DCS.dcssip",hn,"DCS.dcsuri",escape(pth+e.hash),"WT.ti","Anchor:"+e.hash,"WT.dl","21","WT.nv",this.dcsNavigation(evt));
		    }
		}
	}
}
// Code section for clicks to image maps.
WebTrends.prototype.dcsImageMap=function(evt){
	evt=evt||(window.event||"");
	if (evt){
		var e=this.dcsEvt(evt,"AREA");
		if (e.href){
		    var hn=e.hostname?(e.hostname.split(":")[0]):"";
		    if ((hn!="")&&e.protocol&&(e.protocol.indexOf("http")!=-1)){
			    var ttl="";
			    var map=this.dcsEvt(evt,"MAP");
			    if (map){
			        if (map.name){
				        ttl=map.name;
			        }
			        else if (map.id){
				        ttl=map.id;
			        }
			    }
			    var pth=e.pathname?((e.pathname.indexOf("/")!=0)?"/"+e.pathname:e.pathname):"/";
			    this.dcsMultiTrack("DCS.dcssip",hn,"DCS.dcsuri",pth,"DCS.dcsqry",e.search||"","WT.ti","ImageMap:"+ttl,"WT.dl","30","WT.nv",this.dcsNavigation(evt));
		    }			
		}			
	}
}
WebTrends.prototype.dcsAdv=function(){
	if (this.trackevents&&(typeof(this.dcsET)=="function")){
		if (window.addEventListener){
			window.addEventListener("load",this.dcsET.wtbind(this),false);
		}
		else if (window.attachEvent){
			window.attachEvent("onload",this.dcsET.wtbind(this));
		}
	}
	this.dcsFPC();
	this.dcsTP();
}
WebTrends.prototype.dcsVar=function(){
	var dCurrent=new Date();
	var WT=this.WT;
	var DCS=this.DCS;
	WT.tz=parseInt(dCurrent.getTimezoneOffset()/60*-1)||"0";
	WT.bh=dCurrent.getHours()||"0";
	WT.ul=navigator.appName=="Netscape"?navigator.language:navigator.userLanguage;
	if (typeof(screen)=="object"){
		WT.cd=navigator.appName=="Netscape"?screen.pixelDepth:screen.colorDepth;
		WT.sr=screen.width+"x"+screen.height;
	}
	if (typeof(navigator.javaEnabled())=="boolean"){
		WT.jo=navigator.javaEnabled()?"Yes":"No";
	}
	if (document.title){
		if (window.RegExp){
			var tire=new RegExp("^"+window.location.protocol+"//"+window.location.hostname+"\\s-\\s");
			WT.ti=document.title.replace(tire,"");
		}
		else{
			WT.ti=document.title;
		}
	}
	WT.js="Yes";
	WT.jv=(function(){
		var agt=navigator.userAgent.toLowerCase();
		var major=parseInt(navigator.appVersion);
		var mac=(agt.indexOf("mac")!=-1);
		var ff=(agt.indexOf("firefox")!=-1);
		var ff0=(agt.indexOf("firefox/0.")!=-1);
		var ff10=(agt.indexOf("firefox/1.0")!=-1);
		var ff15=(agt.indexOf("firefox/1.5")!=-1);
		var ff20=(agt.indexOf("firefox/2.0")!=-1);
		var ff3up=(ff&&!ff0&&!ff10&!ff15&!ff20);
		var nn=(!ff&&(agt.indexOf("mozilla")!=-1)&&(agt.indexOf("compatible")==-1));
		var nn4=(nn&&(major==4));
		var nn6up=(nn&&(major>=5));
		var ie=((agt.indexOf("msie")!=-1)&&(agt.indexOf("opera")==-1));
		var ie4=(ie&&(major==4)&&(agt.indexOf("msie 4")!=-1));
		var ie5up=(ie&&!ie4);
		var op=(agt.indexOf("opera")!=-1);
		var op5=(agt.indexOf("opera 5")!=-1||agt.indexOf("opera/5")!=-1);
		var op6=(agt.indexOf("opera 6")!=-1||agt.indexOf("opera/6")!=-1);
		var op7up=(op&&!op5&&!op6);
		var jv="1.1";
		if (ff3up){
			jv="1.8";
		}
		else if (ff20){
			jv="1.7";
		}
		else if (ff15){
			jv="1.6";
		}
		else if (ff0||ff10||nn6up||op7up){
			jv="1.5";
		}
		else if ((mac&&ie5up)||op6){
			jv="1.4";
		}
		else if (ie5up||nn4||op5){
			jv="1.3";
		}
		else if (ie4){
			jv="1.2";
		}
		return jv;
	})();
	WT.ct="unknown";
	if (document.body&&document.body.addBehavior){
		try{
			document.body.addBehavior("#default#clientCaps");
			WT.ct=document.body.connectionType||"unknown";
			document.body.addBehavior("#default#homePage");
			WT.hp=document.body.isHomePage(location.href)?"1":"0";
		}
		catch(e){
		}
	}
	if (document.all){
		WT.bs=document.body?document.body.offsetWidth+"x"+document.body.offsetHeight:"unknown";
	}
	else{
		WT.bs=window.innerWidth+"x"+window.innerHeight;
	}
	WT.fv=(function(){
		var i,flash;
		if (window.ActiveXObject){
			for(i=15;i>0;i--){
				try{
					flash=new ActiveXObject("ShockwaveFlash.ShockwaveFlash."+i);
					return i+".0";
				}
				catch(e){
				}
			}
		}
		else if (navigator.plugins&&navigator.plugins.length){
			for (i=0;i<navigator.plugins.length;i++){
				if (navigator.plugins[i].name.indexOf('Shockwave Flash')!=-1){
					return navigator.plugins[i].description.split(" ")[2];
				}
			}
		}
		return "Not enabled";
	})();
	WT.slv=(function(){
		var slv="Not enabled";
		try{     
			if (navigator.userAgent.indexOf('MSIE')!=-1){
				var sli = new ActiveXObject('AgControl.AgControl');
				if (sli){
					slv="Unknown";
				}
			}
			else if (navigator.plugins["Silverlight Plug-In"]){
				slv="Unknown";
			}
		}
		catch(e){
		}
		if (slv!="Not enabled"){
			var i,m,M,F;
			if ((typeof(Silverlight)=="object")&&(typeof(Silverlight.isInstalled)=="function")){
				for(i=9;i>0;i--){
					M=i;
					if (Silverlight.isInstalled(M+".0")){
							break;
					}
					if (slv==M){
						break;
					}
				}
				for (m=9;m>=0;m--){
					F=M+"."+m;
					if (Silverlight.isInstalled(F)){
						slv=F;
						break;
					}
					if (slv==F){
						break;
					}
				}
			}
		}
		return slv;
	})();
	if (this.i18n){
		if (typeof(document.defaultCharset)=="string"){
			WT.le=document.defaultCharset;
		} 
		else if (typeof(document.characterSet)=="string"){
			WT.le=document.characterSet;
		}
		else{
			WT.le="unknown";
		}
	}
	WT.tv="9.4.0";
	WT.sp=this.splitvalue;
	WT.dl="0";
	WT.ssl=(window.location.protocol.indexOf('https:')==0)?"1":"0";
	DCS.dcsdat=dCurrent.getTime();
	DCS.dcssip=window.location.hostname;
	DCS.dcsuri=window.location.pathname;
	WT.es=DCS.dcssip+DCS.dcsuri;
	if (window.location.search){
		DCS.dcsqry=window.location.search;
	}
	if (DCS.dcsqry){
		var dcsqry=DCS.dcsqry.toLowerCase();
		var params=this.paidsearchparams.length?this.paidsearchparams.toLowerCase().split(","):[];
		for (var i=0;i<params.length;i++){
			if (dcsqry.indexOf(params[i]+"=")!=-1){
				WT.srch="1";
				break;
			}
		}
	}
	if ((window.document.referrer!="")&&(window.document.referrer!="-")){
		if (!(navigator.appName=="Microsoft Internet Explorer"&&parseInt(navigator.appVersion)<4)){
			DCS.dcsref=window.document.referrer;
		}
	}
}
WebTrends.prototype.dcsEscape=function(S, REL){
	if (REL!=""){
		S=S.toString();
		for (var R in REL){
 			if (REL[R] instanceof RegExp){
				S=S.replace(REL[R],R);
 			}
		}
		return S;
	}
	else{
		return escape(S);
	}
}
WebTrends.prototype.dcsA=function(N,V){
	if (this.i18n&&(this.exre!="")&&!this.exre.test(N)){
		if (N=="dcsqry"){
			var newV="";
			var params=V.substring(1).split("&");
			for (var i=0;i<params.length;i++){
				var pair=params[i];
				var pos=pair.indexOf("=");
				if (pos!=-1){
					var key=pair.substring(0,pos);
					var val=pair.substring(pos+1);
					if (i!=0){
						newV+="&";
					}
					newV+=key+"="+this.dcsEncode(val);
				}
			}
			V=V.substring(0,1)+newV;
		}
		else{
			V=this.dcsEncode(V);
		}
	}
	return "&"+N+"="+this.dcsEscape(V, this.re);
}
WebTrends.prototype.dcsEncode=function(S){
	return (typeof(encodeURIComponent)=="function")?encodeURIComponent(S):escape(S);
}
WebTrends.prototype.dcsCreateImage=function(dcsSrc){
	if (document.images){
		this.images[this.index]=new Image();
		this.images[this.index].src=dcsSrc;
		this.index++;
	}
}
WebTrends.prototype.dcsMeta=function(){
	var elems;
	if (document.documentElement){
		elems=document.getElementsByTagName("meta");
	}
	else if (document.all){
		elems=document.all.tags("meta");
	}
	if (typeof(elems)!="undefined"){
		var length=elems.length;
		for (var i=0;i<length;i++){
			var name=elems.item(i).name;
			var content=elems.item(i).content;
			var equiv=elems.item(i).httpEquiv;
			if (name.length>0){
				if (name.toUpperCase().indexOf("WT.")==0){
					this.WT[name.substring(3)]=content;
				}
				else if (name.toUpperCase().indexOf("DCSEXT.")==0){
					this.DCSext[name.substring(7)]=content;
				}
				else if (name.toUpperCase().indexOf("DCS.")==0){
					this.DCS[name.substring(4)]=content;
				}
			}
		}
	}
}
WebTrends.prototype.dcsTag=function(){
	if (document.cookie.indexOf("WTLOPTOUT=")!=-1){
		return;
	}
	var WT=this.WT;
	var DCS=this.DCS;
	var DCSext=this.DCSext;
	var i18n=this.i18n;
	var P="http"+(window.location.protocol.indexOf('https:')==0?'s':'')+"://"+this.domain+(this.dcsid==""?'':'/'+this.dcsid)+"/dcs.gif?";
	if (i18n){
		WT.dep="";
	}
	for (var N in DCS){
 		if (DCS[N]&&(typeof DCS[N]!="function")){
			P+=this.dcsA(N,DCS[N]);
		}
	}
	for (N in WT){
		if (WT[N]&&(typeof WT[N]!="function")){
			P+=this.dcsA("WT."+N,WT[N]);
		}
	}
	for (N in DCSext){
		if (DCSext[N]&&(typeof DCSext[N]!="function")){
			if (i18n){
				WT.dep=(WT.dep.length==0)?N:(WT.dep+";"+N);
			}
			P+=this.dcsA(N,DCSext[N]);
		}
	}
	if (i18n&&(WT.dep.length>0)){
		P+=this.dcsA("WT.dep",WT.dep);
	}
	if (P.length>2048&&navigator.userAgent.indexOf('MSIE')>=0){
		P=P.substring(0,2040)+"&WT.tu=1";
	}
	this.dcsCreateImage(P);
	this.WT.ad="";
}
WebTrends.prototype.dcsDebug=function(){
	var t=this;
	var i=t.images[0].src;
	var q=i.indexOf("?");
	var r=i.substring(0,q).split("/");
	var m="<b>Protocol</b><br><code>"+r[0]+"<br></code>";
	m+="<b>Domain</b><br><code>"+r[2]+"<br></code>";
	m+="<b>Path</b><br><code>/"+r[3]+"/"+r[4]+"<br></code>";
	m+="<b>Query Params</b><code>"+i.substring(q+1).replace(/\&/g,"<br>")+"</code>";
	m+="<br><b>Cookies</b><br><code>"+document.cookie.replace(/\;/g,"<br>")+"</code>";
	if (t.w&&!t.w.closed){
		t.w.close();
	}
	t.w=window.open("","dcsDebug","width=500,height=650,scrollbars=yes,resizable=yes");
	t.w.document.write(m);
	t.w.focus();
}
WebTrends.prototype.dcsCollect=function(){
    if (this.enabled){
        this.dcsVar();
        this.dcsMeta();
        this.dcsAdv();
        if (typeof(this.dcsCustom)=="function"){
			this.dcsCustom();
        }
        this.dcsTag();
    }
}

function dcsMultiTrack(){
	if (typeof(_tag)!="undefined"){
		return(_tag.dcsMultiTrack());
	}
}

function dcsDebug(){
	if (typeof(_tag)!="undefined"){
		return(_tag.dcsDebug());
	}
}

Function.prototype.wtbind = function(obj){
	var method=this;
	var temp=function(){
		return method.apply(obj,arguments);
	};
	return temp;
};


/*! basepath.js version 1.0 gbaker */
(function(lib, undefined){
	var lb = window[lib] = window[lib] || {}, forcePath;
	if(lb['basepath'] !== undefined) return;
	lb.basepath = function(value){
		var domBase = document.getElementsByTagName('base');
		var basePath = (forcePath !== undefined ? forcePath : (domBase.length > 0 ? domBase[0].href : "/"));
		return value === undefined ? basePath : basePath + value;
	}
	lb.basepathOverride = function(value){forcePath = value;}
	
	jQuery.fn.attrBasePath = function( name, value ) {
		return arguments.length == 2 ? this.attr(name, lb.basepath(value)) : this.attr(name);		
	};
	
})('ND');



(function(){
	// make it safe to use console.log always
	(function(b){function c(){}for(var d="assert,clear,count,debug,dir,dirxml,error,exception,firebug,group,groupCollapsed,groupEnd,info,log,memoryProfile,memoryProfileEnd,profile,profileEnd,table,time,timeEnd,timeStamp,trace,warn".split(","),a;a=d.pop();){b[a]=b[a]||c}})((function(){try
	{console.log();return window.console;}catch(err){return window.console={};}})());

	jQuery.fn.log = function (msg) {
		console.log("%s: %o", msg, this); 
		return this;
	};
 })();



/*
    http://www.JSON.org/json2.js
    2010-08-25

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, strict: false */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (!this.JSON) {
    this.JSON = {};
}

(function () {

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                   this.getUTCFullYear()   + '-' +
                 f(this.getUTCMonth() + 1) + '-' +
                 f(this.getUTCDate())      + 'T' +
                 f(this.getUTCHours())     + ':' +
                 f(this.getUTCMinutes())   + ':' +
                 f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON =
        Number.prototype.toJSON =
        Boolean.prototype.toJSON = function (key) {
            return this.valueOf();
        };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ?
            '"' + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === 'string' ? c :
                    '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' :
            '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' :
                    gap ? '[\n' + gap +
                            partial.join(',\n' + gap) + '\n' +
                                mind + ']' :
                          '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' :
                gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' +
                        mind + '}' : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                     typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
.replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());



(function($) {

$.extend({
  metadata : {
    defaults : {
      type: 'class',
      name: 'metadata',
      cre: /({.*})/,
      single: 'metadata'
    },
    setType: function( type, name ){
      this.defaults.type = type;
      this.defaults.name = name;
    },
    get: function( elem, opts ){
      var settings = $.extend({},this.defaults,opts);
      // check for empty string in single property
      if ( !settings.single.length ) settings.single = 'metadata';
      
      var data = $.data(elem, settings.single);
      // returned cached data if it already exists
      if ( data ) return data;
      
      data = "{}";
      
      var getData = function(data) {
        if(typeof data != "string") return data;
        
        if( data.indexOf('{') < 0 ) {
          data = eval("(" + data + ")");
        }
      }
      
      var getObject = function(data) {
        if(typeof data != "string") return data;
        
        data = eval("(" + data + ")");
        return data;
      }
      
      if ( settings.type == "html5" ) {
        var object = {};
        $( elem.attributes ).each(function() {
          var name = this.nodeName;
          if(name.match(/^data-/)) name = name.replace(/^data-/, '');
          else return true;
          object[name] = getObject(this.nodeValue);
        });
      } else {
        if ( settings.type == "class" ) {
          var m = settings.cre.exec( elem.className );
          if ( m )
            data = m[1];
        } else if ( settings.type == "elem" ) {
          if( !elem.getElementsByTagName ) return;
          var e = elem.getElementsByTagName(settings.name);
          if ( e.length )
            data = $.trim(e[0].innerHTML);
        } else if ( elem.getAttribute != undefined ) {
          var attr = elem.getAttribute( settings.name );
          if ( attr )
            data = attr;
        }
        object = getObject(data.indexOf("{") < 0 ? "{" + data + "}" : data);
      }
      
      $.data( elem, settings.single, object );
      return object;
    }
  }
});

/**
 * Returns the metadata object for the first member of the jQuery object.
 *
 * @name metadata
 * @descr Returns element's metadata object
 * @param Object opts An object contianing settings to override the defaults
 * @type jQuery
 * @cat Plugins/Metadata
 */
$.fn.metadata = function( opts ){
  return $.metadata.get( this[0], opts );
};

})(jQuery);


// jQuery SWFObject
(function($, flash, Plugin) {
	var OBJECT = 'object',
		ENCODE = true;

	function _compareArrayIntegers(a, b) {
		var x = (a[0] || 0) - (b[0] || 0);

		return x > 0 || (
			!x &&
			a.length > 0 &&
			_compareArrayIntegers(a.slice(1), b.slice(1))
		);
	}

	function _objectToArguments(obj) {
		
		if (typeof obj != OBJECT) {
			return obj;
		}

		var arr = [],
			str = '';

		for (var i in obj) {
			
			if (typeof obj[i] == OBJECT) {
				str = _objectToArguments(obj[i]);
			}
			else {
				str = [i, (ENCODE) ? encodeURI(obj[i]).replace(/\&/g, "%26") : obj[i]].join('=');
			}

			arr.push(str);
		}

		return arr.join('&');
	}

	function _objectFromObject(obj) {
		var arr = [];

		for (var i in obj) {
			if (obj[i]) {
				arr.push([i, '="', obj[i], '"'].join(''));
			}
		}

		return arr.join(' ');
	}

	function _paramsFromObject(obj) {
		var arr = [];

		for (var i in obj) {
			
			arr.push([
				'<param name="', i,
				'" value="', _objectToArguments(obj[i]), '" />'
			].join(''));
		}

		return arr.join('');
	}

	try {
		var flashVersion = Plugin.description || (function () {
			return (
				new Plugin('ShockwaveFlash.ShockwaveFlash')
			).GetVariable('$version');
		}())
	}
	catch (e) {
		flashVersion = 'Unavailable';
	}

	var flashVersionMatchVersionNumbers = flashVersion.match(/\d+/g) || [0];

	$[flash] = {
		available: flashVersionMatchVersionNumbers[0] > 0,

		activeX: Plugin && !Plugin.name,

		version: {
			original: flashVersion,
			array: flashVersionMatchVersionNumbers,
			string: flashVersionMatchVersionNumbers.join('.'),
			major: parseInt(flashVersionMatchVersionNumbers[0], 10) || 0,
			minor: parseInt(flashVersionMatchVersionNumbers[1], 10) || 0,
			release: parseInt(flashVersionMatchVersionNumbers[2], 10) || 0
		},

		hasVersion: function (version) {
			var versionArray = (/string|number/.test(typeof version))
				? version.toString().split('.')
				: (/object/.test(typeof version))
					? [version.major, version.minor]
					: version || [0, 0];

			return _compareArrayIntegers(
				flashVersionMatchVersionNumbers,
				versionArray
			);
		},

		encodeParams: true,

		expressInstall: 'expressInstall.swf',
		expressInstallIsActive: false,

		create: function (obj) {
			var instance = this;

			if (
				!obj.swf ||
				instance.expressInstallIsActive ||
				(!instance.available && !obj.hasVersionFail)
			) {
				return false;
			}

			if (!instance.hasVersion(obj.hasVersion || 1)) {
				instance.expressInstallIsActive = true;

				if (typeof obj.hasVersionFail == 'function') {
					if (!obj.hasVersionFail.apply(obj)) {
						return false;
					}
				}

				obj = {
					swf: obj.expressInstall || instance.expressInstall,
					height: 137,
					width: 214,
					flashvars: {
						MMredirectURL: location.href,
						MMplayerType: (instance.activeX)
							? 'ActiveX' : 'PlugIn',
						MMdoctitle: document.title.slice(0, 47) +
							' - Flash Player Installation'
					}
				};
			}

			attrs = {
				data: obj.swf,
				type: 'application/x-shockwave-flash',
				id: obj.id || 'flash_' + Math.floor(Math.random() * 999999999),
				width: obj.width || 320,
				height: obj.height || 180,
				style: obj.style || ''
			};

			ENCODE = typeof obj.useEncode !== 'undefined' ? obj.useEncode : instance.encodeParams;

			obj.movie = obj.swf;
			obj.wmode = obj.wmode || 'opaque';
			//
			
			//

			delete obj.fallback;
			delete obj.hasVersion;
			delete obj.hasVersionFail;
			delete obj.height;
			delete obj.id;
			delete obj.swf;
			delete obj.useEncode;
			delete obj.width;

			var flashContainer = document.createElement('div');

			flashContainer.innerHTML = [
				'<object ', _objectFromObject(attrs), '>',
				_paramsFromObject(obj),
				'</object>'
			].join('');

			return flashContainer.firstChild;
		}
	};

	$.fn[flash] = function (options) {
		var $this = this.find(OBJECT).andSelf().filter(OBJECT);

		if (/string|object/.test(typeof options)) {
			this.each(
				function () {
					var $this = $(this),
						flashObject;

					options = (typeof options == OBJECT) ? options : {
						swf: options
					};

					options.fallback = this;

					flashObject = $[flash].create(options);

					if (flashObject) {
						$this.children().remove();

						$this.html(flashObject);
					}
				}
			);
		}

		if (typeof options == 'function') {
			$this.each(
				function () {
					var instance = this,
					jsInteractionTimeoutMs = 'jsInteractionTimeoutMs';

					instance[jsInteractionTimeoutMs] =
						instance[jsInteractionTimeoutMs] || 0;

					if (instance[jsInteractionTimeoutMs] < 660) {
						if (instance.clientWidth || instance.clientHeight) {
							options.call(instance);
						}
						else {
							setTimeout(
								function () {
									$(instance)[flash](options);
								},
								instance[jsInteractionTimeoutMs] + 66
							);
						}
					}
				}
			);
		}

		return $this;
	};
}(
	jQuery,
	'flash',
	navigator.plugins['Shockwave Flash'] || window.ActiveXObject
));



if(typeof asual=="undefined"){var asual={}}if(typeof asual.util=="undefined"){asual.util={}}asual.util.Browser=new function(){var b=navigator.userAgent.toLowerCase(),a=/webkit/.test(b),e=/opera/.test(b),c=/msie/.test(b)&&!/opera/.test(b),d=/mozilla/.test(b)&&!/(compatible|webkit)/.test(b),f=parseFloat(c?b.substr(b.indexOf("msie")+4):(b.match(/.+(?:rv|it|ra|ie)[\/: ]([\d.]+)/)||[0,"0"])[1]);this.toString=function(){return"[class Browser]"};this.getVersion=function(){return f};this.isMSIE=function(){return c};this.isSafari=function(){return a};this.isOpera=function(){return e};this.isMozilla=function(){return d}};asual.util.Events=new function(){var c="DOMContentLoaded",j="onstop",k=window,h=document,b=[],a=asual.util,e=a.Browser,d=e.isMSIE(),g=e.isSafari();this.toString=function(){return"[class Events]"};this.addListener=function(n,l,m){b.push({o:n,t:l,l:m});if(!(l==c&&(d||g))){if(n.addEventListener){n.addEventListener(l,m,false)}else{if(n.attachEvent){n.attachEvent("on"+l,m)}}}};this.removeListener=function(p,m,n){for(var l=0,o;o=b[l];l++){if(o.o==p&&o.t==m&&o.l==n){b.splice(l,1);break}}if(!(m==c&&(d||g))){if(p.removeEventListener){p.removeEventListener(m,n,false)}else{if(p.detachEvent){p.detachEvent("on"+m,n)}}}};var i=function(){for(var m=0,l;l=b[m];m++){if(l.t!=c){a.Events.removeListener(l.o,l.t,l.l)}}};var f=function(){if(h.readyState=="interactive"){function l(){h.detachEvent(j,l);i()}h.attachEvent(j,l);k.setTimeout(function(){h.detachEvent(j,l)},0)}};if(d||g){(function(){try{if((d&&h.body)||!/loaded|complete/.test(h.readyState)){h.documentElement.doScroll("left")}}catch(m){return setTimeout(arguments.callee,0)}for(var l=0,m;m=b[l];l++){if(m.t==c){m.l.call(null)}}})()}if(d){k.attachEvent("onbeforeunload",f)}this.addListener(k,"unload",i)};asual.util.Functions=new function(){this.toString=function(){return"[class Functions]"};this.bind=function(f,b,e){for(var c=2,d,a=[];d=arguments[c];c++){a.push(d)}return function(){return f.apply(b,a)}}};var SWFAddressEvent=function(d){this.toString=function(){return"[object SWFAddressEvent]"};this.type=d;this.target=[SWFAddress][0];this.value=SWFAddress.getValue();this.path=SWFAddress.getPath();this.pathNames=SWFAddress.getPathNames();this.parameters={};var c=SWFAddress.getParameterNames();for(var b=0,a=c.length;b<a;b++){this.parameters[c[b]]=SWFAddress.getParameter(c[b])}this.parameterNames=c};SWFAddressEvent.INIT="init";SWFAddressEvent.CHANGE="change";SWFAddressEvent.INTERNAL_CHANGE="internalChange";SWFAddressEvent.EXTERNAL_CHANGE="externalChange";var SWFAddress=new function(){var _getHash=function(){var index=_l.href.indexOf("#");return index!=-1?_ec(_dc(_l.href.substr(index+1))):""};var _getWindow=function(){try{top.document;return top}catch(e){return window}};var _strictCheck=function(value,force){if(_opts.strict){value=force?(value.substr(0,1)!="/"?"/"+value:value):(value==""?"/":value)}return value};var _ieLocal=function(value,direction){return(_msie&&_l.protocol=="file:")?(direction?_value.replace(/\?/,"%3F"):_value.replace(/%253F/,"?")):value};var _searchScript=function(el){if(el.childNodes){for(var i=0,l=el.childNodes.length,s;i<l;i++){if(el.childNodes[i].src){_url=String(el.childNodes[i].src)}if(s=_searchScript(el.childNodes[i])){return s}}}};var _titleCheck=function(){if(_d.title!=_title&&_d.title.indexOf("#")!=-1){_d.title=_title}};var _listen=function(){if(!_silent){var hash=_getHash();var diff=!(_value==hash);if(_safari&&_version<523){if(_length!=_h.length){_length=_h.length;if(typeof _stack[_length-1]!=UNDEFINED){_value=_stack[_length-1]}_update.call(this,false)}}else{if(_msie&&diff){if(_version<7){_l.reload()}else{this.setValue(hash)}}else{if(diff){_value=hash;_update.call(this,false)}}}if(_msie){_titleCheck.call(this)}}};var _bodyClick=function(e){if(_popup.length>0){var popup=window.open(_popup[0],_popup[1],eval(_popup[2]));if(typeof _popup[3]!=UNDEFINED){eval(_popup[3])}}_popup=[]};var _swfChange=function(){for(var i=0,id,obj,value=SWFAddress.getValue(),setter="setSWFAddressValue";id=_ids[i];i++){obj=document.getElementById(id);if(obj){if(obj.parentNode&&typeof obj.parentNode.so!=UNDEFINED){obj.parentNode.so.call(setter,value)}else{if(!(obj&&typeof obj[setter]!=UNDEFINED)){var objects=obj.getElementsByTagName("object");var embeds=obj.getElementsByTagName("embed");obj=((objects[0]&&typeof objects[0][setter]!=UNDEFINED)?objects[0]:((embeds[0]&&typeof embeds[0][setter]!=UNDEFINED)?embeds[0]:null))}if(obj){obj[setter](value)}}}else{if(obj=document[id]){if(typeof obj[setter]!=UNDEFINED){obj[setter](value)}}}}};var _jsDispatch=function(type){this.dispatchEvent(new SWFAddressEvent(type));type=type.substr(0,1).toUpperCase()+type.substr(1);if(typeof this["on"+type]==FUNCTION){this["on"+type]()}};var _jsInit=function(){if(_util.Browser.isSafari()){_d.body.addEventListener("click",_bodyClick)}_jsDispatch.call(this,"init")};var _jsChange=function(){_swfChange();_jsDispatch.call(this,"change")};var _update=function(internal){_jsChange.call(this);if(internal){_jsDispatch.call(this,"internalChange")}else{_jsDispatch.call(this,"externalChange")}_st(_functions.bind(_track,this),10)};var _track=function(){var value=(_l.pathname+(/\/$/.test(_l.pathname)?"":"/")+this.getValue()).replace(/\/\//,"/").replace(/^\/$/,"");var fn=_t[_opts.tracker];if(typeof fn==FUNCTION){fn(value)}else{if(typeof _t.pageTracker!=UNDEFINED&&typeof _t.pageTracker._trackPageview==FUNCTION){_t.pageTracker._trackPageview(value)}else{if(typeof _t.urchinTracker==FUNCTION){_t.urchinTracker(value)}}}};var _htmlWrite=function(){var doc=_frame.contentWindow.document;doc.open();doc.write("<html><head><title>"+_d.title+"</title><script>var "+ID+' = "'+_getHash()+'";<\/script></head></html>');doc.close()};var _htmlLoad=function(){var win=_frame.contentWindow;var src=win.location.href;_value=(typeof win[ID]!=UNDEFINED?win[ID]:"");if(_value!=_getHash()){_update.call(SWFAddress,false);_l.hash=_ieLocal(_value,TRUE)}};var _load=function(){if(!_loaded){_loaded=TRUE;if(_msie&&_version<8){var frameset=_d.getElementsByTagName("frameset")[0];_frame=_d.createElement((frameset?"":"i")+"frame");if(frameset){frameset.insertAdjacentElement("beforeEnd",_frame);frameset[frameset.cols?"cols":"rows"]+=",0";_frame.src="javascript:false";_frame.noResize=true;_frame.frameBorder=_frame.frameSpacing=0}else{_frame.src="javascript:false";_frame.style.display="none";_d.body.insertAdjacentElement("afterBegin",_frame)}_st(function(){_events.addListener(_frame,"load",_htmlLoad);if(typeof _frame.contentWindow[ID]==UNDEFINED){_htmlWrite()}},50)}else{if(_safari){if(_version<418){_d.body.innerHTML+='<form id="'+ID+'" style="position:absolute;top:-9999px;" method="get"></form>';_form=_d.getElementById(ID)}if(typeof _l[ID]==UNDEFINED){_l[ID]={}}if(typeof _l[ID][_l.pathname]!=UNDEFINED){_stack=_l[ID][_l.pathname].split(",")}}}_st(_functions.bind(function(){_jsInit.call(this);_jsChange.call(this);_track.call(this)},this),1);if(_msie&&_version>=8){_d.body.onhashchange=_functions.bind(_listen,this);_si(_functions.bind(_titleCheck,this),50)}else{_si(_functions.bind(_listen,this),50)}}};var ID="swfaddress",FUNCTION="function",UNDEFINED="undefined",TRUE=true,FALSE=false,_util=asual.util,_browser=_util.Browser,_events=_util.Events,_functions=_util.Functions,_version=_browser.getVersion(),_msie=_browser.isMSIE(),_mozilla=_browser.isMozilla(),_opera=_browser.isOpera(),_safari=_browser.isSafari(),_supported=FALSE,_t=_getWindow(),_d=_t.document,_h=_t.history,_l=_t.location,_si=setInterval,_st=setTimeout,_dc=decodeURI,_ec=encodeURI,_frame,_form,_url,_title=_d.title,_length=_h.length,_silent=FALSE,_loaded=FALSE,_justset=TRUE,_juststart=TRUE,_ref=this,_stack=[],_ids=[],_popup=[],_listeners={},_value=_getHash(),_opts={history:TRUE,strict:false};if(_msie&&_d.documentMode&&_d.documentMode!=_version){_version=_d.documentMode!=8?7:8}_supported=(_mozilla&&_version>=1)||(_msie&&_version>=6)||(_opera&&_version>=9.5)||(_safari&&_version>=312);if(_supported){if(_opera){history.navigationMode="compatible"}for(var i=1;i<_length;i++){_stack.push("")}_stack.push(_getHash());if(_msie&&_l.hash!=_getHash()){_l.hash="#"+_ieLocal(_getHash(),TRUE)}_searchScript(document);var _qi=_url?_url.indexOf("?"):-1;if(_qi!=-1){var param,params=_url.substr(_qi+1).split("&");for(var i=0,p;p=params[i];i++){param=p.split("=");if(/^(history|strict)$/.test(param[0])){_opts[param[0]]=(isNaN(param[1])?/^(true|yes)$/i.test(param[1]):(parseInt(param[1])!=0))}if(/^tracker$/.test(param[0])){_opts[param[0]]=param[1]}}}if(_msie){_titleCheck.call(this)}if(window==_t){_events.addListener(document,"DOMContentLoaded",_functions.bind(_load,this))}_events.addListener(_t,"load",_functions.bind(_load,this))}else{if((!_supported&&_l.href.indexOf("#")!=-1)||(_safari&&_version<418&&_l.href.indexOf("#")!=-1&&_l.search!="")){_d.open();_d.write('<html><head><meta http-equiv="refresh" content="0;url='+_l.href.substr(0,_l.href.indexOf("#"))+'" /></head></html>');_d.close()}else{_track()}}this.toString=function(){return"[class SWFAddress]"};this.back=function(){_h.back()};this.forward=function(){_h.forward()};this.up=function(){var path=this.getPath();this.setValue(path.substr(0,path.lastIndexOf("/",path.length-2)+(path.substr(path.length-1)=="/"?1:0)))};this.go=function(delta){_h.go(delta)};this.href=function(url,target){target=typeof target!=UNDEFINED?target:"_self";if(target=="_self"){self.location.href=url}else{if(target=="_top"){_l.href=url}else{if(target=="_blank"){window.open(url)}else{_t.frames[target].location.href=url}}}};this.popup=function(url,name,options,handler){try{var popup=window.open(url,name,eval(options));if(typeof handler!=UNDEFINED){eval(handler)}}catch(ex){}_popup=arguments};this.getIds=function(){return _ids};this.getId=function(index){return _ids[0]};this.setId=function(id){_ids[0]=id};this.addId=function(id){this.removeId(id);_ids.push(id)};this.removeId=function(id){for(var i=0;i<_ids.length;i++){if(id==_ids[i]){_ids.splice(i,1);break}}};this.addEventListener=function(type,listener){if(typeof _listeners[type]==UNDEFINED){_listeners[type]=[]}_listeners[type].push(listener)};this.removeEventListener=function(type,listener){if(typeof _listeners[type]!=UNDEFINED){for(var i=0,l;l=_listeners[type][i];i++){if(l==listener){break}}_listeners[type].splice(i,1)}};this.dispatchEvent=function(event){if(this.hasEventListener(event.type)){event.target=this;for(var i=0,l;l=_listeners[event.type][i];i++){l(event)}return TRUE}return FALSE};this.hasEventListener=function(type){return(typeof _listeners[type]!=UNDEFINED&&_listeners[type].length>0)};this.getBaseURL=function(){var url=_l.href;if(url.indexOf("#")!=-1){url=url.substr(0,url.indexOf("#"))}if(url.substr(url.length-1)=="/"){url=url.substr(0,url.length-1)}return url};this.getStrict=function(){return _opts.strict};this.setStrict=function(strict){_opts.strict=strict};this.getHistory=function(){return _opts.history};this.setHistory=function(history){_opts.history=history};this.getTracker=function(){return _opts.tracker};this.setTracker=function(tracker){_opts.tracker=tracker};this.getTitle=function(){return _d.title};this.setTitle=function(title){if(!_supported){return null}if(typeof title==UNDEFINED){return}if(title=="null"){title=""}title=_dc(title);_st(function(){_title=_d.title=title;if(_juststart&&_frame&&_frame.contentWindow&&_frame.contentWindow.document){_frame.contentWindow.document.title=title;_juststart=FALSE}if(!_justset&&_mozilla){_l.replace(_l.href.indexOf("#")!=-1?_l.href:_l.href+"#")}_justset=FALSE},10)};this.getStatus=function(){return _t.status};this.setStatus=function(status){if(!_supported){return null}if(typeof status==UNDEFINED){return}if(status=="null"){status=""}status=_dc(status);if(!_safari){status=_strictCheck((status!="null")?status:"",TRUE);if(status=="/"){status=""}if(!(/http(s)?:\/\//.test(status))){var index=_l.href.indexOf("#");status=(index==-1?_l.href:_l.href.substr(0,index))+"#"+status}_t.status=status}};this.resetStatus=function(){_t.status=""};this.getValue=function(){if(!_supported){return null}return _dc(_strictCheck(_ieLocal(_value,FALSE),FALSE))};this.setValue=function(value){if(!_supported){return null}if(typeof value==UNDEFINED){return}if(value=="null"){value=""}value=_ec(_dc(_strictCheck(value,TRUE)));if(value=="/"){value=""}if(_value==value){return}_justset=TRUE;_value=value;_silent=TRUE;_update.call(SWFAddress,true);_stack[_h.length]=_value;if(_safari){if(_opts.history){_l[ID][_l.pathname]=_stack.toString();_length=_h.length+1;if(_version<418){if(_l.search==""){_form.action="#"+_value;_form.submit()}}else{if(_version<523||_value==""){var evt=_d.createEvent("MouseEvents");evt.initEvent("click",TRUE,TRUE);var anchor=_d.createElement("a");anchor.href="#"+_value;anchor.dispatchEvent(evt)}else{_l.hash="#"+_value}}}else{_l.replace("#"+_value)}}else{if(_value!=_getHash()){if(_opts.history){_l.hash="#"+_dc(_ieLocal(_value,TRUE))}else{_l.replace("#"+_dc(_value))}}}if((_msie&&_version<8)&&_opts.history){_st(_htmlWrite,50)}if(_safari){_st(function(){_silent=FALSE},1)}else{_silent=FALSE}};this.getPath=function(){var value=this.getValue();if(value.indexOf("?")!=-1){return value.split("?")[0]}else{if(value.indexOf("#")!=-1){return value.split("#")[0]}else{return value}}};this.getPathNames=function(){var path=this.getPath(),names=path.split("/");if(path.substr(0,1)=="/"||path.length==0){names.splice(0,1)}if(path.substr(path.length-1,1)=="/"){names.splice(names.length-1,1)}return names};this.getQueryString=function(){var value=this.getValue(),index=value.indexOf("?");if(index!=-1&&index<value.length){return value.substr(index+1)}};this.getParameter=function(param){var value=this.getValue();var index=value.indexOf("?");if(index!=-1){value=value.substr(index+1);var p,params=value.split("&"),i=params.length,r=[];while(i--){p=params[i].split("=");if(p[0]==param){r.push(p[1])}}if(r.length!=0){return r.length!=1?r:r[0]}}};this.getParameterNames=function(){var value=this.getValue();var index=value.indexOf("?");var names=[];if(index!=-1){value=value.substr(index+1);if(value!=""&&value.indexOf("=")!=-1){var params=value.split("&"),i=0;while(i<params.length){names.push(params[i].split("=")[0]);i++}}}return names};this.onInit=null;this.onChange=null;this.onInternalChange=null;this.onExternalChange=null;(function(){var _args;if(typeof FlashObject!=UNDEFINED){SWFObject=FlashObject}if(typeof SWFObject!=UNDEFINED&&SWFObject.prototype&&SWFObject.prototype.write){var _s1=SWFObject.prototype.write;SWFObject.prototype.write=function(){_args=arguments;if(this.getAttribute("version").major<8){this.addVariable("$swfaddress",SWFAddress.getValue());((typeof _args[0]=="string")?document.getElementById(_args[0]):_args[0]).so=this}var success;if(success=_s1.apply(this,_args)){_ref.addId(this.getAttribute("id"))}return success}}if(typeof swfobject!=UNDEFINED){var _s2r=swfobject.registerObject;swfobject.registerObject=function(){_args=arguments;_s2r.apply(this,_args);_ref.addId(_args[0])};var _s2c=swfobject.createSWF;swfobject.createSWF=function(){_args=arguments;var swf=_s2c.apply(this,_args);if(swf){_ref.addId(_args[0].id)}return swf};var _s2e=swfobject.embedSWF;swfobject.embedSWF=function(){_args=arguments;if(typeof _args[8]==UNDEFINED){_args[8]={}}if(typeof _args[8].id==UNDEFINED){_args[8].id=_args[1]}_s2e.apply(this,_args);_ref.addId(_args[8].id)}}if(typeof UFO!=UNDEFINED){var _u=UFO.create;UFO.create=function(){_args=arguments;_u.apply(this,_args);_ref.addId(_args[0].id)}}if(typeof AC_FL_RunContent!=UNDEFINED){var _a=AC_FL_RunContent;AC_FL_RunContent=function(){_args=arguments;_a.apply(this,_args);for(var i=0,l=_args.length;i<l;i++){if(_args[i]=="id"){_ref.addId(_args[i+1])}}}}})()};


//Duck Punch jQuery SWFObject into submission and then hook it up on a date with SWFAddress
(function($){
	var _oldFlash = jQuery.fn.flash;
	$.fn.flash = function(){ 
		var ret = _oldFlash.apply(this,arguments);
		this.each(function(){
			var $flash = $(this).find('object').andSelf().filter('object');
			if (typeof SWFAddress != 'undefined') {
				SWFAddress.addId($flash.attr('id'))
			} 
		});		 
		return ret
	}
})(jQuery);	



(function($){$.fn.hoverIntent=function(f,g){var cfg={sensitivity:7,interval:100,timeout:0};cfg=$.extend(cfg,g?{over:f,out:g}:f);var cX,cY,pX,pY;var track=function(ev){cX=ev.pageX;cY=ev.pageY;};var compare=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);if((Math.abs(pX-cX)+Math.abs(pY-cY))<cfg.sensitivity){$(ob).unbind("mousemove",track);ob.hoverIntent_s=1;return cfg.over.apply(ob,[ev]);}else{pX=cX;pY=cY;ob.hoverIntent_t=setTimeout(function(){compare(ev,ob);},cfg.interval);}};var delay=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);ob.hoverIntent_s=0;return cfg.out.apply(ob,[ev]);};var handleHover=function(e){var p=(e.type=="mouseover"?e.fromElement:e.toElement)||e.relatedTarget;while(p&&p!=this){try{p=p.parentNode;}catch(e){p=this;}}if(p==this){return false;}var ev=jQuery.extend({},e);var ob=this;if(ob.hoverIntent_t){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);}if(e.type=="mouseover"){pX=ev.pageX;pY=ev.pageY;$(ob).bind("mousemove",track);if(ob.hoverIntent_s!=1){ob.hoverIntent_t=setTimeout(function(){compare(ev,ob);},cfg.interval);}}else{$(ob).unbind("mousemove",track);if(ob.hoverIntent_s==1){ob.hoverIntent_t=setTimeout(function(){delay(ev,ob);},cfg.timeout);}}};return this.mouseover(handleHover).mouseout(handleHover);};})(jQuery);



(function($) {
    /**
     * Creates a carousel for all matched elements.
     *
     * @example $("#mycarousel").jcarousel();
     * @before <ul id="mycarousel" class="jcarousel-skin-name"><li>First item</li><li>Second item</li></ul>
     * @result
     *
     * <div class="jcarousel-skin-name">
     *   <div class="jcarousel-container">
     *     <div class="jcarousel-clip">
     *       <ul class="jcarousel-list">
     *         <li class="jcarousel-item-1">First item</li>
     *         <li class="jcarousel-item-2">Second item</li>
     *       </ul>
     *     </div>
     *     <div disabled="disabled" class="jcarousel-prev jcarousel-prev-disabled"></div>
     *     <div class="jcarousel-next"></div>
     *   </div>
     * </div>
     *
     * @method jcarousel
     * @return jQuery
     * @param o {Hash|String} A set of key/value pairs to set as configuration properties or a method name to call on a formerly created instance.
     */
    $.fn.jcarousel = function(o) {
        if (typeof o == 'string') {
            var instance = $(this).data('jcarousel'), args = Array.prototype.slice.call(arguments, 1);
            return instance[o].apply(instance, args);
        } else
            return this.each(function() {
                $(this).data('jcarousel', new $jc(this, o));
            });
    };

    // Default configuration properties.
    var defaults = {
        vertical: false,
        rtl: false,
        start: 1,
        offset: 1,
        size: null,
        scroll: 3,
        visible: null,
        animation: 'normal',
        easing: 'swing',
        auto: 0,
        wrap: null,
        initCallback: null,
        reloadCallback: null,
        itemLoadCallback: null,
        itemFirstInCallback: null,
        itemFirstOutCallback: null,
        itemLastInCallback: null,
        itemLastOutCallback: null,
        itemVisibleInCallback: null,
        itemVisibleOutCallback: null,
        buttonNextHTML: '<div></div>',
        buttonPrevHTML: '<div></div>',
        buttonNextEvent: 'click',
        buttonPrevEvent: 'click',
        buttonNextCallback: null,
        buttonPrevCallback: null,
        itemFallbackDimension: null
    }, windowLoaded = false;

    $(window).bind('load.jcarousel', function() { windowLoaded = true; })

    /**
     * The jCarousel object.
     *
     * @constructor
     * @class jcarousel
     * @param e {HTMLElement} The element to create the carousel for.
     * @param o {Object} A set of key/value pairs to set as configuration properties.
     * @cat Plugins/jCarousel
     */
    $.jcarousel = function(e, o) {
        this.options    = $.extend({}, defaults, o || {});

        this.locked     = false;

        this.container  = null;
        this.clip       = null;
        this.list       = null;
        this.buttonNext = null;
        this.buttonPrev = null;

        // Only set if not explicitly passed as option
        if (!o || o.rtl === undefined)
            this.options.rtl = ($(e).attr('dir') || $('html').attr('dir') || '').toLowerCase() == 'rtl';

        this.wh = !this.options.vertical ? 'width' : 'height';
        this.lt = !this.options.vertical ? (this.options.rtl ? 'right' : 'left') : 'top';

        // Extract skin class
        var skin = '', split = e.className.split(' ');

        for (var i = 0; i < split.length; i++) {
            if (split[i].indexOf('jcarousel-skin') != -1) {
                $(e).removeClass(split[i]);
                skin = split[i];
                break;
            }
        }

        if (e.nodeName.toUpperCase() == 'UL' || e.nodeName.toUpperCase() == 'OL') {
            this.list = $(e);
            this.container = this.list.parent();

            if (this.container.hasClass('jcarousel-clip')) {
                if (!this.container.parent().hasClass('jcarousel-container'))
                    this.container = this.container.wrap('<div></div>');

                this.container = this.container.parent();
            } else if (!this.container.hasClass('jcarousel-container'))
                this.container = this.list.wrap('<div></div>').parent();
        } else {
            this.container = $(e);
            this.list = this.container.find('ul,ol').eq(0);
        }

        if (skin != '' && this.container.parent()[0].className.indexOf('jcarousel-skin') == -1)
            this.container.wrap('<div class=" '+ skin + '"></div>');

        this.clip = this.list.parent();

        if (!this.clip.length || !this.clip.hasClass('jcarousel-clip'))
            this.clip = this.list.wrap('<div></div>').parent();

        this.buttonNext = $('.jcarousel-next', this.container);

        if (this.buttonNext.size() == 0 && this.options.buttonNextHTML != null)
            this.buttonNext = this.clip.after(this.options.buttonNextHTML).next();

        this.buttonNext.addClass(this.className('jcarousel-next'));

        this.buttonPrev = $('.jcarousel-prev', this.container);

        if (this.buttonPrev.size() == 0 && this.options.buttonPrevHTML != null)
            this.buttonPrev = this.clip.after(this.options.buttonPrevHTML).next();

        this.buttonPrev.addClass(this.className('jcarousel-prev'));

        this.clip.addClass(this.className('jcarousel-clip')).css({
            overflow: 'hidden',
            position: 'relative'
        });
        this.list.addClass(this.className('jcarousel-list')).css({
            overflow: 'hidden',
            position: 'relative',
            top: 0,
            margin: 0,
            padding: 0
        }).css((this.options.rtl ? 'right' : 'left'), 0);
        this.container.addClass(this.className('jcarousel-container')).css({
            position: 'relative'
        });
        if (!this.options.vertical && this.options.rtl)
            this.container.addClass('jcarousel-direction-rtl').attr('dir', 'rtl');

        var di = this.options.visible != null ? Math.ceil(this.clipping() / this.options.visible) : null;
        var li = this.list.children('li');

        var self = this;

        if (li.size() > 0) {
            var wh = 0, i = this.options.offset;
            li.each(function() {
                self.format(this, i++);
                wh += self.dimension(this, di);
            });

            this.list.css(this.wh, (wh + 100) + 'px');

            // Only set if not explicitly passed as option
            if (!o || o.size === undefined)
                this.options.size = li.size();
        }

        // For whatever reason, .show() does not work in Safari...
        this.container.css('display', 'block');
        this.buttonNext.css('display', 'block');
        this.buttonPrev.css('display', 'block');

        this.funcNext   = function() { self.next(); };
        this.funcPrev   = function() { self.prev(); };
        this.funcResize = function() { self.reload(); };

        if (this.options.initCallback != null)
            this.options.initCallback(this, 'init');

        if (!windowLoaded && $.browser.safari) {
            this.buttons(false, false);
            $(window).bind('load.jcarousel', function() { self.setup(); });
        } else
            this.setup();
    };

    // Create shortcut for internal use
    var $jc = $.jcarousel;

    $jc.fn = $jc.prototype = {
        jcarousel: '0.2.5'
    };

    $jc.fn.extend = $jc.extend = $.extend;

    $jc.fn.extend({
        /**
         * Setups the carousel.
         *
         * @method setup
         * @return undefined
         */
        setup: function() {
            this.first     = null;
            this.last      = null;
            this.prevFirst = null;
            this.prevLast  = null;
            this.animating = false;
            this.timer     = null;
            this.tail      = null;
            this.inTail    = false;

            if (this.locked)
                return;

            this.list.css(this.lt, this.pos(this.options.offset) + 'px');
            var p = this.pos(this.options.start);
            this.prevFirst = this.prevLast = null;
            this.animate(p, false);

            $(window).unbind('resize.jcarousel', this.funcResize).bind('resize.jcarousel', this.funcResize);
        },

        /**
         * Clears the list and resets the carousel.
         *
         * @method reset
         * @return undefined
         */
        reset: function() {
            this.list.empty();

            this.list.css(this.lt, '0px');
            this.list.css(this.wh, '10px');

            if (this.options.initCallback != null)
                this.options.initCallback(this, 'reset');

            this.setup();
        },

        /**
         * Reloads the carousel and adjusts positions.
         *
         * @method reload
         * @return undefined
         */
        reload: function() {
            if (this.tail != null && this.inTail)
                this.list.css(this.lt, $jc.intval(this.list.css(this.lt)) + this.tail);

            this.tail   = null;
            this.inTail = false;

            if (this.options.reloadCallback != null)
                this.options.reloadCallback(this);

            if (this.options.visible != null) {
                var self = this;
                var di = Math.ceil(this.clipping() / this.options.visible), wh = 0, lt = 0;
                this.list.children('li').each(function(i) {
                    wh += self.dimension(this, di);
                    if (i + 1 < self.first)
                        lt = wh;
                });

                this.list.css(this.wh, wh + 'px');
                this.list.css(this.lt, -lt + 'px');
            }

            this.scroll(this.first, false);
        },

        /**
         * Locks the carousel.
         *
         * @method lock
         * @return undefined
         */
        lock: function() {
            this.locked = true;
            this.buttons();
        },

        /**
         * Unlocks the carousel.
         *
         * @method unlock
         * @return undefined
         */
        unlock: function() {
            this.locked = false;
            this.buttons();
        },

        /**
         * Sets the size of the carousel.
         *
         * @method size
         * @return undefined
         * @param s {Number} The size of the carousel.
         */
        size: function(s) {
            if (s != undefined) {
                this.options.size = s;
                if (!this.locked)
                    this.buttons();
            }

            return this.options.size;
        },

        /**
         * Checks whether a list element exists for the given index (or index range).
         *
         * @method get
         * @return bool
         * @param i {Number} The index of the (first) element.
         * @param i2 {Number} The index of the last element.
         */
        has: function(i, i2) {
            if (i2 == undefined || !i2)
                i2 = i;

            if (this.options.size !== null && i2 > this.options.size)
                i2 = this.options.size;

            for (var j = i; j <= i2; j++) {
                var e = this.get(j);
                if (!e.length || e.hasClass('jcarousel-item-placeholder'))
                    return false;
            }

            return true;
        },

        /**
         * Returns a jQuery object with list element for the given index.
         *
         * @method get
         * @return jQuery
         * @param i {Number} The index of the element.
         */
        get: function(i) {
            return $('.jcarousel-item-' + i, this.list);
        },

        /**
         * Adds an element for the given index to the list.
         * If the element already exists, it updates the inner html.
         * Returns the created element as jQuery object.
         *
         * @method add
         * @return jQuery
         * @param i {Number} The index of the element.
         * @param s {String} The innerHTML of the element.
         */
        add: function(i, s) {
            var e = this.get(i), old = 0, n = $(s);

            if (e.length == 0) {
                var c, e = this.create(i), j = $jc.intval(i);
                while (c = this.get(--j)) {
                    if (j <= 0 || c.length) {
                        j <= 0 ? this.list.prepend(e) : c.after(e);
                        break;
                    }
                }
            } else
                old = this.dimension(e);

            if (n.get(0).nodeName.toUpperCase() == 'LI') {
                e.replaceWith(n);
                e = n;
            } else
                e.empty().append(s);

            this.format(e.removeClass(this.className('jcarousel-item-placeholder')), i);

            var di = this.options.visible != null ? Math.ceil(this.clipping() / this.options.visible) : null;
            var wh = this.dimension(e, di) - old;

            if (i > 0 && i < this.first)
                this.list.css(this.lt, $jc.intval(this.list.css(this.lt)) - wh + 'px');

            this.list.css(this.wh, $jc.intval(this.list.css(this.wh)) + wh + 'px');

            return e;
        },

        /**
         * Removes an element for the given index from the list.
         *
         * @method remove
         * @return undefined
         * @param i {Number} The index of the element.
         */
        remove: function(i) {
            var e = this.get(i);

            // Check if item exists and is not currently visible
            if (!e.length || (i >= this.first && i <= this.last))
                return;

            var d = this.dimension(e);

            if (i < this.first)
                this.list.css(this.lt, $jc.intval(this.list.css(this.lt)) + d + 'px');

            e.remove();

            this.list.css(this.wh, $jc.intval(this.list.css(this.wh)) - d + 'px');
        },

        /**
         * Moves the carousel forwards.
         *
         * @method next
         * @return undefined
         */
        next: function() {
            this.stopAuto();

            if (this.tail != null && !this.inTail)
                this.scrollTail(false);
            else
                this.scroll(((this.options.wrap == 'both' || this.options.wrap == 'last') && this.options.size != null && this.last == this.options.size) ? 1 : this.first + this.options.scroll);
        },

        /**
         * Moves the carousel backwards.
         *
         * @method prev
         * @return undefined
         */
        prev: function() {
            this.stopAuto();

            if (this.tail != null && this.inTail)
                this.scrollTail(true);
            else
                this.scroll(((this.options.wrap == 'both' || this.options.wrap == 'first') && this.options.size != null && this.first == 1) ? this.options.size : this.first - this.options.scroll);
        },

        /**
         * Scrolls the tail of the carousel.
         *
         * @method scrollTail
         * @return undefined
         * @param b {Boolean} Whether scroll the tail back or forward.
         */
        scrollTail: function(b) {
            if (this.locked || this.animating || !this.tail)
                return;

            var pos  = $jc.intval(this.list.css(this.lt));

            !b ? pos -= this.tail : pos += this.tail;
            this.inTail = !b;

            // Save for callbacks
            this.prevFirst = this.first;
            this.prevLast  = this.last;

            this.animate(pos);
        },

        /**
         * Scrolls the carousel to a certain position.
         *
         * @method scroll
         * @return undefined
         * @param i {Number} The index of the element to scoll to.
         * @param a {Boolean} Flag indicating whether to perform animation.
         */
        scroll: function(i, a) {
            if (this.locked || this.animating)
                return;

            this.animate(this.pos(i), a);
        },

        /**
         * Prepares the carousel and return the position for a certian index.
         *
         * @method pos
         * @return {Number}
         * @param i {Number} The index of the element to scoll to.
         */
        pos: function(i) {
            var pos  = $jc.intval(this.list.css(this.lt));

            if (this.locked || this.animating)
                return pos;

            if (this.options.wrap != 'circular')
                i = i < 1 ? 1 : (this.options.size && i > this.options.size ? this.options.size : i);

            var back = this.first > i;

            // Create placeholders, new list width/height
            // and new list position
            var f = this.options.wrap != 'circular' && this.first <= 1 ? 1 : this.first;
            var c = back ? this.get(f) : this.get(this.last);
            var j = back ? f : f - 1;
            var e = null, l = 0, p = false, d = 0, g;

            while (back ? --j >= i : ++j < i) {
                e = this.get(j);
                p = !e.length;
                if (e.length == 0) {
                    e = this.create(j).addClass(this.className('jcarousel-item-placeholder'));
                    c[back ? 'before' : 'after' ](e);

                    if (this.first != null && this.options.wrap == 'circular' && this.options.size !== null && (j <= 0 || j > this.options.size)) {
                        g = this.get(this.index(j));
                        if (g.length)
                            e = this.add(j, g.clone(true));
                    }
                }

                c = e;
                d = this.dimension(e);

                if (p)
                    l += d;

                if (this.first != null && (this.options.wrap == 'circular' || (j >= 1 && (this.options.size == null || j <= this.options.size))))
                    pos = back ? pos + d : pos - d;
            }

            // Calculate visible items
            var clipping = this.clipping();
            var cache = [];
            var visible = 0, j = i, v = 0;
            var c = this.get(i - 1);

            while (++visible) {
                e = this.get(j);
                p = !e.length;
                if (e.length == 0) {
                    e = this.create(j).addClass(this.className('jcarousel-item-placeholder'));
                    // This should only happen on a next scroll
                    c.length == 0 ? this.list.prepend(e) : c[back ? 'before' : 'after' ](e);

                    if (this.first != null && this.options.wrap == 'circular' && this.options.size !== null && (j <= 0 || j > this.options.size)) {
                        g = this.get(this.index(j));
                        if (g.length)
                            e = this.add(j, g.clone(true));
                    }
                }

                c = e;
                var d = this.dimension(e);
                if (d == 0) {
                    throw new Error('jCarousel: No width/height set for items. This will cause an infinite loop. Aborting...');
                }

                if (this.options.wrap != 'circular' && this.options.size !== null && j > this.options.size)
                    cache.push(e);
                else if (p)
                    l += d;

                v += d;

                if (v >= clipping)
                    break;

                j++;
            }

             // Remove out-of-range placeholders
            for (var x = 0; x < cache.length; x++)
                cache[x].remove();

            // Resize list
            if (l > 0) {
                this.list.css(this.wh, this.dimension(this.list) + l + 'px');

                if (back) {
                    pos -= l;
                    this.list.css(this.lt, $jc.intval(this.list.css(this.lt)) - l + 'px');
                }
            }

            // Calculate first and last item
            var last = i + visible - 1;
            if (this.options.wrap != 'circular' && this.options.size && last > this.options.size)
                last = this.options.size;

            if (j > last) {
                visible = 0, j = last, v = 0;
                while (++visible) {
                    var e = this.get(j--);
                    if (!e.length)
                        break;
                    v += this.dimension(e);
                    if (v >= clipping)
                        break;
                }
            }

            var first = last - visible + 1;
            if (this.options.wrap != 'circular' && first < 1)
                first = 1;

            if (this.inTail && back) {
                pos += this.tail;
                this.inTail = false;
            }

            this.tail = null;
            if (this.options.wrap != 'circular' && last == this.options.size && (last - visible + 1) >= 1) {
                var m = $jc.margin(this.get(last), !this.options.vertical ? 'marginRight' : 'marginBottom');
                if ((v - m) > clipping)
                    this.tail = v - clipping - m;
            }

            // Adjust position
            while (i-- > first)
                pos += this.dimension(this.get(i));

            // Save visible item range
            this.prevFirst = this.first;
            this.prevLast  = this.last;
            this.first     = first;
            this.last      = last;

            return pos;
        },

        /**
         * Animates the carousel to a certain position.
         *
         * @method animate
         * @return undefined
         * @param p {Number} Position to scroll to.
         * @param a {Boolean} Flag indicating whether to perform animation.
         */
        animate: function(p, a) {
            if (this.locked || this.animating)
                return;

            this.animating = true;

            var self = this;
            var scrolled = function() {
                self.animating = false;

                if (p == 0)
                    self.list.css(self.lt,  0);

                if (self.options.wrap == 'circular' || self.options.wrap == 'both' || self.options.wrap == 'last' || self.options.size == null || self.last < self.options.size)
                    self.startAuto();

                self.buttons();
                self.notify('onAfterAnimation');

                // This function removes items which are appended automatically for circulation.
                // This prevents the list from growing infinitely.
                if (self.options.wrap == 'circular' && self.options.size !== null)
                    for (var i = self.prevFirst; i <= self.prevLast; i++)
                        if (i !== null && !(i >= self.first && i <= self.last) && (i < 1 || i > self.options.size))
                            self.remove(i);
            };

            this.notify('onBeforeAnimation');

            // Animate
            if (!this.options.animation || a == false) {
                this.list.css(this.lt, p + 'px');
                scrolled();
            } else {
                var o = !this.options.vertical ? (this.options.rtl ? {'right': p} : {'left': p}) : {'top': p};
                this.list.animate(o, this.options.animation, this.options.easing, scrolled);
            }
        },

        /**
         * Starts autoscrolling.
         *
         * @method auto
         * @return undefined
         * @param s {Number} Seconds to periodically autoscroll the content.
         */
        startAuto: function(s) {
            if (s != undefined)
                this.options.auto = s;

            if (this.options.auto == 0)
                return this.stopAuto();

            if (this.timer != null)
                return;

            var self = this;
            this.timer = setTimeout(function() { self.next(); }, this.options.auto * 1000);
        },

        /**
         * Stops autoscrolling.
         *
         * @method stopAuto
         * @return undefined
         */
        stopAuto: function() {
            if (this.timer == null)
                return;

            clearTimeout(this.timer);
            this.timer = null;
        },

        /**
         * Sets the states of the prev/next buttons.
         *
         * @method buttons
         * @return undefined
         */
        buttons: function(n, p) {
            if (n == undefined || n == null) {
                var n = !this.locked && this.options.size !== 0 && ((this.options.wrap && this.options.wrap != 'first') || this.options.size == null || this.last < this.options.size);
                if (!this.locked && (!this.options.wrap || this.options.wrap == 'first') && this.options.size != null && this.last >= this.options.size)
                    n = this.tail != null && !this.inTail;
            }

            if (p == undefined || p == null) {
                var p = !this.locked && this.options.size !== 0 && ((this.options.wrap && this.options.wrap != 'last') || this.first > 1);
                if (!this.locked && (!this.options.wrap || this.options.wrap == 'last') && this.options.size != null && this.first == 1)
                    p = this.tail != null && this.inTail;
            }

            var self = this;

            this.buttonNext[n ? 'bind' : 'unbind'](this.options.buttonNextEvent + '.jcarousel', this.funcNext)[n ? 'removeClass' : 'addClass'](this.className('jcarousel-next-disabled')).attr('disabled', n ? false : true);
            this.buttonPrev[p ? 'bind' : 'unbind'](this.options.buttonPrevEvent + '.jcarousel', this.funcPrev)[p ? 'removeClass' : 'addClass'](this.className('jcarousel-prev-disabled')).attr('disabled', p ? false : true);

            if (this.options.buttonNextCallback != null && this.buttonNext.data('jcarouselstate') != n) {
                this.buttonNext.each(function() { self.options.buttonNextCallback(self, this, n); }).data('jcarouselstate', n);
            }

            if (this.options.buttonPrevCallback != null && (this.buttonPrev.data('jcarouselstate') != p)) {
                this.buttonPrev.each(function() { self.options.buttonPrevCallback(self, this, p); }).data('jcarouselstate', p);
            }
        },

        /**
         * Notify callback of a specified event.
         *
         * @method notify
         * @return undefined
         * @param evt {String} The event name
         */
        notify: function(evt) {
            var state = this.prevFirst == null ? 'init' : (this.prevFirst < this.first ? 'next' : 'prev');

            // Load items
            this.callback('itemLoadCallback', evt, state);

            if (this.prevFirst !== this.first) {
                this.callback('itemFirstInCallback', evt, state, this.first);
                this.callback('itemFirstOutCallback', evt, state, this.prevFirst);
            }

            if (this.prevLast !== this.last) {
                this.callback('itemLastInCallback', evt, state, this.last);
                this.callback('itemLastOutCallback', evt, state, this.prevLast);
            }

            this.callback('itemVisibleInCallback', evt, state, this.first, this.last, this.prevFirst, this.prevLast);
            this.callback('itemVisibleOutCallback', evt, state, this.prevFirst, this.prevLast, this.first, this.last);
        },

        callback: function(cb, evt, state, i1, i2, i3, i4) {
            if (this.options[cb] == undefined || (typeof this.options[cb] != 'object' && evt != 'onAfterAnimation'))
                return;

            var callback = typeof this.options[cb] == 'object' ? this.options[cb][evt] : this.options[cb];

            if (!$.isFunction(callback))
                return;

            var self = this;

            if (i1 === undefined)
                callback(self, state, evt);
            else if (i2 === undefined)
                this.get(i1).each(function() { callback(self, this, i1, state, evt); });
            else {
                for (var i = i1; i <= i2; i++)
                    if (i !== null && !(i >= i3 && i <= i4))
                        this.get(i).each(function() { callback(self, this, i, state, evt); });
            }
        },

        create: function(i) {
            return this.format('<li></li>', i);
        },

        format: function(e, i) {
            var e = $(e), split = e.get(0).className.split(' ');
            for (var j = 0; j < split.length; j++) {
                if (split[j].indexOf('jcarousel-') != -1) {
                    e.removeClass(split[j]);
                }
            }
            e.addClass(this.className('jcarousel-item')).addClass(this.className('jcarousel-item-' + i)).css({
                'float': (this.options.rtl ? 'right' : 'left'),
                'list-style': 'none'
            }).attr('jcarouselindex', i);
            return e;
        },

        className: function(c) {
            return c + ' ' + c + (!this.options.vertical ? '-horizontal' : '-vertical');
        },

        dimension: function(e, d) {
            var el = e.jquery != undefined ? e[0] : e;

            var old = !this.options.vertical ?
                (el.offsetWidth || $jc.intval(this.options.itemFallbackDimension)) + $jc.margin(el, 'marginLeft') + $jc.margin(el, 'marginRight') :
                (el.offsetHeight || $jc.intval(this.options.itemFallbackDimension)) + $jc.margin(el, 'marginTop') + $jc.margin(el, 'marginBottom');

            if (d == undefined || old == d)
                return old;

            var w = !this.options.vertical ?
                d - $jc.margin(el, 'marginLeft') - $jc.margin(el, 'marginRight') :
                d - $jc.margin(el, 'marginTop') - $jc.margin(el, 'marginBottom');

            $(el).css(this.wh, w + 'px');

            return this.dimension(el);
        },

        clipping: function() {
            return !this.options.vertical ?
                this.clip[0].offsetWidth - $jc.intval(this.clip.css('borderLeftWidth')) - $jc.intval(this.clip.css('borderRightWidth')) :
                this.clip[0].offsetHeight - $jc.intval(this.clip.css('borderTopWidth')) - $jc.intval(this.clip.css('borderBottomWidth'));
        },

        index: function(i, s) {
            if (s == undefined)
                s = this.options.size;

            return Math.round((((i-1) / s) - Math.floor((i-1) / s)) * s) + 1;
        }
    });

    $jc.extend({
        /**
         * Gets/Sets the global default configuration properties.
         *
         * @method defaults
         * @return {Object}
         * @param d {Object} A set of key/value pairs to set as configuration properties.
         */
        defaults: function(d) {
            return $.extend(defaults, d || {});
        },

        margin: function(e, p) {
            if (!e)
                return 0;

            var el = e.jquery != undefined ? e[0] : e;

            if (p == 'marginRight' && $.browser.safari) {
                var old = {'display': 'block', 'float': 'none', 'width': 'auto'}, oWidth, oWidth2;

                $.swap(el, old, function() { oWidth = el.offsetWidth; });

                old['marginRight'] = 0;
                $.swap(el, old, function() { oWidth2 = el.offsetWidth; });

                return oWidth2 - oWidth;
            }

            return $jc.intval($.css(el, p));
        },

        intval: function(v) {
            v = parseInt(v);
            return isNaN(v) ? 0 : v;
        }
    });

})(jQuery);


/*!
 * jQuery Cookie Plugin v1.4.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2006, 2014 Klaus Hartl
 * Released under the MIT license
 */
(function (factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // CommonJS
        factory(require('jquery'));
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function ($) {

    var pluses = /\+/g;

    function encode(s) {
        return config.raw ? s : encodeURIComponent(s);
    }

    function decode(s) {
        return config.raw ? s : decodeURIComponent(s);
    }

    function stringifyCookieValue(value) {
        return encode(config.json ? JSON.stringify(value) : String(value));
    }

    function parseCookieValue(s) {
        if (s.indexOf('"') === 0) {
            // This is a quoted cookie as according to RFC2068, unescape...
            s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
        }

        try {
            // Replace server-side written pluses with spaces.
            // If we can't decode the cookie, ignore it, it's unusable.
            // If we can't parse the cookie, ignore it, it's unusable.
            s = decodeURIComponent(s.replace(pluses, ' '));
            return config.json ? JSON.parse(s) : s;
        } catch(e) {}
    }

    function read(s, converter) {
        var value = config.raw ? s : parseCookieValue(s);
        return $.isFunction(converter) ? converter(value) : value;
    }

    var config = $.cookie = function (key, value, options) {

        // Write

        if (arguments.length > 1 && !$.isFunction(value)) {
            options = $.extend({}, config.defaults, options);

            if (typeof options.expires === 'number') {
                var days = options.expires, t = options.expires = new Date();
                t.setTime(+t + days * 864e+5);
            }

            return (document.cookie = [
                encode(key), '=', stringifyCookieValue(value),
                options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
                options.path    ? '; path=' + options.path : '',
                options.domain  ? '; domain=' + options.domain : '',
                options.secure  ? '; secure' : ''
            ].join(''));
        }

        // Read

        var result = key ? undefined : {};

        // To prevent the for loop in the first place assign an empty array
        // in case there are no cookies at all. Also prevents odd result when
        // calling $.cookie().
        var cookies = document.cookie ? document.cookie.split('; ') : [];

        for (var i = 0, l = cookies.length; i < l; i++) {
            var parts = cookies[i].split('=');
            var name = decode(parts.shift());
            var cookie = parts.join('=');

            if (key && key === name) {
                // If second argument (value) is a function it's a converter...
                result = read(cookie, value);
                break;
            }

            // Prevent storing a cookie that we couldn't decode.
            if (!key && (cookie = read(cookie)) !== undefined) {
                result[name] = cookie;
            }
        }

        return result;
    };

    config.defaults = {};

    $.removeCookie = function (key, options) {
        if ($.cookie(key) === undefined) {
            return false;
        }

        // Must not alter options, thus extending a fresh object...
        $.cookie(key, '', $.extend({}, options, { expires: -1 }));
        return !$.cookie(key);
    };

}));



(function( $, undefined ) {

$.ui = $.ui || {};

var horizontalPositions = /left|center|right/,
	horizontalDefault = "center",
	verticalPositions = /top|center|bottom/,
	verticalDefault = "center",
	_position = $.fn.position,
	_offset = $.fn.offset;

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var target = $( options.of ),
		collision = ( options.collision || "flip" ).split( " " ),
		offset = options.offset ? options.offset.split( " " ) : [ 0, 0 ],
		targetWidth,
		targetHeight,
		basePosition;

	if ( options.of.nodeType === 9 ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: 0, left: 0 };
	} else if ( options.of.scrollTo && options.of.document ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: target.scrollTop(), left: target.scrollLeft() };
	} else if ( options.of.preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
		targetWidth = targetHeight = 0;
		basePosition = { top: options.of.pageY, left: options.of.pageX };
	} else {
		targetWidth = target.outerWidth();
		targetHeight = target.outerHeight();
		basePosition = target.offset();
	}

	// force my and at to have valid horizontal and veritcal positions
	// if a value is missing or invalid, it will be converted to center 
	$.each( [ "my", "at" ], function() {
		var pos = ( options[this] || "" ).split( " " );
		if ( pos.length === 1) {
			pos = horizontalPositions.test( pos[0] ) ?
				pos.concat( [verticalDefault] ) :
				verticalPositions.test( pos[0] ) ?
					[ horizontalDefault ].concat( pos ) :
					[ horizontalDefault, verticalDefault ];
		}
		pos[ 0 ] = horizontalPositions.test( pos[0] ) ? pos[ 0 ] : horizontalDefault;
		pos[ 1 ] = verticalPositions.test( pos[1] ) ? pos[ 1 ] : verticalDefault;
		options[ this ] = pos;
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	// normalize offset option
	offset[ 0 ] = parseInt( offset[0], 10 ) || 0;
	if ( offset.length === 1 ) {
		offset[ 1 ] = offset[ 0 ];
	}
	offset[ 1 ] = parseInt( offset[1], 10 ) || 0;

	if ( options.at[0] === "right" ) {
		basePosition.left += targetWidth;
	} else if (options.at[0] === horizontalDefault ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[1] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[1] === verticalDefault ) {
		basePosition.top += targetHeight / 2;
	}

	basePosition.left += offset[ 0 ];
	basePosition.top += offset[ 1 ];

	return this.each(function() {
		var elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			position = $.extend( {}, basePosition );

		if ( options.my[0] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[0] === horizontalDefault ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[1] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[1] === verticalDefault ) {
			position.top -= elemHeight / 2;
		}

		// prevent fractions (see #5280)
		position.left = parseInt( position.left );
		position.top = parseInt( position.top );

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[i] ] ) {
				$.ui.position[ collision[i] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					offset: offset,
					my: options.my,
					at: options.at
				});
			}
		});

		if ( $.fn.bgiframe ) {
			elem.bgiframe();
		}
		elem.offset( $.extend( position, { using: options.using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var win = $( window ),
				over = position.left + data.elemWidth - win.width() - win.scrollLeft();
			position.left = over > 0 ? position.left - over : Math.max( 0, position.left );
		},
		top: function( position, data ) {
			var win = $( window ),
				over = position.top + data.elemHeight - win.height() - win.scrollTop();
			position.top = over > 0 ? position.top - over : Math.max( 0, position.top );
		}
	},

	flip: {
		left: function( position, data ) {
			if ( data.at[0] === "center" ) {
				return;
			}
			var win = $( window ),
				over = position.left + data.elemWidth - win.width() - win.scrollLeft(),
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				offset = -2 * data.offset[ 0 ];
			position.left += position.left < 0 ?
				myOffset + data.targetWidth + offset :
				over > 0 ?
					myOffset - data.targetWidth + offset :
					0;
		},
		top: function( position, data ) {
			if ( data.at[1] === "center" ) {
				return;
			}
			var win = $( window ),
				over = position.top + data.elemHeight - win.height() - win.scrollTop(),
				myOffset = data.my[ 1 ] === "top" ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					-data.targetHeight,
				offset = -2 * data.offset[ 1 ];
			position.top += position.top < 0 ?
				myOffset + data.targetHeight + offset :
				over > 0 ?
					myOffset + atOffset + offset :
					0;
		}
	}
};

// offset setter from jQuery 1.4
if ( !$.offset.setOffset ) {
	$.offset.setOffset = function( elem, options ) {
		// set position first, in-case top/left are set even on static elem
		if ( /static/.test( $.curCSS( elem, "position" ) ) ) {
			elem.style.position = "relative";
		}
		var curElem   = $( elem ),
			curOffset = curElem.offset(),
			curTop    = parseInt( $.curCSS( elem, "top",  true ), 10 ) || 0,
			curLeft   = parseInt( $.curCSS( elem, "left", true ), 10)  || 0,
			props     = {
				top:  (options.top  - curOffset.top)  + curTop,
				left: (options.left - curOffset.left) + curLeft
			};
		
		if ( 'using' in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	};

	$.fn.offset = function( options ) {
		var elem = this[ 0 ];
		if ( !elem || !elem.ownerDocument ) { return null; }
		if ( options ) { 
			return this.each(function() {
				$.offset.setOffset( this, options );
			});
		}
		return _offset.call( this );
	};
}

}( jQuery ));


(function($) {
 
  $.fn.tweet = function(o){
    var s = {
      username: ["seaofclouds"],              // [string]   required, unless you want to display our tweets. :) it can be an array, just do ["username1","username2","etc"]
      list: null,                             //[string]   optional name of list belonging to username
      avatar_size: null,                      // [integer]  height and width of avatar if displayed (48px max)
      tweets: 9,                              // [integer]  how many tweets to display?
      intro_text: null,                       // [string]   do you want text BEFORE your your tweets?
      outro_text: null,                       // [string]   do you want text AFTER your tweets?
      join_text:  null,                       // [string]   optional text in between date and tweet, try setting to "auto"
      auto_join_text_default: "i said,",      // [string]   auto text for non verb: "i said" bullocks
      auto_join_text_ed: "i",                 // [string]   auto text for past tense: "i" surfed
      auto_join_text_ing: "i am",             // [string]   auto tense for present tense: "i was" surfing
      auto_join_text_reply: "i replied to",   // [string]   auto tense for replies: "i replied to" @someone "with"
      auto_join_text_url: "i was looking at", // [string]   auto tense for urls: "i was looking at" http:...
      loading_text: null,                     // [string]   optional loading text, displayed while tweets load
      query: null                             // [string]   optional search query
    };
    
    if(o) $.extend(s, o);
    
    $.fn.extend({
      linkUrl: function() {
        var returning = [];
        var regexp = /((ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?)/gi;
        this.each(function() {
          returning.push(this.replace(regexp,"<a href=\"$1\">$1</a>"));
        });
        return $(returning);
      },
      linkUser: function() {
        var returning = [];
        var regexp = /[\@]+([A-Za-z0-9-_]+)/gi;
        this.each(function() {
          returning.push(this.replace(regexp,"<a href=\"http://twitter.com/$1\">@$1</a>"));
        });
        return $(returning);
      },
      linkHash: function() {
        var returning = [];
        var regexp = /(?:^| )[\#]+([A-Za-z0-9-_]+)/gi;
        this.each(function() {
          returning.push(this.replace(regexp, ' <a href="http://search.twitter.com/search?q=&tag=$1&lang=all&from='+s.username.join("%2BOR%2B")+'">#$1</a>'));
        });
        return $(returning);
      },
      capAwesome: function() {
        var returning = [];
        this.each(function() {
          returning.push(this.replace(/\b(awesome)\b/gi, '<span class="awesome">$1</span>'));
        });
        return $(returning);
      },
      capEpic: function() {
        var returning = [];
        this.each(function() {
          returning.push(this.replace(/\b(epic)\b/gi, '<span class="epic">$1</span>'));
        });
        return $(returning);
      },
      makeHeart: function() {
        var returning = [];
        this.each(function() {
          returning.push(this.replace(/(&lt;)+[3]/gi, "<tt class='heart'>&#x2665;</tt>"));
        });
        return $(returning);
      }
    });

    function parse_date(date_str) {
      // The non-search twitter APIs return inconsistently-formatted dates, which Date.parse
      // cannot handle in IE. We therefore perform the following transformation:
      // "Wed Apr 29 08:53:31 +0000 2009" => "Wed, Apr 29 2009 08:53:31 +0000"
      return Date.parse(date_str.replace(/^([a-z]{3})( [a-z]{3} \d\d?)(.*)( \d{4})$/i, '$1,$2$4$3'));
    }

    function relative_time(time_value) {
      var parsed_date = parse_date(time_value);
      var relative_to = (arguments.length > 1) ? arguments[1] : new Date();
      var delta = parseInt((relative_to.getTime() - parsed_date) / 1000);
      var r = '';
      if (delta < 60) {
	r = delta + ' seconds ago';
      } else if(delta < 120) {
	r = 'a minute ago';
      } else if(delta < (45*60)) {
	r = (parseInt(delta / 60, 10)).toString() + ' minutes ago';
      } else if(delta < (2*60*60)) {
	r = 'an hour ago';
      } else if(delta < (24*60*60)) {
	r = '' + (parseInt(delta / 3600, 10)).toString() + ' hours ago';
      } else if(delta < (48*60*60)) {
	r = 'a day ago';
      } else {
	r = (parseInt(delta / 86400, 10)).toString() + ' days ago';
      }
      return 'about ' + r;
    }

    function build_url() {
      var proto = ('https:' == document.location.protocol ? 'https:' : 'http:');
      if (s.list) {
        return proto+"//api.twitter.com/1/"+s.username[0]+"/lists/"+s.list+"/statuses.json?per_page="+s.tweets+"&callback=?";
      } else if (s.query == null && s.username.length == 1) {
        return proto+'//api.twitter.com/1/statuses/user_timeline.json?screen_name='+s.username[0]+'&count='+s.tweets+'&include_rts=1&callback=?';
      } else {
        var query = (s.query || 'from:'+s.username.join(' OR from:'));
        return proto+'//search.twitter.com/search.json?&q='+encodeURIComponent(query)+'&rpp='+s.tweets+'&callback=?';
      }
    }

    return this.each(function(i, widget){
      //var list = $('<ul class="tweet_list">').appendTo(widget);
      var intro = '<p class="tweet_intro">'+s.intro_text+'</p>';
      var outro = '<p class="tweet_outro">'+s.outro_text+'</p>';
      var loading = $('<p class="loading">'+s.loading_text+'</p>');

      if(typeof(s.username) == "string"){
        s.username = [s.username];
      }

      if (s.loading_text) $(widget).append(loading);
      $.getJSON(build_url(), function(data){
        if (s.loading_text) loading.remove();
        if (s.intro_text) widget.before(intro);
        var tweets = (data.results || data);
        $.each(tweets, function(i,item){
          // auto join text based on verb tense and content
          if (s.join_text == "auto") {
            if (item.text.match(/^(@([A-Za-z0-9-_]+)) .*/i)) {
              var join_text = s.auto_join_text_reply;
            } else if (item.text.match(/(^\w+:\/\/[A-Za-z0-9-_]+\.[A-Za-z0-9-_:%&\?\/.=]+) .*/i)) {
              var join_text = s.auto_join_text_url;
            } else if (item.text.match(/^((\w+ed)|just) .*/im)) {
              var join_text = s.auto_join_text_ed;
            } else if (item.text.match(/^(\w*ing) .*/i)) {
              var join_text = s.auto_join_text_ing;
            } else {
              var join_text = s.auto_join_text_default;
            }
          } else {
            var join_text = s.join_text;
          };

          var from_user = item.from_user || item.user.screen_name;
          var profile_image_url = item.profile_image_url || item.user.profile_image_url;
          var join_template = '<span class="tweet_join"> '+join_text+' </span>';
          var join = ((s.join_text) ? join_template : ' ');
          var avatar_template = '<a class="tweet_avatar" href="http://twitter.com/'+from_user+'"><img src="'+profile_image_url+'" height="'+s.avatar_size+'" width="'+s.avatar_size+'" alt="'+from_user+'\'s avatar" title="'+from_user+'\'s avatar" border="0"/></a>';
          var avatar = (s.avatar_size ? avatar_template : '');
          var date = '<span class="tweet_time"><a href="http://twitter.com/'+from_user+'/statuses/'+item.id+'" title="view tweet on twitter">'+relative_time(item.created_at)+'</a></span>';
          var text = '<span class="tweet_text">' +$([item.text]).linkUrl().linkUser().linkHash().makeHeart().capAwesome().capEpic()[0]+ '</span>';

          // until we create a template option, arrange the items below to alter a tweet's display.
          $(widget).append('<li>' + avatar + date + join + text + '</li>');

          $(widget).children('li:first').addClass('tweet_first');
          $(widget).children('li:odd').addClass('tweet_even');
          $(widget).children('li:even').addClass('tweet_odd');
        });
        if (s.outro_text) widget.after(outro);
        $(widget).trigger("loaded").trigger((tweets.length == 0 ? "empty" : "full"));
        
        s.success();
      });

    });
  };
})(jQuery);


/*!
 * jScrollPane - v2.0.0beta11 - 2011-07-04
 * http://jscrollpane.kelvinluck.com/
 *
 * Copyright (c) 2010 Kelvin Luck
 * Dual licensed under the MIT and GPL licenses.
 */

// Script: jScrollPane - cross browser customisable scrollbars
//
// *Version: 2.0.0beta11, Last updated: 2011-07-04*
//
// Project Home - http://jscrollpane.kelvinluck.com/
// GitHub       - http://github.com/vitch/jScrollPane
// Source       - http://github.com/vitch/jScrollPane/raw/master/script/jquery.jscrollpane.js
// (Minified)   - http://github.com/vitch/jScrollPane/raw/master/script/jquery.jscrollpane.min.js
//
// About: License
//
// Copyright (c) 2011 Kelvin Luck
// Dual licensed under the MIT or GPL Version 2 licenses.
// http://jscrollpane.kelvinluck.com/MIT-LICENSE.txt
// http://jscrollpane.kelvinluck.com/GPL-LICENSE.txt
//
// About: Examples
//
// All examples and demos are available through the jScrollPane example site at:
// http://jscrollpane.kelvinluck.com/
//
// About: Support and Testing
//
// This plugin is tested on the browsers below and has been found to work reliably on them. If you run
// into a problem on one of the supported browsers then please visit the support section on the jScrollPane
// website (http://jscrollpane.kelvinluck.com/) for more information on getting support. You are also
// welcome to fork the project on GitHub if you can contribute a fix for a given issue. 
//
// jQuery Versions - tested in 1.4.2+ - reported to work in 1.3.x
// Browsers Tested - Firefox 3.6.8, Safari 5, Opera 10.6, Chrome 5.0, IE 6, 7, 8
//
// About: Release History
//
// 2.0.0beta11 - (in progress) 
// 2.0.0beta10 - (2011-04-17) cleaner required size calculation, improved keyboard support, stickToBottom/Left, other small fixes
// 2.0.0beta9 - (2011-01-31) new API methods, bug fixes and correct keyboard support for FF/OSX
// 2.0.0beta8 - (2011-01-29) touchscreen support, improved keyboard support
// 2.0.0beta7 - (2011-01-23) scroll speed consistent (thanks Aivo Paas)
// 2.0.0beta6 - (2010-12-07) scrollToElement horizontal support
// 2.0.0beta5 - (2010-10-18) jQuery 1.4.3 support, various bug fixes
// 2.0.0beta4 - (2010-09-17) clickOnTrack support, bug fixes
// 2.0.0beta3 - (2010-08-27) Horizontal mousewheel, mwheelIntent, keyboard support, bug fixes
// 2.0.0beta2 - (2010-08-21) Bug fixes
// 2.0.0beta1 - (2010-08-17) Rewrite to follow modern best practices and enable horizontal scrolling, initially hidden
//							 elements and dynamically sized elements.
// 1.x - (2006-12-31 - 2010-07-31) Initial version, hosted at googlecode, deprecated

(function($,window,undefined){

	$.fn.jScrollPane = function(settings)
	{
		// JScrollPane "class" - public methods are available through $('selector').data('jsp')
		function JScrollPane(elem, s)
		{
			var settings, jsp = this, pane, paneWidth, paneHeight, container, contentWidth, contentHeight,
				percentInViewH, percentInViewV, isScrollableV, isScrollableH, verticalDrag, dragMaxY,
				verticalDragPosition, horizontalDrag, dragMaxX, horizontalDragPosition,
				verticalBar, verticalTrack, scrollbarWidth, verticalTrackHeight, verticalDragHeight, arrowUp, arrowDown,
				horizontalBar, horizontalTrack, horizontalTrackWidth, horizontalDragWidth, arrowLeft, arrowRight,
				reinitialiseInterval, originalPadding, originalPaddingTotalWidth, previousContentWidth,
				wasAtTop = true, wasAtLeft = true, wasAtBottom = false, wasAtRight = false,
				originalElement = elem.clone(false, false).empty(),
				mwEvent = $.fn.mwheelIntent ? 'mwheelIntent.jsp' : 'mousewheel.jsp';

			originalPadding = elem.css('paddingTop') + ' ' +
								elem.css('paddingRight') + ' ' +
								elem.css('paddingBottom') + ' ' +
								elem.css('paddingLeft');
			originalPaddingTotalWidth = (parseInt(elem.css('paddingLeft'), 10) || 0) +
										(parseInt(elem.css('paddingRight'), 10) || 0);

			function initialise(s)
			{

				var /*firstChild, lastChild, */isMaintainingPositon, lastContentX, lastContentY,
						hasContainingSpaceChanged, originalScrollTop, originalScrollLeft,
						maintainAtBottom = false, maintainAtRight = false;

				settings = s;

				if (pane === undefined) {
					originalScrollTop = elem.scrollTop();
					originalScrollLeft = elem.scrollLeft();

					elem.css(
						{
							overflow: 'hidden',
							padding: 0
						}
					);
					// TODO: Deal with where width/ height is 0 as it probably means the element is hidden and we should
					// come back to it later and check once it is unhidden...
					paneWidth = elem.innerWidth() + originalPaddingTotalWidth;
					paneHeight = elem.innerHeight();

					elem.width(paneWidth);
					
					pane = $('<div class="jspPane" />').css('padding', originalPadding).append(elem.children());
					container = $('<div class="jspContainer" />')
						.css({
							'width': paneWidth + 'px',
							'height': paneHeight + 'px'
						}
					).append(pane).appendTo(elem);

					/*
					// Move any margins from the first and last children up to the container so they can still
					// collapse with neighbouring elements as they would before jScrollPane 
					firstChild = pane.find(':first-child');
					lastChild = pane.find(':last-child');
					elem.css(
						{
							'margin-top': firstChild.css('margin-top'),
							'margin-bottom': lastChild.css('margin-bottom')
						}
					);
					firstChild.css('margin-top', 0);
					lastChild.css('margin-bottom', 0);
					*/
				} else {
					elem.css('width', '');

					maintainAtBottom = settings.stickToBottom && isCloseToBottom();
					maintainAtRight  = settings.stickToRight  && isCloseToRight();

					hasContainingSpaceChanged = elem.innerWidth() + originalPaddingTotalWidth != paneWidth || elem.outerHeight() != paneHeight;

					if (hasContainingSpaceChanged) {
						paneWidth = elem.innerWidth() + originalPaddingTotalWidth;
						paneHeight = elem.innerHeight();
						container.css({
							width: paneWidth + 'px',
							height: paneHeight + 'px'
						});
					}

					// If nothing changed since last check...
					if (!hasContainingSpaceChanged && previousContentWidth == contentWidth && pane.outerHeight() == contentHeight) {
						elem.width(paneWidth);
						return;
					}
					previousContentWidth = contentWidth;
					
					pane.css('width', '');
					elem.width(paneWidth);

					container.find('>.jspVerticalBar,>.jspHorizontalBar').remove().end();
				}

				pane.css('overflow', 'auto');
				if (s.contentWidth) {
					contentWidth = s.contentWidth;
				} else {
					contentWidth = pane[0].scrollWidth;
				}
				contentHeight = pane[0].scrollHeight;
				pane.css('overflow', '');

				percentInViewH = contentWidth / paneWidth;
				percentInViewV = contentHeight / paneHeight;
				isScrollableV = percentInViewV > 1;

				isScrollableH = percentInViewH > 1;

				//console.log(paneWidth, paneHeight, contentWidth, contentHeight, percentInViewH, percentInViewV, isScrollableH, isScrollableV);

				if (!(isScrollableH || isScrollableV)) {
					elem.removeClass('jspScrollable');
					pane.css({
						top: 0,
						width: container.width() - originalPaddingTotalWidth
					});
					removeMousewheel();
					removeFocusHandler();
					removeKeyboardNav();
					removeClickOnTrack();
					unhijackInternalLinks();
				} else {
					elem.addClass('jspScrollable');

					isMaintainingPositon = settings.maintainPosition && (verticalDragPosition || horizontalDragPosition);
					if (isMaintainingPositon) {
						lastContentX = contentPositionX();
						lastContentY = contentPositionY();
					}

					initialiseVerticalScroll();
					initialiseHorizontalScroll();
					resizeScrollbars();

					if (isMaintainingPositon) {
						scrollToX(maintainAtRight  ? (contentWidth  - paneWidth ) : lastContentX, false);
						scrollToY(maintainAtBottom ? (contentHeight - paneHeight) : lastContentY, false);
					}

					initFocusHandler();
					initMousewheel();
					initTouch();
					
					if (settings.enableKeyboardNavigation) {
						initKeyboardNav();
					}
					if (settings.clickOnTrack) {
						initClickOnTrack();
					}
					
					observeHash();
					if (settings.hijackInternalLinks) {
						hijackInternalLinks();
					}
				}

				if (settings.autoReinitialise && !reinitialiseInterval) {
					reinitialiseInterval = setInterval(
						function()
						{
							initialise(settings);
						},
						settings.autoReinitialiseDelay
					);
				} else if (!settings.autoReinitialise && reinitialiseInterval) {
					clearInterval(reinitialiseInterval);
				}

				originalScrollTop && elem.scrollTop(0) && scrollToY(originalScrollTop, false);
				originalScrollLeft && elem.scrollLeft(0) && scrollToX(originalScrollLeft, false);

				elem.trigger('jsp-initialised', [isScrollableH || isScrollableV]);
			}

			function initialiseVerticalScroll()
			{
				if (isScrollableV) {

					container.append(
						$('<div class="jspVerticalBar" />').append(
							$('<div class="jspCap jspCapTop" />'),
							$('<div class="jspTrack" />').append(
								$('<div class="jspDrag" />').append(
									$('<div class="jspDragTop" />'),
									$('<div class="jspDragBottom" />')
								)
							),
							$('<div class="jspCap jspCapBottom" />')
						)
					);

					verticalBar = container.find('>.jspVerticalBar');
					verticalTrack = verticalBar.find('>.jspTrack');
					verticalDrag = verticalTrack.find('>.jspDrag');

					if (settings.showArrows) {
						arrowUp = $('<a class="jspArrow jspArrowUp" />').bind(
							'mousedown.jsp', getArrowScroll(0, -1)
						).bind('click.jsp', nil);
						arrowDown = $('<a class="jspArrow jspArrowDown" />').bind(
							'mousedown.jsp', getArrowScroll(0, 1)
						).bind('click.jsp', nil);
						if (settings.arrowScrollOnHover) {
							arrowUp.bind('mouseover.jsp', getArrowScroll(0, -1, arrowUp));
							arrowDown.bind('mouseover.jsp', getArrowScroll(0, 1, arrowDown));
						}

						appendArrows(verticalTrack, settings.verticalArrowPositions, arrowUp, arrowDown);
					}

					verticalTrackHeight = paneHeight;
					container.find('>.jspVerticalBar>.jspCap:visible,>.jspVerticalBar>.jspArrow').each(
						function()
						{
							verticalTrackHeight -= $(this).outerHeight();
						}
					);


					verticalDrag.hover(
						function()
						{
							verticalDrag.addClass('jspHover');
						},
						function()
						{
							verticalDrag.removeClass('jspHover');
						}
					).bind(
						'mousedown.jsp',
						function(e)
						{
							// Stop IE from allowing text selection
							$('html').bind('dragstart.jsp selectstart.jsp', nil);

							verticalDrag.addClass('jspActive');

							var startY = e.pageY - verticalDrag.position().top;

							$('html').bind(
								'mousemove.jsp',
								function(e)
								{
									positionDragY(e.pageY - startY, false);
								}
							).bind('mouseup.jsp mouseleave.jsp', cancelDrag);
							return false;
						}
					);
					sizeVerticalScrollbar();
				}
			}

			function sizeVerticalScrollbar()
			{
				verticalTrack.height(verticalTrackHeight + 'px');
				verticalDragPosition = 0;
				scrollbarWidth = settings.verticalGutter + verticalTrack.outerWidth();

				// Make the pane thinner to allow for the vertical scrollbar
				pane.width(paneWidth - scrollbarWidth - originalPaddingTotalWidth);

				// Add margin to the left of the pane if scrollbars are on that side (to position
				// the scrollbar on the left or right set it's left or right property in CSS)
				try {
					if (verticalBar.position().left === 0) {
						pane.css('margin-left', scrollbarWidth + 'px');
					}
				} catch (err) {
				}
			}

			function initialiseHorizontalScroll()
			{
				if (isScrollableH) {

					container.append(
						$('<div class="jspHorizontalBar" />').append(
							$('<div class="jspCap jspCapLeft" />'),
							$('<div class="jspTrack" />').append(
								$('<div class="jspDrag" />').append(
									$('<div class="jspDragLeft" />'),
									$('<div class="jspDragRight" />')
								)
							),
							$('<div class="jspCap jspCapRight" />')
						)
					);

					horizontalBar = container.find('>.jspHorizontalBar');
					horizontalTrack = horizontalBar.find('>.jspTrack');
					horizontalDrag = horizontalTrack.find('>.jspDrag');

					if (settings.showArrows) {
						arrowLeft = $('<a class="jspArrow jspArrowLeft" />').bind(
							'mousedown.jsp', getArrowScroll(-1, 0)
						).bind('click.jsp', nil);
						arrowRight = $('<a class="jspArrow jspArrowRight" />').bind(
							'mousedown.jsp', getArrowScroll(1, 0)
						).bind('click.jsp', nil);
						if (settings.arrowScrollOnHover) {
							arrowLeft.bind('mouseover.jsp', getArrowScroll(-1, 0, arrowLeft));
							arrowRight.bind('mouseover.jsp', getArrowScroll(1, 0, arrowRight));
						}
						appendArrows(horizontalTrack, settings.horizontalArrowPositions, arrowLeft, arrowRight);
					}

					horizontalDrag.hover(
						function()
						{
							horizontalDrag.addClass('jspHover');
						},
						function()
						{
							horizontalDrag.removeClass('jspHover');
						}
					).bind(
						'mousedown.jsp',
						function(e)
						{
							// Stop IE from allowing text selection
							$('html').bind('dragstart.jsp selectstart.jsp', nil);

							horizontalDrag.addClass('jspActive');

							var startX = e.pageX - horizontalDrag.position().left;

							$('html').bind(
								'mousemove.jsp',
								function(e)
								{
									positionDragX(e.pageX - startX, false);
								}
							).bind('mouseup.jsp mouseleave.jsp', cancelDrag);
							return false;
						}
					);
					horizontalTrackWidth = container.innerWidth();
					sizeHorizontalScrollbar();
				}
			}

			function sizeHorizontalScrollbar()
			{
				container.find('>.jspHorizontalBar>.jspCap:visible,>.jspHorizontalBar>.jspArrow').each(
					function()
					{
						horizontalTrackWidth -= $(this).outerWidth();
					}
				);

				horizontalTrack.width(horizontalTrackWidth + 'px');
				horizontalDragPosition = 0;
			}

			function resizeScrollbars()
			{
				if (isScrollableH && isScrollableV) {
					var horizontalTrackHeight = horizontalTrack.outerHeight(),
						verticalTrackWidth = verticalTrack.outerWidth();
					verticalTrackHeight -= horizontalTrackHeight;
					$(horizontalBar).find('>.jspCap:visible,>.jspArrow').each(
						function()
						{
							horizontalTrackWidth += $(this).outerWidth();
						}
					);
					horizontalTrackWidth -= verticalTrackWidth;
					paneHeight -= verticalTrackWidth;
					paneWidth -= horizontalTrackHeight;
					horizontalTrack.parent().append(
						$('<div class="jspCorner" />').css('width', horizontalTrackHeight + 'px')
					);
					sizeVerticalScrollbar();
					sizeHorizontalScrollbar();
				}
				// reflow content
				if (isScrollableH) {
					pane.width((container.outerWidth() - originalPaddingTotalWidth) + 'px');
				}
				contentHeight = pane.outerHeight();
				percentInViewV = contentHeight / paneHeight;

				if (isScrollableH) {
					horizontalDragWidth = Math.ceil(1 / percentInViewH * horizontalTrackWidth);
					if (horizontalDragWidth > settings.horizontalDragMaxWidth) {
						horizontalDragWidth = settings.horizontalDragMaxWidth;
					} else if (horizontalDragWidth < settings.horizontalDragMinWidth) {
						horizontalDragWidth = settings.horizontalDragMinWidth;
					}
					horizontalDrag.width(horizontalDragWidth + 'px');
					dragMaxX = horizontalTrackWidth - horizontalDragWidth;
					_positionDragX(horizontalDragPosition); // To update the state for the arrow buttons
				}
				if (isScrollableV) {
					verticalDragHeight = Math.ceil(1 / percentInViewV * verticalTrackHeight);
					if (verticalDragHeight > settings.verticalDragMaxHeight) {
						verticalDragHeight = settings.verticalDragMaxHeight;
					} else if (verticalDragHeight < settings.verticalDragMinHeight) {
						verticalDragHeight = settings.verticalDragMinHeight;
					}
					verticalDrag.height(verticalDragHeight + 'px');
					dragMaxY = verticalTrackHeight - verticalDragHeight;
					_positionDragY(verticalDragPosition); // To update the state for the arrow buttons
				}
			}

			function appendArrows(ele, p, a1, a2)
			{
				var p1 = "before", p2 = "after", aTemp;
				
				// Sniff for mac... Is there a better way to determine whether the arrows would naturally appear
				// at the top or the bottom of the bar?
				if (p == "os") {
					p = /Mac/.test(navigator.platform) ? "after" : "split";
				}
				if (p == p1) {
					p2 = p;
				} else if (p == p2) {
					p1 = p;
					aTemp = a1;
					a1 = a2;
					a2 = aTemp;
				}

				ele[p1](a1)[p2](a2);
			}

			function getArrowScroll(dirX, dirY, ele)
			{
				return function()
				{
					arrowScroll(dirX, dirY, this, ele);
					this.blur();
					return false;
				};
			}

			function arrowScroll(dirX, dirY, arrow, ele)
			{
				arrow = $(arrow).addClass('jspActive');

				var eve,
					scrollTimeout,
					isFirst = true,
					doScroll = function()
					{
						if (dirX !== 0) {
							jsp.scrollByX(dirX * settings.arrowButtonSpeed);
						}
						if (dirY !== 0) {
							jsp.scrollByY(dirY * settings.arrowButtonSpeed);
						}
						scrollTimeout = setTimeout(doScroll, isFirst ? settings.initialDelay : settings.arrowRepeatFreq);
						isFirst = false;
					};

				doScroll();

				eve = ele ? 'mouseout.jsp' : 'mouseup.jsp';
				ele = ele || $('html');
				ele.bind(
					eve,
					function()
					{
						arrow.removeClass('jspActive');
						scrollTimeout && clearTimeout(scrollTimeout);
						scrollTimeout = null;
						ele.unbind(eve);
					}
				);
			}

			function initClickOnTrack()
			{
				removeClickOnTrack();
				if (isScrollableV) {
					verticalTrack.bind(
						'mousedown.jsp',
						function(e)
						{
							if (e.originalTarget === undefined || e.originalTarget == e.currentTarget) {
								var clickedTrack = $(this),
									offset = clickedTrack.offset(),
									direction = e.pageY - offset.top - verticalDragPosition,
									scrollTimeout,
									isFirst = true,
									doScroll = function()
									{
										var offset = clickedTrack.offset(),
											pos = e.pageY - offset.top - verticalDragHeight / 2,
											contentDragY = paneHeight * settings.scrollPagePercent,
											dragY = dragMaxY * contentDragY / (contentHeight - paneHeight);
										if (direction < 0) {
											if (verticalDragPosition - dragY > pos) {
												jsp.scrollByY(-contentDragY);
											} else {
												positionDragY(pos);
											}
										} else if (direction > 0) {
											if (verticalDragPosition + dragY < pos) {
												jsp.scrollByY(contentDragY);
											} else {
												positionDragY(pos);
											}
										} else {
											cancelClick();
											return;
										}
										scrollTimeout = setTimeout(doScroll, isFirst ? settings.initialDelay : settings.trackClickRepeatFreq);
										isFirst = false;
									},
									cancelClick = function()
									{
										scrollTimeout && clearTimeout(scrollTimeout);
										scrollTimeout = null;
										$(document).unbind('mouseup.jsp', cancelClick);
									};
								doScroll();
								$(document).bind('mouseup.jsp', cancelClick);
								return false;
							}
						}
					);
				}
				
				if (isScrollableH) {
					horizontalTrack.bind(
						'mousedown.jsp',
						function(e)
						{
							if (e.originalTarget === undefined || e.originalTarget == e.currentTarget) {
								var clickedTrack = $(this),
									offset = clickedTrack.offset(),
									direction = e.pageX - offset.left - horizontalDragPosition,
									scrollTimeout,
									isFirst = true,
									doScroll = function()
									{
										var offset = clickedTrack.offset(),
											pos = e.pageX - offset.left - horizontalDragWidth / 2,
											contentDragX = paneWidth * settings.scrollPagePercent,
											dragX = dragMaxX * contentDragX / (contentWidth - paneWidth);
										if (direction < 0) {
											if (horizontalDragPosition - dragX > pos) {
												jsp.scrollByX(-contentDragX);
											} else {
												positionDragX(pos);
											}
										} else if (direction > 0) {
											if (horizontalDragPosition + dragX < pos) {
												jsp.scrollByX(contentDragX);
											} else {
												positionDragX(pos);
											}
										} else {
											cancelClick();
											return;
										}
										scrollTimeout = setTimeout(doScroll, isFirst ? settings.initialDelay : settings.trackClickRepeatFreq);
										isFirst = false;
									},
									cancelClick = function()
									{
										scrollTimeout && clearTimeout(scrollTimeout);
										scrollTimeout = null;
										$(document).unbind('mouseup.jsp', cancelClick);
									};
								doScroll();
								$(document).bind('mouseup.jsp', cancelClick);
								return false;
							}
						}
					);
				}
			}

			function removeClickOnTrack()
			{
				if (horizontalTrack) {
					horizontalTrack.unbind('mousedown.jsp');
				}
				if (verticalTrack) {
					verticalTrack.unbind('mousedown.jsp');
				}
			}

			function cancelDrag()
			{
				$('html').unbind('dragstart.jsp selectstart.jsp mousemove.jsp mouseup.jsp mouseleave.jsp');

				if (verticalDrag) {
					verticalDrag.removeClass('jspActive');
				}
				if (horizontalDrag) {
					horizontalDrag.removeClass('jspActive');
				}
			}

			function positionDragY(destY, animate)
			{
				if (!isScrollableV) {
					return;
				}
				if (destY < 0) {
					destY = 0;
				} else if (destY > dragMaxY) {
					destY = dragMaxY;
				}

				// can't just check if(animate) because false is a valid value that could be passed in...
				if (animate === undefined) {
					animate = settings.animateScroll;
				}
				if (animate) {
					jsp.animate(verticalDrag, 'top', destY,	_positionDragY);
				} else {
					verticalDrag.css('top', destY);
					_positionDragY(destY);
				}

			}

			function _positionDragY(destY)
			{
				if (destY === undefined) {
					destY = verticalDrag.position().top;
				}

				container.scrollTop(0);
				verticalDragPosition = destY;

				var isAtTop = verticalDragPosition === 0,
					isAtBottom = verticalDragPosition == dragMaxY,
					percentScrolled = destY/ dragMaxY,
					destTop = -percentScrolled * (contentHeight - paneHeight);

				if (wasAtTop != isAtTop || wasAtBottom != isAtBottom) {
					wasAtTop = isAtTop;
					wasAtBottom = isAtBottom;
					elem.trigger('jsp-arrow-change', [wasAtTop, wasAtBottom, wasAtLeft, wasAtRight]);
				}
				
				updateVerticalArrows(isAtTop, isAtBottom);
				pane.css('top', destTop);
				elem.trigger('jsp-scroll-y', [-destTop, isAtTop, isAtBottom]).trigger('scroll');
			}

			function positionDragX(destX, animate)
			{
				if (!isScrollableH) {
					return;
				}
				if (destX < 0) {
					destX = 0;
				} else if (destX > dragMaxX) {
					destX = dragMaxX;
				}

				if (animate === undefined) {
					animate = settings.animateScroll;
				}
				if (animate) {
					jsp.animate(horizontalDrag, 'left', destX,	_positionDragX);
				} else {
					horizontalDrag.css('left', destX);
					_positionDragX(destX);
				}
			}

			function _positionDragX(destX)
			{
				if (destX === undefined) {
					destX = horizontalDrag.position().left;
				}

				container.scrollTop(0);
				horizontalDragPosition = destX;

				var isAtLeft = horizontalDragPosition === 0,
					isAtRight = horizontalDragPosition == dragMaxX,
					percentScrolled = destX / dragMaxX,
					destLeft = -percentScrolled * (contentWidth - paneWidth);

				if (wasAtLeft != isAtLeft || wasAtRight != isAtRight) {
					wasAtLeft = isAtLeft;
					wasAtRight = isAtRight;
					elem.trigger('jsp-arrow-change', [wasAtTop, wasAtBottom, wasAtLeft, wasAtRight]);
				}
				
				updateHorizontalArrows(isAtLeft, isAtRight);
				pane.css('left', destLeft);
				elem.trigger('jsp-scroll-x', [-destLeft, isAtLeft, isAtRight]).trigger('scroll');
			}

			function updateVerticalArrows(isAtTop, isAtBottom)
			{
				if (settings.showArrows) {
					arrowUp[isAtTop ? 'addClass' : 'removeClass']('jspDisabled');
					arrowDown[isAtBottom ? 'addClass' : 'removeClass']('jspDisabled');
				}
			}

			function updateHorizontalArrows(isAtLeft, isAtRight)
			{
				if (settings.showArrows) {
					arrowLeft[isAtLeft ? 'addClass' : 'removeClass']('jspDisabled');
					arrowRight[isAtRight ? 'addClass' : 'removeClass']('jspDisabled');
				}
			}

			function scrollToY(destY, animate)
			{
				var percentScrolled = destY / (contentHeight - paneHeight);
				positionDragY(percentScrolled * dragMaxY, animate);
			}

			function scrollToX(destX, animate)
			{
				var percentScrolled = destX / (contentWidth - paneWidth);
				positionDragX(percentScrolled * dragMaxX, animate);
			}

			function scrollToElement(ele, stickToTop, animate)
			{
				var e, eleHeight, eleWidth, eleTop = 0, eleLeft = 0, viewportTop, viewportLeft, maxVisibleEleTop, maxVisibleEleLeft, destY, destX;

				// Legal hash values aren't necessarily legal jQuery selectors so we need to catch any
				// errors from the lookup...
				try {
					e = $(ele);
				} catch (err) {
					return;
				}
				eleHeight = e.outerHeight();
				eleWidth= e.outerWidth();

				container.scrollTop(0);
				container.scrollLeft(0);
				
				// loop through parents adding the offset top of any elements that are relatively positioned between
				// the focused element and the jspPane so we can get the true distance from the top
				// of the focused element to the top of the scrollpane...
				while (!e.is('.jspPane')) {
					eleTop += e.position().top;
					eleLeft += e.position().left;
					e = e.offsetParent();
					if (/^body|html$/i.test(e[0].nodeName)) {
						// we ended up too high in the document structure. Quit!
						return;
					}
				}

				viewportTop = contentPositionY();
				maxVisibleEleTop = viewportTop + paneHeight;
				if (eleTop < viewportTop || stickToTop) { // element is above viewport
					destY = eleTop - settings.verticalGutter;
				} else if (eleTop + eleHeight > maxVisibleEleTop) { // element is below viewport
					destY = eleTop - paneHeight + eleHeight + settings.verticalGutter;
				}
				if (destY) {
					scrollToY(destY, animate);
				}
				
				viewportLeft = contentPositionX();
	            maxVisibleEleLeft = viewportLeft + paneWidth;
	            if (eleLeft < viewportLeft || stickToTop) { // element is to the left of viewport
	                destX = eleLeft - settings.horizontalGutter;
	            } else if (eleLeft + eleWidth > maxVisibleEleLeft) { // element is to the right viewport
	                destX = eleLeft - paneWidth + eleWidth + settings.horizontalGutter;
	            }
	            if (destX) {
	                scrollToX(destX, animate);
	            }

			}

			function contentPositionX()
			{
				return -pane.position().left;
			}

			function contentPositionY()
			{
				return -pane.position().top;
			}

			function isCloseToBottom()
			{
				var scrollableHeight = contentHeight - paneHeight;
				return (scrollableHeight > 20) && (scrollableHeight - contentPositionY() < 10);
			}

			function isCloseToRight()
			{
				var scrollableWidth = contentWidth - paneWidth;
				return (scrollableWidth > 20) && (scrollableWidth - contentPositionX() < 10);
			}

			function initMousewheel()
			{
				container.unbind(mwEvent).bind(
					mwEvent,
					function (event, delta, deltaX, deltaY) {
						var dX = horizontalDragPosition, dY = verticalDragPosition;
						jsp.scrollBy(deltaX * settings.mouseWheelSpeed, -deltaY * settings.mouseWheelSpeed, false);
						// return true if there was no movement so rest of screen can scroll
						return dX == horizontalDragPosition && dY == verticalDragPosition;
					}
				);
			}

			function removeMousewheel()
			{
				container.unbind(mwEvent);
			}

			function nil()
			{
				return false;
			}

			function initFocusHandler()
			{
				pane.find(':input,a').unbind('focus.jsp').bind(
					'focus.jsp',
					function(e)
					{
						scrollToElement(e.target, false);
					}
				);
			}

			function removeFocusHandler()
			{
				pane.find(':input,a').unbind('focus.jsp');
			}
			
			function initKeyboardNav()
			{
				var keyDown, elementHasScrolled, validParents = [];
				isScrollableH && validParents.push(horizontalBar[0]);
				isScrollableV && validParents.push(verticalBar[0]);
				
				// IE also focuses elements that don't have tabindex set.
				pane.focus(
					function()
					{
						elem.focus();
					}
				);
				
				elem.attr('tabindex', 0)
					.unbind('keydown.jsp keypress.jsp')
					.bind(
						'keydown.jsp',
						function(e)
						{
							if (e.target !== this && !(validParents.length && $(e.target).closest(validParents).length)){
								return;
							}
							var dX = horizontalDragPosition, dY = verticalDragPosition;
							switch(e.keyCode) {
								case 40: // down
								case 38: // up
								case 34: // page down
								case 32: // space
								case 33: // page up
								case 39: // right
								case 37: // left
									keyDown = e.keyCode;
									keyDownHandler();
									break;
								case 35: // end
									scrollToY(contentHeight - paneHeight);
									keyDown = null;
									break;
								case 36: // home
									scrollToY(0);
									keyDown = null;
									break;
							}

							elementHasScrolled = e.keyCode == keyDown && dX != horizontalDragPosition || dY != verticalDragPosition;
							return !elementHasScrolled;
						}
					).bind(
						'keypress.jsp', // For FF/ OSX so that we can cancel the repeat key presses if the JSP scrolls...
						function(e)
						{
							if (e.keyCode == keyDown) {
								keyDownHandler();
							}
							return !elementHasScrolled;
						}
					);
				
				if (settings.hideFocus) {
					elem.css('outline', 'none');
					if ('hideFocus' in container[0]){
						elem.attr('hideFocus', true);
					}
				} else {
					elem.css('outline', '');
					if ('hideFocus' in container[0]){
						elem.attr('hideFocus', false);
					}
				}
				
				function keyDownHandler()
				{
					var dX = horizontalDragPosition, dY = verticalDragPosition;
					switch(keyDown) {
						case 40: // down
							jsp.scrollByY(settings.keyboardSpeed, false);
							break;
						case 38: // up
							jsp.scrollByY(-settings.keyboardSpeed, false);
							break;
						case 34: // page down
						case 32: // space
							jsp.scrollByY(paneHeight * settings.scrollPagePercent, false);
							break;
						case 33: // page up
							jsp.scrollByY(-paneHeight * settings.scrollPagePercent, false);
							break;
						case 39: // right
							jsp.scrollByX(settings.keyboardSpeed, false);
							break;
						case 37: // left
							jsp.scrollByX(-settings.keyboardSpeed, false);
							break;
					}

					elementHasScrolled = dX != horizontalDragPosition || dY != verticalDragPosition;
					return elementHasScrolled;
				}
			}
			
			function removeKeyboardNav()
			{
				elem.attr('tabindex', '-1')
					.removeAttr('tabindex')
					.unbind('keydown.jsp keypress.jsp');
			}

			function observeHash()
			{
				if (location.hash && location.hash.length > 1) {
					var e,
						retryInt,
						hash = escape(location.hash) // hash must be escaped to prevent XSS
						;
					try {
						e = $(hash);
					} catch (err) {
						return;
					}

					if (e.length && pane.find(hash)) {
						// nasty workaround but it appears to take a little while before the hash has done its thing
						// to the rendered page so we just wait until the container's scrollTop has been messed up.
						if (container.scrollTop() === 0) {
							retryInt = setInterval(
								function()
								{
									if (container.scrollTop() > 0) {
										scrollToElement(hash, true);
										$(document).scrollTop(container.position().top);
										clearInterval(retryInt);
									}
								},
								50
							);
						} else {
							scrollToElement(hash, true);
							$(document).scrollTop(container.position().top);
						}
					}
				}
			}

			function unhijackInternalLinks()
			{
				$('a.jspHijack').unbind('click.jsp-hijack').removeClass('jspHijack');
			}

			function hijackInternalLinks()
			{
				unhijackInternalLinks();
				$('a[href^=#]').addClass('jspHijack').bind(
					'click.jsp-hijack',
					function()
					{
						var uriParts = this.href.split('#'), hash;
						if (uriParts.length > 1) {
							hash = uriParts[1];
							if (hash.length > 0 && pane.find('#' + hash).length > 0) {
								scrollToElement('#' + hash, true);
								// Need to return false otherwise things mess up... Would be nice to maybe also scroll
								// the window to the top of the scrollpane?
								return false;
							}
						}
					}
				);
			}
			
			// Init touch on iPad, iPhone, iPod, Android
			function initTouch()
			{
				var startX,
					startY,
					touchStartX,
					touchStartY,
					moved,
					moving = false;
  
				container.unbind('touchstart.jsp touchmove.jsp touchend.jsp click.jsp-touchclick').bind(
					'touchstart.jsp',
					function(e)
					{
						var touch = e.originalEvent.touches[0];
						startX = contentPositionX();
						startY = contentPositionY();
						touchStartX = touch.pageX;
						touchStartY = touch.pageY;
						moved = false;
						moving = true;
					}
				).bind(
					'touchmove.jsp',
					function(ev)
					{
						if(!moving) {
							return;
						}
						
						var touchPos = ev.originalEvent.touches[0],
							dX = horizontalDragPosition, dY = verticalDragPosition;
						
						jsp.scrollTo(startX + touchStartX - touchPos.pageX, startY + touchStartY - touchPos.pageY);
						
						moved = moved || Math.abs(touchStartX - touchPos.pageX) > 5 || Math.abs(touchStartY - touchPos.pageY) > 5;
						
						// return true if there was no movement so rest of screen can scroll
						return dX == horizontalDragPosition && dY == verticalDragPosition;
					}
				).bind(
					'touchend.jsp',
					function(e)
					{
						moving = false;
						/*if(moved) {
							return false;
						}*/
					}
				).bind(
					'click.jsp-touchclick',
					function(e)
					{
						if(moved) {
							moved = false;
							return false;
						}
					}
				);
			}
			
			function destroy(){
				var currentY = contentPositionY(),
					currentX = contentPositionX();
				elem.removeClass('jspScrollable').unbind('.jsp');
				elem.replaceWith(originalElement.append(pane.children()));
				originalElement.scrollTop(currentY);
				originalElement.scrollLeft(currentX);
			}

			// Public API
			$.extend(
				jsp,
				{
					// Reinitialises the scroll pane (if it's internal dimensions have changed since the last time it
					// was initialised). The settings object which is passed in will override any settings from the
					// previous time it was initialised - if you don't pass any settings then the ones from the previous
					// initialisation will be used.
					reinitialise: function(s)
					{
						s = $.extend({}, settings, s);
						initialise(s);
					},
					// Scrolls the specified element (a jQuery object, DOM node or jQuery selector string) into view so
					// that it can be seen within the viewport. If stickToTop is true then the element will appear at
					// the top of the viewport, if it is false then the viewport will scroll as little as possible to
					// show the element. You can also specify if you want animation to occur. If you don't provide this
					// argument then the animateScroll value from the settings object is used instead.
					scrollToElement: function(ele, stickToTop, animate)
					{
						scrollToElement(ele, stickToTop, animate);
					},
					// Scrolls the pane so that the specified co-ordinates within the content are at the top left
					// of the viewport. animate is optional and if not passed then the value of animateScroll from
					// the settings object this jScrollPane was initialised with is used.
					scrollTo: function(destX, destY, animate)
					{
						scrollToX(destX, animate);
						scrollToY(destY, animate);
					},
					// Scrolls the pane so that the specified co-ordinate within the content is at the left of the
					// viewport. animate is optional and if not passed then the value of animateScroll from the settings
					// object this jScrollPane was initialised with is used.
					scrollToX: function(destX, animate)
					{
						scrollToX(destX, animate);
					},
					// Scrolls the pane so that the specified co-ordinate within the content is at the top of the
					// viewport. animate is optional and if not passed then the value of animateScroll from the settings
					// object this jScrollPane was initialised with is used.
					scrollToY: function(destY, animate)
					{
						scrollToY(destY, animate);
					},
					// Scrolls the pane to the specified percentage of its maximum horizontal scroll position. animate
					// is optional and if not passed then the value of animateScroll from the settings object this
					// jScrollPane was initialised with is used.
					scrollToPercentX: function(destPercentX, animate)
					{
						scrollToX(destPercentX * (contentWidth - paneWidth), animate);
					},
					// Scrolls the pane to the specified percentage of its maximum vertical scroll position. animate
					// is optional and if not passed then the value of animateScroll from the settings object this
					// jScrollPane was initialised with is used.
					scrollToPercentY: function(destPercentY, animate)
					{
						scrollToY(destPercentY * (contentHeight - paneHeight), animate);
					},
					// Scrolls the pane by the specified amount of pixels. animate is optional and if not passed then
					// the value of animateScroll from the settings object this jScrollPane was initialised with is used.
					scrollBy: function(deltaX, deltaY, animate)
					{
						jsp.scrollByX(deltaX, animate);
						jsp.scrollByY(deltaY, animate);
					},
					// Scrolls the pane by the specified amount of pixels. animate is optional and if not passed then
					// the value of animateScroll from the settings object this jScrollPane was initialised with is used.
					scrollByX: function(deltaX, animate)
					{
						var destX = contentPositionX() + Math[deltaX<0 ? 'floor' : 'ceil'](deltaX),
							percentScrolled = destX / (contentWidth - paneWidth);
						positionDragX(percentScrolled * dragMaxX, animate);
					},
					// Scrolls the pane by the specified amount of pixels. animate is optional and if not passed then
					// the value of animateScroll from the settings object this jScrollPane was initialised with is used.
					scrollByY: function(deltaY, animate)
					{
						var destY = contentPositionY() + Math[deltaY<0 ? 'floor' : 'ceil'](deltaY),
							percentScrolled = destY / (contentHeight - paneHeight);
						positionDragY(percentScrolled * dragMaxY, animate);
					},
					// Positions the horizontal drag at the specified x position (and updates the viewport to reflect
					// this). animate is optional and if not passed then the value of animateScroll from the settings
					// object this jScrollPane was initialised with is used.
					positionDragX: function(x, animate)
					{
						positionDragX(x, animate);
					},
					// Positions the vertical drag at the specified y position (and updates the viewport to reflect
					// this). animate is optional and if not passed then the value of animateScroll from the settings
					// object this jScrollPane was initialised with is used.
					positionDragY: function(y, animate)
					{
						positionDragY(y, animate);
					},
					// This method is called when jScrollPane is trying to animate to a new position. You can override
					// it if you want to provide advanced animation functionality. It is passed the following arguments:
					//  * ele          - the element whose position is being animated
					//  * prop         - the property that is being animated
					//  * value        - the value it's being animated to
					//  * stepCallback - a function that you must execute each time you update the value of the property
					// You can use the default implementation (below) as a starting point for your own implementation.
					animate: function(ele, prop, value, stepCallback)
					{
						var params = {};
						params[prop] = value;
						ele.animate(
							params,
							{
								'duration'	: settings.animateDuration,
								'easing'	: settings.animateEase,
								'queue'		: false,
								'step'		: stepCallback
							}
						);
					},
					// Returns the current x position of the viewport with regards to the content pane.
					getContentPositionX: function()
					{
						return contentPositionX();
					},
					// Returns the current y position of the viewport with regards to the content pane.
					getContentPositionY: function()
					{
						return contentPositionY();
					},
					// Returns the width of the content within the scroll pane.
					getContentWidth: function()
					{
						return contentWidth;
					},
					// Returns the height of the content within the scroll pane.
					getContentHeight: function()
					{
						return contentHeight;
					},
					// Returns the horizontal position of the viewport within the pane content.
					getPercentScrolledX: function()
					{
						return contentPositionX() / (contentWidth - paneWidth);
					},
					// Returns the vertical position of the viewport within the pane content.
					getPercentScrolledY: function()
					{
						return contentPositionY() / (contentHeight - paneHeight);
					},
					// Returns whether or not this scrollpane has a horizontal scrollbar.
					getIsScrollableH: function()
					{
						return isScrollableH;
					},
					// Returns whether or not this scrollpane has a vertical scrollbar.
					getIsScrollableV: function()
					{
						return isScrollableV;
					},
					// Gets a reference to the content pane. It is important that you use this method if you want to
					// edit the content of your jScrollPane as if you access the element directly then you may have some
					// problems (as your original element has had additional elements for the scrollbars etc added into
					// it).
					getContentPane: function()
					{
						return pane;
					},
					// Scrolls this jScrollPane down as far as it can currently scroll. If animate isn't passed then the
					// animateScroll value from settings is used instead.
					scrollToBottom: function(animate)
					{
						positionDragY(dragMaxY, animate);
					},
					// Hijacks the links on the page which link to content inside the scrollpane. If you have changed
					// the content of your page (e.g. via AJAX) and want to make sure any new anchor links to the
					// contents of your scroll pane will work then call this function.
					hijackInternalLinks: function()
					{
						hijackInternalLinks();
					},
					// Removes the jScrollPane and returns the page to the state it was in before jScrollPane was
					// initialised.
					destroy: function()
					{
							destroy();
					}
				}
			);
			
			initialise(s);
		}

		// Pluginifying code...
		settings = $.extend({}, $.fn.jScrollPane.defaults, settings);
		
		// Apply default speed
		$.each(['mouseWheelSpeed', 'arrowButtonSpeed', 'trackClickSpeed', 'keyboardSpeed'], function() {
			settings[this] = settings[this] || settings.speed;
		});

		return this.each(
			function()
			{
				var elem = $(this), jspApi = elem.data('jsp');
				if (jspApi) {
					jspApi.reinitialise(settings);
				} else {
					jspApi = new JScrollPane(elem, settings);
					elem.data('jsp', jspApi);
				}
			}
		);
	};

	$.fn.jScrollPane.defaults = {
		showArrows					: false,
		maintainPosition			: true,
		stickToBottom				: false,
		stickToRight				: false,
		clickOnTrack				: true,
		autoReinitialise			: false,
		autoReinitialiseDelay		: 500,
		verticalDragMinHeight		: 0,
		verticalDragMaxHeight		: 99999,
		horizontalDragMinWidth		: 0,
		horizontalDragMaxWidth		: 99999,
		contentWidth				: undefined,
		animateScroll				: false,
		animateDuration				: 300,
		animateEase					: 'linear',
		hijackInternalLinks			: false,
		verticalGutter				: 4,
		horizontalGutter			: 4,
		mouseWheelSpeed				: 0,
		arrowButtonSpeed			: 0,
		arrowRepeatFreq				: 50,
		arrowScrollOnHover			: false,
		trackClickSpeed				: 0,
		trackClickRepeatFreq		: 70,
		verticalArrowPositions		: 'split',
		horizontalArrowPositions	: 'split',
		enableKeyboardNavigation	: true,
		hideFocus					: false,
		keyboardSpeed				: 0,
		initialDelay                : 300,        // Delay before starting repeating
		speed						: 30,		// Default speed when others falsey
		scrollPagePercent			: .8		// Percent of visible area scrolled when pageUp/Down or track area pressed
	};

})(jQuery,this);



/*! Copyright (c) 2011 Brandon Aaron (http://brandonaaron.net)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.0.6
 * 
 * Requires: 1.2.2+
 */

(function($) {

var types = ['DOMMouseScroll', 'mousewheel'];

if ($.event.fixHooks) {
    for ( var i=types.length; i; ) {
        $.event.fixHooks[ types[--i] ] = $.event.mouseHooks;
    }
}

$.event.special.mousewheel = {
    setup: function() {
        if ( this.addEventListener ) {
            for ( var i=types.length; i; ) {
                this.addEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = handler;
        }
    },
    
    teardown: function() {
        if ( this.removeEventListener ) {
            for ( var i=types.length; i; ) {
                this.removeEventListener( types[--i], handler, false );
            }
        } else {
            this.onmousewheel = null;
        }
    }
};

$.fn.extend({
    mousewheel: function(fn) {
        return fn ? this.bind("mousewheel", fn) : this.trigger("mousewheel");
    },
    
    unmousewheel: function(fn) {
        return this.unbind("mousewheel", fn);
    }
});


function handler(event) {
    var orgEvent = event || window.event, args = [].slice.call( arguments, 1 ), delta = 0, returnValue = true, deltaX = 0, deltaY = 0;
    event = $.event.fix(orgEvent);
    event.type = "mousewheel";
    
    // Old school scrollwheel delta
    if ( orgEvent.wheelDelta ) { delta = orgEvent.wheelDelta/120; }
    if ( orgEvent.detail     ) { delta = -orgEvent.detail/3; }
    
    // New school multidimensional scroll (touchpads) deltas
    deltaY = delta;
    
    // Gecko
    if ( orgEvent.axis !== undefined && orgEvent.axis === orgEvent.HORIZONTAL_AXIS ) {
        deltaY = 0;
        deltaX = -1*delta;
    }
    
    // Webkit
    if ( orgEvent.wheelDeltaY !== undefined ) { deltaY = orgEvent.wheelDeltaY/120; }
    if ( orgEvent.wheelDeltaX !== undefined ) { deltaX = -1*orgEvent.wheelDeltaX/120; }
    
    // Add event and delta to the front of the arguments
    args.unshift(event, delta, deltaX, deltaY);
    
    return ($.event.dispatch || $.event.handle).apply(this, args);
}

})(jQuery);



(function(jQuery){

    // We override the animation for all of these color styles
    jQuery.each(['backgroundColor', 'borderBottomColor', 'borderLeftColor', 'borderRightColor', 'borderTopColor', 'color', 'outlineColor'], function(i,attr){
        jQuery.fx.step[attr] = function(fx){
            if ( !fx.colorInit ) {
                fx.start = getColor( fx.elem, attr );
                fx.end = getRGB( fx.end );
                fx.colorInit = true;
            }

            fx.elem.style[attr] = "rgb(" + [
                Math.max(Math.min( parseInt((fx.pos * (fx.end[0] - fx.start[0])) + fx.start[0]), 255), 0),
                Math.max(Math.min( parseInt((fx.pos * (fx.end[1] - fx.start[1])) + fx.start[1]), 255), 0),
                Math.max(Math.min( parseInt((fx.pos * (fx.end[2] - fx.start[2])) + fx.start[2]), 255), 0)
            ].join(",") + ")";
        }
    });

    // Color Conversion functions from highlightFade
    // By Blair Mitchelmore
    // http://jquery.offput.ca/highlightFade/

    // Parse strings looking for color tuples [255,255,255]
    function getRGB(color) {
        var result;

        // Check if we're already dealing with an array of colors
        if ( color && color.constructor == Array && color.length == 3 )
            return color;

        // Look for rgb(num,num,num)
        if (result = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(color))
            return [parseInt(result[1]), parseInt(result[2]), parseInt(result[3])];

        // Look for rgb(num%,num%,num%)
        if (result = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(color))
            return [parseFloat(result[1])*2.55, parseFloat(result[2])*2.55, parseFloat(result[3])*2.55];

        // Look for #a0b1c2
        if (result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(color))
            return [parseInt(result[1],16), parseInt(result[2],16), parseInt(result[3],16)];

        // Look for #fff
        if (result = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(color))
            return [parseInt(result[1]+result[1],16), parseInt(result[2]+result[2],16), parseInt(result[3]+result[3],16)];

        // Look for rgba(0, 0, 0, 0) == transparent in Safari 3
        if (result = /rgba\(0, 0, 0, 0\)/.exec(color))
            return colors['transparent'];

        // Otherwise, we're most likely dealing with a named color
        return colors[jQuery.trim(color).toLowerCase()];
    }

    function getColor(elem, attr) {
        var color;

        do {
            color = jQuery.curCSS(elem, attr);

            // Keep going until we find an element that has color, or we hit the body
            if ( color != '' && color != 'transparent' || jQuery.nodeName(elem, "body") )
                break;

            attr = "backgroundColor";
        } while ( elem = elem.parentNode );

        return getRGB(color);
    };

    // Some named colors to work with
    // From Interface by Stefan Petre
    // http://interface.eyecon.ro/

    var colors = {
        aqua:[0,255,255],
        azure:[240,255,255],
        beige:[245,245,220],
        black:[0,0,0],
        blue:[0,0,255],
        brown:[165,42,42],
        cyan:[0,255,255],
        darkblue:[0,0,139],
        darkcyan:[0,139,139],
        darkgrey:[169,169,169],
        darkgreen:[0,100,0],
        darkkhaki:[189,183,107],
        darkmagenta:[139,0,139],
        darkolivegreen:[85,107,47],
        darkorange:[255,140,0],
        darkorchid:[153,50,204],
        darkred:[139,0,0],
        darksalmon:[233,150,122],
        darkviolet:[148,0,211],
        fuchsia:[255,0,255],
        gold:[255,215,0],
        green:[0,128,0],
        indigo:[75,0,130],
        khaki:[240,230,140],
        lightblue:[173,216,230],
        lightcyan:[224,255,255],
        lightgreen:[144,238,144],
        lightgrey:[211,211,211],
        lightpink:[255,182,193],
        lightyellow:[255,255,224],
        lime:[0,255,0],
        magenta:[255,0,255],
        maroon:[128,0,0],
        navy:[0,0,128],
        olive:[128,128,0],
        orange:[255,165,0],
        pink:[255,192,203],
        purple:[128,0,128],
        violet:[128,0,128],
        red:[255,0,0],
        silver:[192,192,192],
        white:[255,255,255],
        yellow:[255,255,0],
        transparent: [255,255,255]
    };

})(jQuery);



(function($){
  
  $.pubsubLogging = false;
  
  var o = $({});
  
  $.subscribe = function() {
    o.bind.apply( o, arguments );
  };
  
  $.subscribeOnce = function() {
    o.one.apply( o, arguments );
  };
  
  $.unsubscribe = function() {
    o.unbind.apply( o, arguments );
  };
  
  $.publish = function() {
    if( $.pubsubLogging ) { console.log.apply( console, arguments ); }
	o.trigger.apply( o, arguments );
  };
  
}(jQuery));


//Ford chooses to use jQuery tmpl and its associated components under the MIT License.
(function(a){var r=a.fn.domManip,d="_tmplitem",q=/^[^<]*(<[\w\W]+>)[^>]*$|\{\{\! /,b={},f={},e,p={key:0,data:{}},h=0,c=0,l=[];function g(e,d,g,i){var c={data:i||(d?d.data:{}),_wrap:d?d._wrap:null,tmpl:null,parent:d||null,nodes:[],calls:u,nest:w,wrap:x,html:v,update:t};e&&a.extend(c,e,{nodes:[],parent:d});if(g){c.tmpl=g;c._ctnt=c._ctnt||c.tmpl(a,c);c.key=++h;(l.length?f:b)[h]=c}return c}a.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(f,d){a.fn[f]=function(n){var g=[],i=a(n),k,h,m,l,j=this.length===1&&this[0].parentNode;e=b||{};if(j&&j.nodeType===11&&j.childNodes.length===1&&i.length===1){i[d](this[0]);g=this}else{for(h=0,m=i.length;h<m;h++){c=h;k=(h>0?this.clone(true):this).get();a.fn[d].apply(a(i[h]),k);g=g.concat(k)}c=0;g=this.pushStack(g,f,i.selector)}l=e;e=null;a.tmpl.complete(l);return g}});a.fn.extend({tmpl:function(d,c,b){return a.tmpl(this[0],d,c,b)},tmplItem:function(){return a.tmplItem(this[0])},template:function(b){return a.template(b,this[0])},domManip:function(d,l,j){if(d[0]&&d[0].nodeType){var f=a.makeArray(arguments),g=d.length,i=0,h;while(i<g&&!(h=a.data(d[i++],"tmplItem")));if(g>1)f[0]=[a.makeArray(d)];if(h&&c)f[2]=function(b){a.tmpl.afterManip(this,b,j)};r.apply(this,f)}else r.apply(this,arguments);c=0;!e&&a.tmpl.complete(b);return this}});a.extend({tmpl:function(d,h,e,c){var j,k=!c;if(k){c=p;d=a.template[d]||a.template(null,d);f={}}else if(!d){d=c.tmpl;b[c.key]=c;c.nodes=[];c.wrapped&&n(c,c.wrapped);return a(i(c,null,c.tmpl(a,c)))}if(!d)return[];if(typeof h==="function")h=h.call(c||{});e&&e.wrapped&&n(e,e.wrapped);j=a.isArray(h)?a.map(h,function(a){return a?g(e,c,d,a):null}):[g(e,c,d,h)];return k?a(i(c,null,j)):j},tmplItem:function(b){var c;if(b instanceof a)b=b[0];while(b&&b.nodeType===1&&!(c=a.data(b,"tmplItem"))&&(b=b.parentNode));return c||p},template:function(c,b){if(b){if(typeof b==="string")b=o(b);else if(b instanceof a)b=b[0]||{};if(b.nodeType)b=a.data(b,"tmpl")||a.data(b,"tmpl",o(b.innerHTML));return typeof c==="string"?(a.template[c]=b):b}return c?typeof c!=="string"?a.template(null,c):a.template[c]||a.template(null,q.test(c)?c:a(c)):null},encode:function(a){return(""+a).split("<").join("&lt;").split(">").join("&gt;").split('"').join("&#34;").split("'").join("&#39;")}});a.extend(a.tmpl,{tag:{tmpl:{_default:{$2:"null"},open:"if($notnull_1){_=_.concat($item.nest($1,$2));}"},wrap:{_default:{$2:"null"},open:"$item.calls(_,$1,$2);_=[];",close:"call=$item.calls();_=call._.concat($item.wrap(call,_));"},each:{_default:{$2:"$index, $value"},open:"if($notnull_1){$.each($1a,function($2){with(this){",close:"}});}"},"if":{open:"if(($notnull_1) && $1a){",close:"}"},"else":{_default:{$1:"true"},open:"}else if(($notnull_1) && $1a){"},html:{open:"if($notnull_1){_.push($1a);}"},"=":{_default:{$1:"$data"},open:"if($notnull_1){_.push($.encode($1a));}"},"!":{open:""}},complete:function(){b={}},afterManip:function(f,b,d){var e=b.nodeType===11?a.makeArray(b.childNodes):b.nodeType===1?[b]:[];d.call(f,b);m(e);c++}});function i(e,g,f){var b,c=f?a.map(f,function(a){return typeof a==="string"?e.key?a.replace(/(<\w+)(?=[\s>])(?![^>]*_tmplitem)([^>]*)/g,"$1 "+d+'="'+e.key+'" $2'):a:i(a,e,a._ctnt)}):e;if(g)return c;c=c.join("");c.replace(/^\s*([^<\s][^<]*)?(<[\w\W]+>)([^>]*[^>\s])?\s*$/,function(f,c,e,d){b=a(e).get();m(b);if(c)b=j(c).concat(b);if(d)b=b.concat(j(d))});return b?b:j(c)}function j(c){var b=document.createElement("div");b.innerHTML=c;return a.makeArray(b.childNodes)}function o(b){return new Function("jQuery","$item","var $=jQuery,call,_=[],$data=$item.data;with($data){_.push('"+a.trim(b).replace(/([\\'])/g,"\\$1").replace(/[\r\t\n]/g," ").replace(/\$\{([^\}]*)\}/g,"{{= $1}}").replace(/\{\{(\/?)(\w+|.)(?:\(((?:[^\}]|\}(?!\}))*?)?\))?(?:\s+(.*?)?)?(\(((?:[^\}]|\}(?!\}))*?)\))?\s*\}\}/g,function(m,l,j,d,b,c,e){var i=a.tmpl.tag[j],h,f,g;h=i._default||[];if(c&&!/\w$/.test(b)){b+=c;c=""}if(b){b=k(b);e=e?","+k(e)+")":c?")":"";f=c?b.indexOf(".")>-1?b+c:"("+b+").call($item"+e:b;g=c?f:"(typeof("+b+")==='function'?("+b+").call($item):("+b+"))"}else g=f=h.$1||"null";d=k(d);return"');"+i[l?"close":"open"].split("$notnull_1").join(b?"typeof("+b+")!=='undefined' && ("+b+")!=null":"true").split("$1a").join(g).split("$1").join(f).split("$2").join(d?d.replace(/\s*([^\(]+)\s*(\((.*?)\))?/g,function(d,c,b,a){a=a?","+a+")":b?")":"";return a?"("+c+").call($item"+a:d}):h.$2||"")+"_.push('"})+"');}return _;")}function n(c,b){c._wrap=i(c,true,a.isArray(b)?b:[q.test(b)?b:a(b).html()]).join("")}function k(a){return a?a.replace(/\\'/g,"'").replace(/\\\\/g,"\\"):null}function s(b){var a=document.createElement("div");a.appendChild(b.cloneNode(true));return a.innerHTML}function m(o){var n="_"+c,k,j,l={},e,p,i;for(e=0,p=o.length;e<p;e++){if((k=o[e]).nodeType!==1)continue;j=k.getElementsByTagName("*");for(i=j.length-1;i>=0;i--)m(j[i]);m(k)}function m(j){var p,i=j,k,e,m;if(m=j.getAttribute(d)){while(i.parentNode&&(i=i.parentNode).nodeType===1&&!(p=i.getAttribute(d)));if(p!==m){i=i.parentNode?i.nodeType===11?0:i.getAttribute(d)||0:0;if(!(e=b[m])){e=f[m];e=g(e,b[i]||f[i],null,true);e.key=++h;b[h]=e}c&&o(m)}j.removeAttribute(d)}else if(c&&(e=a.data(j,"tmplItem"))){o(e.key);b[e.key]=e;i=a.data(j.parentNode,"tmplItem");i=i?i.key:0}if(e){k=e;while(k&&k.key!=i){k.nodes.push(j);k=k.parent}delete e._ctnt;delete e._wrap;a.data(j,"tmplItem",e)}function o(a){a=a+n;e=l[a]=l[a]||g(e,b[e.parent.key+n]||e.parent,null,true)}}}function u(a,d,c,b){if(!a)return l.pop();l.push({_:a,tmpl:d,item:this,data:c,options:b})}function w(d,c,b){return a.tmpl(a.template(d),c,b,this)}function x(b,d){var c=b.options||{};c.wrapped=d;return a.tmpl(a.template(b.tmpl),b.data,c,b.item)}function v(d,c){var b=this._wrap;return a.map(a(a.isArray(b)?b.join(""):b).filter(d||"*"),function(a){return c?a.innerText||a.textContent:a.outerHTML||s(a)})}function t(){var b=this.nodes;a.tmpl(null,null,null,this).insertBefore(b[0]);a(b).remove()}})(jQuery);



(function($,window){
  '$:nomunge'; // Used by YUI compressor.
  
  // Some convenient shortcuts.
  var undefined,
    aps = Array.prototype.slice,
    decode = decodeURIComponent,
    
    // Method / object references.
    jq_param = $.param,
    jq_param_fragment,
    jq_deparam,
    jq_deparam_fragment,
    jq_bbq = $.bbq = $.bbq || {},
    jq_bbq_pushState,
    jq_bbq_getState,
    jq_elemUrlAttr,
    jq_event_special = $.event.special,
    
    // Reused strings.
    str_hashchange = 'hashchange',
    str_querystring = 'querystring',
    str_fragment = 'fragment',
    str_elemUrlAttr = 'elemUrlAttr',
    str_location = 'location',
    str_href = 'href',
    str_src = 'src',
    
    // Reused RegExp.
    re_trim_querystring = /^.*\?|#.*$/g,
    re_trim_fragment = /^.*\#/,
    re_no_escape,
    
    // Used by jQuery.elemUrlAttr.
    elemUrlAttr_cache = {};
  
  // A few commonly used bits, broken out to help reduce minified file size.
  function is_string( arg ) {
    return typeof arg === 'string';
  };
  
  // Why write the same function twice? Let's curry! Mmmm, curry..
  
  function curry( func ) {
    var args = aps.call( arguments, 1 );
    
    return function() {
      return func.apply( this, args.concat( aps.call( arguments ) ) );
    };
  };
  
  // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!
  function get_fragment( url ) {
    return url.replace( /^[^#]*#?(.*)$/, '$1' );
  };
  
  // Get location.search (or what you'd expect location.search to be) sans any
  // leading #. Thanks for making this necessary, IE6!
  function get_querystring( url ) {
    return url.replace( /(?:^[^?#]*\?([^#]*).*$)?.*/, '$1' );
  };
  
  // Section: Param (to string)
  // 
  // Method: jQuery.param.querystring
  // 
  // Retrieve the query string from a URL or if no arguments are passed, the
  // current window.location.
  // 
  // Usage:
  // 
  // > jQuery.param.querystring( [ url ] );
  // 
  // Arguments:
  // 
  //  url - (String) A URL containing query string params to be parsed. If url
  //    is not passed, the current window.location is used.
  // 
  // Returns:
  // 
  //  (String) The parsed query string, with any leading "?" removed.
  //
  
  // Method: jQuery.param.querystring (build url)
  // 
  // Merge a URL, with or without pre-existing query string params, plus any
  // object, params string or URL containing query string params into a new URL.
  // 
  // Usage:
  // 
  // > jQuery.param.querystring( url, params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  url - (String) A valid URL for params to be merged into. This URL may
  //    contain a query string and/or fragment (hash).
  //  params - (String) A params string or URL containing query string params to
  //    be merged into url.
  //  params - (Object) A params object to be merged into url.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  // 
  //    * 0: params in the params argument will override any query string
  //         params in url.
  //    * 1: any query string params in url will override params in the params
  //         argument.
  //    * 2: params argument will completely replace any query string in url.
  // 
  // Returns:
  // 
  //  (String) Either a params string with urlencoded data or a URL with a
  //    urlencoded query string in the format 'a=b&c=d&e=f'.
  
  // Method: jQuery.param.fragment
  // 
  // Retrieve the fragment (hash) from a URL or if no arguments are passed, the
  // current window.location.
  // 
  // Usage:
  // 
  // > jQuery.param.fragment( [ url ] );
  // 
  // Arguments:
  // 
  //  url - (String) A URL containing fragment (hash) params to be parsed. If
  //    url is not passed, the current window.location is used.
  // 
  // Returns:
  // 
  //  (String) The parsed fragment (hash) string, with any leading "#" removed.
  
  // Method: jQuery.param.fragment (build url)
  // 
  // Merge a URL, with or without pre-existing fragment (hash) params, plus any
  // object, params string or URL containing fragment (hash) params into a new
  // URL.
  // 
  // Usage:
  // 
  // > jQuery.param.fragment( url, params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  url - (String) A valid URL for params to be merged into. This URL may
  //    contain a query string and/or fragment (hash).
  //  params - (String) A params string or URL containing fragment (hash) params
  //    to be merged into url.
  //  params - (Object) A params object to be merged into url.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  // 
  //    * 0: params in the params argument will override any fragment (hash)
  //         params in url.
  //    * 1: any fragment (hash) params in url will override params in the
  //         params argument.
  //    * 2: params argument will completely replace any query string in url.
  // 
  // Returns:
  // 
  //  (String) Either a params string with urlencoded data or a URL with a
  //    urlencoded fragment (hash) in the format 'a=b&c=d&e=f'.
  
  function jq_param_sub( is_fragment, get_func, url, params, merge_mode ) {
    var result,
      qs,
      matches,
      url_params,
      hash;
    
    if ( params !== undefined ) {
      // Build URL by merging params into url string.
      
      // matches[1] = url part that precedes params, not including trailing ?/#
      // matches[2] = params, not including leading ?/#
      // matches[3] = if in 'querystring' mode, hash including leading #, otherwise ''
      matches = url.match( is_fragment ? /^([^#]*)\#?(.*)$/ : /^([^#?]*)\??([^#]*)(#?.*)/ );
      
      // Get the hash if in 'querystring' mode, and it exists.
      hash = matches[3] || '';
      
      if ( merge_mode === 2 && is_string( params ) ) {
        // If merge_mode is 2 and params is a string, merge the fragment / query
        // string into the URL wholesale, without converting it into an object.
        qs = params.replace( is_fragment ? re_trim_fragment : re_trim_querystring, '' );
        
      } else {
        // Convert relevant params in url to object.
        url_params = jq_deparam( matches[2] );
        
        params = is_string( params )
          
          // Convert passed params string into object.
          ? jq_deparam[ is_fragment ? str_fragment : str_querystring ]( params )
          
          // Passed params object.
          : params;
        
        qs = merge_mode === 2 ? params                              // passed params replace url params
          : merge_mode === 1  ? $.extend( {}, params, url_params )  // url params override passed params
          : $.extend( {}, url_params, params );                     // passed params override url params
        
        // Convert params object to a string.
        qs = jq_param( qs );
        
        // Unescape characters specified via $.param.noEscape. Since only hash-
        // history users have requested this feature, it's only enabled for
        // fragment-related params strings.
        if ( is_fragment ) {
          qs = qs.replace( re_no_escape, decode );
        }
      }
      
      // Build URL from the base url, querystring and hash. In 'querystring'
      // mode, ? is only added if a query string exists. In 'fragment' mode, #
      // is always added.
      result = matches[1] + ( is_fragment ? '#' : qs || !matches[1] ? '?' : '' ) + qs + hash;
      
    } else {
      // If URL was passed in, parse params from URL string, otherwise parse
      // params from window.location.
      result = get_func( url !== undefined ? url : window[ str_location ][ str_href ] );
    }
    
    return result;
  };
  
  jq_param[ str_querystring ]                  = curry( jq_param_sub, 0, get_querystring );
  jq_param[ str_fragment ] = jq_param_fragment = curry( jq_param_sub, 1, get_fragment );
  
  // Method: jQuery.param.fragment.noEscape
  // 
  // Specify characters that will be left unescaped when fragments are created
  // or merged using <jQuery.param.fragment>, or when the fragment is modified
  // using <jQuery.bbq.pushState>. This option only applies to serialized data
  // object fragments, and not set-as-string fragments. Does not affect the
  // query string. Defaults to ",/" (comma, forward slash).
  // 
  // Note that this is considered a purely aesthetic option, and will help to
  // create URLs that "look pretty" in the address bar or bookmarks, without
  // affecting functionality in any way. That being said, be careful to not
  // unescape characters that are used as delimiters or serve a special
  // purpose, such as the "#?&=+" (octothorpe, question mark, ampersand,
  // equals, plus) characters.
  // 
  // Usage:
  // 
  // > jQuery.param.fragment.noEscape( [ chars ] );
  // 
  // Arguments:
  // 
  //  chars - (String) The characters to not escape in the fragment. If
  //    unspecified, defaults to empty string (escape all characters).
  // 
  // Returns:
  // 
  //  Nothing.
  
  jq_param_fragment.noEscape = function( chars ) {
    chars = chars || '';
    var arr = $.map( chars.split(''), encodeURIComponent );
    re_no_escape = new RegExp( arr.join('|'), 'g' );
  };
  
  // A sensible default. These are the characters people seem to complain about
  // "uglifying up the URL" the most.
  jq_param_fragment.noEscape( ',/' );
  
  // Section: Deparam (from string)
  // 
  // Method: jQuery.deparam
  // 
  // Deserialize a params string into an object, optionally coercing numbers,
  // booleans, null and undefined values; this method is the counterpart to the
  // internal jQuery.param method.
  // 
  // Usage:
  // 
  // > jQuery.deparam( params [, coerce ] );
  // 
  // Arguments:
  // 
  //  params - (String) A params string to be parsed.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  // 
  // Returns:
  // 
  //  (Object) An object representing the deserialized params string.
  
  $.deparam = jq_deparam = function( params, coerce ) {
    var obj = {},
      coerce_types = { 'true': !0, 'false': !1, 'null': null };
    
    // Iterate over all name=value pairs.
    $.each( params.replace( /\+/g, ' ' ).split( '&' ), function(j,v){
      var param = v.split( '=' ),
        key = decode( param[0] ),
        val,
        cur = obj,
        i = 0,
        
        // If key is more complex than 'foo', like 'a[]' or 'a[b][c]', split it
        // into its component parts.
        keys = key.split( '][' ),
        keys_last = keys.length - 1;
      
      // If the first keys part contains [ and the last ends with ], then []
      // are correctly balanced.
      if ( /\[/.test( keys[0] ) && /\]$/.test( keys[ keys_last ] ) ) {
        // Remove the trailing ] from the last keys part.
        keys[ keys_last ] = keys[ keys_last ].replace( /\]$/, '' );
        
        // Split first keys part into two parts on the [ and add them back onto
        // the beginning of the keys array.
        keys = keys.shift().split('[').concat( keys );
        
        keys_last = keys.length - 1;
      } else {
        // Basic 'foo' style key.
        keys_last = 0;
      }
      
      // Are we dealing with a name=value pair, or just a name?
      if ( param.length === 2 ) {
        val = decode( param[1] );
        
        // Coerce values.
        if ( coerce ) {
          val = val && !isNaN(val)            ? +val              // number
            : val === 'undefined'             ? undefined         // undefined
            : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null
            : val;                                                // string
        }
        
        if ( keys_last ) {
          // Complex key, build deep object structure based on a few rules:
          // * The 'cur' pointer starts at the object top-level.
          // * [] = array push (n is set to array length), [n] = array if n is 
          //   numeric, otherwise object.
          // * If at the last keys part, set the value.
          // * For each keys part, if the current level is undefined create an
          //   object or array based on the type of the next keys part.
          // * Move the 'cur' pointer to the next level.
          // * Rinse & repeat.
          for ( ; i <= keys_last; i++ ) {
            key = keys[i] === '' ? cur.length : keys[i];
            cur = cur[key] = i < keys_last
              ? cur[key] || ( keys[i+1] && isNaN( keys[i+1] ) ? {} : [] )
              : val;
          }
          
        } else {
          // Simple key, even simpler rules, since only scalars and shallow
          // arrays are allowed.
          
          if ( $.isArray( obj[key] ) ) {
            // val is already an array, so push on the next value.
            obj[key].push( val );
            
          } else if ( obj[key] !== undefined ) {
            // val isn't an array, but since a second value has been specified,
            // convert val into an array.
            obj[key] = [ obj[key], val ];
            
          } else {
            // val is a scalar.
            obj[key] = val;
          }
        }
        
      } else if ( key ) {
        // No value was defined, so set something meaningful.
        obj[key] = coerce
          ? undefined
          : '';
      }
    });
    
    return obj;
  };
  
  // Method: jQuery.deparam.querystring
  // 
  // Parse the query string from a URL or the current window.location,
  // deserializing it into an object, optionally coercing numbers, booleans,
  // null and undefined values.
  // 
  // Usage:
  // 
  // > jQuery.deparam.querystring( [ url ] [, coerce ] );
  // 
  // Arguments:
  // 
  //  url - (String) An optional params string or URL containing query string
  //    params to be parsed. If url is omitted, the current window.location
  //    is used.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  // 
  // Returns:
  // 
  //  (Object) An object representing the deserialized params string.
  
  // Method: jQuery.deparam.fragment
  // 
  // Parse the fragment (hash) from a URL or the current window.location,
  // deserializing it into an object, optionally coercing numbers, booleans,
  // null and undefined values.
  // 
  // Usage:
  // 
  // > jQuery.deparam.fragment( [ url ] [, coerce ] );
  // 
  // Arguments:
  // 
  //  url - (String) An optional params string or URL containing fragment (hash)
  //    params to be parsed. If url is omitted, the current window.location
  //    is used.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  // 
  // Returns:
  // 
  //  (Object) An object representing the deserialized params string.
  
  function jq_deparam_sub( is_fragment, url_or_params, coerce ) {
    if ( url_or_params === undefined || typeof url_or_params === 'boolean' ) {
      // url_or_params not specified.
      coerce = url_or_params;
      url_or_params = jq_param[ is_fragment ? str_fragment : str_querystring ]();
    } else {
      url_or_params = is_string( url_or_params )
        ? url_or_params.replace( is_fragment ? re_trim_fragment : re_trim_querystring, '' )
        : url_or_params;
    }
    
    return jq_deparam( url_or_params, coerce );
  };
  
  jq_deparam[ str_querystring ]                    = curry( jq_deparam_sub, 0 );
  jq_deparam[ str_fragment ] = jq_deparam_fragment = curry( jq_deparam_sub, 1 );
  
  // Section: Element manipulation
  // 
  // Method: jQuery.elemUrlAttr
  // 
  // Get the internal "Default URL attribute per tag" list, or augment the list
  // with additional tag-attribute pairs, in case the defaults are insufficient.
  // 
  // In the <jQuery.fn.querystring> and <jQuery.fn.fragment> methods, this list
  // is used to determine which attribute contains the URL to be modified, if
  // an "attr" param is not specified.
  // 
  // Default Tag-Attribute List:
  // 
  //  a      - href
  //  base   - href
  //  iframe - src
  //  img    - src
  //  input  - src
  //  form   - action
  //  link   - href
  //  script - src
  // 
  // Usage:
  // 
  // > jQuery.elemUrlAttr( [ tag_attr ] );
  // 
  // Arguments:
  // 
  //  tag_attr - (Object) An object containing a list of tag names and their
  //    associated default attribute names in the format { tag: 'attr', ... } to
  //    be merged into the internal tag-attribute list.
  // 
  // Returns:
  // 
  //  (Object) An object containing all stored tag-attribute values.
  
  // Only define function and set defaults if function doesn't already exist, as
  // the urlInternal plugin will provide this method as well.
  $[ str_elemUrlAttr ] || ($[ str_elemUrlAttr ] = function( obj ) {
    return $.extend( elemUrlAttr_cache, obj );
  })({
    a: str_href,
    base: str_href,
    iframe: str_src,
    img: str_src,
    input: str_src,
    form: 'action',
    link: str_href,
    script: str_src
  });
  
  jq_elemUrlAttr = $[ str_elemUrlAttr ];
  
  // Method: jQuery.fn.querystring
  // 
  // Update URL attribute in one or more elements, merging the current URL (with
  // or without pre-existing query string params) plus any params object or
  // string into a new URL, which is then set into that attribute. Like
  // <jQuery.param.querystring (build url)>, but for all elements in a jQuery
  // collection.
  // 
  // Usage:
  // 
  // > jQuery('selector').querystring( [ attr, ] params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  attr - (String) Optional name of an attribute that will contain a URL to
  //    merge params or url into. See <jQuery.elemUrlAttr> for a list of default
  //    attributes.
  //  params - (Object) A params object to be merged into the URL attribute.
  //  params - (String) A URL containing query string params, or params string
  //    to be merged into the URL attribute.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //    
  //    * 0: params in the params argument will override any params in attr URL.
  //    * 1: any params in attr URL will override params in the params argument.
  //    * 2: params argument will completely replace any query string in attr
  //         URL.
  // 
  // Returns:
  // 
  //  (jQuery) The initial jQuery collection of elements, but with modified URL
  //  attribute values.
  
  // Method: jQuery.fn.fragment
  // 
  // Update URL attribute in one or more elements, merging the current URL (with
  // or without pre-existing fragment/hash params) plus any params object or
  // string into a new URL, which is then set into that attribute. Like
  // <jQuery.param.fragment (build url)>, but for all elements in a jQuery
  // collection.
  // 
  // Usage:
  // 
  // > jQuery('selector').fragment( [ attr, ] params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  attr - (String) Optional name of an attribute that will contain a URL to
  //    merge params into. See <jQuery.elemUrlAttr> for a list of default
  //    attributes.
  //  params - (Object) A params object to be merged into the URL attribute.
  //  params - (String) A URL containing fragment (hash) params, or params
  //    string to be merged into the URL attribute.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //    
  //    * 0: params in the params argument will override any params in attr URL.
  //    * 1: any params in attr URL will override params in the params argument.
  //    * 2: params argument will completely replace any fragment (hash) in attr
  //         URL.
  // 
  // Returns:
  // 
  //  (jQuery) The initial jQuery collection of elements, but with modified URL
  //  attribute values.
  
  function jq_fn_sub( mode, force_attr, params, merge_mode ) {
    if ( !is_string( params ) && typeof params !== 'object' ) {
      // force_attr not specified.
      merge_mode = params;
      params = force_attr;
      force_attr = undefined;
    }
    
    return this.each(function(){
      var that = $(this),
        
        // Get attribute specified, or default specified via $.elemUrlAttr.
        attr = force_attr || jq_elemUrlAttr()[ ( this.nodeName || '' ).toLowerCase() ] || '',
        
        // Get URL value.
        url = attr && that.attr( attr ) || '';
      
      // Update attribute with new URL.
      that.attr( attr, jq_param[ mode ]( url, params, merge_mode ) );
    });
    
  };
  
  $.fn[ str_querystring ] = curry( jq_fn_sub, str_querystring );
  $.fn[ str_fragment ]    = curry( jq_fn_sub, str_fragment );
  
  // Section: History, hashchange event
  // 
  // Method: jQuery.bbq.pushState
  // 
  // Adds a 'state' into the browser history at the current position, setting
  // location.hash and triggering any bound <hashchange event> callbacks
  // (provided the new state is different than the previous state).
  // 
  // If no arguments are passed, an empty state is created, which is just a
  // shortcut for jQuery.bbq.pushState( {}, 2 ).
  // 
  // Usage:
  // 
  // > jQuery.bbq.pushState( [ params [, merge_mode ] ] );
  // 
  // Arguments:
  // 
  //  params - (String) A serialized params string or a hash string beginning
  //    with # to merge into location.hash.
  //  params - (Object) A params object to merge into location.hash.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified (unless a hash string beginning with # is specified, in which
  //    case merge behavior defaults to 2), and is as-follows:
  // 
  //    * 0: params in the params argument will override any params in the
  //         current state.
  //    * 1: any params in the current state will override params in the params
  //         argument.
  //    * 2: params argument will completely replace current state.
  // 
  // Returns:
  // 
  //  Nothing.
  // 
  // Additional Notes:
  // 
  //  * Setting an empty state may cause the browser to scroll.
  //  * Unlike the fragment and querystring methods, if a hash string beginning
  //    with # is specified as the params agrument, merge_mode defaults to 2.
  
  jq_bbq.pushState = jq_bbq_pushState = function( params, merge_mode ) {
    if ( is_string( params ) && /^#/.test( params ) && merge_mode === undefined ) {
      // Params string begins with # and merge_mode not specified, so completely
      // overwrite window.location.hash.
      merge_mode = 2;
    }
    
    var has_args = params !== undefined,
      // Merge params into window.location using $.param.fragment.
      url = jq_param_fragment( window[ str_location ][ str_href ],
        has_args ? params : {}, has_args ? merge_mode : 2 );
    
    // Set new window.location.href. If hash is empty, use just # to prevent
    // browser from reloading the page. Note that Safari 3 & Chrome barf on
    // location.hash = '#'.
    window[ str_location ][ str_href ] = url + ( /#/.test( url ) ? '' : '#' );
  };
  
  // Method: jQuery.bbq.getState
  // 
  // Retrieves the current 'state' from the browser history, parsing
  // location.hash for a specific key or returning an object containing the
  // entire state, optionally coercing numbers, booleans, null and undefined
  // values.
  // 
  // Usage:
  // 
  // > jQuery.bbq.getState( [ key ] [, coerce ] );
  // 
  // Arguments:
  // 
  //  key - (String) An optional state key for which to return a value.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false.
  // 
  // Returns:
  // 
  //  (Anything) If key is passed, returns the value corresponding with that key
  //    in the location.hash 'state', or undefined. If not, an object
  //    representing the entire 'state' is returned.
  
  jq_bbq.getState = jq_bbq_getState = function( key, coerce ) {
    return key === undefined || typeof key === 'boolean'
      ? jq_deparam_fragment( key ) // 'key' really means 'coerce' here
      : jq_deparam_fragment( coerce )[ key ];
  };
  
  // Method: jQuery.bbq.removeState
  // 
  // Remove one or more keys from the current browser history 'state', creating
  // a new state, setting location.hash and triggering any bound
  // <hashchange event> callbacks (provided the new state is different than
  // the previous state).
  // 
  // If no arguments are passed, an empty state is created, which is just a
  // shortcut for jQuery.bbq.pushState( {}, 2 ).
  // 
  // Usage:
  // 
  // > jQuery.bbq.removeState( [ key [, key ... ] ] );
  // 
  // Arguments:
  // 
  //  key - (String) One or more key values to remove from the current state,
  //    passed as individual arguments.
  //  key - (Array) A single array argument that contains a list of key values
  //    to remove from the current state.
  // 
  // Returns:
  // 
  //  Nothing.
  // 
  // Additional Notes:
  // 
  //  * Setting an empty state may cause the browser to scroll.
  
  jq_bbq.removeState = function( arr ) {
    var state = {};
    
    // If one or more arguments is passed..
    if ( arr !== undefined ) {
      
      // Get the current state.
      state = jq_bbq_getState();
      
      // For each passed key, delete the corresponding property from the current
      // state.
      $.each( $.isArray( arr ) ? arr : arguments, function(i,v){
        delete state[ v ];
      });
    }
    
    // Set the state, completely overriding any existing state.
    jq_bbq_pushState( state, 2 );
  };
  
  // Event: hashchange event (BBQ)
  // 
  // Usage in jQuery 1.4 and newer:
  // 
  // In jQuery 1.4 and newer, the event object passed into any hashchange event
  // callback is augmented with a copy of the location.hash fragment at the time
  // the event was triggered as its event.fragment property. In addition, the
  // event.getState method operates on this property (instead of location.hash)
  // which allows this fragment-as-a-state to be referenced later, even after
  // window.location may have changed.
  // 
  // Note that event.fragment and event.getState are not defined according to
  // W3C (or any other) specification, but will still be available whether or
  // not the hashchange event exists natively in the browser, because of the
  // utility they provide.
  // 
  // The event.fragment property contains the output of <jQuery.param.fragment>
  // and the event.getState method is equivalent to the <jQuery.bbq.getState>
  // method.
  // 
  // > $(window).bind( 'hashchange', function( event ) {
  // >   var hash_str = event.fragment,
  // >     param_obj = event.getState(),
  // >     param_val = event.getState( 'param_name' ),
  // >     param_val_coerced = event.getState( 'param_name', true );
  // >   ...
  // > });
  // 
  // Usage in jQuery 1.3.2:
  // 
  // In jQuery 1.3.2, the event object cannot to be augmented as in jQuery 1.4+,
  // so the fragment state isn't bound to the event object and must instead be
  // parsed using the <jQuery.param.fragment> and <jQuery.bbq.getState> methods.
  // 
  // > $(window).bind( 'hashchange', function( event ) {
  // >   var hash_str = $.param.fragment(),
  // >     param_obj = $.bbq.getState(),
  // >     param_val = $.bbq.getState( 'param_name' ),
  // >     param_val_coerced = $.bbq.getState( 'param_name', true );
  // >   ...
  // > });
  // 
  // Additional Notes:
  // 
  // * Due to changes in the special events API, jQuery BBQ v1.2 or newer is
  //   required to enable the augmented event object in jQuery 1.4.2 and newer.
  // * See <jQuery hashchange event> for more detailed information.
  
  jq_event_special[ str_hashchange ] = $.extend( jq_event_special[ str_hashchange ], {
    
    // Augmenting the event object with the .fragment property and .getState
    // method requires jQuery 1.4 or newer. Note: with 1.3.2, everything will
    // work, but the event won't be augmented)
    add: function( handleObj ) {
      var old_handler;
      
      function new_handler(e) {
        // e.fragment is set to the value of location.hash (with any leading #
        // removed) at the time the event is triggered.
        var hash = e[ str_fragment ] = jq_param_fragment();
        
        // e.getState() works just like $.bbq.getState(), but uses the
        // e.fragment property stored on the event object.
        e.getState = function( key, coerce ) {
          return key === undefined || typeof key === 'boolean'
            ? jq_deparam( hash, key ) // 'key' really means 'coerce' here
            : jq_deparam( hash, coerce )[ key ];
        };
        
        old_handler.apply( this, arguments );
      };
      
      // This may seem a little complicated, but it normalizes the special event
      // .add method between jQuery 1.4/1.4.1 and 1.4.2+
      if ( $.isFunction( handleObj ) ) {
        // 1.4, 1.4.1
        old_handler = handleObj;
        return new_handler;
      } else {
        // 1.4.2+
        old_handler = handleObj.handler;
        handleObj.handler = new_handler;
      }
    }
    
  });
  
})(jQuery,this);

/*!
 * jQuery hashchange event - v1.2 - 2/11/2010
 * http://benalman.com/projects/jquery-hashchange-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery hashchange event
//
// *Version: 1.2, Last updated: 2/11/2010*
// 
// Project Home - http://benalman.com/projects/jquery-hashchange-plugin/
// GitHub       - http://github.com/cowboy/jquery-hashchange/
// Source       - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.js
// (Minified)   - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.min.js (1.1kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// This working example, complete with fully commented code, illustrate one way
// in which this plugin can be used.
// 
// hashchange event - http://benalman.com/code/projects/jquery-hashchange/examples/hashchange/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.7, Safari 3-4, Chrome, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-hashchange/unit/
// 
// About: Known issues
// 
// While this jQuery hashchange event implementation is quite stable and robust,
// there are a few unfortunate browser bugs surrounding expected hashchange
// event-based behaviors, independent of any JavaScript window.onhashchange
// abstraction. See the following examples for more information:
// 
// Chrome: Back Button - http://benalman.com/code/projects/jquery-hashchange/examples/bug-chrome-back-button/
// Firefox: Remote XMLHttpRequest - http://benalman.com/code/projects/jquery-hashchange/examples/bug-firefox-remote-xhr/
// WebKit: Back Button in an Iframe - http://benalman.com/code/projects/jquery-hashchange/examples/bug-webkit-hash-iframe/
// Safari: Back Button from a different domain - http://benalman.com/code/projects/jquery-hashchange/examples/bug-safari-back-from-diff-domain/
// 
// About: Release History
// 
// 1.2   - (2/11/2010) Fixed a bug where coming back to a page using this plugin
//         from a page on another domain would cause an error in Safari 4. Also,
//         IE6/7 Iframe is now inserted after the body (this actually works),
//         which prevents the page from scrolling when the event is first bound.
//         Event can also now be bound before DOM ready, but it won't be usable
//         before then in IE6/7.
// 1.1   - (1/21/2010) Incorporated document.documentMode test to fix IE8 bug
//         where browser version is incorrectly reported as 8.0, despite
//         inclusion of the X-UA-Compatible IE=EmulateIE7 meta tag.
// 1.0   - (1/9/2010) Initial Release. Broke out the jQuery BBQ event.special
//         window.onhashchange functionality into a separate plugin for users
//         who want just the basic event & back button support, without all the
//         extra awesomeness that BBQ provides. This plugin will be included as
//         part of jQuery BBQ, but also be available separately.

(function($,window,undefined){
  '$:nomunge'; // Used by YUI compressor.
  
  // Method / object references.
  var fake_onhashchange,
    jq_event_special = $.event.special,
    
    // Reused strings.
    str_location = 'location',
    str_hashchange = 'hashchange',
    str_href = 'href',
    
    // IE6/7 specifically need some special love when it comes to back-button
    // support, so let's do a little browser sniffing..
    browser = $.browser,
    mode = document.documentMode,
    is_old_ie = browser.msie && ( mode === undefined || mode < 8 ),
    
    // Does the browser support window.onhashchange? Test for IE version, since
    // IE8 incorrectly reports this when in "IE7" or "IE8 Compatibility View"!
    supports_onhashchange = 'on' + str_hashchange in window && !is_old_ie;
  
  // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!
  function get_fragment( url ) {
    url = url || window[ str_location ][ str_href ];
    return url.replace( /^[^#]*#?(.*)$/, '$1' );
  };
  
  // Property: jQuery.hashchangeDelay
  // 
  // The numeric interval (in milliseconds) at which the <hashchange event>
  // polling loop executes. Defaults to 100.
  
  $[ str_hashchange + 'Delay' ] = 100;
  
  // Event: hashchange event
  // 
  // Fired when location.hash changes. In browsers that support it, the native
  // window.onhashchange event is used (IE8, FF3.6), otherwise a polling loop is
  // initialized, running every <jQuery.hashchangeDelay> milliseconds to see if
  // the hash has changed. In IE 6 and 7, a hidden Iframe is created to allow
  // the back button and hash-based history to work.
  // 
  // Usage:
  // 
  // > $(window).bind( 'hashchange', function(e) {
  // >   var hash = location.hash;
  // >   ...
  // > });
  // 
  // Additional Notes:
  // 
  // * The polling loop and Iframe are not created until at least one callback
  //   is actually bound to 'hashchange'.
  // * If you need the bound callback(s) to execute immediately, in cases where
  //   the page 'state' exists on page load (via bookmark or page refresh, for
  //   example) use $(window).trigger( 'hashchange' );
  // * The event can be bound before DOM ready, but since it won't be usable
  //   before then in IE6/7 (due to the necessary Iframe), recommended usage is
  //   to bind it inside a $(document).ready() callback.
  
  jq_event_special[ str_hashchange ] = $.extend( jq_event_special[ str_hashchange ], {
    
    // Called only when the first 'hashchange' event is bound to window.
    setup: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to create our own. And we don't want to call this
      // until the user binds to the event, just in case they never do, since it
      // will create a polling loop and possibly even a hidden Iframe.
      $( fake_onhashchange.start );
    },
    
    // Called only when the last 'hashchange' event is unbound from window.
    teardown: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to stop ours (if possible).
      $( fake_onhashchange.stop );
    }
    
  });
  
  // fake_onhashchange does all the work of triggering the window.onhashchange
  // event for browsers that don't natively support it, including creating a
  // polling loop to watch for hash changes and in IE 6/7 creating a hidden
  // Iframe to enable back and forward.
  fake_onhashchange = (function(){
    var self = {},
      timeout_id,
      iframe,
      set_history,
      get_history;
    
    // Initialize. In IE 6/7, creates a hidden Iframe for history handling.
    function init(){
      // Most browsers don't need special methods here..
      set_history = get_history = function(val){ return val; };
      
      // But IE6/7 do!
      if ( is_old_ie ) {
        
        // Create hidden Iframe after the end of the body to prevent initial
        // page load from scrolling unnecessarily.
        iframe = $('<iframe src="javascript:0"/>').hide().insertAfter( 'body' )[0].contentWindow;
        
        // Get history by looking at the hidden Iframe's location.hash.
        get_history = function() {
          return get_fragment( iframe.document[ str_location ][ str_href ] );
        };
        
        // Set a new history item by opening and then closing the Iframe
        // document, *then* setting its location.hash.
        set_history = function( hash, history_hash ) {
          if ( hash !== history_hash ) {
            var doc = iframe.document;
            doc.open().close();
            doc[ str_location ].hash = '#' + hash;
          }
        };
        
        // Set initial history.
        set_history( get_fragment() );
      }
    };
    
    // Start the polling loop.
    self.start = function() {
      // Polling loop is already running!
      if ( timeout_id ) { return; }
      
      // Remember the initial hash so it doesn't get triggered immediately.
      var last_hash = get_fragment();
      
      // Initialize if not yet initialized.
      set_history || init();
      
      // This polling loop checks every $.hashchangeDelay milliseconds to see if
      // location.hash has changed, and triggers the 'hashchange' event on
      // window when necessary.
      (function loopy(){
        var hash = get_fragment(),
          history_hash = get_history( last_hash );
        
        if ( hash !== last_hash ) {
          set_history( last_hash = hash, history_hash );
          
          $(window).trigger( str_hashchange );
          
        } else if ( history_hash !== last_hash ) {
          window[ str_location ][ str_href ] = window[ str_location ][ str_href ].replace( /#.*/, '' ) + '#' + history_hash;
        }
        
        timeout_id = setTimeout( loopy, $[ str_hashchange + 'Delay' ] );
      })();
    };
    
    // Stop the polling loop, but only if an IE6/7 Iframe wasn't created. In
    // that case, even if there are no longer any bound event handlers, the
    // polling loop is still necessary for back/next to work at all!
    self.stop = function() {
      if ( !iframe ) {
        timeout_id && clearTimeout( timeout_id );
        timeout_id = 0;
      }
    };
    
    return self;
  })();
  
})(jQuery,this);


//Ford chooses to use jQuery Validation and its associated components under the MIT license
(function(c){c.extend(c.fn,{validate:function(a){if(this.length){var b=c.data(this[0],"validator");if(b)return b;b=new c.validator(a,this[0]);c.data(this[0],"validator",b);if(b.settings.onsubmit){this.find("input, button").filter(".cancel").click(function(){b.cancelSubmit=true});b.settings.submitHandler&&this.find("input, button").filter(":submit").click(function(){b.submitButton=this});this.submit(function(d){function e(){if(b.settings.submitHandler){if(b.submitButton)var f=c("<input type='hidden'/>").attr("name",
b.submitButton.name).val(b.submitButton.value).appendTo(b.currentForm);b.settings.submitHandler.call(b,b.currentForm);b.submitButton&&f.remove();return false}return true}b.settings.debug&&d.preventDefault();if(b.cancelSubmit){b.cancelSubmit=false;return e()}if(b.form()){if(b.pendingRequest){b.formSubmitted=true;return false}return e()}else{b.focusInvalid();return false}})}return b}else a&&a.debug&&window.console&&console.warn("nothing selected, can't validate, returning nothing")},valid:function(){if(c(this[0]).is("form"))return this.validate().form();
else{var a=true,b=c(this[0].form).validate();this.each(function(){a&=b.element(this)});return a}},removeAttrs:function(a){var b={},d=this;c.each(a.split(/\s/),function(e,f){b[f]=d.attr(f);d.removeAttr(f)});return b},rules:function(a,b){var d=this[0];if(a){var e=c.data(d.form,"validator").settings,f=e.rules,g=c.validator.staticRules(d);switch(a){case "add":c.extend(g,c.validator.normalizeRule(b));f[d.name]=g;if(b.messages)e.messages[d.name]=c.extend(e.messages[d.name],b.messages);break;case "remove":if(!b){delete f[d.name];
return g}var h={};c.each(b.split(/\s/),function(j,i){h[i]=g[i];delete g[i]});return h}}d=c.validator.normalizeRules(c.extend({},c.validator.metadataRules(d),c.validator.classRules(d),c.validator.attributeRules(d),c.validator.staticRules(d)),d);if(d.required){e=d.required;delete d.required;d=c.extend({required:e},d)}return d}});c.extend(c.expr[":"],{blank:function(a){return!c.trim(""+a.value)},filled:function(a){return!!c.trim(""+a.value)},unchecked:function(a){return!a.checked}});c.validator=function(a,
b){this.settings=c.extend(true,{},c.validator.defaults,a);this.currentForm=b;this.init()};c.validator.format=function(a,b){if(arguments.length==1)return function(){var d=c.makeArray(arguments);d.unshift(a);return c.validator.format.apply(this,d)};if(arguments.length>2&&b.constructor!=Array)b=c.makeArray(arguments).slice(1);if(b.constructor!=Array)b=[b];c.each(b,function(d,e){a=a.replace(RegExp("\\{"+d+"\\}","g"),e)});return a};c.extend(c.validator,{defaults:{messages:{},groups:{},rules:{},errorClass:"error",
validClass:"valid",errorElement:"label",focusInvalid:true,errorContainer:c([]),errorLabelContainer:c([]),onsubmit:true,ignore:[],ignoreTitle:false,onfocusin:function(a){this.lastActive=a;if(this.settings.focusCleanup&&!this.blockFocusCleanup){this.settings.unhighlight&&this.settings.unhighlight.call(this,a,this.settings.errorClass,this.settings.validClass);this.addWrapper(this.errorsFor(a)).hide()}},onfocusout:function(a){if(!this.checkable(a)&&(a.name in this.submitted||!this.optional(a)))this.element(a)},
onkeyup:function(a){if(a.name in this.submitted||a==this.lastElement)this.element(a)},onclick:function(a){if(a.name in this.submitted)this.element(a);else a.parentNode.name in this.submitted&&this.element(a.parentNode)},highlight:function(a,b,d){c(a).addClass(b).removeClass(d)},unhighlight:function(a,b,d){c(a).removeClass(b).addClass(d)}},setDefaults:function(a){c.extend(c.validator.defaults,a)},messages:{required:"This field is required.",remote:"Please fix this field.",email:"Please enter a valid email address.",
url:"Please enter a valid URL.",date:"Please enter a valid date.",dateISO:"Please enter a valid date (ISO).",number:"Please enter a valid number.",digits:"Please enter only digits.",creditcard:"Please enter a valid credit card number.",equalTo:"Please enter the same value again.",accept:"Please enter a value with a valid extension.",maxlength:c.validator.format("Please enter no more than {0} characters."),minlength:c.validator.format("Please enter at least {0} characters."),rangelength:c.validator.format("Please enter a value between {0} and {1} characters long."),
range:c.validator.format("Please enter a value between {0} and {1}."),max:c.validator.format("Please enter a value less than or equal to {0}."),min:c.validator.format("Please enter a value greater than or equal to {0}.")},autoCreateRanges:false,prototype:{init:function(){function a(e){var f=c.data(this[0].form,"validator");e="on"+e.type.replace(/^validate/,"");f.settings[e]&&f.settings[e].call(f,this[0])}this.labelContainer=c(this.settings.errorLabelContainer);this.errorContext=this.labelContainer.length&&
this.labelContainer||c(this.currentForm);this.containers=c(this.settings.errorContainer).add(this.settings.errorLabelContainer);this.submitted={};this.valueCache={};this.pendingRequest=0;this.pending={};this.invalid={};this.reset();var b=this.groups={};c.each(this.settings.groups,function(e,f){c.each(f.split(/\s/),function(g,h){b[h]=e})});var d=this.settings.rules;c.each(d,function(e,f){d[e]=c.validator.normalizeRule(f)});c(this.currentForm).validateDelegate(":text, :password, :file, select, textarea",
"focusin focusout keyup",a).validateDelegate(":radio, :checkbox, select, option","click",a);this.settings.invalidHandler&&c(this.currentForm).bind("invalid-form.validate",this.settings.invalidHandler)},form:function(){this.checkForm();c.extend(this.submitted,this.errorMap);this.invalid=c.extend({},this.errorMap);this.valid()||c(this.currentForm).triggerHandler("invalid-form",[this]);this.showErrors();return this.valid()},checkForm:function(){this.prepareForm();for(var a=0,b=this.currentElements=this.elements();b[a];a++)this.check(b[a]);
return this.valid()},element:function(a){this.lastElement=a=this.clean(a);this.prepareElement(a);this.currentElements=c(a);var b=this.check(a);if(b)delete this.invalid[a.name];else this.invalid[a.name]=true;if(!this.numberOfInvalids())this.toHide=this.toHide.add(this.containers);this.showErrors();return b},showErrors:function(a){if(a){c.extend(this.errorMap,a);this.errorList=[];for(var b in a)this.errorList.push({message:a[b],element:this.findByName(b)[0]});this.successList=c.grep(this.successList,
function(d){return!(d.name in a)})}this.settings.showErrors?this.settings.showErrors.call(this,this.errorMap,this.errorList):this.defaultShowErrors()},resetForm:function(){c.fn.resetForm&&c(this.currentForm).resetForm();this.submitted={};this.prepareForm();this.hideErrors();this.elements().removeClass(this.settings.errorClass)},numberOfInvalids:function(){return this.objectLength(this.invalid)},objectLength:function(a){var b=0,d;for(d in a)b++;return b},hideErrors:function(){this.addWrapper(this.toHide).hide()},
valid:function(){return this.size()==0},size:function(){return this.errorList.length},focusInvalid:function(){if(this.settings.focusInvalid)try{c(this.findLastActive()||this.errorList.length&&this.errorList[0].element||[]).filter(":visible").focus().trigger("focusin")}catch(a){}},findLastActive:function(){var a=this.lastActive;return a&&c.grep(this.errorList,function(b){return b.element.name==a.name}).length==1&&a},elements:function(){var a=this,b={};return c([]).add(this.currentForm.elements).filter(":input").not(":submit, :reset, :image, [disabled]").not(this.settings.ignore).filter(function(){!this.name&&
a.settings.debug&&window.console&&console.error("%o has no name assigned",this);if(this.name in b||!a.objectLength(c(this).rules()))return false;return b[this.name]=true})},clean:function(a){return c(a)[0]},errors:function(){return c(this.settings.errorElement+"."+this.settings.errorClass,this.errorContext)},reset:function(){this.successList=[];this.errorList=[];this.errorMap={};this.toShow=c([]);this.toHide=c([]);this.currentElements=c([])},prepareForm:function(){this.reset();this.toHide=this.errors().add(this.containers)},
prepareElement:function(a){this.reset();this.toHide=this.errorsFor(a)},check:function(a){a=this.clean(a);if(this.checkable(a))a=this.findByName(a.name).not(this.settings.ignore)[0];var b=c(a).rules(),d=false,e;for(e in b){var f={method:e,parameters:b[e]};try{var g=c.validator.methods[e].call(this,a.value.replace(/\r/g,""),a,f.parameters);if(g=="dependency-mismatch")d=true;else{d=false;if(g=="pending"){this.toHide=this.toHide.not(this.errorsFor(a));return}if(!g){this.formatAndAdd(a,f);return false}}}catch(h){this.settings.debug&&
window.console&&console.log("exception occured when checking element "+a.id+", check the '"+f.method+"' method",h);throw h;}}if(!d){this.objectLength(b)&&this.successList.push(a);return true}},customMetaMessage:function(a,b){if(c.metadata){var d=this.settings.meta?c(a).metadata()[this.settings.meta]:c(a).metadata();return d&&d.messages&&d.messages[b]}},customMessage:function(a,b){var d=this.settings.messages[a];return d&&(d.constructor==String?d:d[b])},findDefined:function(){for(var a=0;a<arguments.length;a++)if(arguments[a]!==
undefined)return arguments[a]},defaultMessage:function(a,b){return this.findDefined(this.customMessage(a.name,b),this.customMetaMessage(a,b),!this.settings.ignoreTitle&&a.title||undefined,c.validator.messages[b],"<strong>Warning: No message defined for "+a.name+"</strong>")},formatAndAdd:function(a,b){var d=this.defaultMessage(a,b.method),e=/\$?\{(\d+)\}/g;if(typeof d=="function")d=d.call(this,b.parameters,a);else if(e.test(d))d=jQuery.format(d.replace(e,"{$1}"),b.parameters);this.errorList.push({message:d,
element:a});this.errorMap[a.name]=d;this.submitted[a.name]=d},addWrapper:function(a){if(this.settings.wrapper)a=a.add(a.parent(this.settings.wrapper));return a},defaultShowErrors:function(){for(var a=0;this.errorList[a];a++){var b=this.errorList[a];this.settings.highlight&&this.settings.highlight.call(this,b.element,this.settings.errorClass,this.settings.validClass);this.showLabel(b.element,b.message)}if(this.errorList.length)this.toShow=this.toShow.add(this.containers);if(this.settings.success)for(a=
0;this.successList[a];a++)this.showLabel(this.successList[a]);if(this.settings.unhighlight){a=0;for(b=this.validElements();b[a];a++)this.settings.unhighlight.call(this,b[a],this.settings.errorClass,this.settings.validClass)}this.toHide=this.toHide.not(this.toShow);this.hideErrors();this.addWrapper(this.toShow).show()},validElements:function(){return this.currentElements.not(this.invalidElements())},invalidElements:function(){return c(this.errorList).map(function(){return this.element})},showLabel:function(a,
b){var d=this.errorsFor(a);if(d.length){d.removeClass().addClass(this.settings.errorClass);d.attr("generated")&&d.html(b)}else{d=c("<"+this.settings.errorElement+"/>").attr({"for":this.idOrName(a),generated:true}).addClass(this.settings.errorClass).html(b||"");if(this.settings.wrapper)d=d.hide().show().wrap("<"+this.settings.wrapper+"/>").parent();this.labelContainer.append(d).length||(this.settings.errorPlacement?this.settings.errorPlacement(d,c(a)):d.insertAfter(a))}if(!b&&this.settings.success){d.text("");
typeof this.settings.success=="string"?d.addClass(this.settings.success):this.settings.success(d)}this.toShow=this.toShow.add(d)},errorsFor:function(a){var b=this.idOrName(a);return this.errors().filter(function(){return c(this).attr("for")==b})},idOrName:function(a){return this.groups[a.name]||(this.checkable(a)?a.name:a.id||a.name)},checkable:function(a){return/radio|checkbox/i.test(a.type)},findByName:function(a){var b=this.currentForm;return c(document.getElementsByName(a)).map(function(d,e){return e.form==
b&&e.name==a&&e||null})},getLength:function(a,b){switch(b.nodeName.toLowerCase()){case "select":return c("option:selected",b).length;case "input":if(this.checkable(b))return this.findByName(b.name).filter(":checked").length}return a.length},depend:function(a,b){return this.dependTypes[typeof a]?this.dependTypes[typeof a](a,b):true},dependTypes:{"boolean":function(a){return a},string:function(a,b){return!!c(a,b.form).length},"function":function(a,b){return a(b)}},optional:function(a){return!c.validator.methods.required.call(this,
c.trim(a.value),a)&&"dependency-mismatch"},startRequest:function(a){if(!this.pending[a.name]){this.pendingRequest++;this.pending[a.name]=true}},stopRequest:function(a,b){this.pendingRequest--;if(this.pendingRequest<0)this.pendingRequest=0;delete this.pending[a.name];if(b&&this.pendingRequest==0&&this.formSubmitted&&this.form()){c(this.currentForm).submit();this.formSubmitted=false}else if(!b&&this.pendingRequest==0&&this.formSubmitted){c(this.currentForm).triggerHandler("invalid-form",[this]);this.formSubmitted=
false}},previousValue:function(a){return c.data(a,"previousValue")||c.data(a,"previousValue",{old:null,valid:true,message:this.defaultMessage(a,"remote")})}},classRuleSettings:{required:{required:true},email:{email:true},url:{url:true},date:{date:true},dateISO:{dateISO:true},dateDE:{dateDE:true},number:{number:true},numberDE:{numberDE:true},digits:{digits:true},creditcard:{creditcard:true}},addClassRules:function(a,b){a.constructor==String?this.classRuleSettings[a]=b:c.extend(this.classRuleSettings,
a)},classRules:function(a){var b={};(a=c(a).attr("class"))&&c.each(a.split(" "),function(){this in c.validator.classRuleSettings&&c.extend(b,c.validator.classRuleSettings[this])});return b},attributeRules:function(a){var b={};a=c(a);for(var d in c.validator.methods){var e=a.attr(d);if(e)b[d]=e}b.maxlength&&/-1|2147483647|524288/.test(b.maxlength)&&delete b.maxlength;return b},metadataRules:function(a){if(!c.metadata)return{};var b=c.data(a.form,"validator").settings.meta;return b?c(a).metadata()[b]:
c(a).metadata()},staticRules:function(a){var b={},d=c.data(a.form,"validator");if(d.settings.rules)b=c.validator.normalizeRule(d.settings.rules[a.name])||{};return b},normalizeRules:function(a,b){c.each(a,function(d,e){if(e===false)delete a[d];else if(e.param||e.depends){var f=true;switch(typeof e.depends){case "string":f=!!c(e.depends,b.form).length;break;case "function":f=e.depends.call(b,b)}if(f)a[d]=e.param!==undefined?e.param:true;else delete a[d]}});c.each(a,function(d,e){a[d]=c.isFunction(e)?
e(b):e});c.each(["minlength","maxlength","min","max"],function(){if(a[this])a[this]=Number(a[this])});c.each(["rangelength","range"],function(){if(a[this])a[this]=[Number(a[this][0]),Number(a[this][1])]});if(c.validator.autoCreateRanges){if(a.min&&a.max){a.range=[a.min,a.max];delete a.min;delete a.max}if(a.minlength&&a.maxlength){a.rangelength=[a.minlength,a.maxlength];delete a.minlength;delete a.maxlength}}a.messages&&delete a.messages;return a},normalizeRule:function(a){if(typeof a=="string"){var b=
{};c.each(a.split(/\s/),function(){b[this]=true});a=b}return a},addMethod:function(a,b,d){c.validator.methods[a]=b;c.validator.messages[a]=d!=undefined?d:c.validator.messages[a];b.length<3&&c.validator.addClassRules(a,c.validator.normalizeRule(a))},methods:{required:function(a,b,d){if(!this.depend(d,b))return"dependency-mismatch";switch(b.nodeName.toLowerCase()){case "select":return(a=c(b).val())&&a.length>0;case "input":if(this.checkable(b))return this.getLength(a,b)>0;default:return c.trim(a).length>
0}},remote:function(a,b,d){if(this.optional(b))return"dependency-mismatch";var e=this.previousValue(b);this.settings.messages[b.name]||(this.settings.messages[b.name]={});e.originalMessage=this.settings.messages[b.name].remote;this.settings.messages[b.name].remote=e.message;d=typeof d=="string"&&{url:d}||d;if(this.pending[b.name])return"pending";if(e.old===a)return e.valid;e.old=a;var f=this;this.startRequest(b);var g={};g[b.name]=a;c.ajax(c.extend(true,{url:d,mode:"abort",port:"validate"+b.name,
dataType:"json",data:g,success:function(h){f.settings.messages[b.name].remote=e.originalMessage;var j=h===true;if(j){var i=f.formSubmitted;f.prepareElement(b);f.formSubmitted=i;f.successList.push(b);f.showErrors()}else{i={};h=h||f.defaultMessage(b,"remote");i[b.name]=e.message=c.isFunction(h)?h(a):h;f.showErrors(i)}e.valid=j;f.stopRequest(b,j)}},d));return"pending"},minlength:function(a,b,d){return this.optional(b)||this.getLength(c.trim(a),b)>=d},maxlength:function(a,b,d){return this.optional(b)||
this.getLength(c.trim(a),b)<=d},rangelength:function(a,b,d){a=this.getLength(c.trim(a),b);return this.optional(b)||a>=d[0]&&a<=d[1]},min:function(a,b,d){return this.optional(b)||a>=d},max:function(a,b,d){return this.optional(b)||a<=d},range:function(a,b,d){return this.optional(b)||a>=d[0]&&a<=d[1]},email:function(a,b){return this.optional(b)||/^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i.test(a)},
url:function(a,b){return this.optional(b)||/^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(a)},
date:function(a,b){return this.optional(b)||!/Invalid|NaN/.test(new Date(a))},dateISO:function(a,b){return this.optional(b)||/^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(a)},number:function(a,b){return this.optional(b)||/^-?(?:\d+|\d{1,3}(?:,\d{3})+)(?:\.\d+)?$/.test(a)},digits:function(a,b){return this.optional(b)||/^\d+$/.test(a)},creditcard:function(a,b){if(this.optional(b))return"dependency-mismatch";if(/[^0-9-]+/.test(a))return false;var d=0,e=0,f=false;a=a.replace(/\D/g,"");for(var g=a.length-1;g>=
0;g--){e=a.charAt(g);e=parseInt(e,10);if(f)if((e*=2)>9)e-=9;d+=e;f=!f}return d%10==0},accept:function(a,b,d){d=typeof d=="string"?d.replace(/,/g,"|"):"png|jpe?g|gif";return this.optional(b)||a.match(RegExp(".("+d+")$","i"))},equalTo:function(a,b,d){d=c(d).unbind(".validate-equalTo").bind("blur.validate-equalTo",function(){c(b).valid()});return a==d.val()}}});c.format=c.validator.format})(jQuery);
(function(c){var a={};if(c.ajaxPrefilter)c.ajaxPrefilter(function(d,e,f){e=d.port;if(d.mode=="abort"){a[e]&&a[e].abort();a[e]=f}});else{var b=c.ajax;c.ajax=function(d){var e=("port"in d?d:c.ajaxSettings).port;if(("mode"in d?d:c.ajaxSettings).mode=="abort"){a[e]&&a[e].abort();return a[e]=b.apply(this,arguments)}return b.apply(this,arguments)}}})(jQuery);
(function(c){!jQuery.event.special.focusin&&!jQuery.event.special.focusout&&document.addEventListener&&c.each({focus:"focusin",blur:"focusout"},function(a,b){function d(e){e=c.event.fix(e);e.type=b;return c.event.handle.call(this,e)}c.event.special[b]={setup:function(){this.addEventListener(a,d,true)},teardown:function(){this.removeEventListener(a,d,true)},handler:function(e){arguments[0]=c.event.fix(e);arguments[0].type=b;return c.event.handle.apply(this,arguments)}}});c.extend(c.fn,{validateDelegate:function(a,
b,d){return this.bind(b,function(e){var f=c(e.target);if(f.is(a))return d.apply(f,arguments)})}})})(jQuery);




jQuery.reel || (function($, window, document, undefined){

  $.reel= {
    version: '1.1.4',

    // Options defaults
    def: {
      footage:            6, // number of frames per line/column
      frame:              1, // initial frame
      frames:            36, // total number of frames; every 10? for full rotation
      hint:              '', // mouse-sensitive area hint tooltip
      horizontal:      true, // roll flow; defaults to horizontal
      hotspot:    undefined, // [deprecated] use `area` instead
      indicator:          0, // size of a visual indicator of reeling (in pixels)
      klass:             '', // plugin instance class name
      loops:           true, // is it a loop?
      reversed:   undefined, // [deprecated] use `cw` instead
      spacing:            0, // space between frames on reel
      stitched:           0, // pixel width (length) of a stitched (rectilinear) panoramic reel
      suffix:       '-reel', // sprite filename suffix (A.jpg's sprite is A-reel.jpg by default)
      tooltip:           '', // [deprecated] use `hint` instead

      // [NEW] in version 1.1
      area:       undefined, // custom mouse-sensitive area jQuery collection
      brake:            0.5, // brake force of the inertial rotation
      clickfree:      false, // binds to mouse leave/enter events instead of down/up
      cw:             false, // true for clockwise organization of sprite
      delay:             -1, // delay before autoplay in seconds (no autoplay by default (-1))
      directional:    false, // two sets of frames (for forward and backward motion) are used when true
      draggable:       true, // mouse or finger drag interaction (allowed by default)
      entry:      undefined, // speed of the opening animation (Hz, defaults to value of `speed`)
      graph:      undefined, // custom graph function
      image:      undefined, // image sprite to be used
      images:            [], // sequence array of individual images to be used instead of sprite
      inversed:       false, // flags inversed organization of frames in orbital object movie
      laziness:           6, // on "lazy" devices tempo is divided by this divisor for better performace
      monitor:    undefined, // stored value name to monitor in the upper left corner of the viewport
      opening:            0, // duration of opening animation (in seconds)
      orbital:            0, // view centering tolerance in frames for dual-orbit object movies
      path:              '', // URL path to be prepended to `image` or `images` filenames
      preloader:          4, // size (height) of a image loading indicator (in pixels)
      rebound:          0.5, // time spent on the edge (in seconds) of a non-looping panorama before it bounces back
      revolution: undefined, // distance mouse must be dragged for full revolution
                             // (defaults to double the viewport size or half the `stitched` option)
      row:                1, // initial row
      rows:               0, // number of rows for a multi-row setup (zero from one-row setup)
      speed:              0, // animated rotation speed in revolutions per second (Hz)
      step:       undefined, // initial step (overrides `frame`)
      steps:      undefined, // number of steps a revolution is divided in (by default equal to `frames`)
      tempo:             36, // shared ticker tempo in ticks per second
      timeout:            2, // idle timeout in seconds
      throwable:       true, // drag & throw interaction (allowed by default)
      vertical:       false, // switches orbital object movie to vertical mode
      wheelable:       true  // mouse wheel interaction (allowed by default)
    }
    // [deprecated] options defaults may be gone anytime soon
  }

  $.fn.reel= function(options){
    var
      opt= $.extend({}, $.reel.def, options),
      applicable= (function(tags){
        // Only IMG tags with non-empty SRC and non-zero WIDTH and HEIGHT will pass
        var
          pass= []
        tags.filter(_img_).each(function(ix){
          var
            $this= $(this),
            src= opt.images.length && opt.images || opt.image || $this.attr(_src_),
            width= number($this.css(_width_)),
            height= number($this.css(_height_))
          if (!src || src == __ || !width || !height) return;
          pass.push($this);
        });
        tags.filter(_div_ + dot(klass)).each(function(ix){
          pass.push($(this));
        });
        return $(pass);
      })(this),
      instances= []

    // Backward-compatibility of [deprecated] legacy options
    opt.reversed && (opt.cw= true);
    opt.tooltip && (opt.hint= opt.tooltip);
    opt.hotspot && (opt.area= opt.hotspot);

    applicable.each(function(){
      var
        t= $(this),
        data= t.data(),

        // Data storage
        set= function(name, value){
          data[name]= value;
          t.trigger('store', [name, value]);
          return value;
        },
        get= function(name){
          var value= data[name];
          t.trigger('recall', [name, value]);
          return value;
        },

        // Events & handlers
          setup= function(e){
          /*
          - fills up the data storage with values based on options
          - binds to ticker
          */
            if (t.hasClass(klass)) return cleanup.call(e);
            var
              src= t.attr(_src_),
              id= set(_id_, t.attr(_id_) || t.attr(_id_, klass+'-'+(+new Date())).attr(_id_)),
              styles= t.attr('style'),
              images= opt.images,
              stitched= opt.stitched,
              loops= opt.loops,
              size= { x: number(t.css(_width_)), y: number(t.css(_height_)) },
              frames= set(_frames_, opt.orbital && opt.footage || opt.rows <= 1 && images.length || opt.frames),
              rows= stitched ? 1 : ceil(frames / opt.footage),
              style= {
                display: 'block',
                width: size.x,
                height: size.y
              },
              stage_id= '#'+id+opt.suffix,
              classes= t.attr('class'),
              overlay_css= { position: 'relative', width: size.x, height: size.y },
              $overlay= $(_div_tag_, { id: stage_id.substr(1), 'class': classes+___+overlay_klass, css: overlay_css }),
              $instance= t.wrap($overlay).attr({ 'class': klass }).css(style).bind(on),
              instances_count= instances.push(add_instance($instance)[0])
            set(_image_, images.length && images.length || opt.image || src.replace(/^(.*)\.(jpg|jpeg|png|gif)$/, '$1' + opt.suffix + '.$2'));
            set(_classes_, classes);
            set(_frame_, opt.frame);
            set(_spacing_, opt.spacing);
            set(_dimensions_, size);
            set(_fraction_, 0);
            set(_steps_, opt.steps || opt.frames);
            set(_revolution_, opt.revolution || stitched / 2 || size.x * 2);
            set(_rows_, rows);
            set(_bit_, 1 / (frames - (loops && !stitched ? 0 : 1)));
            set(_wheel_step_, 1 / max(frames, get(_steps_)));
            set(_stitched_, stitched);
            set(_stitched_travel_, stitched - (loops ? 0 : size.x));
            set(_stage_, stage_id);
            set(_backwards_, set(_speed_, opt.speed) < 0);
            set(_velocity_, 0);
            set(_vertical_, opt.vertical);
            set(_row_, (opt.row - 1) / (opt.rows - 1));
            set(_cwish_, negative_when(1, !opt.cw && !stitched));
            set(_reeling_, false);
            set(_brake_, opt.brake);
            set(_center_, !!opt.orbital);
            set(_tempo_, opt.tempo / ($.reel.lazy? opt.laziness : 1));
            set(_opening_ticks_, 0);
            set(_backup_, {
              src: src,
              style: styles || __
            });
            pool.bind(_tick_, on.tick);
            cleanup.call(e);
            t.trigger('setup');
          },
        on= {
          teardown: function(e){
          /*
          - unbinds events, erases all state data
          - reconstructs the original DOM element
          */
            // get rid of Reel's own events
            t.unbind(ns).unbind(on);
            var
              events= t.data('events'),
              // clone & restore the original
              $original= t.clone()
              .attr(t.data(_backup_))
              .css({ background: 'transparent' })
              .removeClass(klass).addClass(get(_classes_));
            // clone original events (inspired by Brandon Aaron's copyEvents plugin)
            for (var type in events) $.each(events[type], function(ix, handler){
              // for this we need the 1.4.2+ version
              $original.bind(type+'.'+handler.namespace, handler.handler, handler.data);
            });
            $('img:'+_hidden_, t.parent()).remove();
            remove_instance(t);
            // replace stage with the original
            $(get(_stage_)).before($original).detach();
            no_bias();
            pool
            .unbind(_tick_, on.tick)
            .unbind(_tick_, on.opening_tick);
            stage_pool
            .unbind(_mouseup_).unbind(_mousemove_);
            cleanup.call(e);
          },
          setup: function(e){
          /*
          - binds all mouse/touch events (namespaced)
          - prepares stage overlay elements
          - preloads images if needed
          */
            var
              space= get(_dimensions_),
              frames= get(_frames_),
              resolution= max(frames, get(_steps_)),
              fraction= set(_fraction_, 1 / resolution * ((opt.step || opt.frame) - 1)),
              frame= set(_frame_, fraction * frames + 1),
              loaded= 0,
              id= t.attr('id'),
              $overlay= t.parent(),
              $hi= $(_div_tag_, { 'class': hi_klass,
                css: { position: _absolute_, left: 0, top: 0, width: space.x, height: space.y, background: _hex_black_, opacity: 0 }
              }).appendTo($overlay),
              area= set(_area_, $(opt.area || $hi ))
            if ($.reel.touchy){
              // workaround for downsizing-sprites-bug-in-iPhoneOS inspired by Katrin Ackermann
              t.css({ WebkitUserSelect: 'none', WebkitBackgroundSize: opt.images.length
                ? 'auto'
                : (get(_stitched_) && get(_stitched_)+'px '+space.y+'px')
                || (space.x * opt.footage)+'px '+(space.y * get(_rows_) * (opt.rows || 1) * (opt.directional? 2:1))+'px'
              });
              area
                .bind(_touchstart_, function(e){ t.trigger('down', [finger(e).clientX, finger(e).clientY, true]); })
                .bind(_touchmove_, function(e){ t.trigger('slide', [finger(e).clientX, finger(e).clientY, true]); return !(opt.rows > 1 || opt.orbital || get(_reeling_)) })
                .bind(_touchend_, function(e){ t.trigger('up', [true]); return false })
                .bind(_touchcancel_, function(e){ t.trigger('up', [true]); return false })
            }else{
              area
                .css({ cursor: 'url('+drag_cursor+'), '+failsafe_cursor })
                .bind(_mousewheel_, function(e, delta){ t.trigger('wheel', [delta]); return false })
                .bind(_dblclick_, function(e){ t.trigger('play') })
                .bind(opt.clickfree ? _mouseenter_ : _mousedown_, function(e){ t.trigger('down', [e.clientX, e.clientY]); return false })
                .bind(opt.clickfree ? _mouseleave_ : '', function(e){ t.trigger('up'); return false })
                .disableTextSelect();
            }
            (opt.hint) && area.attr(_title_, opt.hint);
            opt.monitor && $overlay.append($monitor= $(_div_tag_, {
              'class': monitor_klass,
              css: { position: _absolute_, left: 0, top: 0 }
            })) || ($monitor= $());
            opt.indicator && $overlay.append(indicator('x'));
            opt.rows > 1 && opt.indicator && $overlay.append(indicator('y'));
            t.trigger('preload');
          },
          preload: function(e){
          /*
          - preloads all frames and sprites
          */
            var
              space= get(_dimensions_),
              $overlay= t.parent(),
              image= get(_image_),
              images= opt.images,
              preload= !images.length ? [image] : new Array().concat(images),
              img_tag= t[0],
              img_frames= img_tag.frames= preload.length,
              img_preloaded= img_tag.preloaded= 0
            t.trigger('stop');
            $overlay.append($preloader= $(_div_tag_, { 'class': preloader_klass,
              css: {
                position: _absolute_,
                left: 0,
                top: space.y - opt.preloader,
                height: opt.preloader,
                overflow: _hidden_,
                backgroundColor: _hex_black_
              }
            }));
            while(preload.length){
              var
                uri= opt.path+preload.shift(),
                $img= $(new Image()).hide().bind('load'+ns, function update_preloader(){
                  img_tag.preloaded++
                  $(this).unbind(ns);
                  $preloader.css({ width: 1 / img_tag.frames * img_tag.preloaded * space.x })
                  if (img_tag.frames == img_tag.preloaded){
                    $preloader.remove();
                    images.length || t.css({ backgroundImage: url(opt.path+image) });
                    t
                    .attr({ src: transparent })
                    .trigger(opt.rows > 1 && !opt.stitched ? 'rowChange' : 'frameChange')
                    .trigger('loaded')
                    .trigger('opening');
                    cleanup.call(e);
                  }
                });
              $overlay.append($img);
              // The actual loading of the image is done asynchronously
              setTimeout((function($img, uri){ return function(){ $img.attr({ src: uri }) } })($img, uri), 0);
            }
          },
          tick: function(e){
          /*
          - triggered by pool's `tick.reel` event
          - keeps track of operated and braked statuses
          - decreases inertial velocity by braking
          */
            var
              velocity= get(_velocity_)
            if (braking) var
              braked= lofi(velocity - (get(_brake_) / leader(_tempo_) * braking)),
              done= velocity * braked <= 0 || velocity < abs(braked),
              velocity= !done && set(_velocity_, velocity > abs(get(_speed_)) ? braked : (braking= operated= 0))
            $monitor.text(get(opt.monitor));
            velocity && braking++;
            operated && operated++;
            to_bias(0);
            slidable= true;
            if (operated && !velocity) return cleanup.call(e);
            if (get(_clicked_)) return cleanup.call(e, unidle());
            var
              backwards= get(_cwish_) * negative_when(1, get(_backwards_)),
              step= (get(_stopped_) ? velocity : abs(get(_speed_)) + velocity) / leader(_tempo_),
              was= get(_fraction_),
              fraction= set(_fraction_, was - step * backwards)
            cleanup.call(e);
            if (fraction == was) return;
            t.trigger('fractionChange');
          },
          opening: function(e){
          /*
          - initiates opening animation
          - or simply plays the reel when without opening
          */
            var
              speed= opt.entry || opt.speed,
              end= get(_fraction_),
              duration= opt.opening,
              start= set(_fraction_, end - speed * opt.opening),
              ticks= set(_opening_ticks_, duration * leader(_tempo_))
            pool.bind(_tick_, on.opening_tick);
          },
          opening_tick: function(e){
          /*
          - ticker listener dedicated to opening animation
          */
            var
              speed= opt.entry || opt.speed,
              step= speed / leader(_tempo_) * (opt.cw? -1:1),
              was= get(_fraction_),
              fraction= set(_fraction_, lofi(was + step)),
              ticks= set(_opening_ticks_, get(_opening_ticks_) - 1)
            t.trigger('fractionChange');
            cleanup.call(e);
            if (ticks > 1) return;

            pool.unbind(_tick_, on.opening_tick);
            delay_play();
          },
          play: function(e, direction){
            var
              playing= set(_playing_, true),
              stopped= set(_stopped_, !playing)
            idle();
            cleanup.call(e);
          },
          pause: function(e){
            var
              playing= set(_playing_, false)
            unidle();
            cleanup.call(e);
          },
          stop: function(e){
            var
              stopped= set(_stopped_, true),
              playing= set(_playing_, !stopped)
            cleanup.call(e);
          },
          down: function(e, x, y, touched){
          /*
          - starts the dragging operation by binding dragging events to the pool
          */
            if (opt.draggable){
              var
                clicked= set(_clicked_, get(_frame_)),
                velocity= set(_velocity_, 0),
                origin= last= recenter_mouse(x, y, get(_fraction_), get(_revolution_), get(_row_))
              unidle();
              no_bias();
              if (!touched){
                stage_pool
                .css({ cursor: url(drag_cursor_down)+', '+failsafe_cursor })
                .bind(_mousemove_, function(e){ t.trigger('slide', [e.clientX, e.clientY]); cleanup.call(e); return false })
                opt.clickfree || stage_pool.bind(_mouseup_, function(e){ t.trigger('up'); cleanup.call(e) })
              }
            }
            cleanup.call(e);
          },
          up: function(e, touched){
          /*
          - ends dragging operation by calculating velocity by summing the bias
          - unbinds dragging events from pool
          - resets the mouse cursor
          */
            if (!opt.draggable) return cleanup.call(e);
            var
              clicked= set(_clicked_, false),
              reeling= set(_reeling_, false),
              velocity= set(_velocity_, !opt.throwable ? 0 : abs(bias[0] + bias[1]) / 60),
              brakes= braking= velocity ? 1 : 0
            velocity ? idle() : unidle();
            no_bias();
            !touched
            && stage_pool.unbind(_mouseup_).unbind(_mousemove_)
            && get(_area_).css({ cursor: url(drag_cursor)+', '+failsafe_cursor });
            cleanup.call(e);
          },
          slide: function(e, x, y, touched){
          /*
          - calculates the X distance from drag center and applies graph on it to get fraction
          - recenters the drag when dragged over limits
          - detects the direction of the motion
          - builds inertial motion bias
          - (`slide` was originally `drag` which conflicted with MSIE)
          */
            if (opt.draggable && slidable){
              // by checking slidable sync with the ticker tempo is achieved
              slidable= false;
              unidle();
              var
                delta= { x: x - last.x, y: y - last.y }
              if (abs(delta.x) > 0 || abs(delta.y) > 0){
                last= { x: x, y: y };
                var
                  revolution= get(_revolution_),
                  origin= get(_clicked_location_),
                  vertical= get(_vertical_),
                  fraction= set(_fraction_, graph(vertical ? y - origin.y : x - origin.x, get(_clicked_on_), revolution, get(_lo_), get(_hi_), get(_cwish_))),
                  reeling= set(_reeling_, get(_reeling_) || get(_frame_) != get(_clicked_)),
                  motion= to_bias(vertical ? delta.y : delta.x || 0),
                  backwards= motion && set(_backwards_, motion < 0)
                if (opt.orbital && get(_center_)) var
                  vertical= set(_vertical_, abs(y - origin.y) > abs(x - origin.x)),
                  origin= recenter_mouse(x, y, fraction, revolution, get(_row_))
                if (opt.rows > 1) var
                  space_y= get(_dimensions_).y,
                  start= get(_clicked_row_),
                  lo= - start * space_y,
                  row= set(_row_, lofi($.reel.math.envelope(y - origin.y, start, space_y, lo, lo + space_y, -1)))
                var
                  origin= !(fraction % 1) && !opt.loops && recenter_mouse(x, y, fraction, revolution, get(_row_))
                t.trigger('fractionChange');
              }
            }
            cleanup.call(e);
          },
          wheel: function(e, distance){
          /*
          - calculates wheel input delta and adjusts fraction using the graph
          - recenters the "drag" each and every time
          - detects motion direction
          - nullifies the velocity
          */
            if (!opt.wheelable || !distance) return cleanup.call(e);
            var
              delta= ceil(sqrt(abs(distance)) / 2),
              delta= negative_when(delta, distance > 0),
              revolution= 0.2 * get(_revolution_), // Wheel's revolution is just 20 % of full revolution
              origin= recenter_mouse(undefined, undefined, get(_fraction_), revolution, get(_row_)),
              fraction= set(_fraction_, graph(delta, get(_clicked_on_), revolution, get(_lo_), get(_hi_), get(_cwish_))),
              backwards= delta && set(_backwards_, delta < 0),
              velocity= set(_velocity_, 0)
            unidle();
            cleanup.call(e);
            t.trigger('fractionChange');
            return false;
          },
          fractionChange: function(e, fraction){
          /*
          - normalizes given fraction (if any) - loop/limit and round
          - calculates and changes sprite frame
          - for non-looping panoramas
              - keeps track of ticks spent on edge
              - reverses motion direction if too long
          */
            var
              fraction= !fraction ? get(_fraction_) : set(_fraction_, fraction),
              fraction= opt.loops ? fraction - floor(fraction) : min_max(0, 1, fraction),
              fraction= set(_fraction_, lofi(fraction)),
              was= get(_frame_),
              frame= set(_frame_, 1 + floor(fraction / get(_bit_))),
              orbital= opt.orbital,
              center= set(_center_, !!orbital && (frame <= orbital || frame >= opt.footage - orbital + 2))
            if (!opt.loops && opt.rebound) var
              edgy= !operated && !(fraction % 1) ? on_edge++ : (on_edge= 0),
              bounce= on_edge >= opt.rebound * 1000 / leader(_tempo_),
              backwards= bounce && set(_backwards_, !get(_backwards_))
            var
              space= get(_dimensions_),
              travel= (get(_vertical_) ? space.y : space.x) - opt.indicator,
              indicator= min_max(0, travel, round($.reel.math.interpolate(fraction, -1, travel+2))),
              indicator= !opt.cw || opt.stitched ? indicator : travel - indicator,
              $indicator= $(dot(indicator_klass+'.x'), get(_stage_)).css(get(_vertical_) ? { left: 0, top: indicator } : { left: indicator, top: space.y - opt.indicator });
            if (opt.rows > 1) var
              ytravel= get(_dimensions_).y - opt.indicator,
              yindicator= min_max(0, ytravel, round($.reel.math.interpolate(get(_row_), -1, ytravel+2))),
              $yindicator= $(dot(indicator_klass+'.y'), get(_stage_)).css({ top: yindicator })
            if (frame == was && frame != 1) return cleanup.call(e);
            t.trigger(opt.rows > 1 ? 'rowChange' : 'frameChange');
            cleanup.call(e);
          },
          rowChange: function(e, row){
          /*
          - recalculates frame from fraction in order to have fresh unshifted value
          - shifts the stored frame to a desired row
          */
            var
              frame= floor(get(_fraction_) / get(_bit_)) + 1,
              row= set(_row_, min_max(0, 1, lofi(row != undefined ? (row-1) / (opt.rows-1) : get(_row_)))),
              frame= set(_frame_, frame + (opt.rows <= 1 ? 0 : round(row * (opt.rows - 1)) * opt.frames))
            cleanup.call(e);
            t.trigger('frameChange');
          },
          frameChange: function(e, frame){
          /*
          - rounds given frame (if any) and calculates fraction using it
          - calculates sprite background position shift and applies it
            or changes sprite image
          - adjusts indicator position
          */
            var
              fraction= !frame ? get(_fraction_) : set(_fraction_, lofi(get(_bit_) * (frame-1))),
              frame= set(_frame_, round(frame ? frame : get(_frame_))),
              images= opt.images,
              footage= opt.footage,
              space= get(_dimensions_),
              horizontal= opt.horizontal
            if (get(_vertical_)) var
              frame= opt.inversed ? footage + 1 - frame : frame,
              frame= frame + footage
            if (images.length){
              var
                sprite= images[frame - 1]
              t.attr({ src: opt.path+sprite })
            }else{
              if (!opt.stitched) var
                minor= (frame % footage) - 1,
                minor= minor < 0 ? footage - 1 : minor,
                major= floor((frame - 0.1) / footage),
                major= major + (opt.rows > 1 ? 0 : (get(_backwards_) ? 0 : get(_rows_))),
                spacing= get(_spacing_),
                a= major * ((horizontal ? space.y : space.x) + spacing),
                b= minor * ((horizontal ? space.x : space.y) + spacing),
                shift= images.length ? [0, 0] : horizontal ? [-b + _px_, -a + _px_] : [-a + _px_, -b + _px_]
              else var
                x= round(fraction * get(_stitched_travel_)),
                y= 0,
                shift= [-x + _px_, y + _px_]
              t.css({ backgroundPosition: shift.join(___) })
            }
            cleanup.call(e);
          }
        },

        // Garbage clean-up facility called by every event
        cleanup= function(pass){ ie || delete this; return pass },

        // User idle control
        operated,
        braking= 0,
        idle= function(){ return operated= 0 },
        unidle= function(){
          clearTimeout(delay);
          pool.unbind(_tick_, on.opening_tick);
          t.trigger('play');
          return operated= -opt.timeout * leader(_tempo_)
        },
        delay,
        // Triggers "play" delayed or immediate play
        delay_play= function(){
          delay= setTimeout(function play(){
            t.trigger('play');
          }, opt.delay * 1000 || 0);
        },

        $monitor,
        $preloader,
        indicator= function(axis){
          return $(_div_tag_, {
            'class': [indicator_klass, axis].join(___),
            css: {
              width: opt.indicator,
              height: opt.indicator,
              overflow: _hidden_,
              top: get(_dimensions_).y - opt.indicator,
              left: 0,
              position: _absolute_,
              backgroundColor: _hex_black_
            }
          })
        },

        // Inertia rotation control
        on_edge= 0,
        last= { x: 0, y: 0 },
        to_bias= function(value){ return bias.push(value) && bias.shift() && value },
        no_bias= function(){ return bias= [0,0] },
        bias= no_bias(),

        // Graph function to be used
        graph= opt.graph || $.reel.math[opt.loops ? 'hatch' : 'envelope'],

        // Resets the interaction graph's zero point
        recenter_mouse= function(x, y, fraction, revolution, row){
          set(_clicked_on_, fraction);
          set(_clicked_row_, row);
          set(_lo_, opt.loops ? 0 : - fraction * revolution);
          set(_hi_, opt.loops ? revolution : revolution - fraction * revolution);
          return x && set(_clicked_location_, { x: x, y: y }) || undefined
        },
        slidable= true,
        stage_pool= $.browser.opera ? pool : $.unique(pool.add(window.top.document))
      setup();
    });

    ticker= ticker || (function tick(){
      var
        start= +new Date(),
        tempo= leader(_tempo_);
      if (tempo){
        pool.trigger(_tick_);
        $.reel.cost= (+new Date() + $.reel.cost - start) / 2;
        return ticker= setTimeout(tick, max(4, 1000 / tempo - $.reel.cost));
      }else{
        return ticker= undefined
      }
    })();

    return $(instances);
  }

  // Mathematics core
  $.reel.math= {
    envelope: function(x, start, revolution, lo, hi, cwness){
      return start + max(lo, min(hi, - x * cwness)) / revolution
    },
    hatch: function(x, start, revolution, lo, hi, cwness){
      var
        x= (x < lo ? hi : 0) + x % hi, // Looping
        fraction= start + (- x * cwness) / revolution
      return fraction - floor(fraction)
    },
    interpolate: function(fraction, lo, hi){
      return lo + fraction * (hi - lo)
    }
  }

  $.reel.touchy= (/iphone|ipod|ipad|android/i).test(navigator.userAgent);
  $.reel.lazy= (/iphone|ipod|android/i).test(navigator.userAgent);

  $.reel.instances= $();
  $.reel.cost= 0;

  function leader(key){ return $.reel.instances.length ? $.reel.instances.first().data(key) : null }
  $.reel.leader= leader;

  function add_instance($instance){ return ($.reel.instances.push($instance[0])) && $instance }
  function remove_instance($instance){ return ($.reel.instances= $.reel.instances.not('#'+$instance.attr(_id_))) && $instance }

  // Double plugin functions in case plugin is missing
  double_for('mousewheel disableTextSelect enableTextSelect'.split(/ /));

  // PRIVATE
  var
    pool= $(document),
    browser_version= +$.browser.version.split('.').slice(0,2).join('.'),
    ie= $.browser.msie,
    knows_data_url= !(ie && browser_version < 8),
    failsafe_cursor= 'ew-resize',
    ticker,
    ticks= { before: 0, now: new Date() },

    // HTML classes
    klass= 'jquery-reel',
    overlay_klass= klass + '-overlay',
    indicator_klass= klass + '-indicator',
    preloader_klass= klass + '-preloader',
    monitor_klass= klass + '-monitor',
    hi_klass= klass + '-interface',

    // Image resources
    transparent= embedded('CAAIAIAAAAAAAAAAACH5BAEAAAAALAAAAAAIAAgAAAIHhI+py+1dAAA7') || cdn('blank.gif'),
    drag_cursor= embedded('EAAQAJECAAAAAP///////wAAACH5BAEAAAIALAAAAAAQABAAQAI3lC8AeBDvgosQxQtne7yvLWGStVBelXBKqDJpNzLKq3xWBlU2nUs4C/O8cCvU0EfZGUwt19FYAAA7') || cdn('jquery.reel.cursor-drag.gif'),
    drag_cursor_down= embedded('EAAQAJECAAAAAP///////wAAACH5BAEAAAIALAAAAAAQABAAQAIslI95EB3MHECxNjBVdE/5b2zcRV1QBabqhwltq41St4hj5konmVioZ6OtEgUAOw==') || cdn('jquery.reel.cursor-drag-down.gif'),

    // Shortcuts
    round= Math.round, floor= Math.floor, ceil= Math.ceil,
    min= Math.min, max= Math.max, abs= Math.abs, sqrt= Math.sqrt,
    number= parseInt,

    // Storage keys
    _area_= 'area', _backup_= 'backup', _backwards_= 'backwards', _bit_= 'bit', _brake_= 'brake', _center_= 'center',
    _classes_= 'classes', _clicked_= 'clicked', _clicked_location_= 'clicked_location',
    _clicked_on_= 'clicked_on', _clicked_row_= 'clicked_row', _cwish_= 'cwish', _dimensions_= 'dimensions',
    _fraction_= 'fraction', _frame_= 'frame', _frames_= 'frames', _hi_= 'hi', _hidden_= 'hidden', _image_= 'image',
    _opening_ticks_= 'opening_ticks', _lo_= 'lo', _playing_= 'playing', _reeling_= 'reeling', _revolution_= 'revolution',
    _row_= 'row', _rows_= 'rows', _spacing_= 'spacing', _speed_= 'speed', _stage_= 'stage',
    _steps_= 'steps', _stitched_= 'stitched', _stitched_travel_= 'stitched_travel', _stopped_= 'stopped',
    _tempo_= 'tempo', _velocity_= 'velocity', _vertical_= 'vertical', _wheel_step_= 'wheel_step',

    // Events
    ns= '.reel',
    _dblclick_= 'dblclick'+ns, _mousedown_= 'mousedown'+ns, _mouseenter_= 'mouseenter'+ns,
    _mouseleave_= 'mouseleave'+ns, _mousemove_= 'mousemove'+ns, _mouseup_= 'mouseup'+ns,
    _mousewheel_= 'mousewheel'+ns, _tick_= 'tick'+ns, _touchcancel_= 'touchcancel'+ns,
    _touchend_= 'touchend'+ns, _touchstart_= 'touchstart'+ns, _touchmove_= 'touchmove'+ns,

    // Various string primitives
    __= '', ___= ' ', _absolute_= 'absolute', _div_= 'div', _div_tag_= tag(_div_),
    _height_= 'height', _hex_black_= '#000', _id_= 'id', _img_= 'img', _px_= 'px', _src_= 'src',
    _title_= 'title', _width_= 'width'

  // Helpers
  function embedded(image){ return knows_data_url && 'data:image/gif;base64,R0lGODlh'+image }
  function tag(string){ return '<' + string + '/>' }
  function dot(string){ return '.' + string }
  function cdn(path){ return 'http://code.vostrel.cz/' + path }
  function url(location){ return 'url(' + location + ')' }
  function lofi(number){ return +number.toFixed(4) }
  function min_max(minimum, maximum, number){ return max(minimum, min(maximum, number)) }
  function double_for(methods){ $.each(methods, pretend);
    function pretend(){ if (!$.fn[this]) $.fn[this]= function(){ return this }}
  }
  function negative_when(value, condition){ return abs(value) * (condition ? -1 : 1) }
  function finger(e){ return e.originalEvent.touches[0] }
})(jQuery, window, document);


//Ford chooses to use jQuery Touchwipe and all associated files under the MIT license.
/**
 * Copyright (c) 2010 Matt Bryson* Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * jQuery Plugin to obtain touch gestures from iPhone, iPod Touch and iPad, should also work with Android mobile phones (not tested yet!)
 * Common usage: wipe images (left and right to show the previous or next image)
 * 
 * @author Andreas Waltl, netCU Internetagentur (http://www.netcu.de)
 * @version 1.1.1 (9th December 2010) - fix bug (older IE's had problems)
 * @version 1.1 (1st September 2010) - support wipe up and wipe down
 * @version 1.0 (15th July 2010)
 */
 (function($) { 
   $.fn.touchwipe = function(settings) {
     var config = {
    		min_move_x: 20,
    		min_move_y: 20,
 			wipeLeft: function() { },
 			wipeRight: function() { },
 			wipeUp: function() { },
 			wipeDown: function() { },
			preventDefaultEvents: true
	 };
     
     if (settings) $.extend(config, settings);
 
     this.each(function() {
    	 var startX;
    	 var startY;
		 var isMoving = false;

    	 function cancelTouch() {
    		 this.removeEventListener('touchmove', onTouchMove);
    		 startX = null;
    		 isMoving = false;
    	 }	
    	 
    	 function onTouchMove(e) {
    		 if(config.preventDefaultEvents) {
    			 e.preventDefault();
    		 }
    		 if(isMoving) {
	    		 var x = e.touches[0].pageX;
	    		 var y = e.touches[0].pageY;
	    		 var dx = startX - x;
	    		 var dy = startY - y;
	    		 if(Math.abs(dx) >= config.min_move_x) {
	    			cancelTouch();
	    			if(dx > 0) {
	    				config.wipeLeft();
	    			}
	    			else {
	    				config.wipeRight();
	    			}
	    		 }
	    		 else if(Math.abs(dy) >= config.min_move_y) {
		    			cancelTouch();
		    			if(dy > 0) {
		    				config.wipeDown();
		    			}
		    			else {
		    				config.wipeUp();
		    			}
		    		 }
    		 }
    	 }
    	 
    	 function onTouchStart(e)
    	 {
    		 if (e.touches.length == 1) {
    			 startX = e.touches[0].pageX;
    			 startY = e.touches[0].pageY;
    			 isMoving = true;
    			 this.addEventListener('touchmove', onTouchMove, false);
    		 }
    	 }    	 
    	 if ('ontouchstart' in document.documentElement) {
    		 this.addEventListener('touchstart', onTouchStart, false);
    	 }
     });
 
     return this;
   };
 
 })(jQuery);



(function(a){if(a.browser.mozilla){a.fn.disableTextSelect=function(){return this.each(function(){a(this).css({MozUserSelect:"none"})})};a.fn.enableTextSelect=function(){return this.each(function(){a(this).css({MozUserSelect:""})})}}else if(a.browser.msie){a.fn.disableTextSelect=function(){return this.each(function(){a(this).bind("selectstart.disableTextSelect",function(){return false})})};a.fn.enableTextSelect=function(){return this.each(function(){a(this).unbind("selectstart.disableTextSelect")})}}else{a.fn.disableTextSelect=
function(){return this.each(function(){a(this).bind("mousedown.disableTextSelect",function(){return false})})};a.fn.enableTextSelect=function(){return this.each(function(){a(this).unbind("mousedown.disableTextSelect")})}}})(jQuery);



(function(window, doc){
var m = Math,
	dummyStyle = doc.createElement('div').style,
	vendor = (function () {
		var vendors = 't,webkitT,MozT,msT,OT'.split(','),
			t,
			i = 0,
			l = vendors.length;

		for ( ; i < l; i++ ) {
			t = vendors[i] + 'ransform';
			if ( t in dummyStyle ) {
				return vendors[i].substr(0, vendors[i].length - 1);
			}
		}

		return false;
	})(),
	cssVendor = vendor ? '-' + vendor.toLowerCase() + '-' : '',

	// Style properties
	transform = prefixStyle('transform'),
	transitionProperty = prefixStyle('transitionProperty'),
	transitionDuration = prefixStyle('transitionDuration'),
	transformOrigin = prefixStyle('transformOrigin'),
	transitionTimingFunction = prefixStyle('transitionTimingFunction'),
	transitionDelay = prefixStyle('transitionDelay'),

    // Browser capabilities
	isAndroid = (/android/gi).test(navigator.appVersion),
	isIDevice = (/iphone|ipad/gi).test(navigator.appVersion),
	isTouchPad = (/hp-tablet/gi).test(navigator.appVersion),

    has3d = prefixStyle('perspective') in dummyStyle,
    hasTouch = 'ontouchstart' in window && !isTouchPad,
    hasTransform = !!vendor,
    hasTransitionEnd = prefixStyle('transition') in dummyStyle,

	RESIZE_EV = 'onorientationchange' in window ? 'orientationchange' : 'resize',
	START_EV = hasTouch ? 'touchstart' : 'mousedown',
	MOVE_EV = hasTouch ? 'touchmove' : 'mousemove',
	END_EV = hasTouch ? 'touchend' : 'mouseup',
	CANCEL_EV = hasTouch ? 'touchcancel' : 'mouseup',
	WHEEL_EV = vendor == 'Moz' ? 'DOMMouseScroll' : 'mousewheel',
	TRNEND_EV = (function () {
		if ( vendor === false ) return false;

		var transitionEnd = {
				''			: 'transitionend',
				'webkit'	: 'webkitTransitionEnd',
				'Moz'		: 'transitionend',
				'O'			: 'oTransitionEnd',
				'ms'		: 'MSTransitionEnd'
			};

		return transitionEnd[vendor];
	})(),

	nextFrame = (function() {
		return window.requestAnimationFrame ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame ||
			window.oRequestAnimationFrame ||
			window.msRequestAnimationFrame ||
			function(callback) { return setTimeout(callback, 1); };
	})(),
	cancelFrame = (function () {
		return window.cancelRequestAnimationFrame ||
			window.webkitCancelAnimationFrame ||
			window.webkitCancelRequestAnimationFrame ||
			window.mozCancelRequestAnimationFrame ||
			window.oCancelRequestAnimationFrame ||
			window.msCancelRequestAnimationFrame ||
			clearTimeout;
	})(),

	// Helpers
	translateZ = has3d ? ' translateZ(0)' : '',

	// Constructor
	iScroll = function (el, options) {
		var that = this,
			i;

		that.wrapper = typeof el == 'object' ? el : doc.getElementById(el);
		that.wrapper.style.overflow = 'hidden';
		that.scroller = that.wrapper.children[0];

		// Default options
		that.options = {
			hScroll: true,
			vScroll: true,
			x: 0,
			y: 0,
			bounce: true,
			bounceLock: false,
			momentum: true,
			lockDirection: true,
			useTransform: true,
			useTransition: false,
			topOffset: 0,
			checkDOMChanges: false,		// Experimental
			handleClick: true,

			// Scrollbar
			hScrollbar: true,
			vScrollbar: true,
			fixedScrollbar: isAndroid,
			hideScrollbar: isIDevice,
			fadeScrollbar: isIDevice && has3d,
			scrollbarClass: '',

			// Zoom
			zoom: false,
			zoomMin: 1,
			zoomMax: 4,
			doubleTapZoom: 2,
			wheelAction: 'scroll',

			// Snap
			snap: false,
			snapThreshold: 1,

			// Events
			onRefresh: null,
			onBeforeScrollStart: function (e) { e.preventDefault(); },
			onScrollStart: null,
			onBeforeScrollMove: null,
			onScrollMove: null,
			onBeforeScrollEnd: null,
			onScrollEnd: null,
			onTouchEnd: null,
			onDestroy: null,
			onZoomStart: null,
			onZoom: null,
			onZoomEnd: null
		};

		// User defined options
		for (i in options) that.options[i] = options[i];
		
		// Set starting position
		that.x = that.options.x;
		that.y = that.options.y;

		// Normalize options
		that.options.useTransform = hasTransform && that.options.useTransform;
		that.options.hScrollbar = that.options.hScroll && that.options.hScrollbar;
		that.options.vScrollbar = that.options.vScroll && that.options.vScrollbar;
		that.options.zoom = that.options.useTransform && that.options.zoom;
		that.options.useTransition = hasTransitionEnd && that.options.useTransition;

		// Helpers FIX ANDROID BUG!
		// translate3d and scale doesn't work together!
		// Ignoring 3d ONLY WHEN YOU SET that.options.zoom
		if ( that.options.zoom && isAndroid ){
			translateZ = '';
		}
		
		// Set some default styles
		that.scroller.style[transitionProperty] = that.options.useTransform ? cssVendor + 'transform' : 'top left';
		that.scroller.style[transitionDuration] = '0';
		that.scroller.style[transformOrigin] = '0 0';
		if (that.options.useTransition) that.scroller.style[transitionTimingFunction] = 'cubic-bezier(0.33,0.66,0.66,1)';
		
		if (that.options.useTransform) that.scroller.style[transform] = 'translate(' + that.x + 'px,' + that.y + 'px)' + translateZ;
		else that.scroller.style.cssText += ';position:absolute;top:' + that.y + 'px;left:' + that.x + 'px';

		if (that.options.useTransition) that.options.fixedScrollbar = true;

		that.refresh();

		that._bind(RESIZE_EV, window);
		that._bind(START_EV);
		if (!hasTouch) {
			that._bind('mouseout', that.wrapper);
			if (that.options.wheelAction != 'none')
				that._bind(WHEEL_EV);
		}

		if (that.options.checkDOMChanges) that.checkDOMTime = setInterval(function () {
			that._checkDOMChanges();
		}, 500);
	};

// Prototype
iScroll.prototype = {
	enabled: true,
	x: 0,
	y: 0,
	steps: [],
	scale: 1,
	currPageX: 0, currPageY: 0,
	pagesX: [], pagesY: [],
	aniTime: null,
	wheelZoomCount: 0,
	
	handleEvent: function (e) {
		var that = this;
		switch(e.type) {
			case START_EV:
				if (!hasTouch && e.button !== 0) return;
				that._start(e);
				break;
			case MOVE_EV: that._move(e); break;
			case END_EV:
			case CANCEL_EV: that._end(e); break;
			case RESIZE_EV: that._resize(); break;
			case WHEEL_EV: that._wheel(e); break;
			case 'mouseout': that._mouseout(e); break;
			case TRNEND_EV: that._transitionEnd(e); break;
		}
	},
	
	_checkDOMChanges: function () {
		if (this.moved || this.zoomed || this.animating ||
			(this.scrollerW == this.scroller.offsetWidth * this.scale && this.scrollerH == this.scroller.offsetHeight * this.scale)) return;

		this.refresh();
	},
	
	_scrollbar: function (dir) {
		var that = this,
			bar;

		if (!that[dir + 'Scrollbar']) {
			if (that[dir + 'ScrollbarWrapper']) {
				if (hasTransform) that[dir + 'ScrollbarIndicator'].style[transform] = '';
				that[dir + 'ScrollbarWrapper'].parentNode.removeChild(that[dir + 'ScrollbarWrapper']);
				that[dir + 'ScrollbarWrapper'] = null;
				that[dir + 'ScrollbarIndicator'] = null;
			}

			return;
		}

		if (!that[dir + 'ScrollbarWrapper']) {
			// Create the scrollbar wrapper
			bar = doc.createElement('div');

			if (that.options.scrollbarClass) bar.className = that.options.scrollbarClass + dir.toUpperCase();
			else bar.style.cssText = 'position:absolute;z-index:100;' + (dir == 'h' ? 'height:7px;bottom:1px;left:2px;right:' + (that.vScrollbar ? '7' : '2') + 'px' : 'width:7px;bottom:' + (that.hScrollbar ? '7' : '2') + 'px;top:2px;right:1px');

			bar.style.cssText += ';pointer-events:none;' + cssVendor + 'transition-property:opacity;' + cssVendor + 'transition-duration:' + (that.options.fadeScrollbar ? '350ms' : '0') + ';overflow:hidden;opacity:' + (that.options.hideScrollbar ? '0' : '1');

			that.wrapper.appendChild(bar);
			that[dir + 'ScrollbarWrapper'] = bar;

			// Create the scrollbar indicator
			bar = doc.createElement('div');
			if (!that.options.scrollbarClass) {
				bar.style.cssText = 'position:absolute;z-index:100;background:rgba(0,0,0,0.5);border:1px solid rgba(255,255,255,0.9);' + cssVendor + 'background-clip:padding-box;' + cssVendor + 'box-sizing:border-box;' + (dir == 'h' ? 'height:100%' : 'width:100%') + ';' + cssVendor + 'border-radius:3px;border-radius:3px';
			}
			bar.style.cssText += ';pointer-events:none;' + cssVendor + 'transition-property:' + cssVendor + 'transform;' + cssVendor + 'transition-timing-function:cubic-bezier(0.33,0.66,0.66,1);' + cssVendor + 'transition-duration:0;' + cssVendor + 'transform: translate(0,0)' + translateZ;
			if (that.options.useTransition) bar.style.cssText += ';' + cssVendor + 'transition-timing-function:cubic-bezier(0.33,0.66,0.66,1)';

			that[dir + 'ScrollbarWrapper'].appendChild(bar);
			that[dir + 'ScrollbarIndicator'] = bar;
		}

		if (dir == 'h') {
			that.hScrollbarSize = that.hScrollbarWrapper.clientWidth;
			that.hScrollbarIndicatorSize = m.max(m.round(that.hScrollbarSize * that.hScrollbarSize / that.scrollerW), 8);
			that.hScrollbarIndicator.style.width = that.hScrollbarIndicatorSize + 'px';
			that.hScrollbarMaxScroll = that.hScrollbarSize - that.hScrollbarIndicatorSize;
			that.hScrollbarProp = that.hScrollbarMaxScroll / that.maxScrollX;
		} else {
			that.vScrollbarSize = that.vScrollbarWrapper.clientHeight;
			that.vScrollbarIndicatorSize = m.max(m.round(that.vScrollbarSize * that.vScrollbarSize / that.scrollerH), 8);
			that.vScrollbarIndicator.style.height = that.vScrollbarIndicatorSize + 'px';
			that.vScrollbarMaxScroll = that.vScrollbarSize - that.vScrollbarIndicatorSize;
			that.vScrollbarProp = that.vScrollbarMaxScroll / that.maxScrollY;
		}

		// Reset position
		that._scrollbarPos(dir, true);
	},
	
	_resize: function () {
		var that = this;
		setTimeout(function () { that.refresh(); }, isAndroid ? 200 : 0);
	},
	
	_pos: function (x, y) {
		if (this.zoomed) return;

		x = this.hScroll ? x : 0;
		y = this.vScroll ? y : 0;

		if (this.options.useTransform) {
			this.scroller.style[transform] = 'translate(' + x + 'px,' + y + 'px) scale(' + this.scale + ')' + translateZ;
		} else {
			x = m.round(x);
			y = m.round(y);
			this.scroller.style.left = x + 'px';
			this.scroller.style.top = y + 'px';
		}

		this.x = x;
		this.y = y;

		this._scrollbarPos('h');
		this._scrollbarPos('v');
	},

	_scrollbarPos: function (dir, hidden) {
		var that = this,
			pos = dir == 'h' ? that.x : that.y,
			size;

		if (!that[dir + 'Scrollbar']) return;

		pos = that[dir + 'ScrollbarProp'] * pos;

		if (pos < 0) {
			if (!that.options.fixedScrollbar) {
				size = that[dir + 'ScrollbarIndicatorSize'] + m.round(pos * 3);
				if (size < 8) size = 8;
				that[dir + 'ScrollbarIndicator'].style[dir == 'h' ? 'width' : 'height'] = size + 'px';
			}
			pos = 0;
		} else if (pos > that[dir + 'ScrollbarMaxScroll']) {
			if (!that.options.fixedScrollbar) {
				size = that[dir + 'ScrollbarIndicatorSize'] - m.round((pos - that[dir + 'ScrollbarMaxScroll']) * 3);
				if (size < 8) size = 8;
				that[dir + 'ScrollbarIndicator'].style[dir == 'h' ? 'width' : 'height'] = size + 'px';
				pos = that[dir + 'ScrollbarMaxScroll'] + (that[dir + 'ScrollbarIndicatorSize'] - size);
			} else {
				pos = that[dir + 'ScrollbarMaxScroll'];
			}
		}

		that[dir + 'ScrollbarWrapper'].style[transitionDelay] = '0';
		that[dir + 'ScrollbarWrapper'].style.opacity = hidden && that.options.hideScrollbar ? '0' : '1';
		that[dir + 'ScrollbarIndicator'].style[transform] = 'translate(' + (dir == 'h' ? pos + 'px,0)' : '0,' + pos + 'px)') + translateZ;
	},
	
	_start: function (e) {
		var that = this,
			point = hasTouch ? e.touches[0] : e,
			matrix, x, y,
			c1, c2;

		if (!that.enabled) return;

		if (that.options.onBeforeScrollStart) that.options.onBeforeScrollStart.call(that, e);

		if (that.options.useTransition || that.options.zoom) that._transitionTime(0);

		that.moved = false;
		that.animating = false;
		that.zoomed = false;
		that.distX = 0;
		that.distY = 0;
		that.absDistX = 0;
		that.absDistY = 0;
		that.dirX = 0;
		that.dirY = 0;

		// Gesture start
		if (that.options.zoom && hasTouch && e.touches.length > 1) {
			c1 = m.abs(e.touches[0].pageX-e.touches[1].pageX);
			c2 = m.abs(e.touches[0].pageY-e.touches[1].pageY);
			that.touchesDistStart = m.sqrt(c1 * c1 + c2 * c2);

			that.originX = m.abs(e.touches[0].pageX + e.touches[1].pageX - that.wrapperOffsetLeft * 2) / 2 - that.x;
			that.originY = m.abs(e.touches[0].pageY + e.touches[1].pageY - that.wrapperOffsetTop * 2) / 2 - that.y;

			if (that.options.onZoomStart) that.options.onZoomStart.call(that, e);
		}

		if (that.options.momentum) {
			if (that.options.useTransform) {
				// Very lame general purpose alternative to CSSMatrix
				matrix = getComputedStyle(that.scroller, null)[transform].replace(/[^0-9\-.,]/g, '').split(',');
				x = matrix[4] * 1;
				y = matrix[5] * 1;
			} else {
				x = getComputedStyle(that.scroller, null).left.replace(/[^0-9-]/g, '') * 1;
				y = getComputedStyle(that.scroller, null).top.replace(/[^0-9-]/g, '') * 1;
			}
			
			if (x != that.x || y != that.y) {
				if (that.options.useTransition) that._unbind(TRNEND_EV);
				else cancelFrame(that.aniTime);
				that.steps = [];
				that._pos(x, y);
			}
		}

		that.absStartX = that.x;	// Needed by snap threshold
		that.absStartY = that.y;

		that.startX = that.x;
		that.startY = that.y;
		that.pointX = point.pageX;
		that.pointY = point.pageY;

		that.startTime = e.timeStamp || Date.now();

		if (that.options.onScrollStart) that.options.onScrollStart.call(that, e);

		that._bind(MOVE_EV);
		that._bind(END_EV);
		that._bind(CANCEL_EV);
	},
	
	_move: function (e) {
		var that = this,
			point = hasTouch ? e.touches[0] : e,
			deltaX = point.pageX - that.pointX,
			deltaY = point.pageY - that.pointY,
			newX = that.x + deltaX,
			newY = that.y + deltaY,
			c1, c2, scale,
			timestamp = e.timeStamp || Date.now();

		if (that.options.onBeforeScrollMove) that.options.onBeforeScrollMove.call(that, e);

		// Zoom
		if (that.options.zoom && hasTouch && e.touches.length > 1) {
			c1 = m.abs(e.touches[0].pageX - e.touches[1].pageX);
			c2 = m.abs(e.touches[0].pageY - e.touches[1].pageY);
			that.touchesDist = m.sqrt(c1*c1+c2*c2);

			that.zoomed = true;

			scale = 1 / that.touchesDistStart * that.touchesDist * this.scale;

			if (scale < that.options.zoomMin) scale = 0.5 * that.options.zoomMin * Math.pow(2.0, scale / that.options.zoomMin);
			else if (scale > that.options.zoomMax) scale = 2.0 * that.options.zoomMax * Math.pow(0.5, that.options.zoomMax / scale);

			that.lastScale = scale / this.scale;

			newX = this.originX - this.originX * that.lastScale + this.x,
			newY = this.originY - this.originY * that.lastScale + this.y;

			this.scroller.style[transform] = 'translate(' + newX + 'px,' + newY + 'px) scale(' + scale + ')' + translateZ;

			if (that.options.onZoom) that.options.onZoom.call(that, e);
			return;
		}

		that.pointX = point.pageX;
		that.pointY = point.pageY;

		// Slow down if outside of the boundaries
		if (newX > 0 || newX < that.maxScrollX) {
			newX = that.options.bounce ? that.x + (deltaX / 2) : newX >= 0 || that.maxScrollX >= 0 ? 0 : that.maxScrollX;
		}
		if (newY > that.minScrollY || newY < that.maxScrollY) {
			newY = that.options.bounce ? that.y + (deltaY / 2) : newY >= that.minScrollY || that.maxScrollY >= 0 ? that.minScrollY : that.maxScrollY;
		}

		that.distX += deltaX;
		that.distY += deltaY;
		that.absDistX = m.abs(that.distX);
		that.absDistY = m.abs(that.distY);

		if (that.absDistX < 6 && that.absDistY < 6) {
			return;
		}

		// Lock direction
		if (that.options.lockDirection) {
			if (that.absDistX > that.absDistY + 5) {
				newY = that.y;
				deltaY = 0;
			} else if (that.absDistY > that.absDistX + 5) {
				newX = that.x;
				deltaX = 0;
			}
		}

		that.moved = true;
		that._pos(newX, newY);
		that.dirX = deltaX > 0 ? -1 : deltaX < 0 ? 1 : 0;
		that.dirY = deltaY > 0 ? -1 : deltaY < 0 ? 1 : 0;

		if (timestamp - that.startTime > 300) {
			that.startTime = timestamp;
			that.startX = that.x;
			that.startY = that.y;
		}
		
		if (that.options.onScrollMove) that.options.onScrollMove.call(that, e);
	},
	
	_end: function (e) {
		if (hasTouch && e.touches.length !== 0) return;

		var that = this,
			point = hasTouch ? e.changedTouches[0] : e,
			target, ev,
			momentumX = { dist:0, time:0 },
			momentumY = { dist:0, time:0 },
			duration = (e.timeStamp || Date.now()) - that.startTime,
			newPosX = that.x,
			newPosY = that.y,
			distX, distY,
			newDuration,
			snap,
			scale;

		that._unbind(MOVE_EV);
		that._unbind(END_EV);
		that._unbind(CANCEL_EV);

		if (that.options.onBeforeScrollEnd) that.options.onBeforeScrollEnd.call(that, e);

		if (that.zoomed) {
			scale = that.scale * that.lastScale;
			scale = Math.max(that.options.zoomMin, scale);
			scale = Math.min(that.options.zoomMax, scale);
			that.lastScale = scale / that.scale;
			that.scale = scale;

			that.x = that.originX - that.originX * that.lastScale + that.x;
			that.y = that.originY - that.originY * that.lastScale + that.y;
			
			that.scroller.style[transitionDuration] = '200ms';
			that.scroller.style[transform] = 'translate(' + that.x + 'px,' + that.y + 'px) scale(' + that.scale + ')' + translateZ;
			
			that.zoomed = false;
			that.refresh();

			if (that.options.onZoomEnd) that.options.onZoomEnd.call(that, e);
			return;
		}

		if (!that.moved) {
			if (hasTouch) {
				if (that.doubleTapTimer && that.options.zoom) {
					// Double tapped
					clearTimeout(that.doubleTapTimer);
					that.doubleTapTimer = null;
					if (that.options.onZoomStart) that.options.onZoomStart.call(that, e);
					that.zoom(that.pointX, that.pointY, that.scale == 1 ? that.options.doubleTapZoom : 1);
					if (that.options.onZoomEnd) {
						setTimeout(function() {
							that.options.onZoomEnd.call(that, e);
						}, 200); // 200 is default zoom duration
					}
				} else if (this.options.handleClick) {
					that.doubleTapTimer = setTimeout(function () {
						that.doubleTapTimer = null;

						// Find the last touched element
						target = point.target;
						while (target.nodeType != 1) target = target.parentNode;

						if (target.tagName != 'SELECT' && target.tagName != 'INPUT' && target.tagName != 'TEXTAREA') {
							ev = doc.createEvent('MouseEvents');
							ev.initMouseEvent('click', true, true, e.view, 1,
								point.screenX, point.screenY, point.clientX, point.clientY,
								e.ctrlKey, e.altKey, e.shiftKey, e.metaKey,
								0, null);
							ev._fake = true;
							target.dispatchEvent(ev);
						}
					}, that.options.zoom ? 250 : 0);
				}
			}

			that._resetPos(200);

			if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
			return;
		}

		if (duration < 300 && that.options.momentum) {
			momentumX = newPosX ? that._momentum(newPosX - that.startX, duration, -that.x, that.scrollerW - that.wrapperW + that.x, that.options.bounce ? that.wrapperW : 0) : momentumX;
			momentumY = newPosY ? that._momentum(newPosY - that.startY, duration, -that.y, (that.maxScrollY < 0 ? that.scrollerH - that.wrapperH + that.y - that.minScrollY : 0), that.options.bounce ? that.wrapperH : 0) : momentumY;

			newPosX = that.x + momentumX.dist;
			newPosY = that.y + momentumY.dist;

			if ((that.x > 0 && newPosX > 0) || (that.x < that.maxScrollX && newPosX < that.maxScrollX)) momentumX = { dist:0, time:0 };
			if ((that.y > that.minScrollY && newPosY > that.minScrollY) || (that.y < that.maxScrollY && newPosY < that.maxScrollY)) momentumY = { dist:0, time:0 };
		}

		if (momentumX.dist || momentumY.dist) {
			newDuration = m.max(m.max(momentumX.time, momentumY.time), 10);

			// Do we need to snap?
			if (that.options.snap) {
				distX = newPosX - that.absStartX;
				distY = newPosY - that.absStartY;
				if (m.abs(distX) < that.options.snapThreshold && m.abs(distY) < that.options.snapThreshold) { that.scrollTo(that.absStartX, that.absStartY, 200); }
				else {
					snap = that._snap(newPosX, newPosY);
					newPosX = snap.x;
					newPosY = snap.y;
					newDuration = m.max(snap.time, newDuration);
				}
			}

			that.scrollTo(m.round(newPosX), m.round(newPosY), newDuration);

			if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
			return;
		}

		// Do we need to snap?
		if (that.options.snap) {
			distX = newPosX - that.absStartX;
			distY = newPosY - that.absStartY;
			if (m.abs(distX) < that.options.snapThreshold && m.abs(distY) < that.options.snapThreshold) that.scrollTo(that.absStartX, that.absStartY, 200);
			else {
				snap = that._snap(that.x, that.y);
				if (snap.x != that.x || snap.y != that.y) that.scrollTo(snap.x, snap.y, snap.time);
			}

			if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
			return;
		}

		that._resetPos(200);
		if (that.options.onTouchEnd) that.options.onTouchEnd.call(that, e);
	},
	
	_resetPos: function (time) {
		var that = this,
			resetX = that.x >= 0 ? 0 : that.x < that.maxScrollX ? that.maxScrollX : that.x,
			resetY = that.y >= that.minScrollY || that.maxScrollY > 0 ? that.minScrollY : that.y < that.maxScrollY ? that.maxScrollY : that.y;

		if (resetX == that.x && resetY == that.y) {
			if (that.moved) {
				that.moved = false;
				if (that.options.onScrollEnd) that.options.onScrollEnd.call(that);		// Execute custom code on scroll end
			}

			if (that.hScrollbar && that.options.hideScrollbar) {
				if (vendor == 'webkit') that.hScrollbarWrapper.style[transitionDelay] = '300ms';
				that.hScrollbarWrapper.style.opacity = '0';
			}
			if (that.vScrollbar && that.options.hideScrollbar) {
				if (vendor == 'webkit') that.vScrollbarWrapper.style[transitionDelay] = '300ms';
				that.vScrollbarWrapper.style.opacity = '0';
			}

			return;
		}

		that.scrollTo(resetX, resetY, time || 0);
	},

	_wheel: function (e) {
		var that = this,
			wheelDeltaX, wheelDeltaY,
			deltaX, deltaY,
			deltaScale;

		if ('wheelDeltaX' in e) {
			wheelDeltaX = e.wheelDeltaX / 12;
			wheelDeltaY = e.wheelDeltaY / 12;
		} else if('wheelDelta' in e) {
			wheelDeltaX = wheelDeltaY = e.wheelDelta / 12;
		} else if ('detail' in e) {
			wheelDeltaX = wheelDeltaY = -e.detail * 3;
		} else {
			return;
		}
		
		if (that.options.wheelAction == 'zoom') {
			deltaScale = that.scale * Math.pow(2, 1/3 * (wheelDeltaY ? wheelDeltaY / Math.abs(wheelDeltaY) : 0));
			if (deltaScale < that.options.zoomMin) deltaScale = that.options.zoomMin;
			if (deltaScale > that.options.zoomMax) deltaScale = that.options.zoomMax;
			
			if (deltaScale != that.scale) {
				if (!that.wheelZoomCount && that.options.onZoomStart) that.options.onZoomStart.call(that, e);
				that.wheelZoomCount++;
				
				that.zoom(e.pageX, e.pageY, deltaScale, 400);
				
				setTimeout(function() {
					that.wheelZoomCount--;
					if (!that.wheelZoomCount && that.options.onZoomEnd) that.options.onZoomEnd.call(that, e);
				}, 400);
			}
			
			return;
		}
		
		deltaX = that.x + wheelDeltaX;
		deltaY = that.y + wheelDeltaY;

		if (deltaX > 0) deltaX = 0;
		else if (deltaX < that.maxScrollX) deltaX = that.maxScrollX;

		if (deltaY > that.minScrollY) deltaY = that.minScrollY;
		else if (deltaY < that.maxScrollY) deltaY = that.maxScrollY;
    
		if (that.maxScrollY < 0) {
			that.scrollTo(deltaX, deltaY, 0);
		}
	},
	
	_mouseout: function (e) {
		var t = e.relatedTarget;

		if (!t) {
			this._end(e);
			return;
		}

		while (t = t.parentNode) if (t == this.wrapper) return;
		
		this._end(e);
	},

	_transitionEnd: function (e) {
		var that = this;

		if (e.target != that.scroller) return;

		that._unbind(TRNEND_EV);
		
		that._startAni();
	},


	/**
	*
	* Utilities
	*
	*/
	_startAni: function () {
		var that = this,
			startX = that.x, startY = that.y,
			startTime = Date.now(),
			step, easeOut,
			animate;

		if (that.animating) return;
		
		if (!that.steps.length) {
			that._resetPos(400);
			return;
		}
		
		step = that.steps.shift();
		
		if (step.x == startX && step.y == startY) step.time = 0;

		that.animating = true;
		that.moved = true;
		
		if (that.options.useTransition) {
			that._transitionTime(step.time);
			that._pos(step.x, step.y);
			that.animating = false;
			if (step.time) that._bind(TRNEND_EV);
			else that._resetPos(0);
			return;
		}

		animate = function () {
			var now = Date.now(),
				newX, newY;

			if (now >= startTime + step.time) {
				that._pos(step.x, step.y);
				that.animating = false;
				if (that.options.onAnimationEnd) that.options.onAnimationEnd.call(that);			// Execute custom code on animation end
				that._startAni();
				return;
			}

			now = (now - startTime) / step.time - 1;
			easeOut = m.sqrt(1 - now * now);
			newX = (step.x - startX) * easeOut + startX;
			newY = (step.y - startY) * easeOut + startY;
			that._pos(newX, newY);
			if (that.animating) that.aniTime = nextFrame(animate);
		};

		animate();
	},

	_transitionTime: function (time) {
		time += 'ms';
		this.scroller.style[transitionDuration] = time;
		if (this.hScrollbar) this.hScrollbarIndicator.style[transitionDuration] = time;
		if (this.vScrollbar) this.vScrollbarIndicator.style[transitionDuration] = time;
	},

	_momentum: function (dist, time, maxDistUpper, maxDistLower, size) {
		var deceleration = 0.0006,
			speed = m.abs(dist) / time,
			newDist = (speed * speed) / (2 * deceleration),
			newTime = 0, outsideDist = 0;

		// Proportinally reduce speed if we are outside of the boundaries
		if (dist > 0 && newDist > maxDistUpper) {
			outsideDist = size / (6 / (newDist / speed * deceleration));
			maxDistUpper = maxDistUpper + outsideDist;
			speed = speed * maxDistUpper / newDist;
			newDist = maxDistUpper;
		} else if (dist < 0 && newDist > maxDistLower) {
			outsideDist = size / (6 / (newDist / speed * deceleration));
			maxDistLower = maxDistLower + outsideDist;
			speed = speed * maxDistLower / newDist;
			newDist = maxDistLower;
		}

		newDist = newDist * (dist < 0 ? -1 : 1);
		newTime = speed / deceleration;

		return { dist: newDist, time: m.round(newTime) };
	},

	_offset: function (el) {
		var left = -el.offsetLeft,
			top = -el.offsetTop;
			
		while (el = el.offsetParent) {
			left -= el.offsetLeft;
			top -= el.offsetTop;
		}
		
		if (el != this.wrapper) {
			left *= this.scale;
			top *= this.scale;
		}

		return { left: left, top: top };
	},

	_snap: function (x, y) {
		var that = this,
			i, l,
			page, time,
			sizeX, sizeY;

		// Check page X
		page = that.pagesX.length - 1;
		for (i=0, l=that.pagesX.length; i<l; i++) {
			if (x >= that.pagesX[i]) {
				page = i;
				break;
			}
		}
		if (page == that.currPageX && page > 0 && that.dirX < 0) page--;
		x = that.pagesX[page];
		sizeX = m.abs(x - that.pagesX[that.currPageX]);
		sizeX = sizeX ? m.abs(that.x - x) / sizeX * 500 : 0;
		that.currPageX = page;

		// Check page Y
		page = that.pagesY.length-1;
		for (i=0; i<page; i++) {
			if (y >= that.pagesY[i]) {
				page = i;
				break;
			}
		}
		if (page == that.currPageY && page > 0 && that.dirY < 0) page--;
		y = that.pagesY[page];
		sizeY = m.abs(y - that.pagesY[that.currPageY]);
		sizeY = sizeY ? m.abs(that.y - y) / sizeY * 500 : 0;
		that.currPageY = page;

		// Snap with constant speed (proportional duration)
		time = m.round(m.max(sizeX, sizeY)) || 200;

		return { x: x, y: y, time: time };
	},

	_bind: function (type, el, bubble) {
		(el || this.scroller).addEventListener(type, this, !!bubble);
	},

	_unbind: function (type, el, bubble) {
		(el || this.scroller).removeEventListener(type, this, !!bubble);
	},


	/**
	*
	* Public methods
	*
	*/
	destroy: function () {
		var that = this;

		that.scroller.style[transform] = '';

		// Remove the scrollbars
		that.hScrollbar = false;
		that.vScrollbar = false;
		that._scrollbar('h');
		that._scrollbar('v');

		// Remove the event listeners
		that._unbind(RESIZE_EV, window);
		that._unbind(START_EV);
		that._unbind(MOVE_EV);
		that._unbind(END_EV);
		that._unbind(CANCEL_EV);
		
		if (!that.options.hasTouch) {
			that._unbind('mouseout', that.wrapper);
			that._unbind(WHEEL_EV);
		}
		
		if (that.options.useTransition) that._unbind(TRNEND_EV);
		
		if (that.options.checkDOMChanges) clearInterval(that.checkDOMTime);
		
		if (that.options.onDestroy) that.options.onDestroy.call(that);
	},

	refresh: function () {
		var that = this,
			offset,
			i, l,
			els,
			pos = 0,
			page = 0;

		if (that.scale < that.options.zoomMin) that.scale = that.options.zoomMin;
		that.wrapperW = that.wrapper.clientWidth || 1;
		that.wrapperH = that.wrapper.clientHeight || 1;

		that.minScrollY = -that.options.topOffset || 0;
		that.scrollerW = m.round(that.scroller.offsetWidth * that.scale);
		that.scrollerH = m.round((that.scroller.offsetHeight + that.minScrollY) * that.scale);
		that.maxScrollX = that.wrapperW - that.scrollerW;
		that.maxScrollY = that.wrapperH - that.scrollerH + that.minScrollY;
		that.dirX = 0;
		that.dirY = 0;

		if (that.options.onRefresh) that.options.onRefresh.call(that);

		that.hScroll = that.options.hScroll && that.maxScrollX < 0;
		that.vScroll = that.options.vScroll && (!that.options.bounceLock && !that.hScroll || that.scrollerH > that.wrapperH);

		that.hScrollbar = that.hScroll && that.options.hScrollbar;
		that.vScrollbar = that.vScroll && that.options.vScrollbar && that.scrollerH > that.wrapperH;

		offset = that._offset(that.wrapper);
		that.wrapperOffsetLeft = -offset.left;
		that.wrapperOffsetTop = -offset.top;

		// Prepare snap
		if (typeof that.options.snap == 'string') {
			that.pagesX = [];
			that.pagesY = [];
			els = that.scroller.querySelectorAll(that.options.snap);
			for (i=0, l=els.length; i<l; i++) {
				pos = that._offset(els[i]);
				pos.left += that.wrapperOffsetLeft;
				pos.top += that.wrapperOffsetTop;
				that.pagesX[i] = pos.left < that.maxScrollX ? that.maxScrollX : pos.left * that.scale;
				that.pagesY[i] = pos.top < that.maxScrollY ? that.maxScrollY : pos.top * that.scale;
			}
		} else if (that.options.snap) {
			that.pagesX = [];
			while (pos >= that.maxScrollX) {
				that.pagesX[page] = pos;
				pos = pos - that.wrapperW;
				page++;
			}
			if (that.maxScrollX%that.wrapperW) that.pagesX[that.pagesX.length] = that.maxScrollX - that.pagesX[that.pagesX.length-1] + that.pagesX[that.pagesX.length-1];

			pos = 0;
			page = 0;
			that.pagesY = [];
			while (pos >= that.maxScrollY) {
				that.pagesY[page] = pos;
				pos = pos - that.wrapperH;
				page++;
			}
			if (that.maxScrollY%that.wrapperH) that.pagesY[that.pagesY.length] = that.maxScrollY - that.pagesY[that.pagesY.length-1] + that.pagesY[that.pagesY.length-1];
		}

		// Prepare the scrollbars
		that._scrollbar('h');
		that._scrollbar('v');

		if (!that.zoomed) {
			that.scroller.style[transitionDuration] = '0';
			that._resetPos(200);
		}
	},

	scrollTo: function (x, y, time, relative) {
		var that = this,
			step = x,
			i, l;

		that.stop();

		if (!step.length) step = [{ x: x, y: y, time: time, relative: relative }];
		
		for (i=0, l=step.length; i<l; i++) {
			if (step[i].relative) { step[i].x = that.x - step[i].x; step[i].y = that.y - step[i].y; }
			that.steps.push({ x: step[i].x, y: step[i].y, time: step[i].time || 0 });
		}

		that._startAni();
	},

	scrollToElement: function (el, time) {
		var that = this, pos;
		el = el.nodeType ? el : that.scroller.querySelector(el);
		if (!el) return;

		pos = that._offset(el);
		pos.left += that.wrapperOffsetLeft;
		pos.top += that.wrapperOffsetTop;

		pos.left = pos.left > 0 ? 0 : pos.left < that.maxScrollX ? that.maxScrollX : pos.left;
		pos.top = pos.top > that.minScrollY ? that.minScrollY : pos.top < that.maxScrollY ? that.maxScrollY : pos.top;
		time = time === undefined ? m.max(m.abs(pos.left)*2, m.abs(pos.top)*2) : time;

		that.scrollTo(pos.left, pos.top, time);
	},

	scrollToPage: function (pageX, pageY, time) {
		var that = this, x, y;
		
		time = time === undefined ? 400 : time;

		if (that.options.onScrollStart) that.options.onScrollStart.call(that);

		if (that.options.snap) {
			pageX = pageX == 'next' ? that.currPageX+1 : pageX == 'prev' ? that.currPageX-1 : pageX;
			pageY = pageY == 'next' ? that.currPageY+1 : pageY == 'prev' ? that.currPageY-1 : pageY;

			pageX = pageX < 0 ? 0 : pageX > that.pagesX.length-1 ? that.pagesX.length-1 : pageX;
			pageY = pageY < 0 ? 0 : pageY > that.pagesY.length-1 ? that.pagesY.length-1 : pageY;

			that.currPageX = pageX;
			that.currPageY = pageY;
			x = that.pagesX[pageX];
			y = that.pagesY[pageY];
		} else {
			x = -that.wrapperW * pageX;
			y = -that.wrapperH * pageY;
			if (x < that.maxScrollX) x = that.maxScrollX;
			if (y < that.maxScrollY) y = that.maxScrollY;
		}

		that.scrollTo(x, y, time);
	},

	disable: function () {
		this.stop();
		this._resetPos(0);
		this.enabled = false;

		// If disabled after touchstart we make sure that there are no left over events
		this._unbind(MOVE_EV);
		this._unbind(END_EV);
		this._unbind(CANCEL_EV);
	},
	
	enable: function () {
		this.enabled = true;
	},
	
	stop: function () {
		if (this.options.useTransition) this._unbind(TRNEND_EV);
		else cancelFrame(this.aniTime);
		this.steps = [];
		this.moved = false;
		this.animating = false;
	},
	
	zoom: function (x, y, scale, time) {
		var that = this,
			relScale = scale / that.scale;

		if (!that.options.useTransform) return;

		that.zoomed = true;
		time = time === undefined ? 200 : time;
		x = x - that.wrapperOffsetLeft - that.x;
		y = y - that.wrapperOffsetTop - that.y;
		that.x = x - x * relScale + that.x;
		that.y = y - y * relScale + that.y;

		that.scale = scale;
		that.refresh();

		that.x = that.x > 0 ? 0 : that.x < that.maxScrollX ? that.maxScrollX : that.x;
		that.y = that.y > that.minScrollY ? that.minScrollY : that.y < that.maxScrollY ? that.maxScrollY : that.y;

		that.scroller.style[transitionDuration] = time + 'ms';
		that.scroller.style[transform] = 'translate(' + that.x + 'px,' + that.y + 'px) scale(' + scale + ')' + translateZ;
		that.zoomed = false;
	},
	
	isReady: function () {
		return !this.moved && !this.zoomed && !this.animating;
	}
};

function prefixStyle (style) {
	if ( vendor === '' ) return style;

	style = style.charAt(0).toUpperCase() + style.substr(1);
	return vendor + style;
}

dummyStyle = null;	// for the sake of it

if (typeof exports !== 'undefined') exports.iScroll = iScroll;
else window.iScroll = iScroll;

})(window, document);



(function($) {
	if(!document.defaultView || !document.defaultView.getComputedStyle){ // IE6-IE8
		var oldCurCSS = $.curCSS;
		$.curCSS = function(elem, name, force){
			if(name === 'background-position'){
				name = 'backgroundPosition';
			}
			if(name !== 'backgroundPosition' || !elem.currentStyle || elem.currentStyle[ name ]){
				return oldCurCSS.apply(this, arguments);
			}
			var style = elem.style;
			if ( !force && style && style[ name ] ){
				return style[ name ];
			}
			return oldCurCSS(elem, 'backgroundPositionX', force) +' '+ oldCurCSS(elem, 'backgroundPositionY', force);
		};
	}
	
	var oldAnim = $.fn.animate;
	$.fn.animate = function(prop){
		if('background-position' in prop){
			prop.backgroundPosition = prop['background-position'];
			delete prop['background-position'];
		}
		if('backgroundPosition' in prop){
			prop.backgroundPosition = '('+ prop.backgroundPosition;
		}
		return oldAnim.apply(this, arguments);
	};
	
	function toArray(strg){
		strg = strg.replace(/left|top/g,'0px');
		strg = strg.replace(/right|bottom/g,'100%');
		strg = strg.replace(/center/g,'50%'); //fixed ie8 bug
		strg = strg.replace(/([0-9\.]+)(\s|\)|$)/g,"$1px$2");
		var res = strg.match(/(-?[0-9\.]+)(px|\%|em|pt)\s(-?[0-9\.]+)(px|\%|em|pt)/);
		return [parseFloat(res[1],10),res[2],parseFloat(res[3],10),res[4]];
	}
	
	$.fx.step. backgroundPosition = function(fx) {
		if (!fx.bgPosReady) {
			var start = $.curCSS(fx.elem,'backgroundPosition');
			if(!start){//FF2 no inline-style fallback
				start = '0px 0px';
			}
			
			start = toArray(start);
			fx.start = [start[0],start[2]];
			var end = toArray(fx.end);
			fx.end = [end[0],end[2]];
			
			fx.unit = [end[1],end[3]];
			fx.bgPosReady = true;
		}
		//return;
		var nowPosX = [];
		nowPosX[0] = ((fx.end[0] - fx.start[0]) * fx.pos) + fx.start[0] + fx.unit[0];
		nowPosX[1] = ((fx.end[1] - fx.start[1]) * fx.pos) + fx.start[1] + fx.unit[1];           
		fx.elem.style.backgroundPosition = nowPosX[0]+' '+nowPosX[1];

	};
})(jQuery);



(function(a,b){function c(b,c){var e=b.nodeName.toLowerCase();if("area"===e){var f=b.parentNode,g=f.name,h;return!b.href||!g||f.nodeName.toLowerCase()!=="map"?!1:(h=a("img[usemap=#"+g+"]")[0],!!h&&d(h))}return(/input|select|textarea|button|object/.test(e)?!b.disabled:"a"==e?b.href||c:c)&&d(b)}function d(b){return!a(b).parents().andSelf().filter(function(){return a.curCSS(this,"visibility")==="hidden"||a.expr.filters.hidden(this)}).length}a.ui=a.ui||{};if(a.ui.version)return;a.extend(a.ui,{version:"1.8.21",keyCode:{ALT:18,BACKSPACE:8,CAPS_LOCK:20,COMMA:188,COMMAND:91,COMMAND_LEFT:91,COMMAND_RIGHT:93,CONTROL:17,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,INSERT:45,LEFT:37,MENU:93,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SHIFT:16,SPACE:32,TAB:9,UP:38,WINDOWS:91}}),a.fn.extend({propAttr:a.fn.prop||a.fn.attr,_focus:a.fn.focus,focus:function(b,c){return typeof b=="number"?this.each(function(){var d=this;setTimeout(function(){a(d).focus(),c&&c.call(d)},b)}):this._focus.apply(this,arguments)},scrollParent:function(){var b;return a.browser.msie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?b=this.parents().filter(function(){return/(relative|absolute|fixed)/.test(a.curCSS(this,"position",1))&&/(auto|scroll)/.test(a.curCSS(this,"overflow",1)+a.curCSS(this,"overflow-y",1)+a.curCSS(this,"overflow-x",1))}).eq(0):b=this.parents().filter(function(){return/(auto|scroll)/.test(a.curCSS(this,"overflow",1)+a.curCSS(this,"overflow-y",1)+a.curCSS(this,"overflow-x",1))}).eq(0),/fixed/.test(this.css("position"))||!b.length?a(document):b},zIndex:function(c){if(c!==b)return this.css("zIndex",c);if(this.length){var d=a(this[0]),e,f;while(d.length&&d[0]!==document){e=d.css("position");if(e==="absolute"||e==="relative"||e==="fixed"){f=parseInt(d.css("zIndex"),10);if(!isNaN(f)&&f!==0)return f}d=d.parent()}}return 0},disableSelection:function(){return this.bind((a.support.selectstart?"selectstart":"mousedown")+".ui-disableSelection",function(a){a.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}}),a.each(["Width","Height"],function(c,d){function h(b,c,d,f){return a.each(e,function(){c-=parseFloat(a.curCSS(b,"padding"+this,!0))||0,d&&(c-=parseFloat(a.curCSS(b,"border"+this+"Width",!0))||0),f&&(c-=parseFloat(a.curCSS(b,"margin"+this,!0))||0)}),c}var e=d==="Width"?["Left","Right"]:["Top","Bottom"],f=d.toLowerCase(),g={innerWidth:a.fn.innerWidth,innerHeight:a.fn.innerHeight,outerWidth:a.fn.outerWidth,outerHeight:a.fn.outerHeight};a.fn["inner"+d]=function(c){return c===b?g["inner"+d].call(this):this.each(function(){a(this).css(f,h(this,c)+"px")})},a.fn["outer"+d]=function(b,c){return typeof b!="number"?g["outer"+d].call(this,b):this.each(function(){a(this).css(f,h(this,b,!0,c)+"px")})}}),a.extend(a.expr[":"],{data:function(b,c,d){return!!a.data(b,d[3])},focusable:function(b){return c(b,!isNaN(a.attr(b,"tabindex")))},tabbable:function(b){var d=a.attr(b,"tabindex"),e=isNaN(d);return(e||d>=0)&&c(b,!e)}}),a(function(){var b=document.body,c=b.appendChild(c=document.createElement("div"));c.offsetHeight,a.extend(c.style,{minHeight:"100px",height:"auto",padding:0,borderWidth:0}),a.support.minHeight=c.offsetHeight===100,a.support.selectstart="onselectstart"in c,b.removeChild(c).style.display="none"}),a.extend(a.ui,{plugin:{add:function(b,c,d){var e=a.ui[b].prototype;for(var f in d)e.plugins[f]=e.plugins[f]||[],e.plugins[f].push([c,d[f]])},call:function(a,b,c){var d=a.plugins[b];if(!d||!a.element[0].parentNode)return;for(var e=0;e<d.length;e++)a.options[d[e][0]]&&d[e][1].apply(a.element,c)}},contains:function(a,b){return document.compareDocumentPosition?a.compareDocumentPosition(b)&16:a!==b&&a.contains(b)},hasScroll:function(b,c){if(a(b).css("overflow")==="hidden")return!1;var d=c&&c==="left"?"scrollLeft":"scrollTop",e=!1;return b[d]>0?!0:(b[d]=1,e=b[d]>0,b[d]=0,e)},isOverAxis:function(a,b,c){return a>b&&a<b+c},isOver:function(b,c,d,e,f,g){return a.ui.isOverAxis(b,d,f)&&a.ui.isOverAxis(c,e,g)}})})(jQuery);;

(function(a,b){if(a.cleanData){var c=a.cleanData;a.cleanData=function(b){for(var d=0,e;(e=b[d])!=null;d++)try{a(e).triggerHandler("remove")}catch(f){}c(b)}}else{var d=a.fn.remove;a.fn.remove=function(b,c){return this.each(function(){return c||(!b||a.filter(b,[this]).length)&&a("*",this).add([this]).each(function(){try{a(this).triggerHandler("remove")}catch(b){}}),d.call(a(this),b,c)})}}a.widget=function(b,c,d){var e=b.split(".")[0],f;b=b.split(".")[1],f=e+"-"+b,d||(d=c,c=a.Widget),a.expr[":"][f]=function(c){return!!a.data(c,b)},a[e]=a[e]||{},a[e][b]=function(a,b){arguments.length&&this._createWidget(a,b)};var g=new c;g.options=a.extend(!0,{},g.options),a[e][b].prototype=a.extend(!0,g,{namespace:e,widgetName:b,widgetEventPrefix:a[e][b].prototype.widgetEventPrefix||b,widgetBaseClass:f},d),a.widget.bridge(b,a[e][b])},a.widget.bridge=function(c,d){a.fn[c]=function(e){var f=typeof e=="string",g=Array.prototype.slice.call(arguments,1),h=this;return e=!f&&g.length?a.extend.apply(null,[!0,e].concat(g)):e,f&&e.charAt(0)==="_"?h:(f?this.each(function(){var d=a.data(this,c),f=d&&a.isFunction(d[e])?d[e].apply(d,g):d;if(f!==d&&f!==b)return h=f,!1}):this.each(function(){var b=a.data(this,c);b?b.option(e||{})._init():a.data(this,c,new d(e,this))}),h)}},a.Widget=function(a,b){arguments.length&&this._createWidget(a,b)},a.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",options:{disabled:!1},_createWidget:function(b,c){a.data(c,this.widgetName,this),this.element=a(c),this.options=a.extend(!0,{},this.options,this._getCreateOptions(),b);var d=this;this.element.bind("remove."+this.widgetName,function(){d.destroy()}),this._create(),this._trigger("create"),this._init()},_getCreateOptions:function(){return a.metadata&&a.metadata.get(this.element[0])[this.widgetName]},_create:function(){},_init:function(){},destroy:function(){this.element.unbind("."+this.widgetName).removeData(this.widgetName),this.widget().unbind("."+this.widgetName).removeAttr("aria-disabled").removeClass(this.widgetBaseClass+"-disabled "+"ui-state-disabled")},widget:function(){return this.element},option:function(c,d){var e=c;if(arguments.length===0)return a.extend({},this.options);if(typeof c=="string"){if(d===b)return this.options[c];e={},e[c]=d}return this._setOptions(e),this},_setOptions:function(b){var c=this;return a.each(b,function(a,b){c._setOption(a,b)}),this},_setOption:function(a,b){return this.options[a]=b,a==="disabled"&&this.widget()[b?"addClass":"removeClass"](this.widgetBaseClass+"-disabled"+" "+"ui-state-disabled").attr("aria-disabled",b),this},enable:function(){return this._setOption("disabled",!1)},disable:function(){return this._setOption("disabled",!0)},_trigger:function(b,c,d){var e,f,g=this.options[b];d=d||{},c=a.Event(c),c.type=(b===this.widgetEventPrefix?b:this.widgetEventPrefix+b).toLowerCase(),c.target=this.element[0],f=c.originalEvent;if(f)for(e in f)e in c||(c[e]=f[e]);return this.element.trigger(c,d),!(a.isFunction(g)&&g.call(this.element[0],c,d)===!1||c.isDefaultPrevented())}}})(jQuery);;

(function(a,b){function e(){return++c}function f(){return++d}var c=0,d=0;a.widget("ui.tabs",{options:{add:null,ajaxOptions:null,cache:!1,cookie:null,collapsible:!1,disable:null,disabled:[],enable:null,event:"click",fx:null,idPrefix:"ui-tabs-",load:null,panelTemplate:"<div></div>",remove:null,select:null,show:null,spinner:"<em>Loading&#8230;</em>",tabTemplate:"<li><a href='#{href}'><span>#{label}</span></a></li>"},_create:function(){this._tabify(!0)},_setOption:function(a,b){if(a=="selected"){if(this.options.collapsible&&b==this.options.selected)return;this.select(b)}else this.options[a]=b,this._tabify()},_tabId:function(a){return a.title&&a.title.replace(/\s/g,"_").replace(/[^\w\u00c0-\uFFFF-]/g,"")||this.options.idPrefix+e()},_sanitizeSelector:function(a){return a.replace(/:/g,"\\:")},_cookie:function(){var b=this.cookie||(this.cookie=this.options.cookie.name||"ui-tabs-"+f());return a.cookie.apply(null,[b].concat(a.makeArray(arguments)))},_ui:function(a,b){return{tab:a,panel:b,index:this.anchors.index(a)}},_cleanup:function(){this.lis.filter(".ui-state-processing").removeClass("ui-state-processing").find("span:data(label.tabs)").each(function(){var b=a(this);b.html(b.data("label.tabs")).removeData("label.tabs")})},_tabify:function(c){function m(b,c){b.css("display",""),!a.support.opacity&&c.opacity&&b[0].style.removeAttribute("filter")}var d=this,e=this.options,f=/^#.+/;this.list=this.element.find("ol,ul").eq(0),this.lis=a(" > li:has(a[href])",this.list),this.anchors=this.lis.map(function(){return a("a",this)[0]}),this.panels=a([]),this.anchors.each(function(b,c){var g=a(c).attr("href"),h=g.split("#")[0],i;h&&(h===location.toString().split("#")[0]||(i=a("base")[0])&&h===i.href)&&(g=c.hash,c.href=g);if(f.test(g))d.panels=d.panels.add(d.element.find(d._sanitizeSelector(g)));else if(g&&g!=="#"){a.data(c,"href.tabs",g),a.data(c,"load.tabs",g.replace(/#.*$/,""));var j=d._tabId(c);c.href="#"+j;var k=d.element.find("#"+j);k.length||(k=a(e.panelTemplate).attr("id",j).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").insertAfter(d.panels[b-1]||d.list),k.data("destroy.tabs",!0)),d.panels=d.panels.add(k)}else e.disabled.push(b)}),c?(this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all"),this.list.addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all"),this.lis.addClass("ui-state-default ui-corner-top"),this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom"),e.selected===b?(location.hash&&this.anchors.each(function(a,b){if(b.hash==location.hash)return e.selected=a,!1}),typeof e.selected!="number"&&e.cookie&&(e.selected=parseInt(d._cookie(),10)),typeof e.selected!="number"&&this.lis.filter(".ui-tabs-selected").length&&(e.selected=this.lis.index(this.lis.filter(".ui-tabs-selected"))),e.selected=e.selected||(this.lis.length?0:-1)):e.selected===null&&(e.selected=-1),e.selected=e.selected>=0&&this.anchors[e.selected]||e.selected<0?e.selected:0,e.disabled=a.unique(e.disabled.concat(a.map(this.lis.filter(".ui-state-disabled"),function(a,b){return d.lis.index(a)}))).sort(),a.inArray(e.selected,e.disabled)!=-1&&e.disabled.splice(a.inArray(e.selected,e.disabled),1),this.panels.addClass("ui-tabs-hide"),this.lis.removeClass("ui-tabs-selected ui-state-active"),e.selected>=0&&this.anchors.length&&(d.element.find(d._sanitizeSelector(d.anchors[e.selected].hash)).removeClass("ui-tabs-hide"),this.lis.eq(e.selected).addClass("ui-tabs-selected ui-state-active"),d.element.queue("tabs",function(){d._trigger("show",null,d._ui(d.anchors[e.selected],d.element.find(d._sanitizeSelector(d.anchors[e.selected].hash))[0]))}),this.load(e.selected)),a(window).bind("unload",function(){d.lis.add(d.anchors).unbind(".tabs"),d.lis=d.anchors=d.panels=null})):e.selected=this.lis.index(this.lis.filter(".ui-tabs-selected")),this.element[e.collapsible?"addClass":"removeClass"]("ui-tabs-collapsible"),e.cookie&&this._cookie(e.selected,e.cookie);for(var g=0,h;h=this.lis[g];g++)a(h)[a.inArray(g,e.disabled)!=-1&&!a(h).hasClass("ui-tabs-selected")?"addClass":"removeClass"]("ui-state-disabled");e.cache===!1&&this.anchors.removeData("cache.tabs"),this.lis.add(this.anchors).unbind(".tabs");if(e.event!=="mouseover"){var i=function(a,b){b.is(":not(.ui-state-disabled)")&&b.addClass("ui-state-"+a)},j=function(a,b){b.removeClass("ui-state-"+a)};this.lis.bind("mouseover.tabs",function(){i("hover",a(this))}),this.lis.bind("mouseout.tabs",function(){j("hover",a(this))}),this.anchors.bind("focus.tabs",function(){i("focus",a(this).closest("li"))}),this.anchors.bind("blur.tabs",function(){j("focus",a(this).closest("li"))})}var k,l;e.fx&&(a.isArray(e.fx)?(k=e.fx[0],l=e.fx[1]):k=l=e.fx);var n=l?function(b,c){a(b).closest("li").addClass("ui-tabs-selected ui-state-active"),c.hide().removeClass("ui-tabs-hide").animate(l,l.duration||"normal",function(){m(c,l),d._trigger("show",null,d._ui(b,c[0]))})}:function(b,c){a(b).closest("li").addClass("ui-tabs-selected ui-state-active"),c.removeClass("ui-tabs-hide"),d._trigger("show",null,d._ui(b,c[0]))},o=k?function(a,b){b.animate(k,k.duration||"normal",function(){d.lis.removeClass("ui-tabs-selected ui-state-active"),b.addClass("ui-tabs-hide"),m(b,k),d.element.dequeue("tabs")})}:function(a,b,c){d.lis.removeClass("ui-tabs-selected ui-state-active"),b.addClass("ui-tabs-hide"),d.element.dequeue("tabs")};this.anchors.bind(e.event+".tabs",function(){var b=this,c=a(b).closest("li"),f=d.panels.filter(":not(.ui-tabs-hide)"),g=d.element.find(d._sanitizeSelector(b.hash));if(c.hasClass("ui-tabs-selected")&&!e.collapsible||c.hasClass("ui-state-disabled")||c.hasClass("ui-state-processing")||d.panels.filter(":animated").length||d._trigger("select",null,d._ui(this,g[0]))===!1)return this.blur(),!1;e.selected=d.anchors.index(this),d.abort();if(e.collapsible){if(c.hasClass("ui-tabs-selected"))return e.selected=-1,e.cookie&&d._cookie(e.selected,e.cookie),d.element.queue("tabs",function(){o(b,f)}).dequeue("tabs"),this.blur(),!1;if(!f.length)return e.cookie&&d._cookie(e.selected,e.cookie),d.element.queue("tabs",function(){n(b,g)}),d.load(d.anchors.index(this)),this.blur(),!1}e.cookie&&d._cookie(e.selected,e.cookie);if(g.length)f.length&&d.element.queue("tabs",function(){o(b,f)}),d.element.queue("tabs",function(){n(b,g)}),d.load(d.anchors.index(this));else throw"jQuery UI Tabs: Mismatching fragment identifier.";a.browser.msie&&this.blur()}),this.anchors.bind("click.tabs",function(){return!1})},_getIndex:function(a){return typeof a=="string"&&(a=this.anchors.index(this.anchors.filter("[href$='"+a+"']"))),a},destroy:function(){var b=this.options;return this.abort(),this.element.unbind(".tabs").removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible").removeData("tabs"),this.list.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all"),this.anchors.each(function(){var b=a.data(this,"href.tabs");b&&(this.href=b);var c=a(this).unbind(".tabs");a.each(["href","load","cache"],function(a,b){c.removeData(b+".tabs")})}),this.lis.unbind(".tabs").add(this.panels).each(function(){a.data(this,"destroy.tabs")?a(this).remove():a(this).removeClass(["ui-state-default","ui-corner-top","ui-tabs-selected","ui-state-active","ui-state-hover","ui-state-focus","ui-state-disabled","ui-tabs-panel","ui-widget-content","ui-corner-bottom","ui-tabs-hide"].join(" "))}),b.cookie&&this._cookie(null,b.cookie),this},add:function(c,d,e){e===b&&(e=this.anchors.length);var f=this,g=this.options,h=a(g.tabTemplate.replace(/#\{href\}/g,c).replace(/#\{label\}/g,d)),i=c.indexOf("#")?this._tabId(a("a",h)[0]):c.replace("#","");h.addClass("ui-state-default ui-corner-top").data("destroy.tabs",!0);var j=f.element.find("#"+i);return j.length||(j=a(g.panelTemplate).attr("id",i).data("destroy.tabs",!0)),j.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide"),e>=this.lis.length?(h.appendTo(this.list),j.appendTo(this.list[0].parentNode)):(h.insertBefore(this.lis[e]),j.insertBefore(this.panels[e])),g.disabled=a.map(g.disabled,function(a,b){return a>=e?++a:a}),this._tabify(),this.anchors.length==1&&(g.selected=0,h.addClass("ui-tabs-selected ui-state-active"),j.removeClass("ui-tabs-hide"),this.element.queue("tabs",function(){f._trigger("show",null,f._ui(f.anchors[0],f.panels[0]))}),this.load(0)),this._trigger("add",null,this._ui(this.anchors[e],this.panels[e])),this},remove:function(b){b=this._getIndex(b);var c=this.options,d=this.lis.eq(b).remove(),e=this.panels.eq(b).remove();return d.hasClass("ui-tabs-selected")&&this.anchors.length>1&&this.select(b+(b+1<this.anchors.length?1:-1)),c.disabled=a.map(a.grep(c.disabled,function(a,c){return a!=b}),function(a,c){return a>=b?--a:a}),this._tabify(),this._trigger("remove",null,this._ui(d.find("a")[0],e[0])),this},enable:function(b){b=this._getIndex(b);var c=this.options;if(a.inArray(b,c.disabled)==-1)return;return this.lis.eq(b).removeClass("ui-state-disabled"),c.disabled=a.grep(c.disabled,function(a,c){return a!=b}),this._trigger("enable",null,this._ui(this.anchors[b],this.panels[b])),this},disable:function(a){a=this._getIndex(a);var b=this,c=this.options;return a!=c.selected&&(this.lis.eq(a).addClass("ui-state-disabled"),c.disabled.push(a),c.disabled.sort(),this._trigger("disable",null,this._ui(this.anchors[a],this.panels[a]))),this},select:function(a){a=this._getIndex(a);if(a==-1)if(this.options.collapsible&&this.options.selected!=-1)a=this.options.selected;else return this;return this.anchors.eq(a).trigger(this.options.event+".tabs"),this},load:function(b){b=this._getIndex(b);var c=this,d=this.options,e=this.anchors.eq(b)[0],f=a.data(e,"load.tabs");this.abort();if(!f||this.element.queue("tabs").length!==0&&a.data(e,"cache.tabs")){this.element.dequeue("tabs");return}this.lis.eq(b).addClass("ui-state-processing");if(d.spinner){var g=a("span",e);g.data("label.tabs",g.html()).html(d.spinner)}return this.xhr=a.ajax(a.extend({},d.ajaxOptions,{url:f,success:function(f,g){c.element.find(c._sanitizeSelector(e.hash)).html(f),c._cleanup(),d.cache&&a.data(e,"cache.tabs",!0),c._trigger("load",null,c._ui(c.anchors[b],c.panels[b]));try{d.ajaxOptions.success(f,g)}catch(h){}},error:function(a,f,g){c._cleanup(),c._trigger("load",null,c._ui(c.anchors[b],c.panels[b]));try{d.ajaxOptions.error(a,f,b,e)}catch(g){}}})),c.element.dequeue("tabs"),this},abort:function(){return this.element.queue([]),this.panels.stop(!1,!0),this.element.queue("tabs",this.element.queue("tabs").splice(-2,2)),this.xhr&&(this.xhr.abort(),delete this.xhr),this._cleanup(),this},url:function(a,b){return this.anchors.eq(a).removeData("cache.tabs").data("load.tabs",b),this},length:function(){return this.anchors.length}}),a.extend(a.ui.tabs,{version:"1.8.21"}),a.extend(a.ui.tabs.prototype,{rotation:null,rotate:function(a,b){var c=this,d=this.options,e=c._rotate||(c._rotate=function(b){clearTimeout(c.rotation),c.rotation=setTimeout(function(){var a=d.selected;c.select(++a<c.anchors.length?a:0)},a),b&&b.stopPropagation()}),f=c._unrotate||(c._unrotate=b?function(a){e()}:function(a){a.clientX&&c.rotate(null)});return a?(this.element.bind("tabsshow",e),this.anchors.bind(d.event+".tabs",f),e()):(clearTimeout(c.rotation),this.element.unbind("tabsshow",e),this.anchors.unbind(d.event+".tabs",f),delete this._rotate,delete this._unrotate),this}})})(jQuery);;


/*!
 * Depends:
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function( e ) {
	mouseHandled = false;
});

$.widget("ui.mouse", {
	options: {
		cancel: ':input,option',
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var self = this;

		this.element
			.bind('mousedown.'+this.widgetName, function(event) {
				return self._mouseDown(event);
			})
			.bind('click.'+this.widgetName, function(event) {
				if (true === $.data(event.target, self.widgetName + '.preventClickEvent')) {
				    $.removeData(event.target, self.widgetName + '.preventClickEvent');
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind('.'+this.widgetName);
		if ( this._mouseMoveDelegate ) {
			$(document)
				.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
				.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if( mouseHandled ) { return };

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var self = this,
			btnIsLeft = (event.which == 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel == "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				self.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) {
			$.removeData(event.target, this.widgetName + '.preventClickEvent');
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return self._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return self._mouseUp(event);
		};
		$(document)
			.bind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.bind('mouseup.'+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();
		
		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.browser.msie && !(document.documentMode >= 9) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target == this._mouseDownEvent.target) {
			    $.data(event.target, this.widgetName + '.preventClickEvent', true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(event) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(event) {},
	_mouseDrag: function(event) {},
	_mouseStop: function(event) {},
	_mouseCapture: function(event) { return true; }
});

})(jQuery);


/*!
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

// number of pages in a slider
// (how many times can you page up/down to go through the whole range)
var numPages = 5;

$.widget( "ui.slider", $.ui.mouse, {

	widgetEventPrefix: "slide",

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null
	},

	_create: function() {
		var self = this,
			o = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
			handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
			handleCount = ( o.values && o.values.length ) || 1,
			handles = [];

		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();

		this.element
			.addClass( "ui-slider" +
				" ui-slider-" + this.orientation +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" +
				( o.disabled ? " ui-slider-disabled ui-disabled" : "" ) );

		this.range = $([]);

		if ( o.range ) {
			if ( o.range === true ) {
				if ( !o.values ) {
					o.values = [ this._valueMin(), this._valueMin() ];
				}
				if ( o.values.length && o.values.length !== 2 ) {
					o.values = [ o.values[0], o.values[0] ];
				}
			}

			this.range = $( "<div></div>" )
				.appendTo( this.element )
				.addClass( "ui-slider-range" +
				// note: this isn't the most fittingly semantic framework class for this element,
				// but worked best visually with a variety of themes
				" ui-widget-header" + 
				( ( o.range === "min" || o.range === "max" ) ? " ui-slider-range-" + o.range : "" ) );
		}

		for ( var i = existingHandles.length; i < handleCount; i += 1 ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( self.element ) );

		this.handle = this.handles.eq( 0 );

		this.handles.add( this.range ).filter( "a" )
			.click(function( event ) {
				event.preventDefault();
			})
			.hover(function() {
				if ( !o.disabled ) {
					$( this ).addClass( "ui-state-hover" );
				}
			}, function() {
				$( this ).removeClass( "ui-state-hover" );
			})
			.focus(function() {
				if ( !o.disabled ) {
					$( ".ui-slider .ui-state-focus" ).removeClass( "ui-state-focus" );
					$( this ).addClass( "ui-state-focus" );
				} else {
					$( this ).blur();
				}
			})
			.blur(function() {
				$( this ).removeClass( "ui-state-focus" );
			});

		this.handles.each(function( i ) {
			$( this ).data( "index.ui-slider-handle", i );
		});

		this.handles
			.keydown(function( event ) {
				var index = $( this ).data( "index.ui-slider-handle" ),
					allowed,
					curVal,
					newVal,
					step;
	
				if ( self.options.disabled ) {
					return;
				}
	
				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
					case $.ui.keyCode.END:
					case $.ui.keyCode.PAGE_UP:
					case $.ui.keyCode.PAGE_DOWN:
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						event.preventDefault();
						if ( !self._keySliding ) {
							self._keySliding = true;
							$( this ).addClass( "ui-state-active" );
							allowed = self._start( event, index );
							if ( allowed === false ) {
								return;
							}
						}
						break;
				}
	
				step = self.options.step;
				if ( self.options.values && self.options.values.length ) {
					curVal = newVal = self.values( index );
				} else {
					curVal = newVal = self.value();
				}
	
				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
						newVal = self._valueMin();
						break;
					case $.ui.keyCode.END:
						newVal = self._valueMax();
						break;
					case $.ui.keyCode.PAGE_UP:
						newVal = self._trimAlignValue( curVal + ( (self._valueMax() - self._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.PAGE_DOWN:
						newVal = self._trimAlignValue( curVal - ( (self._valueMax() - self._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
						if ( curVal === self._valueMax() ) {
							return;
						}
						newVal = self._trimAlignValue( curVal + step );
						break;
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						if ( curVal === self._valueMin() ) {
							return;
						}
						newVal = self._trimAlignValue( curVal - step );
						break;
				}
	
				self._slide( event, index, newVal );
			})
			.keyup(function( event ) {
				var index = $( this ).data( "index.ui-slider-handle" );
	
				if ( self._keySliding ) {
					self._keySliding = false;
					self._stop( event, index );
					self._change( event, index );
					$( this ).removeClass( "ui-state-active" );
				}
	
			});

		this._refreshValue();

		this._animateOff = false;
	},

	destroy: function() {
		this.handles.remove();
		this.range.remove();

		this.element
			.removeClass( "ui-slider" +
				" ui-slider-horizontal" +
				" ui-slider-vertical" +
				" ui-slider-disabled" +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" )
			.removeData( "slider" )
			.unbind( ".slider" );

		this._mouseDestroy();

		return this;
	},

	_mouseCapture: function( event ) {
		var o = this.options,
			position,
			normValue,
			distance,
			closestHandle,
			self,
			index,
			allowed,
			offset,
			mouseOverHandle;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		self = this;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - self.values(i) );
			if ( distance > thisDistance ) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		// workaround for bug #3736 (if both handles of a range are at 0,
		// the first is always used as the one with least distance,
		// and moving it is obviously prevented by preventing negative ranges)
		if( o.range === true && this.values(1) === o.min ) {
			index += 1;
			closestHandle = $( this.handles[index] );
		}

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		self._handleIndex = index;

		closestHandle
			.addClass( "ui-state-active" )
			.focus();
		
		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().andSelf().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
				( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
				( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function( event ) {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );
		
		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},
	
	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( "start", event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values && this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 && this.options.range === true ) && 
					( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal, true );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( "stop", event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			this._trigger( "change", event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values && this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		$.Widget.prototype._setOption.apply( this, arguments );

		switch ( key ) {
			case "disabled":
				if ( value ) {
					this.handles.filter( ".ui-state-focus" ).blur();
					this.handles.removeClass( "ui-state-hover" );
					this.handles.propAttr( "disabled", true );
					this.element.addClass( "ui-disabled" );
				} else {
					this.handles.propAttr( "disabled", false );
					this.element.removeClass( "ui-disabled" );
				}
				break;
			case "orientation":
				this._detectOrientation();
				this.element
					.removeClass( "ui-slider-horizontal ui-slider-vertical" )
					.addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i < valsLength; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
		}
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else {
			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i+= 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		}
	},
	
	// returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = (val - this._valueMin()) % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.options.max;
	},
	
	_refreshValue: function() {
		var oRange = this.options.range,
			o = this.options,
			self = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			valPercent,
			_set = {},
			lastValPercent,
			value,
			valueMin,
			valueMax;

		if ( this.options.values && this.options.values.length ) {
			this.handles.each(function( i, j ) {
				valPercent = ( self.values(i) - self._valueMin() ) / ( self._valueMax() - self._valueMin() ) * 100;
				_set[ self.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( self.options.range === true ) {
					if ( self.orientation === "horizontal" ) {
						if ( i === 0 ) {
							self.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
						}
						if ( i === 1 ) {
							self.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							self.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
						}
						if ( i === 1 ) {
							self.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ self.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
		}
	}

});

$.extend( $.ui.slider, {
	version: "@VERSION"
});

}(jQuery));



(function(b){b.support.touch="ontouchend" in document;if(!b.support.touch){return;}var c=b.ui.mouse.prototype,e=c._mouseInit,a;function d(g,h){if(g.originalEvent.touches.length>1){return;}g.preventDefault();var i=g.originalEvent.changedTouches[0],f=document.createEvent("MouseEvents");f.initMouseEvent(h,true,true,window,1,i.screenX,i.screenY,i.clientX,i.clientY,false,false,false,false,0,null);g.target.dispatchEvent(f);}c._touchStart=function(g){var f=this;if(a||!f._mouseCapture(g.originalEvent.changedTouches[0])){return;}a=true;f._touchMoved=false;d(g,"mouseover");d(g,"mousemove");d(g,"mousedown");};c._touchMove=function(f){if(!a){return;}this._touchMoved=true;d(f,"mousemove");};c._touchEnd=function(f){if(!a){return;}d(f,"mouseup");d(f,"mouseout");if(!this._touchMoved){d(f,"click");}a=false;};c._mouseInit=function(){var f=this;f.element.bind("touchstart",b.proxy(f,"_touchStart")).bind("touchmove",b.proxy(f,"_touchMove")).bind("touchend",b.proxy(f,"_touchEnd"));e.call(f);};})(jQuery);


/**
 * BxSlider v4.1 
 */

;(function($){

	var plugin = {};
	
	var defaults = {
		
		// GENERAL
		mode: 'horizontal',
		slideSelector: '',
		infiniteLoop: true,
		hideControlOnEnd: false,
		speed: 500,
		easing: null,
		slideMargin: 0,
		startSlide: 0,
		randomStart: false,
		captions: false,
		ticker: false,
		tickerHover: false,
		adaptiveHeight: false,
		adaptiveHeightSpeed: 500,
		video: false,
		useCSS: true,
		preloadImages: 'visible',

		// TOUCH
		touchEnabled: true,
		swipeThreshold: 50,
		oneToOneTouch: true,
		preventDefaultSwipeX: true,
		preventDefaultSwipeY: false,
		
		// PAGER
		pager: true,
		pagerType: 'full',
		pagerShortSeparator: ' / ',
		pagerSelector: null,
		buildPager: null,
		pagerCustom: null,
		
		// CONTROLS
		controls: true,
		nextText: 'Next',
		prevText: 'Prev',
		nextSelector: null,
		prevSelector: null,
		autoControls: false,
		startText: 'Start',
		stopText: 'Stop',
		autoControlsCombine: false,
		autoControlsSelector: null,
		
		// AUTO
		auto: false,
		pause: 4000,
		autoStart: true,
		autoDirection: 'next',
		autoHover: false,
		autoDelay: 0,
		
		// CAROUSEL
		minSlides: 1,
		maxSlides: 1,
		moveSlides: 0,
		slideWidth: 0,
		
		// CALLBACKS
		onSliderLoad: function() {},
		onSlideBefore: function() {},
		onSlideAfter: function() {},
		onSlideNext: function() {},
		onSlidePrev: function() {}
	}

	$.fn.bxSlider = function(options){
		
		if(this.length == 0) return;
		
		// support mutltiple elements
		if(this.length > 1){
			this.each(function(){$(this).bxSlider(options)});
			return this;
		}
		
		// create a namespace to be used throughout the plugin
		var slider = {};
		// set a reference to our slider element
		var el = this;
		plugin.el = this;

		/**
		 * Makes slideshow responsive
		 */
		// first get the original window dimens (thanks alot IE)
		var windowWidth = $(window).width();
		var windowHeight = $(window).height();

		
		
		/**
		 * ===================================================================================
		 * = PRIVATE FUNCTIONS
		 * ===================================================================================
		 */
		
		/**
		 * Initializes namespace settings to be used throughout plugin
		 */
		var init = function(){
			// merge user-supplied options with the defaults
			slider.settings = $.extend({}, defaults, options);
			// parse slideWidth setting
			slider.settings.slideWidth = parseInt(slider.settings.slideWidth);
			// store the original children
			slider.children = el.children(slider.settings.slideSelector);
			// check if actual number of slides is less than minSlides / maxSlides
			if(slider.children.length < slider.settings.minSlides) slider.settings.minSlides = slider.children.length;
			if(slider.children.length < slider.settings.maxSlides) slider.settings.maxSlides = slider.children.length;
			// if random start, set the startSlide setting to random number
			if(slider.settings.randomStart) slider.settings.startSlide = Math.floor(Math.random() * slider.children.length);
			// store active slide information
			slider.active = { index: slider.settings.startSlide }
			// store if the slider is in carousel mode (displaying / moving multiple slides)
			slider.carousel = slider.settings.minSlides > 1 || slider.settings.maxSlides > 1;
			// if carousel, force preloadImages = 'all'
			if(slider.carousel) slider.settings.preloadImages = 'all';
			// calculate the min / max width thresholds based on min / max number of slides
			// used to setup and update carousel slides dimensions
			slider.minThreshold = (slider.settings.minSlides * slider.settings.slideWidth) + ((slider.settings.minSlides - 1) * slider.settings.slideMargin);
			slider.maxThreshold = (slider.settings.maxSlides * slider.settings.slideWidth) + ((slider.settings.maxSlides - 1) * slider.settings.slideMargin);
			// store the current state of the slider (if currently animating, working is true)
			slider.working = false;
			// initialize the controls object
			slider.controls = {};
			// initialize an auto interval
			slider.interval = null;
			// determine which property to use for transitions
			slider.animProp = slider.settings.mode == 'vertical' ? 'top' : 'left';
			// determine if hardware acceleration can be used
			slider.usingCSS = slider.settings.useCSS && slider.settings.mode != 'fade' && (function(){
				// create our test div element
				var div = document.createElement('div');
				// css transition properties
				var props = ['WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective'];
				// test for each property
				for(var i in props){
					if(div.style[props[i]] !== undefined){
						slider.cssPrefix = props[i].replace('Perspective', '').toLowerCase();
						slider.animProp = '-' + slider.cssPrefix + '-transform';
						return true;
					}
				}
				return false;
			}());
			// if vertical mode always make maxSlides and minSlides equal
			if(slider.settings.mode == 'vertical') slider.settings.maxSlides = slider.settings.minSlides;
			// perform all DOM / CSS modifications
			setup();
		}

		/**
		 * Performs all DOM and CSS modifications
		 */
		var setup = function(){
			// wrap el in a wrapper
			el.wrap('<div class="bx-wrapper"><div class="bx-viewport"></div></div>');
			// store a namspace reference to .bx-viewport
			slider.viewport = el.parent();
			// add a loading div to display while images are loading
			slider.loader = $('<div class="bx-loading" />');
			slider.viewport.prepend(slider.loader);
			// set el to a massive width, to hold any needed slides
			// also strip any margin and padding from el
			el.css({
				width: slider.settings.mode == 'horizontal' ? slider.children.length * 215 + '%' : 'auto',
				position: 'relative'
			});
			// if using CSS, add the easing property
			if(slider.usingCSS && slider.settings.easing){
				el.css('-' + slider.cssPrefix + '-transition-timing-function', slider.settings.easing);
			// if not using CSS and no easing value was supplied, use the default JS animation easing (swing)
			}else if(!slider.settings.easing){
				slider.settings.easing = 'swing';
			}
			var slidesShowing = getNumberSlidesShowing();
			// make modifications to the viewport (.bx-viewport)
			slider.viewport.css({
				width: '100%',
				overflow: 'hidden',
				position: 'relative'
			});
			slider.viewport.parent().css({
				maxWidth: getViewportMaxWidth()
			});
			// apply css to all slider children
			slider.children.css({
				'float': slider.settings.mode == 'horizontal' ? 'left' : 'none',
				listStyle: 'none',
				position: 'relative'
			});
			// apply the calculated width after the float is applied to prevent scrollbar interference
			slider.children.width(getSlideWidth());
			// if slideMargin is supplied, add the css
			if(slider.settings.mode == 'horizontal' && slider.settings.slideMargin > 0) slider.children.css('marginRight', slider.settings.slideMargin);
			if(slider.settings.mode == 'vertical' && slider.settings.slideMargin > 0) slider.children.css('marginBottom', slider.settings.slideMargin);
			// if "fade" mode, add positioning and z-index CSS
			if(slider.settings.mode == 'fade'){
				slider.children.css({
					position: 'absolute',
					zIndex: 0,
					display: 'none'
				});
				// prepare the z-index on the showing element
				slider.children.eq(slider.settings.startSlide).css({zIndex: 50, display: 'block'});
			}
			// create an element to contain all slider controls (pager, start / stop, etc)
			slider.controls.el = $('<div class="bx-controls" />');
			// if captions are requested, add them
			if(slider.settings.captions) appendCaptions();
			// if infinite loop, prepare additional slides
			if(slider.settings.infiniteLoop && slider.settings.mode != 'fade' && !slider.settings.ticker){
				var slice = slider.settings.mode == 'vertical' ? slider.settings.minSlides : slider.settings.maxSlides;
				var sliceAppend = slider.children.slice(0, slice).clone().addClass('bx-clone');
				var slicePrepend = slider.children.slice(-slice).clone().addClass('bx-clone');
				el.append(sliceAppend).prepend(slicePrepend);
			}
			// check if startSlide is last slide
			slider.active.last = slider.settings.startSlide == getPagerQty() - 1;
			// if video is true, set up the fitVids plugin
			if(slider.settings.video) el.fitVids();
			// set the default preload selector (visible)
			var preloadSelector = slider.children.eq(slider.settings.startSlide);
			if (slider.settings.preloadImages == "all") preloadSelector = el.children();
			// only check for control addition if not in "ticker" mode
			if(!slider.settings.ticker){
				// if pager is requested, add it
				if(slider.settings.pager) appendPager();
				// if controls are requested, add them
				if(slider.settings.controls) appendControls();
				// if auto is true, and auto controls are requested, add them
				if(slider.settings.auto && slider.settings.autoControls) appendControlsAuto();
				// if any control option is requested, add the controls wrapper
				if(slider.settings.controls || slider.settings.autoControls || slider.settings.pager) slider.viewport.after(slider.controls.el);
			}
			// preload all images, then perform final DOM / CSS modifications that depend on images being loaded
			preloadSelector.imagesLoaded(start);
		}

		/**
		 * Start the slider
		 */
		var start = function(){
			// remove the loading DOM element
			slider.loader.remove();
			// set the left / top position of "el"
			setSlidePosition();
			// if "vertical" mode, always use adaptiveHeight to prevent odd behavior
			if (slider.settings.mode == 'vertical') slider.settings.adaptiveHeight = true;
			// set the viewport height
			slider.viewport.height(getViewportHeight());
			// make sure everything is positioned just right (same as a window resize)
			el.redrawSlider();
			// onSliderLoad callback
			slider.settings.onSliderLoad(slider.active.index);
			// slider has been fully initialized
			slider.initialized = true;
			// bind the resize call to the window
			$(window).bind('resize', resizeWindow);
			// if auto is true, start the show
			if (slider.settings.auto && slider.settings.autoStart) initAuto();
			// if ticker is true, start the ticker
			if (slider.settings.ticker) initTicker();
			// if pager is requested, make the appropriate pager link active
			if (slider.settings.pager) updatePagerActive(slider.settings.startSlide);
			// check for any updates to the controls (like hideControlOnEnd updates)
			if (slider.settings.controls) updateDirectionControls();
			// if touchEnabled is true, setup the touch events
			if (slider.settings.touchEnabled && !slider.settings.ticker) initTouch();
		}
		
		/**
		 * Returns the calculated height of the viewport, used to determine either adaptiveHeight or the maxHeight value
		 */
		var getViewportHeight = function(){
			var height = 0;
			// first determine which children (slides) should be used in our height calculation
			var children = $();
			// if mode is not "vertical" and adaptiveHeight is false, include all children
			if(slider.settings.mode != 'vertical' && !slider.settings.adaptiveHeight){
				children = slider.children;
			}else{
				// if not carousel, return the single active child
				if(!slider.carousel){
					children = slider.children.eq(slider.active.index);
				// if carousel, return a slice of children
				}else{
					// get the individual slide index
					var currentIndex = slider.settings.moveSlides == 1 ? slider.active.index : slider.active.index * getMoveBy();
					// add the current slide to the children
					children = slider.children.eq(currentIndex);
					// cycle through the remaining "showing" slides
					for (i = 1; i <= slider.settings.maxSlides - 1; i++){
						// if looped back to the start
						if(currentIndex + i >= slider.children.length){
							children = children.add(slider.children.eq(i - 1));
						}else{
							children = children.add(slider.children.eq(currentIndex + i));
						}
					}
				}
			}
			// if "vertical" mode, calculate the sum of the heights of the children
			if(slider.settings.mode == 'vertical'){
				children.each(function(index) {
				  height += $(this).outerHeight();
				});
				// add user-supplied margins
				if(slider.settings.slideMargin > 0){
					height += slider.settings.slideMargin * (slider.settings.minSlides - 1);
				}
			// if not "vertical" mode, calculate the max height of the children
			}else{
				height = Math.max.apply(Math, children.map(function(){
					return $(this).outerHeight(false);
				}).get());
			}
			return height;
		}

		/**
		 * Returns the calculated width to be used for the outer wrapper / viewport
		 */
		var getViewportMaxWidth = function(){
			var width = '100%';
			if(slider.settings.slideWidth > 0){
				if(slider.settings.mode == 'horizontal'){
					width = (slider.settings.maxSlides * slider.settings.slideWidth) + ((slider.settings.maxSlides - 1) * slider.settings.slideMargin);
				}else{
					width = slider.settings.slideWidth;
				}
			}
			return width;
		}
		
		/**
		 * Returns the calculated width to be applied to each slide
		 */
		var getSlideWidth = function(){
			// start with any user-supplied slide width
			var newElWidth = slider.settings.slideWidth;
			// get the current viewport width
			var wrapWidth = slider.viewport.width();
			// if slide width was not supplied, or is larger than the viewport use the viewport width
			if(slider.settings.slideWidth == 0 ||
				(slider.settings.slideWidth > wrapWidth && !slider.carousel) ||
				slider.settings.mode == 'vertical'){
				newElWidth = wrapWidth;
			// if carousel, use the thresholds to determine the width
			}else if(slider.settings.maxSlides > 1 && slider.settings.mode == 'horizontal'){
				if(wrapWidth > slider.maxThreshold){
					// newElWidth = (wrapWidth - (slider.settings.slideMargin * (slider.settings.maxSlides - 1))) / slider.settings.maxSlides;
				}else if(wrapWidth < slider.minThreshold){
					newElWidth = (wrapWidth - (slider.settings.slideMargin * (slider.settings.minSlides - 1))) / slider.settings.minSlides;
				}
			}
			return newElWidth;
		}
		
		/**
		 * Returns the number of slides currently visible in the viewport (includes partially visible slides)
		 */
		var getNumberSlidesShowing = function(){
			var slidesShowing = 1;
			if(slider.settings.mode == 'horizontal' && slider.settings.slideWidth > 0){
				// if viewport is smaller than minThreshold, return minSlides
				if(slider.viewport.width() < slider.minThreshold){
					slidesShowing = slider.settings.minSlides;
				// if viewport is larger than minThreshold, return maxSlides
				}else if(slider.viewport.width() > slider.maxThreshold){
					slidesShowing = slider.settings.maxSlides;
				// if viewport is between min / max thresholds, divide viewport width by first child width
				}else{
					var childWidth = slider.children.first().width();
					slidesShowing = Math.floor(slider.viewport.width() / childWidth);
				}
			// if "vertical" mode, slides showing will always be minSlides
			}else if(slider.settings.mode == 'vertical'){
				slidesShowing = slider.settings.minSlides;
			}
			return slidesShowing;
		}
		
		/**
		 * Returns the number of pages (one full viewport of slides is one "page")
		 */
		var getPagerQty = function(){
			var pagerQty = 0;
			// if moveSlides is specified by the user
			if(slider.settings.moveSlides > 0){
				if(slider.settings.infiniteLoop){
					pagerQty = slider.children.length / getMoveBy();
				}else{
					// use a while loop to determine pages
					var breakPoint = 0;
					var counter = 0
					// when breakpoint goes above children length, counter is the number of pages
					while (breakPoint < slider.children.length){
						++pagerQty;
						breakPoint = counter + getNumberSlidesShowing();
						counter += slider.settings.moveSlides <= getNumberSlidesShowing() ? slider.settings.moveSlides : getNumberSlidesShowing();
					}
				}
			// if moveSlides is 0 (auto) divide children length by sides showing, then round up
			}else{
				pagerQty = Math.ceil(slider.children.length / getNumberSlidesShowing());
			}
			return pagerQty;
		}
		
		/**
		 * Returns the number of indivual slides by which to shift the slider
		 */
		var getMoveBy = function(){
			// if moveSlides was set by the user and moveSlides is less than number of slides showing
			if(slider.settings.moveSlides > 0 && slider.settings.moveSlides <= getNumberSlidesShowing()){
				return slider.settings.moveSlides;
			}
			// if moveSlides is 0 (auto)
			return getNumberSlidesShowing();
		}
		
		/**
		 * Sets the slider's (el) left or top position
		 */
		var setSlidePosition = function(){
			// if last slide, not infinite loop, and number of children is larger than specified maxSlides
			if(slider.children.length > slider.settings.maxSlides && slider.active.last && !slider.settings.infiniteLoop){
				if (slider.settings.mode == 'horizontal'){
					// get the last child's position
					var lastChild = slider.children.last();
					var position = lastChild.position();
					// set the left position
					setPositionProperty(-(position.left - (slider.viewport.width() - lastChild.width())), 'reset', 0);
				}else if(slider.settings.mode == 'vertical'){
					// get the last showing index's position
					var lastShowingIndex = slider.children.length - slider.settings.minSlides;
					var position = slider.children.eq(lastShowingIndex).position();
					// set the top position
					setPositionProperty(-position.top, 'reset', 0);
				}
			// if not last slide
			}else{
				// get the position of the first showing slide
				var position = slider.children.eq(slider.active.index * getMoveBy()).position();
				// check for last slide
				if (slider.active.index == getPagerQty() - 1) slider.active.last = true;
				// set the repective position
				if (position != undefined){
					if (slider.settings.mode == 'horizontal') setPositionProperty(-position.left, 'reset', 0);
					else if (slider.settings.mode == 'vertical') setPositionProperty(-position.top, 'reset', 0);
				}
			}
		}
		
		/**
		 * Sets the el's animating property position (which in turn will sometimes animate el).
		 * If using CSS, sets the transform property. If not using CSS, sets the top / left property.
		 *
		 * @param value (int) 
		 *  - the animating property's value
		 *
		 * @param type (string) 'slider', 'reset', 'ticker'
		 *  - the type of instance for which the function is being
		 *
		 * @param duration (int) 
		 *  - the amount of time (in ms) the transition should occupy
		 *
		 * @param params (array) optional
		 *  - an optional parameter containing any variables that need to be passed in
		 */
		var setPositionProperty = function(value, type, duration, params){
			// use CSS transform
			if(slider.usingCSS){
				// determine the translate3d value
				var propValue = slider.settings.mode == 'vertical' ? 'translate3d(0, ' + value + 'px, 0)' : 'translate3d(' + value + 'px, 0, 0)';
				// add the CSS transition-duration
				el.css('-' + slider.cssPrefix + '-transition-duration', duration / 1000 + 's');
				if(type == 'slide'){
					// set the property value
					el.css(slider.animProp, propValue);
					// turn off the slider working flag here, in case transitionEnd never gets called
                    slider.working = false;
					// bind a callback method - executes when CSS transition completes
					el.bind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function(){
						// unbind the callback
						el.unbind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd');
						updateAfterSlideTransition();
					});
				}else if(type == 'reset'){
					el.css(slider.animProp, propValue);
				}else if(type == 'ticker'){
					// make the transition use 'linear'
					el.css('-' + slider.cssPrefix + '-transition-timing-function', 'linear');
					el.css(slider.animProp, propValue);
					// bind a callback method - executes when CSS transition completes
					el.bind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd', function(){
						// unbind the callback
						el.unbind('transitionend webkitTransitionEnd oTransitionEnd MSTransitionEnd');
						// reset the position
						setPositionProperty(params['resetValue'], 'reset', 0);
						// start the loop again
						tickerLoop();
					});
				}
			// use JS animate
			}else{
				var animateObj = {};
				animateObj[slider.animProp] = value;
				if(type == 'slide'){
					el.animate(animateObj, duration, slider.settings.easing, function(){
						updateAfterSlideTransition();
					});
				}else if(type == 'reset'){
					el.css(slider.animProp, value)
				}else if(type == 'ticker'){
					el.animate(animateObj, speed, 'linear', function(){
						setPositionProperty(params['resetValue'], 'reset', 0);
						// run the recursive loop after animation
						tickerLoop();
					});
				}
			}
		}
		
		/**
		 * Populates the pager with proper amount of pages
		 */
		var populatePager = function(){
			var pagerHtml = '';
			pagerQty = getPagerQty();
			// loop through each pager item
			for(var i=0; i < pagerQty; i++){
				var linkContent = '';
				// if a buildPager function is supplied, use it to get pager link value, else use index + 1
				if(slider.settings.buildPager && $.isFunction(slider.settings.buildPager)){
					linkContent = slider.settings.buildPager(i);
					slider.pagerEl.addClass('bx-custom-pager');
				}else{
					linkContent = i + 1;
					slider.pagerEl.addClass('bx-default-pager');
				}
				// var linkContent = slider.settings.buildPager && $.isFunction(slider.settings.buildPager) ? slider.settings.buildPager(i) : i + 1;
				// add the markup to the string
				pagerHtml += '<div class="bx-pager-item"><a href="" data-slide-index="' + i + '" class="bx-pager-link">' + linkContent + '</a></div>';
			};
			// populate the pager element with pager links
			slider.pagerEl.html(pagerHtml);
		}
		
		/**
		 * Appends the pager to the controls element
		 */
		var appendPager = function(){
			if(!slider.settings.pagerCustom){
				// create the pager DOM element
				slider.pagerEl = $('<div class="bx-pager" />');
				// if a pager selector was supplied, populate it with the pager
				if(slider.settings.pagerSelector){
					$(slider.settings.pagerSelector).html(slider.pagerEl);
				// if no pager selector was supplied, add it after the wrapper
				}else{
					slider.controls.el.addClass('bx-has-pager').append(slider.pagerEl);
				}
				// populate the pager
				populatePager();
			}else{
				slider.pagerEl = $(slider.settings.pagerCustom);
			}
			// assign the pager click binding
			slider.pagerEl.delegate('a', 'click', clickPagerBind);
		}
		
		/**
		 * Appends prev / next controls to the controls element
		 */
		var appendControls = function(){
			slider.controls.next = $('<a class="bx-next" href="">' + slider.settings.nextText + '</a>');
			slider.controls.prev = $('<a class="bx-prev" href="">' + slider.settings.prevText + '</a>');
			// bind click actions to the controls
			slider.controls.next.bind('click', clickNextBind);
			slider.controls.prev.bind('click', clickPrevBind);
			// if nextSlector was supplied, populate it
			if(slider.settings.nextSelector){
				$(slider.settings.nextSelector).append(slider.controls.next);
			}
			// if prevSlector was supplied, populate it
			if(slider.settings.prevSelector){
				$(slider.settings.prevSelector).append(slider.controls.prev);
			}
			// if no custom selectors were supplied
			if(!slider.settings.nextSelector && !slider.settings.prevSelector){
				// add the controls to the DOM
				slider.controls.directionEl = $('<div class="bx-controls-direction" />');
				// add the control elements to the directionEl
				slider.controls.directionEl.append(slider.controls.prev).append(slider.controls.next);
				// slider.viewport.append(slider.controls.directionEl);
				slider.controls.el.addClass('bx-has-controls-direction').append(slider.controls.directionEl);
			}
		}
		
		/**
		 * Appends start / stop auto controls to the controls element
		 */
		var appendControlsAuto = function(){
			slider.controls.start = $('<div class="bx-controls-auto-item"><a class="bx-start" href="">' + slider.settings.startText + '</a></div>');
			slider.controls.stop = $('<div class="bx-controls-auto-item"><a class="bx-stop" href="">' + slider.settings.stopText + '</a></div>');
			// add the controls to the DOM
			slider.controls.autoEl = $('<div class="bx-controls-auto" />');
			// bind click actions to the controls
			slider.controls.autoEl.delegate('.bx-start', 'click', clickStartBind);
			slider.controls.autoEl.delegate('.bx-stop', 'click', clickStopBind);
			// if autoControlsCombine, insert only the "start" control
			if(slider.settings.autoControlsCombine){
				slider.controls.autoEl.append(slider.controls.start);
			// if autoControlsCombine is false, insert both controls
			}else{
				slider.controls.autoEl.append(slider.controls.start).append(slider.controls.stop);
			}
			// if auto controls selector was supplied, populate it with the controls
			if(slider.settings.autoControlsSelector){
				$(slider.settings.autoControlsSelector).html(slider.controls.autoEl);
			// if auto controls selector was not supplied, add it after the wrapper
			}else{
				slider.controls.el.addClass('bx-has-controls-auto').append(slider.controls.autoEl);
			}
			// update the auto controls
			updateAutoControls(slider.settings.autoStart ? 'stop' : 'start');
		}
		
		/**
		 * Appends image captions to the DOM
		 */
		var appendCaptions = function(){
			// cycle through each child
			slider.children.each(function(index){
				// get the image title attribute
				var title = $(this).find('img:first').attr('title');
				// append the caption
				if (title != undefined) $(this).append('<div class="bx-caption"><span>' + title + '</span></div>');
			});
		}
		
		/**
		 * Click next binding
		 *
		 * @param e (event) 
		 *  - DOM event object
		 */
		var clickNextBind = function(e){
			// if auto show is running, stop it
			if (slider.settings.auto) el.stopAuto();
			el.goToNextSlide();
			e.preventDefault();
		}
		
		/**
		 * Click prev binding
		 *
		 * @param e (event) 
		 *  - DOM event object
		 */
		var clickPrevBind = function(e){
			// if auto show is running, stop it
			if (slider.settings.auto) el.stopAuto();
			el.goToPrevSlide();
			e.preventDefault();
		}
		
		/**
		 * Click start binding
		 *
		 * @param e (event) 
		 *  - DOM event object
		 */
		var clickStartBind = function(e){
			el.startAuto();
			e.preventDefault();
		}
		
		/**
		 * Click stop binding
		 *
		 * @param e (event) 
		 *  - DOM event object
		 */
		var clickStopBind = function(e){
			el.stopAuto();
			e.preventDefault();
		}

		/**
		 * Click pager binding
		 *
		 * @param e (event) 
		 *  - DOM event object
		 */
		var clickPagerBind = function(e){
			// if auto show is running, stop it
			if (slider.settings.auto) el.stopAuto();
			var pagerLink = $(e.currentTarget);
			var pagerIndex = parseInt(pagerLink.attr('data-slide-index'));
			// if clicked pager link is not active, continue with the goToSlide call
			if(pagerIndex != slider.active.index) el.goToSlide(pagerIndex);
			e.preventDefault();
		}
		
		/**
		 * Updates the pager links with an active class
		 *
		 * @param slideIndex (int) 
		 *  - index of slide to make active
		 */
		var updatePagerActive = function(slideIndex){
			// if "short" pager type
			if(slider.settings.pagerType == 'short'){
				slider.pagerEl.html((slideIndex + 1) + slider.settings.pagerShortSeparator + slider.children.length);
				return;
			}
			// remove all pager active classes
			slider.pagerEl.find('a').removeClass('active');
			// apply the active class for all pagers
			slider.pagerEl.each(function(i, el) { $(el).find('a').eq(slideIndex).addClass('active'); });
		}
		
		/**
		 * Performs needed actions after a slide transition
		 */
		var updateAfterSlideTransition = function(){
			// if infinte loop is true
			if(slider.settings.infiniteLoop){
				var position = '';
				// first slide
				if(slider.active.index == 0){
					// set the new position
					position = slider.children.eq(0).position();
				// carousel, last slide
				}else if(slider.active.index == getPagerQty() - 1 && slider.carousel){
					position = slider.children.eq((getPagerQty() - 1) * getMoveBy()).position();
				// last slide
				}else if(slider.active.index == slider.children.length - 1){
					position = slider.children.eq(slider.children.length - 1).position();
				}
				if (slider.settings.mode == 'horizontal') { setPositionProperty(-position.left, 'reset', 0);; }
				else if (slider.settings.mode == 'vertical') { setPositionProperty(-position.top, 'reset', 0);; }
			}
			// declare that the transition is complete
			slider.working = false;
			// onSlideAfter callback
			slider.settings.onSlideAfter(slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);
		}
		
		/**
		 * Updates the auto controls state (either active, or combined switch)
		 *
		 * @param state (string) "start", "stop"
		 *  - the new state of the auto show
		 */
		var updateAutoControls = function(state){
			// if autoControlsCombine is true, replace the current control with the new state 
			if(slider.settings.autoControlsCombine){
				slider.controls.autoEl.html(slider.controls[state]);
			// if autoControlsCombine is false, apply the "active" class to the appropriate control 
			}else{
				slider.controls.autoEl.find('a').removeClass('active');
				slider.controls.autoEl.find('a:not(.bx-' + state + ')').addClass('active');
			}
		}
		
		/**
		 * Updates the direction controls (checks if either should be hidden)
		 */
		var updateDirectionControls = function(){
			// if infiniteLoop is false and hideControlOnEnd is true
			if(!slider.settings.infiniteLoop && slider.settings.hideControlOnEnd){
				// if first slide
				if (slider.active.index == 0){
					slider.controls.prev.addClass('disabled');
					slider.controls.next.removeClass('disabled');
				// if last slide
				}else if(slider.active.index == getPagerQty() - 1){
					slider.controls.next.addClass('disabled');
					slider.controls.prev.removeClass('disabled');
				// if any slide in the middle
				}else{
					slider.controls.prev.removeClass('disabled');
					slider.controls.next.removeClass('disabled');
				}
			// if slider has only one page, disable controls
			}else if(getPagerQty() == 1){
				slider.controls.prev.addClass('disabled');
				slider.controls.next.addClass('disabled');
			}
		}
		
		/**
		 * Initialzes the auto process
		 */
		var initAuto = function(){
			// if autoDelay was supplied, launch the auto show using a setTimeout() call
			if(slider.settings.autoDelay > 0){
				var timeout = setTimeout(el.startAuto, slider.settings.autoDelay);
			// if autoDelay was not supplied, start the auto show normally
			}else{
				el.startAuto();
			}
			// if autoHover is requested
			if(slider.settings.autoHover){
				// on el hover
				el.hover(function(){
					// if the auto show is currently playing (has an active interval)
					if(slider.interval){
						// stop the auto show and pass true agument which will prevent control update
						el.stopAuto(true);
						// create a new autoPaused value which will be used by the relative "mouseout" event
						slider.autoPaused = true;
					}
				}, function(){
					// if the autoPaused value was created be the prior "mouseover" event
					if(slider.autoPaused){
						// start the auto show and pass true agument which will prevent control update
						el.startAuto(true);
						// reset the autoPaused value
						slider.autoPaused = null;
					}
				});
			}
		}
		
		/**
		 * Initialzes the ticker process
		 */
		var initTicker = function(){
			var startPosition = 0;
			// if autoDirection is "next", append a clone of the entire slider
			if(slider.settings.autoDirection == 'next'){
				el.append(slider.children.clone().addClass('bx-clone'));
			// if autoDirection is "prev", prepend a clone of the entire slider, and set the left position
			}else{
				el.prepend(slider.children.clone().addClass('bx-clone'));
				var position = slider.children.first().position();
				startPosition = slider.settings.mode == 'horizontal' ? -position.left : -position.top;
			}
			setPositionProperty(startPosition, 'reset', 0);
			// do not allow controls in ticker mode
			slider.settings.pager = false;
			slider.settings.controls = false;
			slider.settings.autoControls = false;
			// if autoHover is requested
			if(slider.settings.tickerHover && !slider.usingCSS){
				// on el hover
				slider.viewport.hover(function(){
					el.stop();
				}, function(){
					// calculate the total width of children (used to calculate the speed ratio)
					var totalDimens = 0;
					slider.children.each(function(index){
					  totalDimens += slider.settings.mode == 'horizontal' ? $(this).outerWidth(true) : $(this).outerHeight(true);
					});
					// calculate the speed ratio (used to determine the new speed to finish the paused animation)
					var ratio = slider.settings.speed / totalDimens;
					// determine which property to use
					var property = slider.settings.mode == 'horizontal' ? 'left' : 'top';
					// calculate the new speed
					var newSpeed = ratio * (totalDimens - (Math.abs(parseInt(el.css(property)))));
					tickerLoop(newSpeed);
				});
			}
			// start the ticker loop
			tickerLoop();
		}
		
		/**
		 * Runs a continuous loop, news ticker-style
		 */
		var tickerLoop = function(resumeSpeed){
			speed = resumeSpeed ? resumeSpeed : slider.settings.speed;
			var position = {left: 0, top: 0};
			var reset = {left: 0, top: 0};
			// if "next" animate left position to last child, then reset left to 0
			if(slider.settings.autoDirection == 'next'){
				position = el.find('.bx-clone').first().position();
			// if "prev" animate left position to 0, then reset left to first non-clone child
			}else{
				reset = slider.children.first().position();
			}
			var animateProperty = slider.settings.mode == 'horizontal' ? -position.left : -position.top;
			var resetValue = slider.settings.mode == 'horizontal' ? -reset.left : -reset.top;
			var params = {resetValue: resetValue};
			setPositionProperty(animateProperty, 'ticker', speed, params);
		}
		
		/**
		 * Initializes touch events
		 */
		var initTouch = function(){
			// initialize object to contain all touch values
			slider.touch = {
				start: {x: 0, y: 0},
				end: {x: 0, y: 0}
			}
			slider.viewport.bind('touchstart', onTouchStart);
		}
		
		/**
		 * Event handler for "touchstart"
		 *
		 * @param e (event) 
		 *  - DOM event object
		 */
		var onTouchStart = function(e){
			if(slider.working){
				e.preventDefault();
			}else{
				// record the original position when touch starts
				slider.touch.originalPos = el.position();
				var orig = e.originalEvent;
				// record the starting touch x, y coordinates
				slider.touch.start.x = orig.changedTouches[0].pageX;
				slider.touch.start.y = orig.changedTouches[0].pageY;
				// bind a "touchmove" event to the viewport
				slider.viewport.bind('touchmove', onTouchMove);
				// bind a "touchend" event to the viewport
				slider.viewport.bind('touchend', onTouchEnd);
			}
		}
		
		/**
		 * Event handler for "touchmove"
		 *
		 * @param e (event) 
		 *  - DOM event object
		 */
		var onTouchMove = function(e){
			var orig = e.originalEvent;
			// if scrolling on y axis, do not prevent default
			var xMovement = Math.abs(orig.changedTouches[0].pageX - slider.touch.start.x);
			var yMovement = Math.abs(orig.changedTouches[0].pageY - slider.touch.start.y);
			// x axis swipe
			if((xMovement * 3) > yMovement && slider.settings.preventDefaultSwipeX){
				e.preventDefault();
			// y axis swipe
			}else if((yMovement * 3) > xMovement && slider.settings.preventDefaultSwipeY){
				e.preventDefault();
			}
			if(slider.settings.mode != 'fade' && slider.settings.oneToOneTouch){
				var value = 0;
				// if horizontal, drag along x axis
				if(slider.settings.mode == 'horizontal'){
					var change = orig.changedTouches[0].pageX - slider.touch.start.x;
					value = slider.touch.originalPos.left + change;
				// if vertical, drag along y axis
				}else{
					var change = orig.changedTouches[0].pageY - slider.touch.start.y;
					value = slider.touch.originalPos.top + change;
				}
				setPositionProperty(value, 'reset', 0);
			}
		}
		
		/**
		 * Event handler for "touchend"
		 *
		 * @param e (event) 
		 *  - DOM event object
		 */
		var onTouchEnd = function(e){
			slider.viewport.unbind('touchmove', onTouchMove);
			var orig = e.originalEvent;
			var value = 0;
			// record end x, y positions
			slider.touch.end.x = orig.changedTouches[0].pageX;
			slider.touch.end.y = orig.changedTouches[0].pageY;
			// if fade mode, check if absolute x distance clears the threshold
			if(slider.settings.mode == 'fade'){
				var distance = Math.abs(slider.touch.start.x - slider.touch.end.x);
				if(distance >= slider.settings.swipeThreshold){
					slider.touch.start.x > slider.touch.end.x ? el.goToNextSlide() : el.goToPrevSlide();
					el.stopAuto();
				}
			// not fade mode
			}else{
				var distance = 0;
				// calculate distance and el's animate property
				if(slider.settings.mode == 'horizontal'){
					distance = slider.touch.end.x - slider.touch.start.x;
					value = slider.touch.originalPos.left;
				}else{
					distance = slider.touch.end.y - slider.touch.start.y;
					value = slider.touch.originalPos.top;
				}
				// if not infinite loop and first / last slide, do not attempt a slide transition
				if(!slider.settings.infiniteLoop && ((slider.active.index == 0 && distance > 0) || (slider.active.last && distance < 0))){
					setPositionProperty(value, 'reset', 200);
				}else{
					// check if distance clears threshold
					if(Math.abs(distance) >= slider.settings.swipeThreshold){
						distance < 0 ? el.goToNextSlide() : el.goToPrevSlide();
						el.stopAuto();
					}else{
						// el.animate(property, 200);
						setPositionProperty(value, 'reset', 200);
					}
				}
			}
			slider.viewport.unbind('touchend', onTouchEnd);
		}

		/**
		 * Window resize event callback
		 */
		var resizeWindow = function(e){
			// get the new window dimens (again, thank you IE)
			var windowWidthNew = $(window).width();
			var windowHeightNew = $(window).height();
			// make sure that it is a true window resize
			// *we must check this because our dinosaur friend IE fires a window resize event when certain DOM elements
			// are resized. Can you just die already?*
			if(windowWidth != windowWidthNew || windowHeight != windowHeightNew){
				// set the new window dimens
				windowWidth = windowWidthNew;
				windowHeight = windowHeightNew;
				// update all dynamic elements
				el.redrawSlider();
			}
		}
		
		/**
		 * ===================================================================================
		 * = PUBLIC FUNCTIONS
		 * ===================================================================================
		 */
		
		/**
		 * Performs slide transition to the specified slide
		 *
		 * @param slideIndex (int) 
		 *  - the destination slide's index (zero-based)
		 *
		 * @param direction (string) 
		 *  - INTERNAL USE ONLY - the direction of travel ("prev" / "next")
		 */
		el.goToSlide = function(slideIndex, direction){
			// if plugin is currently in motion, ignore request
			if(slider.working || slider.active.index == slideIndex) return;
			// declare that plugin is in motion
			slider.working = true;
			// store the old index
			slider.oldIndex = slider.active.index;
			// if slideIndex is less than zero, set active index to last child (this happens during infinite loop)
			if(slideIndex < 0){
				slider.active.index = getPagerQty() - 1;
			// if slideIndex is greater than children length, set active index to 0 (this happens during infinite loop)
			}else if(slideIndex >= getPagerQty()){
				slider.active.index = 0;
			// set active index to requested slide
			}else{
				slider.active.index = slideIndex;
			}
			// onSlideBefore, onSlideNext, onSlidePrev callbacks
			slider.settings.onSlideBefore(slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);
			if(direction == 'next'){
				slider.settings.onSlideNext(slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);
			}else if(direction == 'prev'){
				slider.settings.onSlidePrev(slider.children.eq(slider.active.index), slider.oldIndex, slider.active.index);
			}
			// check if last slide
			slider.active.last = slider.active.index >= getPagerQty() - 1;
			// update the pager with active class
			if(slider.settings.pager) updatePagerActive(slider.active.index);
			// // check for direction control update
			if(slider.settings.controls) updateDirectionControls();
			// if slider is set to mode: "fade"
			if(slider.settings.mode == 'fade'){
				// if adaptiveHeight is true and next height is different from current height, animate to the new height
				if(slider.settings.adaptiveHeight && slider.viewport.height() != getViewportHeight()){
					slider.viewport.animate({height: getViewportHeight()}, slider.settings.adaptiveHeightSpeed);
				}
				// fade out the visible child and reset its z-index value
				slider.children.filter(':visible').fadeOut(slider.settings.speed).css({zIndex: 0});
				// fade in the newly requested slide
				slider.children.eq(slider.active.index).css('zIndex', 51).fadeIn(slider.settings.speed, function(){
					$(this).css('zIndex', 50);
					updateAfterSlideTransition();
				});
			// slider mode is not "fade"
			}else{
				// if adaptiveHeight is true and next height is different from current height, animate to the new height
				if(slider.settings.adaptiveHeight && slider.viewport.height() != getViewportHeight()){
					slider.viewport.animate({height: getViewportHeight()}, slider.settings.adaptiveHeightSpeed);
				}
				var moveBy = 0;
				var position = {left: 0, top: 0};
				// if carousel and not infinite loop
				if(!slider.settings.infiniteLoop && slider.carousel && slider.active.last){
					if(slider.settings.mode == 'horizontal'){
						// get the last child position
						var lastChild = slider.children.eq(slider.children.length - 1);
						position = lastChild.position();
						// calculate the position of the last slide
						moveBy = slider.viewport.width() - lastChild.width();
					}else{
						// get last showing index position
						var lastShowingIndex = slider.children.length - slider.settings.minSlides;
						position = slider.children.eq(lastShowingIndex).position();
					}
					// horizontal carousel, going previous while on first slide (infiniteLoop mode)
				}else if(slider.carousel && slider.active.last && direction == 'prev'){
					// get the last child position
					var eq = slider.settings.moveSlides == 1 ? slider.settings.maxSlides - getMoveBy() : ((getPagerQty() - 1) * getMoveBy()) - (slider.children.length - slider.settings.maxSlides);
					var lastChild = el.children('.bx-clone').eq(eq);
					position = lastChild.position();
				// if infinite loop and "Next" is clicked on the last slide
				}else if(direction == 'next' && slider.active.index == 0){
					// get the last clone position
					position = el.find('.bx-clone').eq(slider.settings.maxSlides).position();
					slider.active.last = false;
				// normal non-zero requests
				}else if(slideIndex >= 0){
					var requestEl = slideIndex * getMoveBy();
					position = slider.children.eq(requestEl).position();
				}
				// plugin values to be animated
				var value = slider.settings.mode == 'horizontal' ? -(position.left - moveBy) : -position.top;
				setPositionProperty(value, 'slide', slider.settings.speed);
			}
		}
		
		/**
		 * Transitions to the next slide in the show
		 */
		el.goToNextSlide = function(){
			// if infiniteLoop is false and last page is showing, disregard call
			if (!slider.settings.infiniteLoop && slider.active.last) return;
			var pagerIndex = parseInt(slider.active.index) + 1;
			el.goToSlide(pagerIndex, 'next');
		}
		
		/**
		 * Transitions to the prev slide in the show
		 */
		el.goToPrevSlide = function(){
			// if infiniteLoop is false and last page is showing, disregard call
			if (!slider.settings.infiniteLoop && slider.active.index == 0) return;
			var pagerIndex = parseInt(slider.active.index) - 1;
			el.goToSlide(pagerIndex, 'prev');
		}
		
		/**
		 * Starts the auto show
		 *
		 * @param preventControlUpdate (boolean) 
		 *  - if true, auto controls state will not be updated
		 */
		el.startAuto = function(preventControlUpdate){
			// if an interval already exists, disregard call
			if(slider.interval) return;
			// create an interval
			slider.interval = setInterval(function(){
				slider.settings.autoDirection == 'next' ? el.goToNextSlide() : el.goToPrevSlide();
			}, slider.settings.pause);
			// if auto controls are displayed and preventControlUpdate is not true
			if (slider.settings.autoControls && preventControlUpdate != true) updateAutoControls('stop');
		}
		
		/**
		 * Stops the auto show
		 *
		 * @param preventControlUpdate (boolean) 
		 *  - if true, auto controls state will not be updated
		 */
		el.stopAuto = function(preventControlUpdate){
			// if no interval exists, disregard call
			if(!slider.interval) return;
			// clear the interval
			clearInterval(slider.interval);
			slider.interval = null;
			// if auto controls are displayed and preventControlUpdate is not true
			if (slider.settings.autoControls && preventControlUpdate != true) updateAutoControls('start');
		}
		
		/**
		 * Returns current slide index (zero-based)
		 */
		el.getCurrentSlide = function(){
			return slider.active.index;
		}
		
		/**
		 * Returns number of slides in show
		 */
		el.getSlideCount = function(){
			return slider.children.length;
		}

		/**
		 * Update all dynamic slider elements
		 */
		el.redrawSlider = function(){
			// resize all children in ratio to new screen size
			slider.children.add(el.find('.bx-clone')).width(getSlideWidth());
			// adjust the height
			slider.viewport.css('height', getViewportHeight());
			// update the slide position
			if(!slider.settings.ticker) setSlidePosition();
			// if active.last was true before the screen resize, we want
			// to keep it last no matter what screen size we end on
			if (slider.active.last) slider.active.index = getPagerQty() - 1;
			// if the active index (page) no longer exists due to the resize, simply set the index as last
			if (slider.active.index >= getPagerQty()) slider.active.last = true;
			// if a pager is being displayed and a custom pager is not being used, update it
			if(slider.settings.pager && !slider.settings.pagerCustom){
				populatePager();
				updatePagerActive(slider.active.index);
			}
		}

		/**
		 * Destroy the current instance of the slider (revert everything back to original state)
		 */
		el.destroySlider = function(){
			// don't do anything if slider has already been destroyed
			if(!slider.initialized) return;
			slider.initialized = false;
			$('.bx-clone', this).remove();
			slider.children.removeAttr('style');
			this.removeAttr('style').unwrap().unwrap();
			if(slider.controls.el) slider.controls.el.remove();
			if(slider.controls.next) slider.controls.next.remove();
			if(slider.controls.prev) slider.controls.prev.remove();
			if(slider.pagerEl) slider.pagerEl.remove();
			$('.bx-caption', this).remove();
			if(slider.controls.autoEl) slider.controls.autoEl.remove();
			clearInterval(slider.interval);
			$(window).unbind('resize', resizeWindow);
		}

		/**
		 * Reload the slider (revert all DOM changes, and re-initialize)
		 */
		el.reloadSlider = function(settings){
			if (settings != undefined) options = settings;
			el.destroySlider();
			init();
		}
		
		init();
		
		// returns the current jQuery object
		return this;
	}

})(jQuery);

/*!
 * jQuery imagesLoaded plugin v2.1.0
 * http://github.com/desandro/imagesloaded
 *
 * MIT License. by Paul Irish et al.
 */

/*jshint curly: true, eqeqeq: true, noempty: true, strict: true, undef: true, browser: true */
/*global jQuery: false */

(function(c,n){var l="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==";c.fn.imagesLoaded=function(f){function m(){var b=c(i),a=c(h);d&&(h.length?d.reject(e,b,a):d.resolve(e));c.isFunction(f)&&f.call(g,e,b,a)}function j(b,a){b.src===l||-1!==c.inArray(b,k)||(k.push(b),a?h.push(b):i.push(b),c.data(b,"imagesLoaded",{isBroken:a,src:b.src}),o&&d.notifyWith(c(b),[a,e,c(i),c(h)]),e.length===k.length&&(setTimeout(m),e.unbind(".imagesLoaded")))}var g=this,d=c.isFunction(c.Deferred)?c.Deferred():
0,o=c.isFunction(d.notify),e=g.find("img").add(g.filter("img")),k=[],i=[],h=[];c.isPlainObject(f)&&c.each(f,function(b,a){if("callback"===b)f=a;else if(d)d[b](a)});e.length?e.bind("load.imagesLoaded error.imagesLoaded",function(b){j(b.target,"error"===b.type)}).each(function(b,a){var d=a.src,e=c.data(a,"imagesLoaded");if(e&&e.src===d)j(a,e.isBroken);else if(a.complete&&a.naturalWidth!==n)j(a,0===a.naturalWidth||0===a.naturalHeight);else if(a.readyState||a.complete)a.src=l,a.src=d}):m();return d?d.promise(g):
g}})(jQuery);


$(document).ready(function() {
jQuery.easing['jswing'] = jQuery.easing['swing'];
jQuery.extend( jQuery.easing,
{
	def: 'easeOutQuad',
	swing: function (x, t, b, c, d) {
		//alert(jQuery.easing.default);
		return jQuery.easing[jQuery.easing.def](x, t, b, c, d);
	},
	easeInQuad: function (x, t, b, c, d) {
		return c*(t/=d)*t + b;
	},
	easeOutQuad: function (x, t, b, c, d) {
		return -c *(t/=d)*(t-2) + b;
	},
	easeInOutQuad: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t + b;
		return -c/2 * ((--t)*(t-2) - 1) + b;
	},
	easeInCubic: function (x, t, b, c, d) {
		return c*(t/=d)*t*t + b;
	},
	easeOutCubic: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t + 1) + b;
	},
	easeInOutCubic: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t + b;
		return c/2*((t-=2)*t*t + 2) + b;
	},
	easeInQuart: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t + b;
	},
	easeOutQuart: function (x, t, b, c, d) {
		return -c * ((t=t/d-1)*t*t*t - 1) + b;
	},
	easeInOutQuart: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t + b;
		return -c/2 * ((t-=2)*t*t*t - 2) + b;
	},
	easeInQuint: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t*t + b;
	},
	easeOutQuint: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t*t*t + 1) + b;
	},
	easeInOutQuint: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;
		return c/2*((t-=2)*t*t*t*t + 2) + b;
	},
	easeInSine: function (x, t, b, c, d) {
		return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
	},
	easeOutSine: function (x, t, b, c, d) {
		return c * Math.sin(t/d * (Math.PI/2)) + b;
	},
	easeInOutSine: function (x, t, b, c, d) {
		return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
	},
	easeInExpo: function (x, t, b, c, d) {
		return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
	},
	easeOutExpo: function (x, t, b, c, d) {
		return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
	},
	easeInOutExpo: function (x, t, b, c, d) {
		if (t==0) return b;
		if (t==d) return b+c;
		if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
		return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
	},
	easeInCirc: function (x, t, b, c, d) {
		return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;
	},
	easeOutCirc: function (x, t, b, c, d) {
		return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
	},
	easeInOutCirc: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
		return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
	},
	easeInElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
	},
	easeOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
	},
	easeInOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
		return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
	},
	easeInBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*(t/=d)*t*((s+1)*t - s) + b;
	},
	easeOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
	},
	easeInOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158; 
		if ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
		return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
	},
	easeInBounce: function (x, t, b, c, d) {
		return c - jQuery.easing.easeOutBounce (x, d-t, 0, c, d) + b;
	},
	easeOutBounce: function (x, t, b, c, d) {
		if ((t/=d) < (1/2.75)) {
			return c*(7.5625*t*t) + b;
		} else if (t < (2/2.75)) {
			return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
		} else if (t < (2.5/2.75)) {
			return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
		} else {
			return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
		}
	},
	easeInOutBounce: function (x, t, b, c, d) {
		if (t < d/2) return jQuery.easing.easeInBounce (x, t*2, 0, c, d) * .5 + b;
		return jQuery.easing.easeOutBounce (x, t*2-d, 0, c, d) * .5 + c*.5 + b;
	}
});
});


(function(e){var t={init:function(t){var r=e.extend({duration:500,spacing:5},t);if(typeof r.size=="undefined")throw new Error('Kwicks option "size" is required');if(typeof r.minSize=="undefined"&&typeof r.maxSize=="undefined")throw new Error('One of Kwicks options "minSize" or "maxSize" is required');if(typeof r.minSize!="undefined"&&typeof r.maxSize!="undefined")throw new Error('Kwicks options "minSize" and "maxSize" may not both be set');if(r.minSize>r.size)throw new Error('Kwicks option "minSize" may not be greater than "size"');if(r.maxSize<r.size)throw new Error('Kwicks option "maxSize" may not be less than "size"');if(r.behavior&&r.behavior!=="menu")throw new Error("Unrecognized Kwicks behavior specified: "+r.behavior);return this.each(function(){e(this).data("kwicks",new n(this,r))})},expand:function(t){return this.each(function(){var n=e(this),r;if(n.is(".kwicks-processed")){if(typeof t!="number")throw new Error('Kwicks method "expand" requires an index');t>=0&&(r=n.children().eq(t))}else{if(!n.parent().is(".kwicks-processed"))throw new Error('Cannot call "expand" method on a non-Kwicks element');r=n,t=r.index()}var i=r&&r.length?r:n;i.trigger("expand.kwicks",{index:t})})},expanded:function(){var e=this.first().data("kwicks");if(!e)throw new Error('Cannot called "expanded" method on a non-Kwicks element');return e.expandedIndex},select:function(t){return this.each(function(){var n=e(this),r;if(n.is(".kwicks-processed")){if(typeof t!="number")throw new Error('Kwicks method "select" requires an index');t>=0&&(r=n.children().eq(t))}else{if(!n.parent().is(".kwicks-processed"))throw new Error('Cannot call "expand" method on a non-Kwicks element');r=n,t=r.index()}var i=r&&r.length?r:n;i.trigger("select.kwicks",{index:t})})},selected:function(){var e=this.first().data("kwicks");if(!e)throw new Error('Cannot called "selected" method on a non-Kwicks element');return e.selectedIndex}};e.fn.kwicks=function(e){if(t[e])return t[e].apply(this,Array.prototype.slice.call(arguments,1));if(typeof e=="object"||!e)return t.init.apply(this,arguments);throw new Error("Unrecognized kwicks method: "+e)},e.event.special.expand={_default:function(t,n){if(t.namespace!=="kwicks")return;var r=e(t.target),i=r.data("kwicks")||r.parent().data("kwicks");if(!i)return;i.expand(n.index)}},e.event.special.select={_default:function(t,n){if(t.namespace!=="kwicks")return;var r=e(t.target),i=r.data("kwicks")||r.parent().data("kwicks");if(!i)return;i.select(n.index)}};var n=function(n,r){this.opts=r;var i=r.isVertical?"vertical":"horizontal";this.$container=e(n).addClass("kwicks").addClass("kwicks-"+i),this.$panels=this.$container.children();var s=this.$panels.length;typeof r.minSize=="undefined"?r.minSize=(r.size*s-r.maxSize)/(s-1):r.maxSize=r.size*s-r.minSize*(s-1),this.selectedIndex=this.$panels.filter(".kwicks-selected").index(),this.expandedIndex=this.selectedIndex,this.primaryDimension=r.isVertical?"height":"width",this.secondaryDimension=r.isVertical?"width":"height",this.primaryAlignment=r.isVertical?"top":"left",this.secondaryAlignment=r.isVertical?"bottom":"right",this.$timer=e({progress:0}),this.offsets=this.getOffsetsForExpanded(),this.initStyles(),this.initBehavior()};n.prototype.getOffsetsForExpanded=function(){var e=this.expandedIndex,t=this.$panels.length,n=this.opts.spacing,r=this.opts.size,i=this.opts.minSize,s=this.opts.maxSize,o=[0];for(var u=1;u<t;u++)e===-1?o[u]=u*(r+n):u<=e?o[u]=u*(i+n):o[u]=s+i*(u-1)+u*n;return o},n.prototype.setStyle=function(){return e.support.style?function(e,t){e.setAttribute("style",t)}:function(e,t){e.style.cssText=t}}(),n.prototype.updatePanelStyles=function(){var e=this.offsets,t=this.$panels,n=this.primaryDimension,r=this.primaryAlignment,i=this.secondaryAlignment,s=this.opts.spacing,o=this._containerSize;o||(o=this._containerSize=this.$container.css(n).replace("px",""));var u=this._stylesInited?"":"position:absolute;",a,f,l,c;for(var h=t.length;h--;)l=a,a=Math.round(e[h]),h===t.length-1?(f=o-a,c=i+":0;"+n+":"+f+"px;"):(f=l-a-s,c=r+":"+a+"px;"+n+":"+f+"px;"),this.setStyle(t[h],u+c);this._stylesInited||(this.$container.addClass("kwicks-processed"),this._stylesInited=!0)},n.prototype.initStyles=function(){var e=this.opts,t=this.$container,n=this.$panels,r=n.length,i=this.primaryDimension,s=this.secondaryDimension;t.css(i,e.size*r+e.spacing*(r-1)),t.css(s,n.eq(0).css(s)),this.updatePanelStyles()},n.prototype.initBehavior=function(){if(!this.opts.behavior)return;var t=this.$container;switch(this.opts.behavior){case"menu":this.$container.on("mouseleave",function(){t.kwicks("expand",-1)}).children().on("mouseover",function(){e(this).kwicks("expand")}).click(function(){e(this).kwicks("select")});break;default:throw new Error("Unrecognized behavior option: "+this.opts.behavior)}},n.prototype.getExpandedPanel=function(){return this.expandedIndex===-1?e([]):this.$panels.eq(this.expandedIndex)},n.prototype.getSelectedPanel=function(){return this.selectedIndex===-1?e([]):this.$panels.eq(this.selectedIndex)},n.prototype.select=function(e){if(e===this.selectedIndex)return this.expand(e);this.getSelectedPanel().removeClass("kwicks-selected"),this.selectedIndex=e,this.getSelectedPanel().addClass("kwicks-selected"),this.expand(e)},n.prototype.expand=function(e){var t=this;e===-1&&(e=this.selectedIndex);if(e===this.expandedIndex)return;this.getExpandedPanel().removeClass("kwicks-expanded"),this.expandedIndex=e,this.getExpandedPanel().addClass("kwicks-expanded");var n=this.$timer,r=this.$panels.length,i=this.offsets.slice(),s=this.offsets,o=this.getOffsetsForExpanded();n.stop()[0].progress=0,n.animate({progress:1},{duration:this.opts.duration,easing:this.opts.easing,step:function(e){s.length=0;for(var n=0;n<r;n++){var u=o[n],a=u-(u-i[n])*(1-e);s[n]=a}t.updatePanelStyles()}})}})(jQuery);


/* ************************ APAC Ford H.27.3 Code *************************/
/*
  CAUTION: AT NO TIME IS ANY PARTY TO MODIFY THIS FILE OTHER THAN FORD ANALYTICS
  REQUIRED: JS variables that must be set of EVERY call are s_account and omni_filters 

	140827 - add gnav tracking, update BTL
	150609 - current file on site
	160614 - change tracking servers to fordap root

*/

/************************ ADDITIONAL FEATURES ************************   	
	Dynamic Report Suite Selection
	Universal Tag
	Plugins
*/

/*************** Load Account and Filters - Should be set on a page level *****************/

	if (typeof s_account == "undefined" || s_account==null || s_account=='' || typeof omni_filters == "undefined" || omni_filters==null || omni_filters==''){
		var s_account="fapadev";
		var s=s_gi(s_account,1);
		s.linkInternalFilters="javascript:,dragonfly.ford.com," + document.location.host;
	}else{
		var s=s_gi(s_account,1);
		s.linkInternalFilters = omni_filters;
	}
	
	if (changeCookiePeriods(document.location.host)){
		s.cookieDomainPeriods="3"
   		s.fpcookieDomainPeriods="3"
   	}	
		

/**************************************************COMMON CODE******************************************/
/* Conversion Config */
/* Link Tracking Config */
s.trackDownloadLinks=false
s.trackExternalLinks=false
s.trackInlineStats=true
s.linkDownloadFileTypes="exe,zip,wav,mp3,mov,mpg,avi,wmv,pdf,doc,docx,xls,xlsx,ppt,pptx"
s.linkTrackVars="None"
s.linkTrackEvents="None"
s.linkLeaveQueryString=false


/* Plugin Config */
s.usePlugins=true
function s_doPlugins(s) {

/* Set the character set to the same as the page */
	if(!s.charSet) {
		if (document.characterSet)
			{s.charSet = document.characterSet} 
		else
			{s.charSet = document.charset}
	}

/* Force pageName to Lowercase all sites*/
	if(s.pageName)
		s.pageName=s.pageName.toLowerCase();
		
/* Web Trends Tracking */
	if(s.getQueryParam('WT.tsrc') || s.getQueryParam('WT.srch') || s.getQueryParam('WT.mc_id')) webTrendsTracking();
	
/* External Campaign Tracking */
	if(!s.campaign){		
		if(s.getQueryParam('bannerid'))s.campaign=s.getQueryParam('bannerid');
		s.campaign=s.getCustomValOnce(s.campaign,"cmp_getval",0)
	}
	
	if(s.campaign) s.events=s.apl(s.events,"event53",",",2);
	s.prop17=s.getAndPersistValue(s.campaign,'s_p17_pers',90);

/* Set ford campaign ID*/
	if(s.getQueryParam('fmccmp')) s.eVar30=s.getQueryParam('fmccmp');
	s.prop30=s.getAndPersistValue(s.eVar30,'s_p30_pers',90);
	s.eVar30=s.getCustomValOnce(s.eVar30,"eVar30_getval",0);	

/* Campaign Path Tracking */
	s.prop19=s.pageName;
	if(s.campaign) s.prop19=s.campaign+': '+s.pageName;
	else if(s.eVar30) s.prop19=s.eVar30+': '+s.pageName;   
	
/* Internal Campaign Tracking */
	if(!s.eVar13) s.eVar13=s.getQueryParam('intcmp'); 
	s.eVar13=s.getCustomValOnce(s.eVar13,"int_getval",0);
	s.prop13=s.getAndPersistValue(s.eVar13,'s_p13_pers',0);
	
/* Adobe Social Integration */
	if (!s.eVar60) s.eVar60=s.getQueryParam('scmp');
	s.socialPlatforms();

/* Referrer Overide */
	if(s.getQueryParam('referrer')) s.referrer=s.getQueryParam('referrer');   

/* Email Campaign Tracking */
	if (s.getQueryParam('emailid')) s.eVar33=s.getQueryParam('emailid');
	s.prop33=s.getAndPersistValue(s.eVar33,'s_p33_pers',90);
	s.eVar33=s.getCustomValOnce(s.eVar33,"eVar33_getval",0);

/* Paid Search Tracking */
	if (s.getQueryParam('searchid')) s.eVar26 = s.prop26 = s.getQueryParam('searchid','');
	s.eVar26=s.getCustomValOnce(s.eVar26,"eVar26_getval",0);
	if(s.eVar26)s.events=s.apl(s.events,"event54",",",2);
	
/* Navigation Tracking */
	if (s.getQueryParam('gnav')) s.eVar5 = s.getQueryParam('gnav');
	
/* Visit Start Logic */	

	var tempSuite="nosuite"
	if(!s.c_r("s_suite")){
		s.setSuite(s_account,"s_suite",0)	
	}else{
		tempSuite=s.c_r("s_suite");
	}
	
	if(s.getVisitStart("s_visit")||((!tempSuite.match(s_account))&& tempSuite!="")){
		if(!isInternal()||document.referrer==''){
			s.prop48=s.prop49=s.eVar8=trafficsource();			
			s.prop8=s.getAndPersistValue(s.eVar8,'s_p_s_prop8',0);
			var dt=popDT();
			s.eVar36 = s.getCustomValOnce(dt,'ev_36_getval',0);
			s.events = s.apl(s.events,"event17,event52",",",2);
		}
	}
	else if (refSearch(document.referrer)){
    	if (s.getQueryParam('searchid')){
      		s.eVar50 = s.prop50 = "paid:"+s.prop50;
    	}else{
      		s.eVar50 = s.prop50 = "natural:"+s.prop50;
    	}
    	s.eVar50=s.getCustomValOnce(s.eVar50,"eVar50_getval",0)
	}
		
	if(!tempSuite.match(s_account)){
		s.setSuite(tempSuite+s_account,"s_suite",0)
		tempSuite=s.c_r("s_suite");
	}
	    
//support vars
	if((s.linkTrackVars!='None'&& s.linkTrackVars!='')||s.linkTrackVars.match('prop')||s.linkTrackVars.match('eVar')||s.linkTrackVars.match('evar')||s.linkTrackVars.match('events'))
	{
		s.linkTrackVars=s.linkTrackVars+",prop37,prop39,pageName,eVar52,prop52,prop14,eVar14,prop15,eVar15,zip,prop1,prop2,prop3,eVar1,eVar2,eVar3"		
	}
   	s.prop37="160614"
   	if(!s.prop39 && s.pageName)s.prop39=s.pageName
	s.eVar52=s.prop52=document.URL
	s.prop47=s.eVar47="D=UserAgent"
 
 if(s.eVar12 && s.eVar16)s.prop36=s.eVar34=s.eVar12+":"+s.eVar16

}
		
/*************************************CUSTOM COMMON SITE FUNCTIONS*****************************/

function webTrendsTracking(){

	if (s.getQueryParam('WT.srch').indexOf('1') != -1) s.prop26 = s.eVar26 = s.getQueryParam('WT.mc_id');
	
	if (s.getQueryParam('WT.tsrc')){
		if (s.getQueryParam('WT.tsrc').indexOf('AutoBuyout') !=-1) s.campaign='autobuyout: ' + s.getQueryParam('WT.mc_id');
		if (s.getQueryParam('WT.tsrc').indexOf('Banner') !=-1) s.campaign='banner: ' + s.getQueryParam('WT.mc_id');
		if (s.getQueryParam('WT.tsrc').indexOf('Advertorial') !=-1) s.campaign='advertorial: ' + s.getQueryParam('WT.mc_id');
		if (s.getQueryParam('WT.tsrc').indexOf('Video') !=-1) s.campaign='video: ' + s.getQueryParam('WT.mc_id');
		if (s.getQueryParam('WT.tsrc').indexOf('QR_code') !=-1) s.campaign='qrcode: ' + s.getQueryParam('WT.mc_id');
		if (s.getQueryParam('WT.tsrc').indexOf('DirectMail') !=-1) s.campaign='directmail: ' + s.getQueryParam('WT.mc_id');

		if (s.getQueryParam('WT.tsrc').indexOf('Email') !=-1)s.prop33= s.eVar33= s.getQueryParam('WT.mc_id');

		if (s.getQueryParam('WT.tsrc').indexOf('eBroc') !=-1) s.prop30=s.eVar30='ebrochure: ' + s.getQueryParam('WT.mc_id');
		if (s.getQueryParam('WT.tsrc').indexOf('CampaignSite') !=-1) s.prop30=s.eVar30='campaignsite: ' + s.getQueryParam('WT.mc_id');
	}
	
	if (!s.getQueryParam('WT.tsrc') && s.getQueryParam('WT.mc_id')){
	
		if (s.getQueryParam('WT.mc_id').indexOf('eDM_') != -1)s.prop33= s.eVar33= s.getQueryParam('WT.mc_id');
		else s.campaign='banner: ' + s.getQueryParam('WT.mc_id');
	}
}


function padFrontZero(val) {
	if (val < 10) return '0'+val; else return val.toString();
}

function popDT() {
	var dte = new Date();
	return dte.getFullYear()+padFrontZero(dte.getMonth()+1)+padFrontZero(dte.getDate())+' '+padFrontZero(dte.getHours());
}


function trafficsource() {

  	return camp()
}

function camp(){

	if(s.getQueryParam('referrer')) var ref=s.getQueryParam('referrer') 
	else var ref = document.referrer; 
	
	var fordCamp = s.getQueryParam('fmccmp');
	 
	if(s.getQueryParam('bannerid')) return 'banner';
	else if(s.getQueryParam('emailid')) return 'email';
    else if(s.getQueryParam('searchid')) {s.eVar50 = s.prop50 = "paid:" + s.prop50; return 'search-paid';}
    else if(s.getQueryParam('scmp')) return 'social-placement';
    else if(fordCamp){if (fordCamp.indexOf('t2-fdaf')>-1 || fordCamp.indexOf('t2-lda')>-1){return 'fmc:tier2';}else return 'fmc:other';}
    else if(ref=='') return 'typed-bookmarked';
    else if(refSearch(ref)) {s.eVar50 = s.prop50 = "natural:"+s.prop50; return 'search-natural';}
    else if(refSocial(ref)) return 'social';
    else return 'natural-referrer';
}


function refSearch(ref) {
   	var se = new Array('google.|q','yahoo.com|p','msn.com|q','ask.com|q','myway.com|searchfor','altavista.com|q','netscape.com|query','live.com|q','allthweb.com|q','lycos.com|query','.aol.|q','.aol.|query','suche.aolsvc.de|query','suche.aolsvc.de|q','bing.com|q','ask.jp|q','ask.co|ask','ask.jp|ask','ask.co|q','search.mywebsearch.com|searchfor','baidu.com|wd');

    for (i = 0; i < se.length; i++) {
        var tmp = se[i].split('|');
        var keyword = s.getQueryParam(tmp[1], '', ref);
        if (ref.indexOf(tmp[0]) > -1) {
	        if(keyword == ''&& typeof keyword != "undefined")keyword="no keyword"
	   		s.eVar50 = s.prop50 = keyword;
            if (tmp[0] == 'google.') {
                var rnk1 = s.getQueryParam('resnum', '', ref);
                var rnk2 = s.getQueryParam('cd', '', ref);
    
                if (rnk1||rnk2) {
                    s.events = s.apl(s.events, "event50", ",", 1);
                    s.events = s.apl(s.events, "event51", ",", 1);
                   
                    if(rnk1)s.products = s.apl(s.products, ";;;;" + "event50=" + rnk1, ",", 1);
                    if(rnk2)s.products = s.apl(s.products, ";;;;" + "event50=" + rnk2, ",", 1);
                	}
            	}
        
            return true;
        }
    }

    return false;
}

function refSocial(ref) {
   	var socialSites = new Array('12seconds.tv','4travel.jp','advogato.org','ameba.jp','anobii.com','asmallworld.net','backtype.com','badoo.com','bebo.com','bigadda.com','bigtent.com','biip.no','blackplanet.com','blog.seesaa.jp','blogspot.com','blogster.com','blomotion.jp','bolt.com','brightkite.com','buzznet.com','cafemom.com','care2.com','classmates.com','cloob.com','collegeblender.com','cyworld.co.kr','cyworld.com.cn','dailymotion.com','delicious.com','deviantart.com','digg.com','diigo.com','disqus.com','draugiem.lv','facebook.com','faceparty.com','fc2.com','flickr.com','flixster.com','fotolog.com','foursquare.com','friendfeed.com','friendsreunited.com','friendster.com','fubar.com','gaiaonline.com','geni.com','goodreads.com','grono.net','habbo.com','hatena.ne.jp','hi5.com','hotnews.infoseek.co.jp','hyves.nl','ibibo.com','identi.ca','imeem.com','intensedebate.com','irc-galleria.net','iwiw.hu','jaiku.com','jp.myspace.com','kaixin001.com','kaixin002.com','kakaku.com','kanshin.com','kozocom.com','last.fm','linkedin.com','livejournal.com','me2day.net','meetup.com','mister-wong.com','mixi.jp','mixx.com','mouthshut.com','multiply.com','myheritage.com','mylife.com','myspace.com','myyearbook.com','nasza-klasa.pl','netlog.com','nettby.no','netvibes.com','nicovideo.jp','ning.com','odnoklassniki.ru','orkut.com','pakila.jp','photobucket.com','pinterest.com','plaxo.com','plurk.com','plus.google.com','reddit.com','renren.com','skyrock.com','slideshare.net','smcb.jp','smugmug.com','sonico.com','studivz.net','stumbleupon.com','t.163.com','t.co','t.hexun.com','t.ifeng.com','t.people.com.cn','t.qq.com','t.sohu.com','tabelog.com','tagged.com','taringa.net','tripit.com','trombi.com','trytrend.jp','tuenti.com','tumblr.com','twine.com','twitter.com','uhuru.jp','viadeo.com','vimeo.com','vkontakte.ru','vox.com','wayn.com','weibo.com','weourfamily.com','wer-kennt-wen.de','wordpress.com','xanga.com','xing.com','yaplog.jp','yelp.com','youtube.com','yozm.daum.net','yuku.com','zooomr.com');
	
    for (i = 0; i < socialSites.length; i++) {
        if (ref.indexOf(socialSites[i]) > -1) {return true;}
    }
    return false;
}


function isInternal()
{
	
	var ref=document.referrer
	if(ref!='')
	{
		if(ref.indexOf('www.')>-1)ref=ref.replace('www.','')
		if(ref.indexOf('https://')>-1)ref=ref.replace('https://','')
		if(ref.indexOf('http://')>-1)ref=ref.replace('http://','')	
		var ref1=ref.split('/');
		var refdom=ref1[0];
		
	var filter =s.linkInternalFilters.split(',')
	
		for(i=0;i<filter.length; i++)
		{
		if(refdom.indexOf(filter[i])>-1)return true;
		}
	}	

		return false;
}

function changeCookiePeriods(host){
//if more than "ford.co" or "ford.com" - return true
	var hostArray = new Array();
	hostArray = host.split('.');
	for (i=0; i < hostArray.length; i++) {
		if (hostArray[i] == 'ford' || hostArray[i] == 'fordpartner' || hostArray[i] == 'fordfranchise' || hostArray[i] == 'mazda' || hostArray[i] == 'lincoln' || hostArray[i] == 'motocraft' || hostArray[i] == 'fordcaminhoes' || hostArray[i] == 'myford'){
			var maxlength = i + 2;
			if (hostArray.length > maxlength) return true;
		}
	}
}

//List of plugins
s.doPlugins=s_doPlugins
/************************** PLUGINS SECTION *************************/
/* You may insert any plugins you wish to use here.                 */

/*
 * Plugin Utility: Replace v1.0
 */
s.repl=new Function("x","o","n",""
+"var i=x.indexOf(o),l=n.length;while(x&&i>=0){x=x.substring(0,i)+n+x."
+"substring(i+o.length);i=x.indexOf(o,i+l)}return x");

/*
 * Plugin: socialPlatforms v1.1
 */
s.socialPlatforms=new Function("a",""
+"var s=this,g,K,D,E,F,i;g=s.referrer?s.referrer:document.referrer;g=g."
+"toLowerCase();K=s.split(s.socPlatList,'|');for(i=0;i<K.length;i++){"
+"D=s.split(K[i],'>');if(g.indexOf(D[0])!=-1){s.contextData['a.socialcontentprovider']=D[1];}}");
 
s.socPlatList="facebook.com>Facebook|twitter.com>Twitter|t.co/>Twitter|youtube.com>Youtube|clipmarks.com>Clipmarks|dailymotion.com>Dailymotion|delicious.com>Delicious|digg.com>Digg|diigo.com>Diigo|flickr.com>Flickr|flixster.com>Flixster|fotolog.com>Fotolog|friendfeed.com>FriendFeed|google.com/buzz>Google Buzz|buzz.googleapis.com>Google Buzz|plus.google.com>Google+|hulu.com>Hulu|identi.ca>identi.ca|ilike.com>iLike|intensedebate.com>IntenseDebate|myspace.com>MySpace|newsgator.com>Newsgator|photobucket.com>Photobucket|plurk.com>Plurk|slideshare.net>SlideShare|smugmug.com>SmugMug|stumbleupon.com>StumbleUpon|tumblr.com>Tumblr|vimeo.com>Vimeo|wordpress.com>WordPress|xanga.com>Xanga|metacafe.com>Metacafe|pinterest.com>Pinterest";

/*  
 * socialAuthors v1.5.2
 */
s.socialAuthors=new Function("",""
+"var s=this,g;g=s.referrer?s.referrer:document.referrer;if(g.indexOf"
+"('http://t.co/')===0||g.indexOf('https://t.co/')===0||g.indexOf('pi"
+"nterest.com/pin')!==-1||g.indexOf('tumblr.com')!==-1||g.indexOf('yo"
+"utube.com')!==-1){s.Integrate.add('SocialAuthor');s.Integrate.Socia"
+"lAuthor.tEvar='reserved';s.Integrate.SocialAuthor.get('http://sa-se"
+"rvices.social.omniture.com/author/name?var=[VAR]&callback=s.socialA"
+"uthorSearch&rs='+encodeURIComponent(s_account)+'&q='+encodeURICompo"
+"nent(g));s.Integrate.SocialAuthor.delay();s.Integrate.SocialAuthor."
+"setVars=function(s,p){if(p.tEvar==='reserved'){s.contextData['a.soc"
+"ialauthor']=s.user;}else{s[p.tEvar]=s.user;}}}");
s.socialAuthorSearch=new Function("obj",""
+"var s=this;if(typeof obj==='undefined'||typeof obj.author==='undefi"
+"ned'){s.user='Not Found';}else{s.user=obj.author;}s.Integrate.Socia"
+"lAuthor.ready();");

/*
* Plugin Utility: apl v1.1
*/
s.apl = new Function("l", "v", "d", "u", ""
+ "var s=this,m=0;if(!l)l='';if(u){var i,n,a=s.split(l,d);for(i=0;i<a."
+ "length;i++){n=a[i];m=m||(u==1?(n==v):(n.toLowerCase()==v.toLowerCas"
+ "e()));}}if(!m)l=l?l+d+v:v;return l");

/*
* Utility Function: split v1.5 (JS 1.0 compatible)
*/
s.split = new Function("l", "d", ""
+ "var i,x=0,a=new Array;while(l){i=l.indexOf(d);i=i>-1?i:l.length;a[x"
+ "++]=l.substring(0,i);l=l.substring(i+d.length);}return a");

/*
 * Plugin: getQueryParam 2.3
 */
s.getQueryParam=new Function("p","d","u",""
+"var s=this,v='',i,t;d=d?d:'';u=u?u:(s.pageURL?s.pageURL:s.wd.locati"
+"on);if(u=='f')u=s.gtfs().location;while(p){i=p.indexOf(',');i=i<0?p"
+".length:i;t=s.p_gpv(p.substring(0,i),u+'');if(t){t=t.indexOf('#')>-"
+"1?t.substring(0,t.indexOf('#')):t;}if(t)v+=v?d+t:t;p=p.substring(i="
+"=p.length?i:i+1)}return v");
s.p_gpv=new Function("k","u",""
+"var s=this,v='',i=u.indexOf('?'),q;if(k&&i>-1){q=u.substring(i+1);v"
+"=s.pt(q,'&','p_gvf',k)}return v");
s.p_gvf=new Function("t","k",""
+"if(t){var s=this,i=t.indexOf('='),p=i<0?t:t.substring(0,i),v=i<0?'T"
+"rue':t.substring(i+1);if(p.toLowerCase()==k.toLowerCase())return s."
+"epa(v)}return ''");

/*
 * Plugin: Set Suite
 */
s.setSuite=new Function("v","c","e",""
+"var s=this,k=s.c_r(c),a=new Date;e=e?e:0;if(v){a.setTime(a.getTime("
+")+1800000);s.c_w(c,v,a);}else{v='novalue';a.setTime(a.getTime()+1800000);s.c_w(c,v,a);}");

/*
 * Plugin: getAndPersistValue 0.3 - get a value on every page
 */
s.getAndPersistValue=new Function("v","c","e",""
+"var s=this,a=new Date;e=e?e:0;a.setTime(a.getTime()+e*86400000);if("
+"v)s.c_w(c,v,e?a:0);return s.c_r(c);");



/*
 * Plugin: getCustomValOnce 
 */
s.getCustomValOnce=new Function("v","c","e",""
+"var s=this,k=s.c_r(c),a=new Date;e=e?e:0;if(v){a.setTime(a.getTime("
+")+1800000);if(!s.c_w(c,v,a))s.c_w(c,v,0);}else{a.setTime(a.getTime()+1800000);v=s.c_r(c);if(!s.c_w(c,v,a))s.c_w(c,v,a);}return v==k?'':v");


s.join = new Function("v","p",""
+"var s = this;var f,b,d,w;if(p){f=p.front?p.front:'';b=p.back?p.back"
+":'';d=p.delim?p.delim:'';w=p.wrap?p.wrap:'';}var str='';for(var x=0"
+";x<v.length;x++){if(typeof(v[x])=='object' )str+=s.join( v[x],p);el"
+"se str+=w+v[x]+w;if(x<v.length-1)str+=d;}return f+str+b;");

/*
 * Plugin: getVisitStart v2.0 - returns 1 on first page of visit
 * otherwise 0
 */
s.getVisitStart=new Function("c",""
+"var s=this,v=1,t=new Date;t.setTime(t.getTime()+1800000);if(s.c_r(c"
+")){v=0}if(!s.c_w(c,1,t)){s.c_w(c,1,0)}if(!s.c_r(c)){v=0}return v;"); 

function fnGetDomain(url) {
return (url.match(/:\/\/(.[^/]+)/)[1]);
}

/* Configure Modules and Plugins */

s.maxDelay='3000';//max time to wait for 3rd party api response in milliseconds
s.loadModule("Integrate")
s.Integrate.onLoad=function(s,m){
	s.socialAuthors();
	//add other integration module dependent functions here
 };


/* WARNING: Changing any of the below variables will cause drastic
changes to how your visitor data is collected.  Changes should only be
made when instructed to do so by your account manager.*/

s.trackingServer="fordap.sc.omtrdc.net"
s.trackingServerSecure="fordap.sc.omtrdc.net"

/************* Modules **************/

/* Module: Integrate */
s.m_Integrate_c="var m=s.m_i('Integrate');m.add=function(n,o){var m=this,p;if(!o)o='s_Integrate_'+n;if(!m.s.wd[o])m.s.wd[o]=new Object;m[n]=new Object;p=m[n];p._n=n;p._m=m;p._c=0;p._d=0;p.disable=0;p"
+".get=m.get;p.delay=m.delay;p.ready=m.ready;p.beacon=m.beacon;p.script=m.script;m.l[m.l.length]=n};m._g=function(t){var m=this,s=m.s,i,p,f=(t?'use':'set')+'Vars',tcf;for(i=0;i<m.l.length;i++){p=m[m."
+"l[i]];if(p&&!p.disable&&p[f]){if(s.apv>=5&&(!s.isopera||s.apv>=7)){tcf=new Function('s','p','f','var e;try{p[f](s,p)}catch(e){}');tcf(s,p,f)}else p[f](s,p)}}};m._t=function(){this._g(1)};m._fu=func"
+"tion(p,u){var m=this,s=m.s,v,x,y,z,tm=new Date;if(u.toLowerCase().substring(0,4) != 'http')u='http://'+u;if(s.ssl)u=s.rep(u,'http:','https:');p.RAND=Math&&Math.random?Math.floor(Math.random()*10000"
+"000000000):tm.getTime();p.RAND+=Math.floor(tm.getTime()/10800000)%10;x=0;while(x>=0){x=u.indexOf('[',x);if(x>=0){y=u.indexOf(']',x);if(y>x){z=u.substring(x+1,y);if(z.length>2&&z.substring(0,2)=='s."
+"'){v=s[z.substring(2)];if(!v)v=''}else{v=''+p[z];if(!(v==p[z]||parseFloat(v)==p[z]))z=0}if(z) {u=u.substring(0,x)+s.rep(escape(v),'+','%2B')+u.substring(y+1);x=y-(z.length-v.length+1)} else {x=y}}}"
+"}return u};m.get=function(u,v){var p=this,m=p._m;if(!p.disable){if(!v)v='s_'+m._in+'_Integrate_'+p._n+'_get_'+p._c;p._c++;p.VAR=v;p._d++;m.s.loadModule('Integrate:'+v,m._fu(p,u),0,1,p._n)}};m.delay"
+"=function(){var p=this;if(p._d<=0)p._d=1};m.ready=function(){var p=this,m=p._m;p._d=0;if(!p.disable)m.s.dlt()};m._d=function(){var m=this,i,p;for(i=0;i<m.l.length;i++){p=m[m.l[i]];if(p&&!p.disable&"
+"&p._d>0)return 1}return 0};m._x=function(d,n){var p=this[n],x;if(!p.disable){for(x in d)if(x&&(!Object||!Object.prototype||!Object.prototype[x]))p[x]=d[x];p._d--}};m.beacon=function(u){var p=this,m"
+"=p._m,s=m.s,imn='s_i_'+m._in+'_Integrate_'+p._n+'_'+p._c,im;if(!p.disable&&s.d.images&&s.apv>=3&&(!s.isopera||s.apv>=7)&&(s.ns6<0||s.apv>=6.1)){p._c++;im=s.wd[imn]=new Image;im.src=m._fu(p,u)}};m.s"
+"cript=function(u){var p=this,m=p._m;if(!p.disable)m.s.loadModule(0,m._fu(p,u),0,1)};m.l=new Array;if(m.onLoad)m.onLoad(s,m)";
s.m_i("Integrate");


/************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
var s_code='',s_objectID;function s_gi(un,pg,ss){var c="s.version='H.27.3';s.an=s_an;s.logDebug=function(m){var s=this,tcf=new Function('var e;try{console.log(\"'+s.rep(s.rep(s.rep(m,\"\\\\\",\"\\\\"
+"\\\\\"),\"\\n\",\"\\\\n\"),\"\\\"\",\"\\\\\\\"\")+'\");}catch(e){}');tcf()};s.cls=function(x,c){var i,y='';if(!c)c=this.an;for(i=0;i<x.length;i++){n=x.substring(i,i+1);if(c.indexOf(n)>=0)y+=n}retur"
+"n y};s.fl=function(x,l){return x?(''+x).substring(0,l):x};s.co=function(o){return o};s.num=function(x){x=''+x;for(var p=0;p<x.length;p++)if(('0123456789').indexOf(x.substring(p,p+1))<0)return 0;ret"
+"urn 1};s.rep=s_rep;s.sp=s_sp;s.jn=s_jn;s.ape=function(x){var s=this,h='0123456789ABCDEF',f=\"+~!*()'\",i,c=s.charSet,n,l,e,y='';c=c?c.toUpperCase():'';if(x){x=''+x;if(s.em==3){x=encodeURIComponent("
+"x);for(i=0;i<f.length;i++) {n=f.substring(i,i+1);if(x.indexOf(n)>=0)x=s.rep(x,n,\"%\"+n.charCodeAt(0).toString(16).toUpperCase())}}else if(c=='AUTO'&&('').charCodeAt){for(i=0;i<x.length;i++){c=x.su"
+"bstring(i,i+1);n=x.charCodeAt(i);if(n>127){l=0;e='';while(n||l<4){e=h.substring(n%16,n%16+1)+e;n=(n-n%16)/16;l++}y+='%u'+e}else if(c=='+')y+='%2B';else y+=escape(c)}x=y}else x=s.rep(escape(''+x),'+"
+"','%2B');if(c&&c!='AUTO'&&s.em==1&&x.indexOf('%u')<0&&x.indexOf('%U')<0){i=x.indexOf('%');while(i>=0){i++;if(h.substring(8).indexOf(x.substring(i,i+1).toUpperCase())>=0)return x.substring(0,i)+'u00"
+"'+x.substring(i);i=x.indexOf('%',i)}}}return x};s.epa=function(x){var s=this,y,tcf;if(x){x=s.rep(''+x,'+',' ');if(s.em==3){tcf=new Function('x','var y,e;try{y=decodeURIComponent(x)}catch(e){y=unesc"
+"ape(x)}return y');return tcf(x)}else return unescape(x)}return y};s.pt=function(x,d,f,a){var s=this,t=x,z=0,y,r;while(t){y=t.indexOf(d);y=y<0?t.length:y;t=t.substring(0,y);r=s[f](t,a);if(r)return r"
+";z+=y+d.length;t=x.substring(z,x.length);t=z<x.length?t:''}return ''};s.isf=function(t,a){var c=a.indexOf(':');if(c>=0)a=a.substring(0,c);c=a.indexOf('=');if(c>=0)a=a.substring(0,c);if(t.substring("
+"0,2)=='s_')t=t.substring(2);return (t!=''&&t==a)};s.fsf=function(t,a){var s=this;if(s.pt(a,',','isf',t))s.fsg+=(s.fsg!=''?',':'')+t;return 0};s.fs=function(x,f){var s=this;s.fsg='';s.pt(x,',','fsf'"
+",f);return s.fsg};s.mpc=function(m,a){var s=this,c,l,n,v;v=s.d.visibilityState;if(!v)v=s.d.webkitVisibilityState;if(v&&v=='prerender'){if(!s.mpq){s.mpq=new Array;l=s.sp('webkitvisibilitychange,visi"
+"bilitychange',',');for(n=0;n<l.length;n++){s.d.addEventListener(l[n],new Function('var s=s_c_il['+s._in+'],c,v;v=s.d.visibilityState;if(!v)v=s.d.webkitVisibilityState;if(s.mpq&&v==\"visible\"){whil"
+"e(s.mpq.length>0){c=s.mpq.shift();s[c.m].apply(s,c.a)}s.mpq=0}'),false)}}c=new Object;c.m=m;c.a=a;s.mpq.push(c);return 1}return 0};s.si=function(){var s=this,i,k,v,c=s_gi+'var s=s_gi(\"'+s.oun+'\")"
+";s.sa(\"'+s.un+'\");';for(i=0;i<s.va_g.length;i++){k=s.va_g[i];v=s[k];if(v!=undefined){if(typeof(v)!='number')c+='s.'+k+'=\"'+s_fe(v)+'\";';else c+='s.'+k+'='+v+';'}}c+=\"s.lnk=s.eo=s.linkName=s.li"
+"nkType=s.wd.s_objectID=s.ppu=s.pe=s.pev1=s.pev2=s.pev3='';\";return c};s.c_d='';s.c_gdf=function(t,a){var s=this;if(!s.num(t))return 1;return 0};s.c_gd=function(){var s=this,d=s.wd.location.hostnam"
+"e,n=s.fpCookieDomainPeriods,p;if(!n)n=s.cookieDomainPeriods;if(d&&!s.c_d){n=n?parseInt(n):2;n=n>2?n:2;p=d.lastIndexOf('.');if(p>=0){while(p>=0&&n>1){p=d.lastIndexOf('.',p-1);n--}s.c_d=p>0&&s.pt(d,'"
+".','c_gdf',0)?d.substring(p):d}}return s.c_d};s.c_r=function(k){var s=this;k=s.ape(k);var c=' '+s.d.cookie,i=c.indexOf(' '+k+'='),e=i<0?i:c.indexOf(';',i),v=i<0?'':s.epa(c.substring(i+2+k.length,e<"
+"0?c.length:e));return v!='[[B]]'?v:''};s.c_w=function(k,v,e){var s=this,d=s.c_gd(),l=s.cookieLifetime,t;v=''+v;l=l?(''+l).toUpperCase():'';if(e&&l!='SESSION'&&l!='NONE'){t=(v!=''?parseInt(l?l:0):-6"
+"0);if(t){e=new Date;e.setTime(e.getTime()+(t*1000))}}if(k&&l!='NONE'){s.d.cookie=k+'='+s.ape(v!=''?v:'[[B]]')+'; path=/;'+(e&&l!='SESSION'?' expires='+e.toGMTString()+';':'')+(d?' domain='+d+';':''"
+");return s.c_r(k)==v}return 0};s.eh=function(o,e,r,f){var s=this,b='s_'+e+'_'+s._in,n=-1,l,i,x;if(!s.ehl)s.ehl=new Array;l=s.ehl;for(i=0;i<l.length&&n<0;i++){if(l[i].o==o&&l[i].e==e)n=i}if(n<0){n=i"
+";l[n]=new Object}x=l[n];x.o=o;x.e=e;f=r?x.b:f;if(r||f){x.b=r?0:o[e];x.o[e]=f}if(x.b){x.o[b]=x.b;return b}return 0};s.cet=function(f,a,t,o,b){var s=this,r,tcf;if(s.apv>=5&&(!s.isopera||s.apv>=7)){tc"
+"f=new Function('s','f','a','t','var e,r;try{r=s[f](a)}catch(e){r=s[t](e)}return r');r=tcf(s,f,a,t)}else{if(s.ismac&&s.u.indexOf('MSIE 4')>=0)r=s[b](a);else{s.eh(s.wd,'onerror',0,o);r=s[f](a);s.eh(s"
+".wd,'onerror',1)}}return r};s.gtfset=function(e){var s=this;return s.tfs};s.gtfsoe=new Function('e','var s=s_c_il['+s._in+'],c;s.eh(window,\"onerror\",1);s.etfs=1;c=s.t();if(c)s.d.write(c);s.etfs=0"
+";return true');s.gtfsfb=function(a){return window};s.gtfsf=function(w){var s=this,p=w.parent,l=w.location;s.tfs=w;if(p&&p.location!=l&&p.location.host==l.host){s.tfs=p;return s.gtfsf(s.tfs)}return "
+"s.tfs};s.gtfs=function(){var s=this;if(!s.tfs){s.tfs=s.wd;if(!s.etfs)s.tfs=s.cet('gtfsf',s.tfs,'gtfset',s.gtfsoe,'gtfsfb')}return s.tfs};s.mrq=function(u){var s=this,l=s.rl[u],n,r;s.rl[u]=0;if(l)fo"
+"r(n=0;n<l.length;n++){r=l[n];s.mr(0,0,r.r,r.t,r.u)}};s.flushBufferedRequests=function(){};s.mr=function(sess,q,rs,ta,u){var s=this,dc=s.dc,t1=s.trackingServer,t2=s.trackingServerSecure,tb=s.trackin"
+"gServerBase,p='.sc',ns=s.visitorNamespace,un=s.cls(u?u:(ns?ns:s.fun)),r=new Object,l,imn='s_i_'+s._in+'_'+un,im,b,e;if(!rs){if(t1){if(t2&&s.ssl)t1=t2}else{if(!tb)tb='2o7.net';if(dc)dc=(''+dc).toLow"
+"erCase();else dc='d1';if(tb=='2o7.net'){if(dc=='d1')dc='112';else if(dc=='d2')dc='122';p=''}t1=un+'.'+dc+'.'+p+tb}rs='http'+(s.ssl?'s':'')+'://'+t1+'/b/ss/'+s.un+'/'+(s.mobile?'5.1':'1')+'/'+s.vers"
+"ion+(s.tcn?'T':'')+'/'+sess+'?AQB=1&ndh=1'+(q?q:'')+'&AQE=1';if(s.isie&&!s.ismac)rs=s.fl(rs,2047)}if(s.d.images&&s.apv>=3&&(!s.isopera||s.apv>=7)&&(s.ns6<0||s.apv>=6.1)){if(!s.rc)s.rc=new Object;if"
+"(!s.rc[un]){s.rc[un]=1;if(!s.rl)s.rl=new Object;s.rl[un]=new Array;setTimeout('if(window.s_c_il)window.s_c_il['+s._in+'].mrq(\"'+un+'\")',750)}else{l=s.rl[un];if(l){r.t=ta;r.u=un;r.r=rs;l[l.length]"
+"=r;return ''}imn+='_'+s.rc[un];s.rc[un]++}if(s.debugTracking){var d='AppMeasurement Debug: '+rs,dl=s.sp(rs,'&'),dln;for(dln=0;dln<dl.length;dln++)d+=\"\\n\\t\"+s.epa(dl[dln]);s.logDebug(d)}im=s.wd["
+"imn];if(!im)im=s.wd[imn]=new Image;im.alt=\"\";im.s_l=0;im.onload=im.onerror=new Function('e','this.s_l=1;var wd=window,s;if(wd.s_c_il){s=wd.s_c_il['+s._in+'];s.bcr();s.mrq(\"'+un+'\");s.nrs--;if(!"
+"s.nrs)s.m_m(\"rr\")}');if(!s.nrs){s.nrs=1;s.m_m('rs')}else s.nrs++;im.src=rs;if(s.useForcedLinkTracking||s.bcf){if(!s.forcedLinkTrackingTimeout)s.forcedLinkTrackingTimeout=250;setTimeout('if(window"
+".s_c_il)window.s_c_il['+s._in+'].bcr()',s.forcedLinkTrackingTimeout);}else if((s.lnk||s.eo)&&(!ta||ta=='_self'||ta=='_top'||ta=='_parent'||(s.wd.name&&ta==s.wd.name))){b=e=new Date;while(!im.s_l&&e"
+".getTime()-b.getTime()<500)e=new Date}return ''}return '<im'+'g sr'+'c=\"'+rs+'\" width=1 height=1 border=0 alt=\"\">'};s.gg=function(v){var s=this;if(!s.wd['s_'+v])s.wd['s_'+v]='';return s.wd['s_'"
+"+v]};s.glf=function(t,a){if(t.substring(0,2)=='s_')t=t.substring(2);var s=this,v=s.gg(t);if(v)s[t]=v};s.gl=function(v){var s=this;if(s.pg)s.pt(v,',','glf',0)};s.rf=function(x){var s=this,y,i,j,h,p,"
+"l=0,q,a,b='',c='',t;if(x&&x.length>255){y=''+x;i=y.indexOf('?');if(i>0){q=y.substring(i+1);y=y.substring(0,i);h=y.toLowerCase();j=0;if(h.substring(0,7)=='http://')j+=7;else if(h.substring(0,8)=='ht"
+"tps://')j+=8;i=h.indexOf(\"/\",j);if(i>0){h=h.substring(j,i);p=y.substring(i);y=y.substring(0,i);if(h.indexOf('google')>=0)l=',q,ie,start,search_key,word,kw,cd,';else if(h.indexOf('yahoo.co')>=0)l="
+"',p,ei,';if(l&&q){a=s.sp(q,'&');if(a&&a.length>1){for(j=0;j<a.length;j++){t=a[j];i=t.indexOf('=');if(i>0&&l.indexOf(','+t.substring(0,i)+',')>=0)b+=(b?'&':'')+t;else c+=(c?'&':'')+t}if(b&&c)q=b+'&'"
+"+c;else c=''}i=253-(q.length-c.length)-y.length;x=y+(i>0?p.substring(0,i):'')+'?'+q}}}}return x};s.s2q=function(k,v,vf,vfp,f){var s=this,qs='',sk,sv,sp,ss,nke,nk,nf,nfl=0,nfn,nfm;if(k==\"contextDat"
+"a\")k=\"c\";if(v){for(sk in v)if((!f||sk.substring(0,f.length)==f)&&v[sk]&&(!vf||vf.indexOf(','+(vfp?vfp+'.':'')+sk+',')>=0)&&(!Object||!Object.prototype||!Object.prototype[sk])){nfm=0;if(nfl)for(n"
+"fn=0;nfn<nfl.length;nfn++)if(sk.substring(0,nfl[nfn].length)==nfl[nfn])nfm=1;if(!nfm){if(qs=='')qs+='&'+k+'.';sv=v[sk];if(f)sk=sk.substring(f.length);if(sk.length>0){nke=sk.indexOf('.');if(nke>0){n"
+"k=sk.substring(0,nke);nf=(f?f:'')+nk+'.';if(!nfl)nfl=new Array;nfl[nfl.length]=nf;qs+=s.s2q(nk,v,vf,vfp,nf)}else{if(typeof(sv)=='boolean'){if(sv)sv='true';else sv='false'}if(sv){if(vfp=='retrieveLi"
+"ghtData'&&f.indexOf('.contextData.')<0){sp=sk.substring(0,4);ss=sk.substring(4);if(sk=='transactionID')sk='xact';else if(sk=='channel')sk='ch';else if(sk=='campaign')sk='v0';else if(s.num(ss)){if(s"
+"p=='prop')sk='c'+ss;else if(sp=='eVar')sk='v'+ss;else if(sp=='list')sk='l'+ss;else if(sp=='hier'){sk='h'+ss;sv=sv.substring(0,255)}}}qs+='&'+s.ape(sk)+'='+s.ape(sv)}}}}}if(qs!='')qs+='&.'+k}return "
+"qs};s.hav=function(){var s=this,qs='',l,fv='',fe='',mn,i,e;if(s.lightProfileID){l=s.va_m;fv=s.lightTrackVars;if(fv)fv=','+fv+','+s.vl_mr+','}else{l=s.va_t;if(s.pe||s.linkType){fv=s.linkTrackVars;fe"
+"=s.linkTrackEvents;if(s.pe){mn=s.pe.substring(0,1).toUpperCase()+s.pe.substring(1);if(s[mn]){fv=s[mn].trackVars;fe=s[mn].trackEvents}}}if(fv)fv=','+fv+','+s.vl_l+','+s.vl_l2;if(fe){fe=','+fe+',';if"
+"(fv)fv+=',events,'}if (s.events2)e=(e?',':'')+s.events2}for(i=0;i<l.length;i++){var k=l[i],v=s[k],b=k.substring(0,4),x=k.substring(4),n=parseInt(x),q=k;if(!v)if(k=='events'&&e){v=e;e=''}if(v&&(!fv|"
+"|fv.indexOf(','+k+',')>=0)&&k!='linkName'&&k!='linkType'){if(k=='supplementalDataID')q='sdid';else if(k=='timestamp')q='ts';else if(k=='dynamicVariablePrefix')q='D';else if(k=='visitorID')q='vid';e"
+"lse if(k=='marketingCloudVisitorID')q='mid';else if(k=='analyticsVisitorID')q='aid';else if(k=='audienceManagerLocationHint')q='aamlh';else if(k=='audienceManagerBlob')q='aamb';else if(k=='authStat"
+"e')q='as';else if(k=='pageURL'){q='g';if(v.length>255){s.pageURLRest=v.substring(255);v=v.substring(0,255);}}else if(k=='pageURLRest')q='-g';else if(k=='referrer'){q='r';v=s.fl(s.rf(v),255)}else if"
+"(k=='vmk'||k=='visitorMigrationKey')q='vmt';else if(k=='visitorMigrationServer'){q='vmf';if(s.ssl&&s.visitorMigrationServerSecure)v=''}else if(k=='visitorMigrationServerSecure'){q='vmf';if(!s.ssl&&"
+"s.visitorMigrationServer)v=''}else if(k=='charSet'){q='ce';if(v.toUpperCase()=='AUTO')v='ISO8859-1';else if(s.em==2||s.em==3)v='UTF-8'}else if(k=='visitorNamespace')q='ns';else if(k=='cookieDomainP"
+"eriods')q='cdp';else if(k=='cookieLifetime')q='cl';else if(k=='variableProvider')q='vvp';else if(k=='currencyCode')q='cc';else if(k=='channel')q='ch';else if(k=='transactionID')q='xact';else if(k=="
+"'campaign')q='v0';else if(k=='resolution')q='s';else if(k=='colorDepth')q='c';else if(k=='javascriptVersion')q='j';else if(k=='javaEnabled')q='v';else if(k=='cookiesEnabled')q='k';else if(k=='brows"
+"erWidth')q='bw';else if(k=='browserHeight')q='bh';else if(k=='connectionType')q='ct';else if(k=='homepage')q='hp';else if(k=='plugins')q='p';else if(k=='events'){if(e)v+=(v?',':'')+e;if(fe)v=s.fs(v"
+",fe)}else if(k=='events2')v='';else if(k=='contextData'){qs+=s.s2q('c',s[k],fv,k,0);v=''}else if(k=='lightProfileID')q='mtp';else if(k=='lightStoreForSeconds'){q='mtss';if(!s.lightProfileID)v=''}el"
+"se if(k=='lightIncrementBy'){q='mti';if(!s.lightProfileID)v=''}else if(k=='retrieveLightProfiles')q='mtsr';else if(k=='deleteLightProfiles')q='mtsd';else if(k=='retrieveLightData'){if(s.retrieveLig"
+"htProfiles)qs+=s.s2q('mts',s[k],fv,k,0);v=''}else if(s.num(x)){if(b=='prop')q='c'+n;else if(b=='eVar')q='v'+n;else if(b=='list')q='l'+n;else if(b=='hier'){q='h'+n;v=s.fl(v,255)}}if(v)qs+='&'+s.ape("
+"q)+'='+(k.substring(0,3)!='pev'?s.ape(v):v)}}return qs};s.ltdf=function(t,h){t=t?t.toLowerCase():'';h=h?h.toLowerCase():'';var qi=h.indexOf('?'),hi=h.indexOf('#');if(qi>=0){if(hi>=0&&hi<qi)qi=hi;}e"
+"lse qi=hi;h=qi>=0?h.substring(0,qi):h;if(t&&h.substring(h.length-(t.length+1))=='.'+t)return 1;return 0};s.ltef=function(t,h){t=t?t.toLowerCase():'';h=h?h.toLowerCase():'';if(t&&h.indexOf(t)>=0)ret"
+"urn 1;return 0};s.lt=function(h){var s=this,lft=s.linkDownloadFileTypes,lef=s.linkExternalFilters,lif=s.linkInternalFilters;lif=lif?lif:s.wd.location.hostname;h=h.toLowerCase();if(s.trackDownloadLi"
+"nks&&lft&&s.pt(lft,',','ltdf',h))return 'd';if(s.trackExternalLinks&&h.indexOf('#')!=0&&h.indexOf('about:')!=0&&h.indexOf('javascript:')!=0&&(lef||lif)&&(!lef||s.pt(lef,',','ltef',h))&&(!lif||!s.pt"
+"(lif,',','ltef',h)))return 'e';return ''};s.lc=new Function('e','var s=s_c_il['+s._in+'],b=s.eh(this,\"onclick\");s.lnk=this;s.t();s.lnk=0;if(b)return this[b](e);return true');s.bcr=function(){var "
+"s=this;if(s.bct&&s.bce)s.bct.dispatchEvent(s.bce);if(s.bcf){if(typeof(s.bcf)=='function')s.bcf();else if(s.bct&&s.bct.href)s.d.location=s.bct.href}s.bct=s.bce=s.bcf=0};s.bc=new Function('e','if(e&&"
+"e.s_fe)return;var s=s_c_il['+s._in+'],f,tcf,t,n,nrs,a,h;if(s.d&&s.d.all&&s.d.all.cppXYctnr)return;if(!s.bbc)s.useForcedLinkTracking=0;else if(!s.useForcedLinkTracking){s.b.removeEventListener(\"cli"
+"ck\",s.bc,true);s.bbc=s.useForcedLinkTracking=0;return}else s.b.removeEventListener(\"click\",s.bc,false);s.eo=e.srcElement?e.srcElement:e.target;nrs=s.nrs;s.t();s.eo=0;if(s.nrs>nrs&&s.useForcedLin"
+"kTracking&&e.target){a=e.target;while(a&&a!=s.b&&a.tagName.toUpperCase()!=\"A\"&&a.tagName.toUpperCase()!=\"AREA\")a=a.parentNode;if(a){h=a.href;if(h.indexOf(\"#\")==0||h.indexOf(\"about:\")==0||h."
+"indexOf(\"javascript:\")==0)h=0;t=a.target;if(e.target.dispatchEvent&&h&&(!t||t==\"_self\"||t==\"_top\"||t==\"_parent\"||(s.wd.name&&t==s.wd.name))){tcf=new Function(\"s\",\"var x;try{n=s.d.createE"
+"vent(\\\\\"MouseEvents\\\\\")}catch(x){n=new MouseEvent}return n\");n=tcf(s);if(n){tcf=new Function(\"n\",\"e\",\"var x;try{n.initMouseEvent(\\\\\"click\\\\\",e.bubbles,e.cancelable,e.view,e.detail"
+",e.screenX,e.screenY,e.clientX,e.clientY,e.ctrlKey,e.altKey,e.shiftKey,e.metaKey,e.button,e.relatedTarget)}catch(x){n=0}return n\");n=tcf(n,e);if(n){n.s_fe=1;e.stopPropagation();if (e.stopImmediate"
+"Propagation) {e.stopImmediatePropagation();}e.preventDefault();s.bct=e.target;s.bce=n}}}}}');s.oh=function(o){var s=this,l=s.wd.location,h=o.href?o.href:'',i,j,k,p;i=h.indexOf(':');j=h.indexOf('?')"
+";k=h.indexOf('/');if(h&&(i<0||(j>=0&&i>j)||(k>=0&&i>k))){p=o.protocol&&o.protocol.length>1?o.protocol:(l.protocol?l.protocol:'');i=l.pathname.lastIndexOf('/');h=(p?p+'//':'')+(o.host?o.host:(l.host"
+"?l.host:''))+(h.substring(0,1)!='/'?l.pathname.substring(0,i<0?0:i)+'/':'')+h}return h};s.ot=function(o){var t=o.tagName;if(o.tagUrn||(o.scopeName&&o.scopeName.toUpperCase()!='HTML'))return '';t=t&"
+"&t.toUpperCase?t.toUpperCase():'';if(t=='SHAPE')t='';if(t){if((t=='INPUT'||t=='BUTTON')&&o.type&&o.type.toUpperCase)t=o.type.toUpperCase();else if(!t&&o.href)t='A';}return t};s.oid=function(o){var "
+"s=this,t=s.ot(o),p,c,n='',x=0;if(t&&!o.s_oid){p=o.protocol;c=o.onclick;if(o.href&&(t=='A'||t=='AREA')&&(!c||!p||p.toLowerCase().indexOf('javascript')<0))n=s.oh(o);else if(c){n=s.rep(s.rep(s.rep(s.r"
+"ep(''+c,\"\\r\",''),\"\\n\",''),\"\\t\",''),' ','');x=2}else if(t=='INPUT'||t=='SUBMIT'){if(o.value)n=o.value;else if(o.innerText)n=o.innerText;else if(o.textContent)n=o.textContent;x=3}else if(o.s"
+"rc&&t=='IMAGE')n=o.src;if(n){o.s_oid=s.fl(n,100);o.s_oidt=x}}return o.s_oid};s.rqf=function(t,un){var s=this,e=t.indexOf('='),u=e>=0?t.substring(0,e):'',q=e>=0?s.epa(t.substring(e+1)):'';if(u&&q&&("
+"','+u+',').indexOf(','+un+',')>=0){if(u!=s.un&&s.un.indexOf(',')>=0)q='&u='+u+q+'&u=0';return q}return ''};s.rq=function(un){if(!un)un=this.un;var s=this,c=un.indexOf(','),v=s.c_r('s_sq'),q='';if(c"
+"<0)return s.pt(v,'&','rqf',un);return s.pt(un,',','rq',0)};s.sqp=function(t,a){var s=this,e=t.indexOf('='),q=e<0?'':s.epa(t.substring(e+1));s.sqq[q]='';if(e>=0)s.pt(t.substring(0,e),',','sqs',q);re"
+"turn 0};s.sqs=function(un,q){var s=this;s.squ[un]=q;return 0};s.sq=function(q){var s=this,k='s_sq',v=s.c_r(k),x,c=0;s.sqq=new Object;s.squ=new Object;s.sqq[q]='';s.pt(v,'&','sqp',0);s.pt(s.un,',','"
+"sqs',q);v='';for(x in s.squ)if(x&&(!Object||!Object.prototype||!Object.prototype[x]))s.sqq[s.squ[x]]+=(s.sqq[s.squ[x]]?',':'')+x;for(x in s.sqq)if(x&&(!Object||!Object.prototype||!Object.prototype["
+"x])&&s.sqq[x]&&(x==q||c<2)){v+=(v?'&':'')+s.sqq[x]+'='+s.ape(x);c++}return s.c_w(k,v,0)};s.wdl=new Function('e','var s=s_c_il['+s._in+'],r=true,b=s.eh(s.wd,\"onload\"),i,o,oc;if(b)r=this[b](e);for("
+"i=0;i<s.d.links.length;i++){o=s.d.links[i];oc=o.onclick?\"\"+o.onclick:\"\";if((oc.indexOf(\"s_gs(\")<0||oc.indexOf(\".s_oc(\")>=0)&&oc.indexOf(\".tl(\")<0)s.eh(o,\"onclick\",0,s.lc);}return r');s."
+"wds=function(){var s=this;if(s.apv>3&&(!s.isie||!s.ismac||s.apv>=5)){if(s.b&&s.b.attachEvent)s.b.attachEvent('onclick',s.bc);else if(s.b&&s.b.addEventListener){if(s.n&&((s.n.userAgent.indexOf('WebK"
+"it')>=0&&s.d.createEvent)||(s.n.userAgent.indexOf('Firefox/2')>=0&&s.wd.MouseEvent))){s.bbc=1;s.useForcedLinkTracking=1;s.b.addEventListener('click',s.bc,true)}s.b.addEventListener('click',s.bc,fal"
+"se)}else s.eh(s.wd,'onload',0,s.wdl)}};s.vs=function(x){var s=this,v=s.visitorSampling,g=s.visitorSamplingGroup,k='s_vsn_'+s.un+(g?'_'+g:''),n=s.c_r(k),e=new Date,y=e.getYear();e.setYear(y+10+(y<19"
+"00?1900:0));if(v){v*=100;if(!n){if(!s.c_w(k,x,e))return 0;n=x}if(n%10000>v)return 0}return 1};s.dyasmf=function(t,m){if(t&&m&&m.indexOf(t)>=0)return 1;return 0};s.dyasf=function(t,m){var s=this,i=t"
+"?t.indexOf('='):-1,n,x;if(i>=0&&m){var n=t.substring(0,i),x=t.substring(i+1);if(s.pt(x,',','dyasmf',m))return n}return 0};s.uns=function(){var s=this,x=s.dynamicAccountSelection,l=s.dynamicAccountL"
+"ist,m=s.dynamicAccountMatch,n,i;s.un=s.un.toLowerCase();if(x&&l){if(!m)m=s.wd.location.host;if(!m.toLowerCase)m=''+m;l=l.toLowerCase();m=m.toLowerCase();n=s.pt(l,';','dyasf',m);if(n)s.un=n}i=s.un.i"
+"ndexOf(',');s.fun=i<0?s.un:s.un.substring(0,i)};s.sa=function(un){var s=this;if(s.un&&s.mpc('sa',arguments))return;s.un=un;if(!s.oun)s.oun=un;else if((','+s.oun+',').indexOf(','+un+',')<0)s.oun+=',"
+"'+un;s.uns()};s.m_i=function(n,a){var s=this,m,f=n.substring(0,1),r,l,i;if(!s.m_l)s.m_l=new Object;if(!s.m_nl)s.m_nl=new Array;m=s.m_l[n];if(!a&&m&&m._e&&!m._i)s.m_a(n);if(!m){m=new Object,m._c='s_"
+"m';m._in=s.wd.s_c_in;m._il=s._il;m._il[m._in]=m;s.wd.s_c_in++;m.s=s;m._n=n;m._l=new Array('_c','_in','_il','_i','_e','_d','_dl','s','n','_r','_g','_g1','_t','_t1','_x','_x1','_rs','_rr','_l');s.m_l"
+"[n]=m;s.m_nl[s.m_nl.length]=n}else if(m._r&&!m._m){r=m._r;r._m=m;l=m._l;for(i=0;i<l.length;i++)if(m[l[i]])r[l[i]]=m[l[i]];r._il[r._in]=r;m=s.m_l[n]=r}if(f==f.toUpperCase())s[n]=m;return m};s.m_a=ne"
+"w Function('n','g','e','if(!g)g=\"m_\"+n;var s=s_c_il['+s._in+'],c=s[g+\"_c\"],m,x,f=0;if(s.mpc(\"m_a\",arguments))return;if(!c)c=s.wd[\"s_\"+g+\"_c\"];if(c&&s_d)s[g]=new Function(\"s\",s_ft(s_d(c)"
+"));x=s[g];if(!x)x=s.wd[\\'s_\\'+g];if(!x)x=s.wd[g];m=s.m_i(n,1);if(x&&(!m._i||g!=\"m_\"+n)){m._i=f=1;if((\"\"+x).indexOf(\"function\")>=0)x(s);else s.m_m(\"x\",n,x,e)}m=s.m_i(n,1);if(m._dl)m._dl=m."
+"_d=0;s.dlt();return f');s.m_m=function(t,n,d,e){t='_'+t;var s=this,i,x,m,f='_'+t,r=0,u;if(s.m_l&&s.m_nl)for(i=0;i<s.m_nl.length;i++){x=s.m_nl[i];if(!n||x==n){m=s.m_i(x);u=m[t];if(u){if((''+u).index"
+"Of('function')>=0){if(d&&e)u=m[t](d,e);else if(d)u=m[t](d);else u=m[t]()}}if(u)r=1;u=m[t+1];if(u&&!m[f]){if((''+u).indexOf('function')>=0){if(d&&e)u=m[t+1](d,e);else if(d)u=m[t+1](d);else u=m[t+1]("
+")}}m[f]=1;if(u)r=1}}return r};s.m_ll=function(){var s=this,g=s.m_dl,i,o;if(g)for(i=0;i<g.length;i++){o=g[i];if(o)s.loadModule(o.n,o.u,o.d,o.l,o.e,1);g[i]=0}};s.loadModule=function(n,u,d,l,e,ln){var"
+" s=this,m=0,i,g,o=0,f1,f2,c=s.h?s.h:s.b,b,tcf;if(n){i=n.indexOf(':');if(i>=0){g=n.substring(i+1);n=n.substring(0,i)}else g=\"m_\"+n;m=s.m_i(n)}if((l||(n&&!s.m_a(n,g)))&&u&&s.d&&c&&s.d.createElement"
+"){if(d){m._d=1;m._dl=1}if(ln){if(s.ssl)u=s.rep(u,'http:','https:');i='s_s:'+s._in+':'+n+':'+g;b='var s=s_c_il['+s._in+'],o=s.d.getElementById(\"'+i+'\");if(s&&o){if(!o.l&&s.wd.'+g+'){o.l=1;if(o.i)c"
+"learTimeout(o.i);o.i=0;s.m_a(\"'+n+'\",\"'+g+'\"'+(e?',\"'+e+'\"':'')+')}';f2=b+'o.c++;if(!s.maxDelay)s.maxDelay=250;if(!o.l&&o.c<(s.maxDelay*2)/100)o.i=setTimeout(o.f2,100)}';f1=new Function('e',b"
+"+'}');tcf=new Function('s','c','i','u','f1','f2','var e,o=0;try{o=s.d.createElement(\"script\");if(o){o.type=\"text/javascript\";'+(n?'o.id=i;o.defer=true;o.onload=o.onreadystatechange=f1;o.f2=f2;o"
+".l=0;':'')+'o.src=u;c.appendChild(o);'+(n?'o.c=0;o.i=setTimeout(f2,100)':'')+'}}catch(e){o=0}return o');o=tcf(s,c,i,u,f1,f2)}else{o=new Object;o.n=n+':'+g;o.u=u;o.d=d;o.l=l;o.e=e;g=s.m_dl;if(!g)g=s"
+".m_dl=new Array;i=0;while(i<g.length&&g[i])i++;g[i]=o}}else if(n){m=s.m_i(n);m._e=1}return m};s.voa=function(vo,r){var s=this,l=s.va_g,i,k,v,x;for(i=0;i<l.length;i++){k=l[i];v=vo[k];if(v||vo['!'+k]"
+"){if(!r&&(k==\"contextData\"||k==\"retrieveLightData\")&&s[k])for(x in s[k])if(!v[x])v[x]=s[k][x];s[k]=v}}};s.vob=function(vo,onlySet){var s=this,l=s.va_g,i,k;for(i=0;i<l.length;i++){k=l[i];vo[k]=s"
+"[k];if(!onlySet&&!vo[k])vo['!'+k]=1}};s.dlt=new Function('var s=s_c_il['+s._in+'],d=new Date,i,vo,f=0;if(s.dll)for(i=0;i<s.dll.length;i++){vo=s.dll[i];if(vo){if(!s.m_m(\"d\")||d.getTime()-vo._t>=s."
+"maxDelay){s.dll[i]=0;s.t(vo)}else f=1}}if(s.dli)clearTimeout(s.dli);s.dli=0;if(f){if(!s.dli)s.dli=setTimeout(s.dlt,s.maxDelay)}else s.dll=0');s.dl=function(vo){var s=this,d=new Date;if(!vo)vo=new O"
+"bject;s.vob(vo);vo._t=d.getTime();if(!s.dll)s.dll=new Array;s.dll[s.dll.length]=vo;if(!s.maxDelay)s.maxDelay=250;s.dlt()};s._waitingForMarketingCloudVisitorID = false;s._doneWaitingForMarketingClou"
+"dVisitorID = false;s._marketingCloudVisitorIDCallback=function(marketingCloudVisitorID) {var s=this;s.marketingCloudVisitorID = marketingCloudVisitorID;s._doneWaitingForMarketingCloudVisitorID = tr"
+"ue;s._callbackWhenReadyToTrackCheck();};s._waitingForAnalyticsVisitorID = false;s._doneWaitingForAnalyticsVisitorID = false;s._analyticsVisitorIDCallback=function(analyticsVisitorID) {var s=this;s."
+"analyticsVisitorID = analyticsVisitorID;s._doneWaitingForAnalyticsVisitorID = true;s._callbackWhenReadyToTrackCheck();};s._waitingForAudienceManagerLocationHint = false;s._doneWaitingForAudienceMan"
+"agerLocationHint = false;s._audienceManagerLocationHintCallback=function(audienceManagerLocationHint) {var s=this;s.audienceManagerLocationHint = audienceManagerLocationHint;s._doneWaitingForAudien"
+"ceManagerLocationHint = true;s._callbackWhenReadyToTrackCheck();};s._waitingForAudienceManagerBlob = false;s._doneWaitingForAudienceManagerBlob = false;s._audienceManagerBlobCallback=function(audie"
+"nceManagerBlob) {var s=this;s.audienceManagerBlob = audienceManagerBlob;s._doneWaitingForAudienceManagerBlob = true;s._callbackWhenReadyToTrackCheck();};s.isReadyToTrack=function() {var s=this,read"
+"yToTrack = true,visitor = s.visitor;if ((visitor) && (visitor.isAllowed())) {if ((!s._waitingForMarketingCloudVisitorID) && (!s.marketingCloudVisitorID) && (visitor.getMarketingCloudVisitorID)) {s."
+"_waitingForMarketingCloudVisitorID = true;s.marketingCloudVisitorID = visitor.getMarketingCloudVisitorID([s,s._marketingCloudVisitorIDCallback]);if (s.marketingCloudVisitorID) {s._doneWaitingForMar"
+"ketingCloudVisitorID = true;}}if ((!s._waitingForAnalyticsVisitorID) && (!s.analyticsVisitorID) && (visitor.getAnalyticsVisitorID)) {s._waitingForAnalyticsVisitorID = true;s.analyticsVisitorID = vi"
+"sitor.getAnalyticsVisitorID([s,s._analyticsVisitorIDCallback]);if (s.analyticsVisitorID) {s._doneWaitingForAnalyticsVisitorID = true;}}if ((!s._waitingForAudienceManagerLocationHint) && (!s.audienc"
+"eManagerLocationHint) && (visitor.getAudienceManagerLocationHint)) {s._waitingForAudienceManagerLocationHint = true;s.audienceManagerLocationHint = visitor.getAudienceManagerLocationHint([s,s._audi"
+"enceManagerLocationHintCallback]);if (s.audienceManagerLocationHint) {s._doneWaitingForAudienceManagerLocationHint = true;}}if ((!s._waitingForAudienceManagerBlob) && (!s.audienceManagerBlob) && (v"
+"isitor.getAudienceManagerBlob)) {s._waitingForAudienceManagerBlob = true;s.audienceManagerBlob = visitor.getAudienceManagerBlob([s,s._audienceManagerBlobCallback]);if (s.audienceManagerBlob) {s._do"
+"neWaitingForAudienceManagerBlob = true;}}if (((s._waitingForMarketingCloudVisitorID)     && (!s._doneWaitingForMarketingCloudVisitorID)     && (!s.marketingCloudVisitorID)) ||((s._waitingForAnalyti"
+"csVisitorID)          && (!s._doneWaitingForAnalyticsVisitorID)          && (!s.analyticsVisitorID)) ||((s._waitingForAudienceManagerLocationHint) && (!s._doneWaitingForAudienceManagerLocationHint)"
+" && (!s.audienceManagerLocationHint)) ||((s._waitingForAudienceManagerBlob)         && (!s._doneWaitingForAudienceManagerBlob)         && (!s.audienceManagerBlob))) {readyToTrack = false;}}return r"
+"eadyToTrack;};s._callbackWhenReadyToTrackQueue = null;s._callbackWhenReadyToTrackInterval = 0;s.callbackWhenReadyToTrack=function(callbackThis,callback,args) {var s=this,callbackInfo;callbackInfo ="
+" {};callbackInfo.callbackThis = callbackThis;callbackInfo.callback     = callback;callbackInfo.args         = args;if (s._callbackWhenReadyToTrackQueue == null) {s._callbackWhenReadyToTrackQueue = "
+"[];}s._callbackWhenReadyToTrackQueue.push(callbackInfo);if (s._callbackWhenReadyToTrackInterval == 0) {s._callbackWhenReadyToTrackInterval = setInterval(s._callbackWhenReadyToTrackCheck,100);}};s._"
+"callbackWhenReadyToTrackCheck=new Function('var s=s_c_il['+s._in+'],callbackNum,callbackInfo;if (s.isReadyToTrack()) {if (s._callbackWhenReadyToTrackInterval) {clearInterval(s._callbackWhenReadyToT"
+"rackInterval);s._callbackWhenReadyToTrackInterval = 0;}if (s._callbackWhenReadyToTrackQueue != null) {while (s._callbackWhenReadyToTrackQueue.length > 0) {callbackInfo = s._callbackWhenReadyToTrack"
+"Queue.shift();callbackInfo.callback.apply(callbackInfo.callbackThis,callbackInfo.args);}}}');s._handleNotReadyToTrack=function(variableOverrides) {var s=this,args,varKey,variableOverridesCopy = nul"
+"l,setVariables = null;if (!s.isReadyToTrack()) {args = [];if (variableOverrides != null) {variableOverridesCopy = {};for (varKey in variableOverrides) {variableOverridesCopy[varKey] = variableOverr"
+"ides[varKey];}}setVariables = {};s.vob(setVariables,true);args.push(variableOverridesCopy);args.push(setVariables);s.callbackWhenReadyToTrack(s,s.track,args);return true;}return false;};s.gfid=func"
+"tion(){var s=this,d='0123456789ABCDEF',k='s_fid',fid=s.c_r(k),h='',l='',i,j,m=8,n=4,e=new Date,y;if(!fid||fid.indexOf('-')<0){for(i=0;i<16;i++){j=Math.floor(Math.random()*m);h+=d.substring(j,j+1);j"
+"=Math.floor(Math.random()*n);l+=d.substring(j,j+1);m=n=16}fid=h+'-'+l;}y=e.getYear();e.setYear(y+2+(y<1900?1900:0));if(!s.c_w(k,fid,e))fid=0;return fid};s.track=s.t=function(vo,setVariables){var s="
+"this,notReadyToTrack,trk=1,tm=new Date,sed=Math&&Math.random?Math.floor(Math.random()*10000000000000):tm.getTime(),sess='s'+Math.floor(tm.getTime()/10800000)%10+sed,y=tm.getYear(),vt=tm.getDate()+'"
+"/'+tm.getMonth()+'/'+(y<1900?y+1900:y)+' '+tm.getHours()+':'+tm.getMinutes()+':'+tm.getSeconds()+' '+tm.getDay()+' '+tm.getTimezoneOffset(),tcf,tfs=s.gtfs(),ta=-1,q='',qs='',code='',vb=new Object;i"
+"f (s.visitor) {if (s.visitor.getAuthState) {s.authState = s.visitor.getAuthState();}if ((!s.supplementalDataID) && (s.visitor.getSupplementalDataID)) {s.supplementalDataID = s.visitor.getSupplement"
+"alDataID(\"AppMeasurement:\" + s._in,(s.expectSupplementalData ? false : true));}}if(s.mpc('t',arguments))return;s.gl(s.vl_g);s.uns();s.m_ll();notReadyToTrack = s._handleNotReadyToTrack(vo);if (!no"
+"tReadyToTrack) {if (setVariables) {s.voa(setVariables);}if(!s.td){var tl=tfs.location,a,o,i,x='',c='',v='',p='',bw='',bh='',j='1.0',k=s.c_w('s_cc','true',0)?'Y':'N',hp='',ct='',pn=0,ps;if(String&&S"
+"tring.prototype){j='1.1';if(j.match){j='1.2';if(tm.setUTCDate){j='1.3';if(s.isie&&s.ismac&&s.apv>=5)j='1.4';if(pn.toPrecision){j='1.5';a=new Array;if(a.forEach){j='1.6';i=0;o=new Object;tcf=new Fun"
+"ction('o','var e,i=0;try{i=new Iterator(o)}catch(e){}return i');i=tcf(o);if(i&&i.next){j='1.7';if(a.reduce){j='1.8';if(j.trim){j='1.8.1';if(Date.parse){j='1.8.2';if(Object.create)j='1.8.5'}}}}}}}}}"
+"if(s.apv>=4)x=screen.width+'x'+screen.height;if(s.isns||s.isopera){if(s.apv>=3){v=s.n.javaEnabled()?'Y':'N';if(s.apv>=4){c=screen.pixelDepth;bw=s.wd.innerWidth;bh=s.wd.innerHeight}}s.pl=s.n.plugins"
+"}else if(s.isie){if(s.apv>=4){v=s.n.javaEnabled()?'Y':'N';c=screen.colorDepth;if(s.apv>=5){bw=s.d.documentElement.offsetWidth;bh=s.d.documentElement.offsetHeight;if(!s.ismac&&s.b){tcf=new Function("
+"'s','tl','var e,hp=0;try{s.b.addBehavior(\"#default#homePage\");hp=s.b.isHomePage(tl)?\"Y\":\"N\"}catch(e){}return hp');hp=tcf(s,tl);tcf=new Function('s','var e,ct=0;try{s.b.addBehavior(\"#default#"
+"clientCaps\");ct=s.b.connectionType}catch(e){}return ct');ct=tcf(s)}}}else r=''}if(s.pl)while(pn<s.pl.length&&pn<30){ps=s.fl(s.pl[pn].name,100)+';';if(p.indexOf(ps)<0)p+=ps;pn++}s.resolution=x;s.co"
+"lorDepth=c;s.javascriptVersion=j;s.javaEnabled=v;s.cookiesEnabled=k;s.browserWidth=bw;s.browserHeight=bh;s.connectionType=ct;s.homepage=hp;s.plugins=p;s.td=1}if(vo){s.vob(vb);s.voa(vo)}if(!s.analyt"
+"icsVisitorID&&!s.marketingCloudVisitorID)s.fid=s.gfid();if((vo&&vo._t)||!s.m_m('d')){if(s.usePlugins)s.doPlugins(s);if(!s.abort){var l=s.wd.location,r=tfs.document.referrer;if(!s.pageURL)s.pageURL="
+"l.href?l.href:l;if(!s.referrer&&!s._1_referrer){s.referrer=r;s._1_referrer=1}s.m_m('g');if(s.lnk||s.eo){var o=s.eo?s.eo:s.lnk,p=s.pageName,w=1,t=s.ot(o),n=s.oid(o),x=o.s_oidt,h,l,i,oc;if(s.eo&&o==s"
+".eo){while(o&&!n&&t!='BODY'){o=o.parentElement?o.parentElement:o.parentNode;if(o){t=s.ot(o);n=s.oid(o);x=o.s_oidt}}if(!n||t=='BODY')o='';if(o){oc=o.onclick?''+o.onclick:'';if((oc.indexOf('s_gs(')>="
+"0&&oc.indexOf('.s_oc(')<0)||oc.indexOf('.tl(')>=0)o=0}}if(o){if(n)ta=o.target;h=s.oh(o);i=h.indexOf('?');h=s.linkLeaveQueryString||i<0?h:h.substring(0,i);l=s.linkName;t=s.linkType?s.linkType.toLowe"
+"rCase():s.lt(h);if(t&&(h||l)){s.pe='lnk_'+(t=='d'||t=='e'?t:'o');s.pev1=(h?s.ape(h):'');s.pev2=(l?s.ape(l):'')}else trk=0;if(s.trackInlineStats){if(!p){p=s.pageURL;w=0}t=s.ot(o);i=o.sourceIndex;if("
+"o.dataset&&o.dataset.sObjectId){s.wd.s_objectID=o.dataset.sObjectId;}else if(o.getAttribute&&o.getAttribute('data-s-object-id')){s.wd.s_objectID=o.getAttribute('data-s-object-id');}else if(s.useFor"
+"cedLinkTracking){s.wd.s_objectID='';oc=o.onclick?''+o.onclick:'';if(oc){var ocb=oc.indexOf('s_objectID'),oce,ocq,ocx;if(ocb>=0){ocb+=10;while(ocb<oc.length&&(\"= \\t\\r\\n\").indexOf(oc.charAt(ocb)"
+")>=0)ocb++;if(ocb<oc.length){oce=ocb;ocq=ocx=0;while(oce<oc.length&&(oc.charAt(oce)!=';'||ocq)){if(ocq){if(oc.charAt(oce)==ocq&&!ocx)ocq=0;else if(oc.charAt(oce)==\"\\\\\")ocx=!ocx;else ocx=0;}else"
+"{ocq=oc.charAt(oce);if(ocq!='\"'&&ocq!=\"'\")ocq=0}oce++;}oc=oc.substring(ocb,oce);if(oc){o.s_soid=new Function('s','var e;try{s.wd.s_objectID='+oc+'}catch(e){}');o.s_soid(s)}}}}}if(s.gg('objectID'"
+")){n=s.gg('objectID');x=1;i=1}if(p&&n&&t)qs='&pid='+s.ape(s.fl(p,255))+(w?'&pidt='+w:'')+'&oid='+s.ape(s.fl(n,100))+(x?'&oidt='+x:'')+'&ot='+s.ape(t)+(i?'&oi='+i:'')}}else trk=0}if(trk||qs){s.sampl"
+"ed=s.vs(sed);if(trk){if(s.sampled)code=s.mr(sess,(vt?'&t='+s.ape(vt):'')+s.hav()+q+(qs?qs:s.rq()),0,ta);qs='';s.m_m('t');if(s.p_r)s.p_r();s.referrer=s.lightProfileID=s.retrieveLightProfiles=s.delet"
+"eLightProfiles=''}s.sq(qs)}}}else s.dl(vo);if(vo)s.voa(vb,1);}s.abort=0;s.supplementalDataID=s.pageURLRest=s.lnk=s.eo=s.linkName=s.linkType=s.wd.s_objectID=s.ppu=s.pe=s.pev1=s.pev2=s.pev3='';if(s.p"
+"g)s.wd.s_lnk=s.wd.s_eo=s.wd.s_linkName=s.wd.s_linkType='';return code};s.trackLink=s.tl=function(o,t,n,vo,f){var s=this;s.lnk=o;s.linkType=t;s.linkName=n;if(f){s.bct=o;s.bcf=f}s.t(vo)};s.trackLight"
+"=function(p,ss,i,vo){var s=this;s.lightProfileID=p;s.lightStoreForSeconds=ss;s.lightIncrementBy=i;s.t(vo)};s.setTagContainer=function(n){var s=this,l=s.wd.s_c_il,i,t,x,y;s.tcn=n;if(l)for(i=0;i<l.le"
+"ngth;i++){t=l[i];if(t&&t._c=='s_l'&&t.tagContainerName==n){s.voa(t);if(t.lmq)for(i=0;i<t.lmq.length;i++){x=t.lmq[i];y='m_'+x.n;if(!s[y]&&!s[y+'_c']){s[y]=t[y];s[y+'_c']=t[y+'_c']}s.loadModule(x.n,x"
+".u,x.d)}if(t.ml)for(x in t.ml)if(s[x]){y=s[x];x=t.ml[x];for(i in x)if(!Object.prototype[i]){if(typeof(x[i])!='function'||(''+x[i]).indexOf('s_c_il')<0)y[i]=x[i]}}if(t.mmq)for(i=0;i<t.mmq.length;i++"
+"){x=t.mmq[i];if(s[x.m]){y=s[x.m];if(y[x.f]&&typeof(y[x.f])=='function'){if(x.a)y[x.f].apply(y,x.a);else y[x.f].apply(y)}}}if(t.tq)for(i=0;i<t.tq.length;i++)s.t(t.tq[i]);t.s=s;return}}};s.wd=window;"
+"s.ssl=(s.wd.location.protocol.toLowerCase().indexOf('https')>=0);s.d=document;s.b=s.d.body;if(s.d.getElementsByTagName){s.h=s.d.getElementsByTagName('HEAD');if(s.h)s.h=s.h[0]}s.n=navigator;s.u=s.n."
+"userAgent;s.ns6=s.u.indexOf('Netscape6/');var apn=s.n.appName,v=s.n.appVersion,ie=v.indexOf('MSIE '),o=s.u.indexOf('Opera '),i;if(v.indexOf('Opera')>=0||o>0)apn='Opera';s.isie=(apn=='Microsoft Inte"
+"rnet Explorer');s.isns=(apn=='Netscape');s.isopera=(apn=='Opera');s.ismac=(s.u.indexOf('Mac')>=0);if(o>0)s.apv=parseFloat(s.u.substring(o+6));else if(ie>0){s.apv=parseInt(i=v.substring(ie+5));if(s."
+"apv>3)s.apv=parseFloat(i)}else if(s.ns6>0)s.apv=parseFloat(s.u.substring(s.ns6+10));else s.apv=parseFloat(v);s.em=0;if(s.em.toPrecision)s.em=3;else if(String.fromCharCode){i=escape(String.fromCharC"
+"ode(256)).toUpperCase();s.em=(i=='%C4%80'?2:(i=='%U0100'?1:0))}if(s.oun)s.sa(s.oun);s.sa(un);s.vl_l='supplementalDataID,timestamp,dynamicVariablePrefix,visitorID,marketingCloudVisitorID,analyticsVi"
+"sitorID,audienceManagerLocationHint,fid,vmk,visitorMigrationKey,visitorMigrationServer,visitorMigrationServerSecure,ppu,charSet,visitorNamespace,cookieDomainPeriods,cookieLifetime,pageName,pageURL,"
+"referrer,contextData,currencyCode,lightProfileID,lightStoreForSeconds,lightIncrementBy,retrieveLightProfiles,deleteLightProfiles,retrieveLightData';s.va_l=s.sp(s.vl_l,',');s.vl_mr=s.vl_m='timestamp"
+",charSet,visitorNamespace,cookieDomainPeriods,cookieLifetime,contextData,lightProfileID,lightStoreForSeconds,lightIncrementBy';s.vl_t=s.vl_l+',variableProvider,channel,server,pageType,transactionID"
+",purchaseID,campaign,state,zip,events,events2,products,audienceManagerBlob,authState,linkName,linkType';var n;for(n=1;n<=75;n++){s.vl_t+=',prop'+n+',eVar'+n;s.vl_m+=',prop'+n+',eVar'+n}for(n=1;n<=5"
+";n++)s.vl_t+=',hier'+n;for(n=1;n<=3;n++)s.vl_t+=',list'+n;s.va_m=s.sp(s.vl_m,',');s.vl_l2=',tnt,pe,pev1,pev2,pev3,resolution,colorDepth,javascriptVersion,javaEnabled,cookiesEnabled,browserWidth,bro"
+"wserHeight,connectionType,homepage,pageURLRest,plugins';s.vl_t+=s.vl_l2;s.va_t=s.sp(s.vl_t,',');s.vl_g=s.vl_t+',trackingServer,trackingServerSecure,trackingServerBase,fpCookieDomainPeriods,disableB"
+"ufferedRequests,mobile,visitorSampling,visitorSamplingGroup,dynamicAccountSelection,dynamicAccountList,dynamicAccountMatch,trackDownloadLinks,trackExternalLinks,trackInlineStats,linkLeaveQueryStrin"
+"g,linkDownloadFileTypes,linkExternalFilters,linkInternalFilters,linkTrackVars,linkTrackEvents,linkNames,lnk,eo,lightTrackVars,_1_referrer,un';s.va_g=s.sp(s.vl_g,',');s.pg=pg;s.gl(s.vl_g);s.contextD"
+"ata=new Object;s.retrieveLightData=new Object;if(!ss)s.wds();if(pg){s.wd.s_co=function(o){return o};s.wd.s_gs=function(un){s_gi(un,1,1).t()};s.wd.s_dc=function(un){s_gi(un,1).t()}}",
w=window,l=w.s_c_il,n=navigator,u=n.userAgent,v=n.appVersion,e=v.indexOf('MSIE '),m=u.indexOf('Netscape6/'),a,i,j,x,s;if(un){un=un.toLowerCase();if(l)for(j=0;j<2;j++)for(i=0;i<l.length;i++){s=l[i];x=s._c;if((!x||x=='s_c'||(j>0&&x=='s_l'))&&(s.oun==un||(s.fs&&s.sa&&s.fs(s.oun,un)))){if(s.sa)s.sa(un);if(x=='s_c')return s}else s=0}}w.s_an='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
w.s_sp=new Function("x","d","var a=new Array,i=0,j;if(x){if(x.split)a=x.split(d);else if(!d)for(i=0;i<x.length;i++)a[a.length]=x.substring(i,i+1);else while(i>=0){j=x.indexOf(d,i);a[a.length]=x.subst"
+"ring(i,j<0?x.length:j);i=j;if(i>=0)i+=d.length}}return a");
w.s_jn=new Function("a","d","var x='',i,j=a.length;if(a&&j>0){x=a[0];if(j>1){if(a.join)x=a.join(d);else for(i=1;i<j;i++)x+=d+a[i]}}return x");
w.s_rep=new Function("x","o","n","return s_jn(s_sp(x,o),n)");
w.s_d=new Function("x","var t='`^@$#',l=s_an,l2=new Object,x2,d,b=0,k,i=x.lastIndexOf('~~'),j,v,w;if(i>0){d=x.substring(0,i);x=x.substring(i+2);l=s_sp(l,'');for(i=0;i<62;i++)l2[l[i]]=i;t=s_sp(t,'');d"
+"=s_sp(d,'~');i=0;while(i<5){v=0;if(x.indexOf(t[i])>=0) {x2=s_sp(x,t[i]);for(j=1;j<x2.length;j++){k=x2[j].substring(0,1);w=t[i]+k;if(k!=' '){v=1;w=d[b+l2[k]]}x2[j]=w+x2[j].substring(1)}}if(v)x=s_jn("
+"x2,'');else{w=t[i]+' ';if(x.indexOf(w)>=0)x=s_rep(x,w,t[i]);i++;b+=62}}}return x");
w.s_fe=new Function("c","return s_rep(s_rep(s_rep(c,'\\\\','\\\\\\\\'),'\"','\\\\\"'),\"\\n\",\"\\\\n\")");
w.s_fa=new Function("f","var s=f.indexOf('(')+1,e=f.indexOf(')'),a='',c;while(s>=0&&s<e){c=f.substring(s,s+1);if(c==',')a+='\",\"';else if((\"\\n\\r\\t \").indexOf(c)<0)a+=c;s++}return a?'\"'+a+'\"':"
+"a");
w.s_ft=new Function("c","c+='';var s,e,o,a,d,q,f,h,x;s=c.indexOf('=function(');while(s>=0){s++;d=1;q='';x=0;f=c.substring(s);a=s_fa(f);e=o=c.indexOf('{',s);e++;while(d>0){h=c.substring(e,e+1);if(q){i"
+"f(h==q&&!x)q='';if(h=='\\\\')x=x?0:1;else x=0}else{if(h=='\"'||h==\"'\")q=h;if(h=='{')d++;if(h=='}')d--}if(d>0)e++}c=c.substring(0,s)+'new Function('+(a?a+',':'')+'\"'+s_fe(c.substring(o+1,e))+'\")"
+"'+c.substring(e+1);s=c.indexOf('=function(')}return c;");
c=s_d(c);if(e>0){a=parseInt(i=v.substring(e+5));if(a>3)a=parseFloat(i)}else if(m>0)a=parseFloat(u.substring(m+10));else a=parseFloat(v);if(a<5||v.indexOf('Opera')>=0||u.indexOf('Opera')>=0)c=s_ft(c);if(!s){s=new Object;if(!w.s_c_in){w.s_c_il=new Array;w.s_c_in=0}s._il=w.s_c_il;s._in=w.s_c_in;s._il[s._in]=s;w.s_c_in++;}s._c='s_c';(new Function("s","un","pg","ss",c))(s,un,pg,ss);return s}
function s_giqf(){var w=window,q=w.s_giq,i,t,s;if(q)for(i=0;i<q.length;i++){t=q[i];s=s_gi(t.oun);s.sa(t.un);s.setTagContainer(t.tagContainerName)}w.s_giq=0}s_giqf();



Date.CultureInfo={name:"en-US",englishName:"English (United States)",nativeName:"English (United States)",dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],abbreviatedDayNames:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],shortestDayNames:["Su","Mo","Tu","We","Th","Fr","Sa"],firstLetterDayNames:["S","M","T","W","T","F","S"],monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],abbreviatedMonthNames:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],amDesignator:"AM",pmDesignator:"PM",firstDayOfWeek:0,twoDigitYearMax:2029,dateElementOrder:"mdy",formatPatterns:{shortDate:"M/d/yyyy",longDate:"dddd, MMMM dd, yyyy",shortTime:"h:mm tt",longTime:"h:mm:ss tt",fullDateTime:"dddd, MMMM dd, yyyy h:mm:ss tt",sortableDateTime:"yyyy-MM-ddTHH:mm:ss",universalSortableDateTime:"yyyy-MM-dd HH:mm:ssZ",rfc1123:"ddd, dd MMM yyyy HH:mm:ss GMT",monthDay:"MMMM dd",yearMonth:"MMMM, yyyy"},regexPatterns:{jan:/^jan(uary)?/i,feb:/^feb(ruary)?/i,mar:/^mar(ch)?/i,apr:/^apr(il)?/i,may:/^may/i,jun:/^jun(e)?/i,jul:/^jul(y)?/i,aug:/^aug(ust)?/i,sep:/^sep(t(ember)?)?/i,oct:/^oct(ober)?/i,nov:/^nov(ember)?/i,dec:/^dec(ember)?/i,sun:/^su(n(day)?)?/i,mon:/^mo(n(day)?)?/i,tue:/^tu(e(s(day)?)?)?/i,wed:/^we(d(nesday)?)?/i,thu:/^th(u(r(s(day)?)?)?)?/i,fri:/^fr(i(day)?)?/i,sat:/^sa(t(urday)?)?/i,future:/^next/i,past:/^last|past|prev(ious)?/i,add:/^(\+|aft(er)?|from|hence)/i,subtract:/^(\-|bef(ore)?|ago)/i,yesterday:/^yes(terday)?/i,today:/^t(od(ay)?)?/i,tomorrow:/^tom(orrow)?/i,now:/^n(ow)?/i,millisecond:/^ms|milli(second)?s?/i,second:/^sec(ond)?s?/i,minute:/^mn|min(ute)?s?/i,hour:/^h(our)?s?/i,week:/^w(eek)?s?/i,month:/^m(onth)?s?/i,day:/^d(ay)?s?/i,year:/^y(ear)?s?/i,shortMeridian:/^(a|p)/i,longMeridian:/^(a\.?m?\.?|p\.?m?\.?)/i,timezone:/^((e(s|d)t|c(s|d)t|m(s|d)t|p(s|d)t)|((gmt)?\s*(\+|\-)\s*\d\d\d\d?)|gmt|utc)/i,ordinalSuffix:/^\s*(st|nd|rd|th)/i,timeContext:/^\s*(\:|a(?!u|p)|p)/i},timezones:[{name:"UTC",offset:"-000"},{name:"GMT",offset:"-000"},{name:"EST",offset:"-0500"},{name:"EDT",offset:"-0400"},{name:"CST",offset:"-0600"},{name:"CDT",offset:"-0500"},{name:"MST",offset:"-0700"},{name:"MDT",offset:"-0600"},{name:"PST",offset:"-0800"},{name:"PDT",offset:"-0700"}]};
(function(){var $D=Date,$P=$D.prototype,$C=$D.CultureInfo,p=function(s,l){if(!l){l=2;}
return("000"+s).slice(l*-1);};$P.clearTime=function(){this.setHours(0);this.setMinutes(0);this.setSeconds(0);this.setMilliseconds(0);return this;};$P.setTimeToNow=function(){var n=new Date();this.setHours(n.getHours());this.setMinutes(n.getMinutes());this.setSeconds(n.getSeconds());this.setMilliseconds(n.getMilliseconds());return this;};$D.today=function(){return new Date().clearTime();};$D.compare=function(date1,date2){if(isNaN(date1)||isNaN(date2)){throw new Error(date1+" - "+date2);}else if(date1 instanceof Date&&date2 instanceof Date){return(date1<date2)?-1:(date1>date2)?1:0;}else{throw new TypeError(date1+" - "+date2);}};$D.equals=function(date1,date2){return(date1.compareTo(date2)===0);};$D.getDayNumberFromName=function(name){var n=$C.dayNames,m=$C.abbreviatedDayNames,o=$C.shortestDayNames,s=name.toLowerCase();for(var i=0;i<n.length;i++){if(n[i].toLowerCase()==s||m[i].toLowerCase()==s||o[i].toLowerCase()==s){return i;}}
return-1;};$D.getMonthNumberFromName=function(name){var n=$C.monthNames,m=$C.abbreviatedMonthNames,s=name.toLowerCase();for(var i=0;i<n.length;i++){if(n[i].toLowerCase()==s||m[i].toLowerCase()==s){return i;}}
return-1;};$D.isLeapYear=function(year){return((year%4===0&&year%100!==0)||year%400===0);};$D.getDaysInMonth=function(year,month){return[31,($D.isLeapYear(year)?29:28),31,30,31,30,31,31,30,31,30,31][month];};$D.getTimezoneAbbreviation=function(offset){var z=$C.timezones,p;for(var i=0;i<z.length;i++){if(z[i].offset===offset){return z[i].name;}}
return null;};$D.getTimezoneOffset=function(name){var z=$C.timezones,p;for(var i=0;i<z.length;i++){if(z[i].name===name.toUpperCase()){return z[i].offset;}}
return null;};$P.clone=function(){return new Date(this.getTime());};$P.compareTo=function(date){return Date.compare(this,date);};$P.equals=function(date){return Date.equals(this,date||new Date());};$P.between=function(start,end){return this.getTime()>=start.getTime()&&this.getTime()<=end.getTime();};$P.isAfter=function(date){return this.compareTo(date||new Date())===1;};$P.isBefore=function(date){return(this.compareTo(date||new Date())===-1);};$P.isToday=function(){return this.isSameDay(new Date());};$P.isSameDay=function(date){return this.clone().clearTime().equals(date.clone().clearTime());};$P.addMilliseconds=function(value){this.setMilliseconds(this.getMilliseconds()+value);return this;};$P.addSeconds=function(value){return this.addMilliseconds(value*1000);};$P.addMinutes=function(value){return this.addMilliseconds(value*60000);};$P.addHours=function(value){return this.addMilliseconds(value*3600000);};$P.addDays=function(value){this.setDate(this.getDate()+value);return this;};$P.addWeeks=function(value){return this.addDays(value*7);};$P.addMonths=function(value){var n=this.getDate();this.setDate(1);this.setMonth(this.getMonth()+value);this.setDate(Math.min(n,$D.getDaysInMonth(this.getFullYear(),this.getMonth())));return this;};$P.addYears=function(value){return this.addMonths(value*12);};$P.add=function(config){if(typeof config=="number"){this._orient=config;return this;}
var x=config;if(x.milliseconds){this.addMilliseconds(x.milliseconds);}
if(x.seconds){this.addSeconds(x.seconds);}
if(x.minutes){this.addMinutes(x.minutes);}
if(x.hours){this.addHours(x.hours);}
if(x.weeks){this.addWeeks(x.weeks);}
if(x.months){this.addMonths(x.months);}
if(x.years){this.addYears(x.years);}
if(x.days){this.addDays(x.days);}
return this;};var $y,$m,$d;$P.getWeek=function(){var a,b,c,d,e,f,g,n,s,w;$y=(!$y)?this.getFullYear():$y;$m=(!$m)?this.getMonth()+1:$m;$d=(!$d)?this.getDate():$d;if($m<=2){a=$y-1;b=(a/4|0)-(a/100|0)+(a/400|0);c=((a-1)/4|0)-((a-1)/100|0)+((a-1)/400|0);s=b-c;e=0;f=$d-1+(31*($m-1));}else{a=$y;b=(a/4|0)-(a/100|0)+(a/400|0);c=((a-1)/4|0)-((a-1)/100|0)+((a-1)/400|0);s=b-c;e=s+1;f=$d+((153*($m-3)+2)/5)+58+s;}
g=(a+b)%7;d=(f+g-e)%7;n=(f+3-d)|0;if(n<0){w=53-((g-s)/5|0);}else if(n>364+s){w=1;}else{w=(n/7|0)+1;}
$y=$m=$d=null;return w;};$P.getISOWeek=function(){$y=this.getUTCFullYear();$m=this.getUTCMonth()+1;$d=this.getUTCDate();return p(this.getWeek());};$P.setWeek=function(n){return this.moveToDayOfWeek(1).addWeeks(n-this.getWeek());};$D._validate=function(n,min,max,name){if(typeof n=="undefined"){return false;}else if(typeof n!="number"){throw new TypeError(n+" is not a Number.");}else if(n<min||n>max){throw new RangeError(n+" is not a valid value for "+name+".");}
return true;};$D.validateMillisecond=function(value){return $D._validate(value,0,999,"millisecond");};$D.validateSecond=function(value){return $D._validate(value,0,59,"second");};$D.validateMinute=function(value){return $D._validate(value,0,59,"minute");};$D.validateHour=function(value){return $D._validate(value,0,23,"hour");};$D.validateDay=function(value,year,month){return $D._validate(value,1,$D.getDaysInMonth(year,month),"day");};$D.validateMonth=function(value){return $D._validate(value,0,11,"month");};$D.validateYear=function(value){return $D._validate(value,0,9999,"year");};$P.set=function(config){if($D.validateMillisecond(config.millisecond)){this.addMilliseconds(config.millisecond-this.getMilliseconds());}
if($D.validateSecond(config.second)){this.addSeconds(config.second-this.getSeconds());}
if($D.validateMinute(config.minute)){this.addMinutes(config.minute-this.getMinutes());}
if($D.validateHour(config.hour)){this.addHours(config.hour-this.getHours());}
if($D.validateMonth(config.month)){this.addMonths(config.month-this.getMonth());}
if($D.validateYear(config.year)){this.addYears(config.year-this.getFullYear());}
if($D.validateDay(config.day,this.getFullYear(),this.getMonth())){this.addDays(config.day-this.getDate());}
if(config.timezone){this.setTimezone(config.timezone);}
if(config.timezoneOffset){this.setTimezoneOffset(config.timezoneOffset);}
if(config.week&&$D._validate(config.week,0,53,"week")){this.setWeek(config.week);}
return this;};$P.moveToFirstDayOfMonth=function(){return this.set({day:1});};$P.moveToLastDayOfMonth=function(){return this.set({day:$D.getDaysInMonth(this.getFullYear(),this.getMonth())});};$P.moveToNthOccurrence=function(dayOfWeek,occurrence){var shift=0;if(occurrence>0){shift=occurrence-1;}
else if(occurrence===-1){this.moveToLastDayOfMonth();if(this.getDay()!==dayOfWeek){this.moveToDayOfWeek(dayOfWeek,-1);}
return this;}
return this.moveToFirstDayOfMonth().addDays(-1).moveToDayOfWeek(dayOfWeek,+1).addWeeks(shift);};$P.moveToDayOfWeek=function(dayOfWeek,orient){var diff=(dayOfWeek-this.getDay()+7*(orient||+1))%7;return this.addDays((diff===0)?diff+=7*(orient||+1):diff);};$P.moveToMonth=function(month,orient){var diff=(month-this.getMonth()+12*(orient||+1))%12;return this.addMonths((diff===0)?diff+=12*(orient||+1):diff);};$P.getOrdinalNumber=function(){return Math.ceil((this.clone().clearTime()-new Date(this.getFullYear(),0,1))/86400000)+1;};$P.getTimezone=function(){return $D.getTimezoneAbbreviation(this.getUTCOffset());};$P.setTimezoneOffset=function(offset){var here=this.getTimezoneOffset(),there=Number(offset)*-6/10;return this.addMinutes(there-here);};$P.setTimezone=function(offset){return this.setTimezoneOffset($D.getTimezoneOffset(offset));};$P.hasDaylightSavingTime=function(){return(Date.today().set({month:0,day:1}).getTimezoneOffset()!==Date.today().set({month:6,day:1}).getTimezoneOffset());};$P.isDaylightSavingTime=function(){return(this.hasDaylightSavingTime()&&new Date().getTimezoneOffset()===Date.today().set({month:6,day:1}).getTimezoneOffset());};$P.getUTCOffset=function(){var n=this.getTimezoneOffset()*-10/6,r;if(n<0){r=(n-10000).toString();return r.charAt(0)+r.substr(2);}else{r=(n+10000).toString();return"+"+r.substr(1);}};$P.getElapsed=function(date){return(date||new Date())-this;};if(!$P.toISOString){$P.toISOString=function(){function f(n){return n<10?'0'+n:n;}
return'"'+this.getUTCFullYear()+'-'+
f(this.getUTCMonth()+1)+'-'+
f(this.getUTCDate())+'T'+
f(this.getUTCHours())+':'+
f(this.getUTCMinutes())+':'+
f(this.getUTCSeconds())+'Z"';};}
$P._toString=$P.toString;$P.toString=function(format){var x=this;if(format&&format.length==1){var c=$C.formatPatterns;x.t=x.toString;switch(format){case"d":return x.t(c.shortDate);case"D":return x.t(c.longDate);case"F":return x.t(c.fullDateTime);case"m":return x.t(c.monthDay);case"r":return x.t(c.rfc1123);case"s":return x.t(c.sortableDateTime);case"t":return x.t(c.shortTime);case"T":return x.t(c.longTime);case"u":return x.t(c.universalSortableDateTime);case"y":return x.t(c.yearMonth);}}
var ord=function(n){switch(n*1){case 1:case 21:case 31:return"st";case 2:case 22:return"nd";case 3:case 23:return"rd";default:return"th";}};return format?format.replace(/(\\)?(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|S)/g,function(m){if(m.charAt(0)==="\\"){return m.replace("\\","");}
x.h=x.getHours;switch(m){case"hh":return p(x.h()<13?(x.h()===0?12:x.h()):(x.h()-12));case"h":return x.h()<13?(x.h()===0?12:x.h()):(x.h()-12);case"HH":return p(x.h());case"H":return x.h();case"mm":return p(x.getMinutes());case"m":return x.getMinutes();case"ss":return p(x.getSeconds());case"s":return x.getSeconds();case"yyyy":return p(x.getFullYear(),4);case"yy":return p(x.getFullYear());case"dddd":return $C.dayNames[x.getDay()];case"ddd":return $C.abbreviatedDayNames[x.getDay()];case"dd":return p(x.getDate());case"d":return x.getDate();case"MMMM":return $C.monthNames[x.getMonth()];case"MMM":return $C.abbreviatedMonthNames[x.getMonth()];case"MM":return p((x.getMonth()+1));case"M":return x.getMonth()+1;case"t":return x.h()<12?$C.amDesignator.substring(0,1):$C.pmDesignator.substring(0,1);case"tt":return x.h()<12?$C.amDesignator:$C.pmDesignator;case"S":return ord(x.getDate());default:return m;}}):this._toString();};}());
(function(){var $D=Date,$P=$D.prototype,$C=$D.CultureInfo,$N=Number.prototype;$P._orient=+1;$P._nth=null;$P._is=false;$P._same=false;$P._isSecond=false;$N._dateElement="day";$P.next=function(){this._orient=+1;return this;};$D.next=function(){return $D.today().next();};$P.last=$P.prev=$P.previous=function(){this._orient=-1;return this;};$D.last=$D.prev=$D.previous=function(){return $D.today().last();};$P.is=function(){this._is=true;return this;};$P.same=function(){this._same=true;this._isSecond=false;return this;};$P.today=function(){return this.same().day();};$P.weekday=function(){if(this._is){this._is=false;return(!this.is().sat()&&!this.is().sun());}
return false;};$P.at=function(time){return(typeof time==="string")?$D.parse(this.toString("d")+" "+time):this.set(time);};$N.fromNow=$N.after=function(date){var c={};c[this._dateElement]=this;return((!date)?new Date():date.clone()).add(c);};$N.ago=$N.before=function(date){var c={};c[this._dateElement]=this*-1;return((!date)?new Date():date.clone()).add(c);};var dx=("sunday monday tuesday wednesday thursday friday saturday").split(/\s/),mx=("january february march april may june july august september october november december").split(/\s/),px=("Millisecond Second Minute Hour Day Week Month Year").split(/\s/),pxf=("Milliseconds Seconds Minutes Hours Date Week Month FullYear").split(/\s/),nth=("final first second third fourth fifth").split(/\s/),de;$P.toObject=function(){var o={};for(var i=0;i<px.length;i++){o[px[i].toLowerCase()]=this["get"+pxf[i]]();}
return o;};$D.fromObject=function(config){config.week=null;return Date.today().set(config);};var df=function(n){return function(){if(this._is){this._is=false;return this.getDay()==n;}
if(this._nth!==null){if(this._isSecond){this.addSeconds(this._orient*-1);}
this._isSecond=false;var ntemp=this._nth;this._nth=null;var temp=this.clone().moveToLastDayOfMonth();this.moveToNthOccurrence(n,ntemp);if(this>temp){throw new RangeError($D.getDayName(n)+" does not occur "+ntemp+" times in the month of "+$D.getMonthName(temp.getMonth())+" "+temp.getFullYear()+".");}
return this;}
return this.moveToDayOfWeek(n,this._orient);};};var sdf=function(n){return function(){var t=$D.today(),shift=n-t.getDay();if(n===0&&$C.firstDayOfWeek===1&&t.getDay()!==0){shift=shift+7;}
return t.addDays(shift);};};for(var i=0;i<dx.length;i++){$D[dx[i].toUpperCase()]=$D[dx[i].toUpperCase().substring(0,3)]=i;$D[dx[i]]=$D[dx[i].substring(0,3)]=sdf(i);$P[dx[i]]=$P[dx[i].substring(0,3)]=df(i);}
var mf=function(n){return function(){if(this._is){this._is=false;return this.getMonth()===n;}
return this.moveToMonth(n,this._orient);};};var smf=function(n){return function(){return $D.today().set({month:n,day:1});};};for(var j=0;j<mx.length;j++){$D[mx[j].toUpperCase()]=$D[mx[j].toUpperCase().substring(0,3)]=j;$D[mx[j]]=$D[mx[j].substring(0,3)]=smf(j);$P[mx[j]]=$P[mx[j].substring(0,3)]=mf(j);}
var ef=function(j){return function(){if(this._isSecond){this._isSecond=false;return this;}
if(this._same){this._same=this._is=false;var o1=this.toObject(),o2=(arguments[0]||new Date()).toObject(),v="",k=j.toLowerCase();for(var m=(px.length-1);m>-1;m--){v=px[m].toLowerCase();if(o1[v]!=o2[v]){return false;}
if(k==v){break;}}
return true;}
if(j.substring(j.length-1)!="s"){j+="s";}
return this["add"+j](this._orient);};};var nf=function(n){return function(){this._dateElement=n;return this;};};for(var k=0;k<px.length;k++){de=px[k].toLowerCase();$P[de]=$P[de+"s"]=ef(px[k]);$N[de]=$N[de+"s"]=nf(de);}
$P._ss=ef("Second");var nthfn=function(n){return function(dayOfWeek){if(this._same){return this._ss(arguments[0]);}
if(dayOfWeek||dayOfWeek===0){return this.moveToNthOccurrence(dayOfWeek,n);}
this._nth=n;if(n===2&&(dayOfWeek===undefined||dayOfWeek===null)){this._isSecond=true;return this.addSeconds(this._orient);}
return this;};};for(var l=0;l<nth.length;l++){$P[nth[l]]=(l===0)?nthfn(-1):nthfn(l);}}());
(function(){Date.Parsing={Exception:function(s){this.message="Parse error at '"+s.substring(0,10)+" ...'";}};var $P=Date.Parsing;var _=$P.Operators={rtoken:function(r){return function(s){var mx=s.match(r);if(mx){return([mx[0],s.substring(mx[0].length)]);}else{throw new $P.Exception(s);}};},token:function(s){return function(s){return _.rtoken(new RegExp("^\s*"+s+"\s*"))(s);};},stoken:function(s){return _.rtoken(new RegExp("^"+s));},until:function(p){return function(s){var qx=[],rx=null;while(s.length){try{rx=p.call(this,s);}catch(e){qx.push(rx[0]);s=rx[1];continue;}
break;}
return[qx,s];};},many:function(p){return function(s){var rx=[],r=null;while(s.length){try{r=p.call(this,s);}catch(e){return[rx,s];}
rx.push(r[0]);s=r[1];}
return[rx,s];};},optional:function(p){return function(s){var r=null;try{r=p.call(this,s);}catch(e){return[null,s];}
return[r[0],r[1]];};},not:function(p){return function(s){try{p.call(this,s);}catch(e){return[null,s];}
throw new $P.Exception(s);};},ignore:function(p){return p?function(s){var r=null;r=p.call(this,s);return[null,r[1]];}:null;},product:function(){var px=arguments[0],qx=Array.prototype.slice.call(arguments,1),rx=[];for(var i=0;i<px.length;i++){rx.push(_.each(px[i],qx));}
return rx;},cache:function(rule){var cache={},r=null;return function(s){try{r=cache[s]=(cache[s]||rule.call(this,s));}catch(e){r=cache[s]=e;}
if(r instanceof $P.Exception){throw r;}else{return r;}};},any:function(){var px=arguments;return function(s){var r=null;for(var i=0;i<px.length;i++){if(px[i]==null){continue;}
try{r=(px[i].call(this,s));}catch(e){r=null;}
if(r){return r;}}
throw new $P.Exception(s);};},each:function(){var px=arguments;return function(s){var rx=[],r=null;for(var i=0;i<px.length;i++){if(px[i]==null){continue;}
try{r=(px[i].call(this,s));}catch(e){throw new $P.Exception(s);}
rx.push(r[0]);s=r[1];}
return[rx,s];};},all:function(){var px=arguments,_=_;return _.each(_.optional(px));},sequence:function(px,d,c){d=d||_.rtoken(/^\s*/);c=c||null;if(px.length==1){return px[0];}
return function(s){var r=null,q=null;var rx=[];for(var i=0;i<px.length;i++){try{r=px[i].call(this,s);}catch(e){break;}
rx.push(r[0]);try{q=d.call(this,r[1]);}catch(ex){q=null;break;}
s=q[1];}
if(!r){throw new $P.Exception(s);}
if(q){throw new $P.Exception(q[1]);}
if(c){try{r=c.call(this,r[1]);}catch(ey){throw new $P.Exception(r[1]);}}
return[rx,(r?r[1]:s)];};},between:function(d1,p,d2){d2=d2||d1;var _fn=_.each(_.ignore(d1),p,_.ignore(d2));return function(s){var rx=_fn.call(this,s);return[[rx[0][0],r[0][2]],rx[1]];};},list:function(p,d,c){d=d||_.rtoken(/^\s*/);c=c||null;return(p instanceof Array?_.each(_.product(p.slice(0,-1),_.ignore(d)),p.slice(-1),_.ignore(c)):_.each(_.many(_.each(p,_.ignore(d))),px,_.ignore(c)));},set:function(px,d,c){d=d||_.rtoken(/^\s*/);c=c||null;return function(s){var r=null,p=null,q=null,rx=null,best=[[],s],last=false;for(var i=0;i<px.length;i++){q=null;p=null;r=null;last=(px.length==1);try{r=px[i].call(this,s);}catch(e){continue;}
rx=[[r[0]],r[1]];if(r[1].length>0&&!last){try{q=d.call(this,r[1]);}catch(ex){last=true;}}else{last=true;}
if(!last&&q[1].length===0){last=true;}
if(!last){var qx=[];for(var j=0;j<px.length;j++){if(i!=j){qx.push(px[j]);}}
p=_.set(qx,d).call(this,q[1]);if(p[0].length>0){rx[0]=rx[0].concat(p[0]);rx[1]=p[1];}}
if(rx[1].length<best[1].length){best=rx;}
if(best[1].length===0){break;}}
if(best[0].length===0){return best;}
if(c){try{q=c.call(this,best[1]);}catch(ey){throw new $P.Exception(best[1]);}
best[1]=q[1];}
return best;};},forward:function(gr,fname){return function(s){return gr[fname].call(this,s);};},replace:function(rule,repl){return function(s){var r=rule.call(this,s);return[repl,r[1]];};},process:function(rule,fn){return function(s){var r=rule.call(this,s);return[fn.call(this,r[0]),r[1]];};},min:function(min,rule){return function(s){var rx=rule.call(this,s);if(rx[0].length<min){throw new $P.Exception(s);}
return rx;};}};var _generator=function(op){return function(){var args=null,rx=[];if(arguments.length>1){args=Array.prototype.slice.call(arguments);}else if(arguments[0]instanceof Array){args=arguments[0];}
if(args){for(var i=0,px=args.shift();i<px.length;i++){args.unshift(px[i]);rx.push(op.apply(null,args));args.shift();return rx;}}else{return op.apply(null,arguments);}};};var gx="optional not ignore cache".split(/\s/);for(var i=0;i<gx.length;i++){_[gx[i]]=_generator(_[gx[i]]);}
var _vector=function(op){return function(){if(arguments[0]instanceof Array){return op.apply(null,arguments[0]);}else{return op.apply(null,arguments);}};};var vx="each any all".split(/\s/);for(var j=0;j<vx.length;j++){_[vx[j]]=_vector(_[vx[j]]);}}());(function(){var $D=Date,$P=$D.prototype,$C=$D.CultureInfo;var flattenAndCompact=function(ax){var rx=[];for(var i=0;i<ax.length;i++){if(ax[i]instanceof Array){rx=rx.concat(flattenAndCompact(ax[i]));}else{if(ax[i]){rx.push(ax[i]);}}}
return rx;};$D.Grammar={};$D.Translator={hour:function(s){return function(){this.hour=Number(s);};},minute:function(s){return function(){this.minute=Number(s);};},second:function(s){return function(){this.second=Number(s);};},meridian:function(s){return function(){this.meridian=s.slice(0,1).toLowerCase();};},timezone:function(s){return function(){var n=s.replace(/[^\d\+\-]/g,"");if(n.length){this.timezoneOffset=Number(n);}else{this.timezone=s.toLowerCase();}};},day:function(x){var s=x[0];return function(){this.day=Number(s.match(/\d+/)[0]);};},month:function(s){return function(){this.month=(s.length==3)?"jan feb mar apr may jun jul aug sep oct nov dec".indexOf(s)/4:Number(s)-1;};},year:function(s){return function(){var n=Number(s);this.year=((s.length>2)?n:(n+(((n+2000)<$C.twoDigitYearMax)?2000:1900)));};},rday:function(s){return function(){switch(s){case"yesterday":this.days=-1;break;case"tomorrow":this.days=1;break;case"today":this.days=0;break;case"now":this.days=0;this.now=true;break;}};},finishExact:function(x){x=(x instanceof Array)?x:[x];for(var i=0;i<x.length;i++){if(x[i]){x[i].call(this);}}
var now=new Date();if((this.hour||this.minute)&&(!this.month&&!this.year&&!this.day)){this.day=now.getDate();}
if(!this.year){this.year=now.getFullYear();}
if(!this.month&&this.month!==0){this.month=now.getMonth();}
if(!this.day){this.day=1;}
if(!this.hour){this.hour=0;}
if(!this.minute){this.minute=0;}
if(!this.second){this.second=0;}
if(this.meridian&&this.hour){if(this.meridian=="p"&&this.hour<12){this.hour=this.hour+12;}else if(this.meridian=="a"&&this.hour==12){this.hour=0;}}
if(this.day>$D.getDaysInMonth(this.year,this.month)){throw new RangeError(this.day+" is not a valid value for days.");}
var r=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second);if(this.timezone){r.set({timezone:this.timezone});}else if(this.timezoneOffset){r.set({timezoneOffset:this.timezoneOffset});}
return r;},finish:function(x){x=(x instanceof Array)?flattenAndCompact(x):[x];if(x.length===0){return null;}
for(var i=0;i<x.length;i++){if(typeof x[i]=="function"){x[i].call(this);}}
var today=$D.today();if(this.now&&!this.unit&&!this.operator){return new Date();}else if(this.now){today=new Date();}
var expression=!!(this.days&&this.days!==null||this.orient||this.operator);var gap,mod,orient;orient=((this.orient=="past"||this.operator=="subtract")?-1:1);if(!this.now&&"hour minute second".indexOf(this.unit)!=-1){today.setTimeToNow();}
if(this.month||this.month===0){if("year day hour minute second".indexOf(this.unit)!=-1){this.value=this.month+1;this.month=null;expression=true;}}
if(!expression&&this.weekday&&!this.day&&!this.days){var temp=Date[this.weekday]();this.day=temp.getDate();if(!this.month){this.month=temp.getMonth();}
this.year=temp.getFullYear();}
if(expression&&this.weekday&&this.unit!="month"){this.unit="day";gap=($D.getDayNumberFromName(this.weekday)-today.getDay());mod=7;this.days=gap?((gap+(orient*mod))%mod):(orient*mod);}
if(this.month&&this.unit=="day"&&this.operator){this.value=(this.month+1);this.month=null;}
if(this.value!=null&&this.month!=null&&this.year!=null){this.day=this.value*1;}
if(this.month&&!this.day&&this.value){today.set({day:this.value*1});if(!expression){this.day=this.value*1;}}
if(!this.month&&this.value&&this.unit=="month"&&!this.now){this.month=this.value;expression=true;}
if(expression&&(this.month||this.month===0)&&this.unit!="year"){this.unit="month";gap=(this.month-today.getMonth());mod=12;this.months=gap?((gap+(orient*mod))%mod):(orient*mod);this.month=null;}
if(!this.unit){this.unit="day";}
if(!this.value&&this.operator&&this.operator!==null&&this[this.unit+"s"]&&this[this.unit+"s"]!==null){this[this.unit+"s"]=this[this.unit+"s"]+((this.operator=="add")?1:-1)+(this.value||0)*orient;}else if(this[this.unit+"s"]==null||this.operator!=null){if(!this.value){this.value=1;}
this[this.unit+"s"]=this.value*orient;}
if(this.meridian&&this.hour){if(this.meridian=="p"&&this.hour<12){this.hour=this.hour+12;}else if(this.meridian=="a"&&this.hour==12){this.hour=0;}}
if(this.weekday&&!this.day&&!this.days){var temp=Date[this.weekday]();this.day=temp.getDate();if(temp.getMonth()!==today.getMonth()){this.month=temp.getMonth();}}
if((this.month||this.month===0)&&!this.day){this.day=1;}
if(!this.orient&&!this.operator&&this.unit=="week"&&this.value&&!this.day&&!this.month){return Date.today().setWeek(this.value);}
if(expression&&this.timezone&&this.day&&this.days){this.day=this.days;}
return(expression)?today.add(this):today.set(this);}};var _=$D.Parsing.Operators,g=$D.Grammar,t=$D.Translator,_fn;g.datePartDelimiter=_.rtoken(/^([\s\-\.\,\/\x27]+)/);g.timePartDelimiter=_.stoken(":");g.whiteSpace=_.rtoken(/^\s*/);g.generalDelimiter=_.rtoken(/^(([\s\,]|at|@|on)+)/);var _C={};g.ctoken=function(keys){var fn=_C[keys];if(!fn){var c=$C.regexPatterns;var kx=keys.split(/\s+/),px=[];for(var i=0;i<kx.length;i++){px.push(_.replace(_.rtoken(c[kx[i]]),kx[i]));}
fn=_C[keys]=_.any.apply(null,px);}
return fn;};g.ctoken2=function(key){return _.rtoken($C.regexPatterns[key]);};g.h=_.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2]|[1-9])/),t.hour));g.hh=_.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2])/),t.hour));g.H=_.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3]|[0-9])/),t.hour));g.HH=_.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3])/),t.hour));g.m=_.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/),t.minute));g.mm=_.cache(_.process(_.rtoken(/^[0-5][0-9]/),t.minute));g.s=_.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/),t.second));g.ss=_.cache(_.process(_.rtoken(/^[0-5][0-9]/),t.second));g.hms=_.cache(_.sequence([g.H,g.m,g.s],g.timePartDelimiter));g.t=_.cache(_.process(g.ctoken2("shortMeridian"),t.meridian));g.tt=_.cache(_.process(g.ctoken2("longMeridian"),t.meridian));g.z=_.cache(_.process(_.rtoken(/^((\+|\-)\s*\d\d\d\d)|((\+|\-)\d\d\:?\d\d)/),t.timezone));g.zz=_.cache(_.process(_.rtoken(/^((\+|\-)\s*\d\d\d\d)|((\+|\-)\d\d\:?\d\d)/),t.timezone));g.zzz=_.cache(_.process(g.ctoken2("timezone"),t.timezone));g.timeSuffix=_.each(_.ignore(g.whiteSpace),_.set([g.tt,g.zzz]));g.time=_.each(_.optional(_.ignore(_.stoken("T"))),g.hms,g.timeSuffix);g.d=_.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1]|\d)/),_.optional(g.ctoken2("ordinalSuffix"))),t.day));g.dd=_.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1])/),_.optional(g.ctoken2("ordinalSuffix"))),t.day));g.ddd=g.dddd=_.cache(_.process(g.ctoken("sun mon tue wed thu fri sat"),function(s){return function(){this.weekday=s;};}));g.M=_.cache(_.process(_.rtoken(/^(1[0-2]|0\d|\d)/),t.month));g.MM=_.cache(_.process(_.rtoken(/^(1[0-2]|0\d)/),t.month));g.MMM=g.MMMM=_.cache(_.process(g.ctoken("jan feb mar apr may jun jul aug sep oct nov dec"),t.month));g.y=_.cache(_.process(_.rtoken(/^(\d\d?)/),t.year));g.yy=_.cache(_.process(_.rtoken(/^(\d\d)/),t.year));g.yyy=_.cache(_.process(_.rtoken(/^(\d\d?\d?\d?)/),t.year));g.yyyy=_.cache(_.process(_.rtoken(/^(\d\d\d\d)/),t.year));_fn=function(){return _.each(_.any.apply(null,arguments),_.not(g.ctoken2("timeContext")));};g.day=_fn(g.d,g.dd);g.month=_fn(g.M,g.MMM);g.year=_fn(g.yyyy,g.yy);g.orientation=_.process(g.ctoken("past future"),function(s){return function(){this.orient=s;};});g.operator=_.process(g.ctoken("add subtract"),function(s){return function(){this.operator=s;};});g.rday=_.process(g.ctoken("yesterday tomorrow today now"),t.rday);g.unit=_.process(g.ctoken("second minute hour day week month year"),function(s){return function(){this.unit=s;};});g.value=_.process(_.rtoken(/^\d\d?(st|nd|rd|th)?/),function(s){return function(){this.value=s.replace(/\D/g,"");};});g.expression=_.set([g.rday,g.operator,g.value,g.unit,g.orientation,g.ddd,g.MMM]);_fn=function(){return _.set(arguments,g.datePartDelimiter);};g.mdy=_fn(g.ddd,g.month,g.day,g.year);g.ymd=_fn(g.ddd,g.year,g.month,g.day);g.dmy=_fn(g.ddd,g.day,g.month,g.year);g.date=function(s){return((g[$C.dateElementOrder]||g.mdy).call(this,s));};g.format=_.process(_.many(_.any(_.process(_.rtoken(/^(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?)/),function(fmt){if(g[fmt]){return g[fmt];}else{throw $D.Parsing.Exception(fmt);}}),_.process(_.rtoken(/^[^dMyhHmstz]+/),function(s){return _.ignore(_.stoken(s));}))),function(rules){return _.process(_.each.apply(null,rules),t.finishExact);});var _F={};var _get=function(f){return _F[f]=(_F[f]||g.format(f)[0]);};g.formats=function(fx){if(fx instanceof Array){var rx=[];for(var i=0;i<fx.length;i++){rx.push(_get(fx[i]));}
return _.any.apply(null,rx);}else{return _get(fx);}};g._formats=g.formats(["\"yyyy-MM-ddTHH:mm:ssZ\"","yyyy-MM-ddTHH:mm:ssZ","yyyy-MM-ddTHH:mm:ssz","yyyy-MM-ddTHH:mm:ss","yyyy-MM-ddTHH:mmZ","yyyy-MM-ddTHH:mmz","yyyy-MM-ddTHH:mm","ddd, MMM dd, yyyy H:mm:ss tt","ddd MMM d yyyy HH:mm:ss zzz","MMddyyyy","ddMMyyyy","Mddyyyy","ddMyyyy","Mdyyyy","dMyyyy","yyyy","Mdyy","dMyy","d"]);g._start=_.process(_.set([g.date,g.time,g.expression],g.generalDelimiter,g.whiteSpace),t.finish);g.start=function(s){try{var r=g._formats.call({},s);if(r[1].length===0){return r;}}catch(e){}
return g._start.call({},s);};$D._parse=$D.parse;$D.parse=function(s){var r=null;if(!s){return null;}
if(s instanceof Date){return s;}
try{r=$D.Grammar.start.call({},s.replace(/^\s*(\S*(\s+\S+)*)\s*$/,"$1"));}catch(e){return null;}
return((r[1].length===0)?r[0]:null);};$D.getParseFunction=function(fx){var fn=$D.Grammar.formats(fx);return function(s){var r=null;try{r=fn.call({},s);}catch(e){return null;}
return((r[1].length===0)?r[0]:null);};};$D.parseExact=function(s,fx){return $D.getParseFunction(fx)(s);};}());


//     uuid.js
//

(function() {
  var _global = this;

  // Unique ID creation requires a high quality random # generator.  We feature
  // detect to determine the best RNG source, normalizing to a function that
  // returns 128-bits of randomness, since that's what's usually required
  var _rng;

  // Node.js crypto-based RNG - http://nodejs.org/docs/v0.6.2/api/crypto.html
  //
  // Moderately fast, high quality
  if (typeof(require) == 'function') {
    try {
      var _rb = require('crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    // WHATWG crypto-based RNG - http://wiki.whatwg.org/wiki/Crypto
    //
    // Moderately fast, high quality
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    // Math.random()-based (RNG)
    //
    // If all else fails, use Math.random().  It's fast, but is of unspecified
    // quality.
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  // Buffer class to use
  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;

  // Maps for number <-> hex string conversion
  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  // **`parse()` - Parse a UUID into it's component bytes**
  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    // Zero out remaining bytes if string was short
    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  // **`unparse()` - Convert UUID byte array (ala parse()) into a string**
  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  // **`v1()` - Generate time-based UUID**
  //
  // Inspired by https://github.com/LiosK/UUID.js
  // and http://docs.python.org/library/uuid.html

  // random #'s we need to init node and clockseq
  var _seedBytes = _rng();

  // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  // Per 4.2.2, randomize (14 bit) clockseq
  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  // Previous uuid creation time
  var _lastMSecs = 0, _lastNSecs = 0;

  // See https://github.com/broofa/node-uuid for API details
  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    // Time since last uuid creation (in msecs)
    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

    // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000;

    // `time_low`
    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    // `time_mid`
    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff;

    // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80;

    // `clock_seq_low`
    b[i++] = clockseq & 0xff;

    // `node`
    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }

  // **`v4()` - Generate random UUID**

  // See https://github.com/broofa/node-uuid for API details
  function v4(options, buf, offset) {
    // Deprecated - 'format' argument, as supported in v1.2
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    // Copy bytes to buffer, if provided
    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  // Export public API
  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (typeof define === 'function' && define.amd) {
    // Publish as AMD module
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    // Publish as node.js module
    module.exports = uuid;
  } else {
    // Publish as global (in browsers)
    var _previousRoot = _global.uuid;

    // **`noConflict()` - (browser only) to reset global 'uuid' var**
    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}).call(this);



(function(a,b,c){"use strict";var d=a.document,e=a.Modernizr,f=function(a){return a.charAt(0).toUpperCase()+a.slice(1)},g="Moz Webkit O Ms".split(" "),h=function(a){var b=d.documentElement.style,c;if(typeof b[a]=="string")return a;a=f(a);for(var e=0,h=g.length;e<h;e++){c=g[e]+a;if(typeof b[c]=="string")return c}},i=h("transform"),j=h("transitionProperty"),k={csstransforms:function(){return!!i},csstransforms3d:function(){var a=!!h("perspective");if(a){var c=" -o- -moz- -ms- -webkit- -khtml- ".split(" "),d="@media ("+c.join("transform-3d),(")+"modernizr)",e=b("<style>"+d+"{#modernizr{height:3px}}"+"</style>").appendTo("head"),f=b('<div id="modernizr" />').appendTo("html");a=f.height()===3,f.remove(),e.remove()}return a},csstransitions:function(){return!!j}},l;if(e)for(l in k)e.hasOwnProperty(l)||e.addTest(l,k[l]);else{e=a.Modernizr={_version:"1.6ish: miniModernizr for Isotope"};var m=" ",n;for(l in k)n=k[l](),e[l]=n,m+=" "+(n?"":"no-")+l;b("html").addClass(m)}if(e.csstransforms){var o=e.csstransforms3d?{translate:function(a){return"translate3d("+a[0]+"px, "+a[1]+"px, 0) "},scale:function(a){return"scale3d("+a+", "+a+", 1) "}}:{translate:function(a){return"translate("+a[0]+"px, "+a[1]+"px) "},scale:function(a){return"scale("+a+") "}},p=function(a,c,d){var e=b.data(a,"isoTransform")||{},f={},g,h={},j;f[c]=d,b.extend(e,f);for(g in e)j=e[g],h[g]=o[g](j);var k=h.translate||"",l=h.scale||"",m=k+l;b.data(a,"isoTransform",e),a.style[i]=m};b.cssNumber.scale=!0,b.cssHooks.scale={set:function(a,b){p(a,"scale",b)},get:function(a,c){var d=b.data(a,"isoTransform");return d&&d.scale?d.scale:1}},b.fx.step.scale=function(a){b.cssHooks.scale.set(a.elem,a.now+a.unit)},b.cssNumber.translate=!0,b.cssHooks.translate={set:function(a,b){p(a,"translate",b)},get:function(a,c){var d=b.data(a,"isoTransform");return d&&d.translate?d.translate:[0,0]}}}var q,r;e.csstransitions&&(q={WebkitTransitionProperty:"webkitTransitionEnd",MozTransitionProperty:"transitionend",OTransitionProperty:"oTransitionEnd otransitionend",transitionProperty:"transitionend"}[j],r=h("transitionDuration"));var s=b.event,t=b.event.handle?"handle":"dispatch",u;s.special.smartresize={setup:function(){b(this).bind("resize",s.special.smartresize.handler)},teardown:function(){b(this).unbind("resize",s.special.smartresize.handler)},handler:function(a,b){var c=this,d=arguments;a.type="smartresize",u&&clearTimeout(u),u=setTimeout(function(){s[t].apply(c,d)},b==="execAsap"?0:100)}},b.fn.smartresize=function(a){return a?this.bind("smartresize",a):this.trigger("smartresize",["execAsap"])},b.Isotope=function(a,c,d){this.element=b(c),this._create(a),this._init(d)};var v=["width","height"],w=b(a);b.Isotope.settings={resizable:!0,layoutMode:"masonry",containerClass:"isotope",itemClass:"isotope-item",hiddenClass:"isotope-hidden",hiddenStyle:{opacity:0,scale:.001},visibleStyle:{opacity:1,scale:1},containerStyle:{position:"relative",overflow:"hidden"},animationEngine:"best-available",animationOptions:{queue:!1,duration:800},sortBy:"original-order",sortAscending:!0,resizesContainer:!0,transformsEnabled:!0,itemPositionDataEnabled:!1},b.Isotope.prototype={_create:function(a){this.options=b.extend({},b.Isotope.settings,a),this.styleQueue=[],this.elemCount=0;var c=this.element[0].style;this.originalStyle={};var d=v.slice(0);for(var e in this.options.containerStyle)d.push(e);for(var f=0,g=d.length;f<g;f++)e=d[f],this.originalStyle[e]=c[e]||"";this.element.css(this.options.containerStyle),this._updateAnimationEngine(),this._updateUsingTransforms();var h={"original-order":function(a,b){return b.elemCount++,b.elemCount},random:function(){return Math.random()}};this.options.getSortData=b.extend(this.options.getSortData,h),this.reloadItems(),this.offset={left:parseInt(this.element.css("padding-left")||0,10),top:parseInt(this.element.css("padding-top")||0,10)};var i=this;setTimeout(function(){i.element.addClass(i.options.containerClass)},0),this.options.resizable&&w.bind("smartresize.isotope",function(){i.resize()}),this.element.delegate("."+this.options.hiddenClass,"click",function(){return!1})},_getAtoms:function(a){var b=this.options.itemSelector,c=b?a.filter(b).add(a.find(b)):a,d={position:"absolute"};return c=c.filter(function(a,b){return b.nodeType===1}),this.usingTransforms&&(d.left=0,d.top=0),c.css(d).addClass(this.options.itemClass),this.updateSortData(c,!0),c},_init:function(a){this.$filteredAtoms=this._filter(this.$allAtoms),this._sort(),this.reLayout(a)},option:function(a){if(b.isPlainObject(a)){this.options=b.extend(!0,this.options,a);var c;for(var d in a)c="_update"+f(d),this[c]&&this[c]()}},_updateAnimationEngine:function(){var a=this.options.animationEngine.toLowerCase().replace(/[ _\-]/g,""),b;switch(a){case"css":case"none":b=!1;break;case"jquery":b=!0;break;default:b=!e.csstransitions}this.isUsingJQueryAnimation=b,this._updateUsingTransforms()},_updateTransformsEnabled:function(){this._updateUsingTransforms()},_updateUsingTransforms:function(){var a=this.usingTransforms=this.options.transformsEnabled&&e.csstransforms&&e.csstransitions&&!this.isUsingJQueryAnimation;a||(delete this.options.hiddenStyle.scale,delete this.options.visibleStyle.scale),this.getPositionStyles=a?this._translate:this._positionAbs},_filter:function(a){var b=this.options.filter===""?"*":this.options.filter;if(!b)return a;var c=this.options.hiddenClass,d="."+c,e=a.filter(d),f=e;if(b!=="*"){f=e.filter(b);var g=a.not(d).not(b).addClass(c);this.styleQueue.push({$el:g,style:this.options.hiddenStyle})}return this.styleQueue.push({$el:f,style:this.options.visibleStyle}),f.removeClass(c),a.filter(b)},updateSortData:function(a,c){var d=this,e=this.options.getSortData,f,g;a.each(function(){f=b(this),g={};for(var a in e)!c&&a==="original-order"?g[a]=b.data(this,"isotope-sort-data")[a]:g[a]=e[a](f,d);b.data(this,"isotope-sort-data",g)})},_sort:function(){var a=this.options.sortBy,b=this._getSorter,c=this.options.sortAscending?1:-1,d=function(d,e){var f=b(d,a),g=b(e,a);return f===g&&a!=="original-order"&&(f=b(d,"original-order"),g=b(e,"original-order")),(f>g?1:f<g?-1:0)*c};this.$filteredAtoms.sort(d)},_getSorter:function(a,c){return b.data(a,"isotope-sort-data")[c]},_translate:function(a,b){return{translate:[a,b]}},_positionAbs:function(a,b){return{left:a,top:b}},_pushPosition:function(a,b,c){b=Math.round(b+this.offset.left),c=Math.round(c+this.offset.top);var d=this.getPositionStyles(b,c);this.styleQueue.push({$el:a,style:d}),this.options.itemPositionDataEnabled&&a.data("isotope-item-position",{x:b,y:c})},layout:function(a,b){var c=this.options.layoutMode;this["_"+c+"Layout"](a);if(this.options.resizesContainer){var d=this["_"+c+"GetContainerSize"]();this.styleQueue.push({$el:this.element,style:d})}this._processStyleQueue(a,b),this.isLaidOut=!0},_processStyleQueue:function(a,c){var d=this.isLaidOut?this.isUsingJQueryAnimation?"animate":"css":"css",f=this.options.animationOptions,g=this.options.onLayout,h,i,j,k;i=function(a,b){b.$el[d](b.style,f)};if(this._isInserting&&this.isUsingJQueryAnimation)i=function(a,b){h=b.$el.hasClass("no-transition")?"css":d,b.$el[h](b.style,f)};else if(c||g||f.complete){var l=!1,m=[c,g,f.complete],n=this;j=!0,k=function(){if(l)return;var b;for(var c=0,d=m.length;c<d;c++)b=m[c],typeof b=="function"&&b.call(n.element,a,n);l=!0};if(this.isUsingJQueryAnimation&&d==="animate")f.complete=k,j=!1;else if(e.csstransitions){var o=0,p=this.styleQueue[0],s=p&&p.$el,t;while(!s||!s.length){t=this.styleQueue[o++];if(!t)return;s=t.$el}var u=parseFloat(getComputedStyle(s[0])[r]);u>0&&(i=function(a,b){b.$el[d](b.style,f).one(q,k)},j=!1)}}b.each(this.styleQueue,i),j&&k(),this.styleQueue=[]},resize:function(){this["_"+this.options.layoutMode+"ResizeChanged"]()&&this.reLayout()},reLayout:function(a){this["_"+this.options.layoutMode+"Reset"](),this.layout(this.$filteredAtoms,a)},addItems:function(a,b){var c=this._getAtoms(a);this.$allAtoms=this.$allAtoms.add(c),b&&b(c)},insert:function(a,b){this.element.append(a);var c=this;this.addItems(a,function(a){var d=c._filter(a);c._addHideAppended(d),c._sort(),c.reLayout(),c._revealAppended(d,b)})},appended:function(a,b){var c=this;this.addItems(a,function(a){c._addHideAppended(a),c.layout(a),c._revealAppended(a,b)})},_addHideAppended:function(a){this.$filteredAtoms=this.$filteredAtoms.add(a),a.addClass("no-transition"),this._isInserting=!0,this.styleQueue.push({$el:a,style:this.options.hiddenStyle})},_revealAppended:function(a,b){var c=this;setTimeout(function(){a.removeClass("no-transition"),c.styleQueue.push({$el:a,style:c.options.visibleStyle}),c._isInserting=!1,c._processStyleQueue(a,b)},10)},reloadItems:function(){this.$allAtoms=this._getAtoms(this.element.children())},remove:function(a,b){this.$allAtoms=this.$allAtoms.not(a),this.$filteredAtoms=this.$filteredAtoms.not(a);var c=this,d=function(){a.remove(),b&&b.call(c.element)};a.filter(":not(."+this.options.hiddenClass+")").length?(this.styleQueue.push({$el:a,style:this.options.hiddenStyle}),this._sort(),this.reLayout(d)):d()},shuffle:function(a){this.updateSortData(this.$allAtoms),this.options.sortBy="random",this._sort(),this.reLayout(a)},destroy:function(){var a=this.usingTransforms,b=this.options;this.$allAtoms.removeClass(b.hiddenClass+" "+b.itemClass).each(function(){var b=this.style;b.position="",b.top="",b.left="",b.opacity="",a&&(b[i]="")});var c=this.element[0].style;for(var d in this.originalStyle)c[d]=this.originalStyle[d];this.element.unbind(".isotope").undelegate("."+b.hiddenClass,"click").removeClass(b.containerClass).removeData("isotope"),w.unbind(".isotope")},_getSegments:function(a){var b=this.options.layoutMode,c=a?"rowHeight":"columnWidth",d=a?"height":"width",e=a?"rows":"cols",g=this.element[d](),h,i=this.options[b]&&this.options[b][c]||this.$filteredAtoms["outer"+f(d)](!0)||g;h=Math.floor(g/i),h=Math.max(h,1),this[b][e]=h,this[b][c]=i},_checkIfSegmentsChanged:function(a){var b=this.options.layoutMode,c=a?"rows":"cols",d=this[b][c];return this._getSegments(a),this[b][c]!==d},_masonryReset:function(){this.masonry={},this._getSegments();var a=this.masonry.cols;this.masonry.colYs=[];while(a--)this.masonry.colYs.push(0)},_masonryLayout:function(a){var c=this,d=c.masonry;a.each(function(){var a=b(this),e=Math.ceil(a.outerWidth(!0)/d.columnWidth);e=Math.min(e,d.cols);if(e===1)c._masonryPlaceBrick(a,d.colYs);else{var f=d.cols+1-e,g=[],h,i;for(i=0;i<f;i++)h=d.colYs.slice(i,i+e),g[i]=Math.max.apply(Math,h);c._masonryPlaceBrick(a,g)}})},_masonryPlaceBrick:function(a,b){var c=Math.min.apply(Math,b),d=0;for(var e=0,f=b.length;e<f;e++)if(b[e]===c){d=e;break}var g=this.masonry.columnWidth*d,h=c;this._pushPosition(a,g,h);var i=c+a.outerHeight(!0),j=this.masonry.cols+1-f;for(e=0;e<j;e++)this.masonry.colYs[d+e]=i},_masonryGetContainerSize:function(){var a=Math.max.apply(Math,this.masonry.colYs);return{height:a}},_masonryResizeChanged:function(){return this._checkIfSegmentsChanged()},_fitRowsReset:function(){this.fitRows={x:0,y:0,height:0}},_fitRowsLayout:function(a){var c=this,d=this.element.width(),e=this.fitRows;a.each(function(){var a=b(this),f=a.outerWidth(!0),g=a.outerHeight(!0);e.x!==0&&f+e.x>d&&(e.x=0,e.y=e.height),c._pushPosition(a,e.x,e.y),e.height=Math.max(e.y+g,e.height),e.x+=f})},_fitRowsGetContainerSize:function(){return{height:this.fitRows.height}},_fitRowsResizeChanged:function(){return!0},_cellsByRowReset:function(){this.cellsByRow={index:0},this._getSegments(),this._getSegments(!0)},_cellsByRowLayout:function(a){var c=this,d=this.cellsByRow;a.each(function(){var a=b(this),e=d.index%d.cols,f=Math.floor(d.index/d.cols),g=(e+.5)*d.columnWidth-a.outerWidth(!0)/2,h=(f+.5)*d.rowHeight-a.outerHeight(!0)/2;c._pushPosition(a,g,h),d.index++})},_cellsByRowGetContainerSize:function(){return{height:Math.ceil(this.$filteredAtoms.length/this.cellsByRow.cols)*this.cellsByRow.rowHeight+this.offset.top}},_cellsByRowResizeChanged:function(){return this._checkIfSegmentsChanged()},_straightDownReset:function(){this.straightDown={y:0}},_straightDownLayout:function(a){var c=this;a.each(function(a){var d=b(this);c._pushPosition(d,0,c.straightDown.y),c.straightDown.y+=d.outerHeight(!0)})},_straightDownGetContainerSize:function(){return{height:this.straightDown.y}},_straightDownResizeChanged:function(){return!0},_masonryHorizontalReset:function(){this.masonryHorizontal={},this._getSegments(!0);var a=this.masonryHorizontal.rows;this.masonryHorizontal.rowXs=[];while(a--)this.masonryHorizontal.rowXs.push(0)},_masonryHorizontalLayout:function(a){var c=this,d=c.masonryHorizontal;a.each(function(){var a=b(this),e=Math.ceil(a.outerHeight(!0)/d.rowHeight);e=Math.min(e,d.rows);if(e===1)c._masonryHorizontalPlaceBrick(a,d.rowXs);else{var f=d.rows+1-e,g=[],h,i;for(i=0;i<f;i++)h=d.rowXs.slice(i,i+e),g[i]=Math.max.apply(Math,h);c._masonryHorizontalPlaceBrick(a,g)}})},_masonryHorizontalPlaceBrick:function(a,b){var c=Math.min.apply(Math,b),d=0;for(var e=0,f=b.length;e<f;e++)if(b[e]===c){d=e;break}var g=c,h=this.masonryHorizontal.rowHeight*d;this._pushPosition(a,g,h);var i=c+a.outerWidth(!0),j=this.masonryHorizontal.rows+1-f;for(e=0;e<j;e++)this.masonryHorizontal.rowXs[d+e]=i},_masonryHorizontalGetContainerSize:function(){var a=Math.max.apply(Math,this.masonryHorizontal.rowXs);return{width:a}},_masonryHorizontalResizeChanged:function(){return this._checkIfSegmentsChanged(!0)},_fitColumnsReset:function(){this.fitColumns={x:0,y:0,width:0}},_fitColumnsLayout:function(a){var c=this,d=this.element.height(),e=this.fitColumns;a.each(function(){var a=b(this),f=a.outerWidth(!0),g=a.outerHeight(!0);e.y!==0&&g+e.y>d&&(e.x=e.width,e.y=0),c._pushPosition(a,e.x,e.y),e.width=Math.max(e.x+f,e.width),e.y+=g})},_fitColumnsGetContainerSize:function(){return{width:this.fitColumns.width}},_fitColumnsResizeChanged:function(){return!0},_cellsByColumnReset:function(){this.cellsByColumn={index:0},this._getSegments(),this._getSegments(!0)},_cellsByColumnLayout:function(a){var c=this,d=this.cellsByColumn;a.each(function(){var a=b(this),e=Math.floor(d.index/d.rows),f=d.index%d.rows,g=(e+.5)*d.columnWidth-a.outerWidth(!0)/2,h=(f+.5)*d.rowHeight-a.outerHeight(!0)/2;c._pushPosition(a,g,h),d.index++})},_cellsByColumnGetContainerSize:function(){return{width:Math.ceil(this.$filteredAtoms.length/this.cellsByColumn.rows)*this.cellsByColumn.columnWidth}},_cellsByColumnResizeChanged:function(){return this._checkIfSegmentsChanged(!0)},_straightAcrossReset:function(){this.straightAcross={x:0}},_straightAcrossLayout:function(a){var c=this;a.each(function(a){var d=b(this);c._pushPosition(d,c.straightAcross.x,0),c.straightAcross.x+=d.outerWidth(!0)})},_straightAcrossGetContainerSize:function(){return{width:this.straightAcross.x}},_straightAcrossResizeChanged:function(){return!0}},b.fn.imagesLoaded=function(a){function h(){a.call(c,d)}function i(a){var c=a.target;c.src!==f&&b.inArray(c,g)===-1&&(g.push(c),--e<=0&&(setTimeout(h),d.unbind(".imagesLoaded",i)))}var c=this,d=c.find("img").add(c.filter("img")),e=d.length,f="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==",g=[];return e||h(),d.bind("load.imagesLoaded error.imagesLoaded",i).each(function(){var a=this.src;this.src=f,this.src=a}),c};var x=function(b){a.console&&a.console.error(b)};b.fn.isotope=function(a,c){if(typeof a=="string"){var d=Array.prototype.slice.call(arguments,1);this.each(function(){var c=b.data(this,"isotope");if(!c){x("cannot call methods on isotope prior to initialization; attempted to call method '"+a+"'");return}if(!b.isFunction(c[a])||a.charAt(0)==="_"){x("no such method '"+a+"' for isotope instance");return}c[a].apply(c,d)})}else this.each(function(){var d=b.data(this,"isotope");d?(d.option(a),d._init(c)):b.data(this,"isotope",new b.Isotope(a,this,c))});return this}})(window,jQuery);


(function() {
    var method;
    var noop = function () {};
    var methods = [
        'assert', 'clear', 'count', 'debug', 'dir', 'dirxml', 'error',
        'exception', 'group', 'groupCollapsed', 'groupEnd', 'info', 'log',
        'markTimeline', 'profile', 'profileEnd', 'table', 'time', 'timeEnd',
        'timeStamp', 'trace', 'warn'
    ];
    var length = methods.length;
    var console = (window.console = window.console || {});

    while (length--) {
        method = methods[length];

        // Only stub undefined methods.
        if (!console[method]) {
            console[method] = noop;
        }
    }
}());


(function($){
	
	$.fn.popupWindow = function (options) {
		var defaults = {
			width: 1000,
			height: 760,
			fullscreen: false,
			resizable: 'yes',
			status: 'no',
			toolbar: 'no',
			menubar: 'no',
			location: 'no'
		},
		settings = $.extend({}, defaults, options);
		
			this.live("click", function (url,window) {
				var url = $(this).attr("href");
				var str = "resizable=" + settings.resizable + ",status=" + settings.status + ",toolbar=" + settings.toolbar + ",menubar=" + settings.menubar + ",location=" + settings.location;
							
				if(settings.fullscreen == true) {					
					var ah = screen.availHeight - 30;
					var aw = screen.availWidth;
					str += ",height=" + ah + ",innerHeight=" + ah;
					str += ",width=" + aw + ",innerWidth=" + aw;
					var xc = 0;
					var yc = 0;
					str += ",left=" + xc + ",screenX=" + xc;
					str += ",top=" + yc + ",screenY=" + yc;
					str += ",type=fullWindow,fullscreen";
				}else {
					str += ",height=" + settings.height + ",innerHeight=" + settings.height;
					str += ",width=" + settings.width + ",innerWidth=" + settings.width;
				}
				
				childWindow = open(url,window,str);
				if(childWindow.opener == null){
					childWindow.opener = self;
				}
				return false;
			}); 
			
			$(".close-window a").live("click", function(){
				window.close();
				return false;
			});

		return this;
	}
	
})(jQuery);


(function($){
	
	$.fn.ndslider = function (options) {
		var defaults = {
				slidespeed: 500
			},
			settings = $.extend({}, defaults, options);

			this.each(function () {

				var slider = $(this),
					sliderItem = slider.find(".slideritem"), 
					sliderWidth = slider.width(), 
					sliderItemLen = sliderItem.length,
					sliderItemWidth = sliderItem.width(),
					sliderItemWrap = slider.find(".slideritemwrap"), 
					sliderItemWrapWidth = sliderItemWidth * sliderItemLen,
					infoBox = slider.find(".infowrap"),
					controlBar = $('<div class="controlbar"><div class="bgwrap"><ul></ul></div></div>'),
					btnCtrl = slider.find(".control"),
					btnNext = slider.find(".control a.next"),
					btnPrev = slider.find(".control a.prev");
				
				//register external listeners
				slider.bind('slidenext.slider', function() { 
					btnNext.trigger('click');
				}).bind('slideprev.slider', function() { 
					btnPrev.trigger('click');
				});
				
				sliderItemWrap.css("width", sliderItemWrapWidth);

				if (sliderItemLen > 1){

					//controlBar mark-up
					slider.append(controlBar);
					for(var i = 0; i < sliderItemLen; i++){
						$("<li><span>Page" + i + "</span></li>").appendTo(slider.find(".controlbar ul"));
					};
					var controlItem = slider.find(".controlbar ul li");
					controlItem.eq(0).addClass("first current");										
					controlBar.fadeIn();
					
					var controlWidth = slider.find(".controlbar .bgwrap").width(),
					controlBarPadding = (sliderWidth - controlWidth)/2;
					if (ND.rtl){
						controlBar.css("padding-right",controlBarPadding);
					}else {
						controlBar.css("padding-left",controlBarPadding);
					}
					
					btnCtrl.show();
					infoBox.eq(0).show(500);
					
					//sliderAction
					var sliderAction = function(itemNo) {
						if (itemNo < sliderItemLen && itemNo > -1){
							var marginleftvalue = -(itemNo * sliderItemWidth);
							if (ND.rtl){
								sliderItemWrap.animate({
									marginRight:marginleftvalue
								 }, settings.slidespeed);
							}else{
								sliderItemWrap.animate({
									marginLeft:marginleftvalue
								 }, settings.slidespeed);
							}
							btnPrev.removeClass("prev-disable");
							btnNext.removeClass("next-disable");
							infoBox.fadeOut();
							infoBox.eq(itemNo).fadeIn();
						}
						if (itemNo >= sliderItemLen-1){
							btnNext.addClass("next-disable");
						}
						if (itemNo <= 0){
							btnPrev.addClass("prev-disable");
						}
					}
					
					//controlBar sliderAction
					controlItem.click(function(){
						var controlCurrentItem = $(this);
						itemNo = controlCurrentItem.index();
						controlItem.removeClass("current");
						controlCurrentItem.addClass("current");
						sliderAction(itemNo);
					});
					//add thumb control
					
					
					
					
					$(".bq_slider_thumbs_item").click(function(){
						
						var $thisthumb= $(this);
						
						var currentid=$thisthumb.attr("id");
						
						for(var i=0;i<$(".bq_slider_thumbs_item").children("a").length;i++){
							
							
							if(i<=1){
								
							if(i%2==0){
							$(".bq_slider_thumbs_item").children("a").eq(i).hide();	
							}else{
							$(".bq_slider_thumbs_item").children("a").eq(i).show();	
							}
								
							}else{
							
							if(i%2==0){
							$(".bq_slider_thumbs_item").children("a").eq(i).show();	
							}else{
							$(".bq_slider_thumbs_item").children("a").eq(i).hide();	
							}
							
							}
								
							
						}
						
						
						$thisthumb.children("a").eq(0).toggle();
						$thisthumb.children("a").eq(1).toggle();
						
						sliderAction(currentid);
						
					});
					
					//$(".bq_slider_thumbs_item").eq(0).click();					
					//control arrow sliderAction
					var itemNo = 0;
					btnNext.click(function(){						
						itemNo = itemNo + 1;						
						sliderAction(itemNo);
						if (itemNo > sliderItemLen-1){
							itemNo = sliderItemLen -1;
							return false;
						}else{
							controlItem.eq(itemNo-1).removeClass("current");
							controlItem.eq(itemNo).addClass("current");						
						}
						return false;
					});
					
					btnPrev.click(function(){
						itemNo = itemNo - 1;
						sliderAction(itemNo);
						if (itemNo < 0){
							itemNo = 0;
							return false;
						}else{
							controlItem.eq(itemNo+1).removeClass("current");
							controlItem.eq(itemNo).addClass("current");					
						}
						return false;
					});

				} else if(sliderItemLen == 1){
					infoBox.eq(0).show();
					return false;
				} else {
					btnCtrl.hide();
					return false;
				}
				
			});

		return this;
	}
	
})(jQuery);


/*
 * File to house the mini plugins that are created for modules.
 */
(function($, win, doc){

	/*
	 * jQuery Plugin - embeddedData
	 * <script id="price-urls" type="text/x-json">
	 * {
	 * 		"xhr-calcprice-data":"GetPrices.js",
	 *		"xhr-calcprice-form":"overlay-calculateprice.html?v2"
	 * }
	 * </script>
	 */
	$.fn.embeddedData = function(prop){
		var xJson = this.data('x-json');
		
		if( !xJson && this.attr('type') === 'text/x-json' ) {
			xJson = $.parseJSON( this.html() );
			this.data( 'x-json', xJson );
		}	
		
		if( prop ) {
			return xJson[prop] || null;
		} else {
			return xJson || {};
		}
	};
	
	
	/*
	 * jQuery Plugin - doOnce
	 * Does nothing if the collection is empty
	 */
	$.fn.doOnce = function(func){ 
	    this.length && func.apply(this); 
	    return this; 
	};
	
	/*
	 * jQuery Plugin - forEach
	 * Does nothing if the collection is empty, other normal loop
	 */
	$.fn.forEach = function(func){ 
	    this.length && this.each(func); 
	    return this; 
	};
	
	/*
	 * jQuery Plugin - killFlash
	 * kill the flash object in the overlay
	 */
	$.fn.killFlash = function(){ 
	    this.length && this.each(function(){
	    	var flash = $(this).flash();
			flash.remove && flash.remove();
	    }); 
	    return this; 
	}
	
	/*
	 * jQuery Plugin - killFlash
	 * Render Flash based on the meta data in the class
	 */
	$.fn.metaBasedFlash = (function(){
		var defaults = {},
			getData = function(flash){
				var data = flash.length > 0 ? flash.metadata({type: 'class'}) : 0,
					ret = (data && 'swf' in data) ? data : 0;
					
				return ret
			};
		
		return function(options){ 
			this.length && this.each(function(){
				var item = $(this),
					data = getData(item);
					options = $.extend(defaults, options);
			
				if(data) {
					//extend the JSON object extracted from the class with some system wide ones.
					data = $.extend(true, data, options.swfobject);
				
					item.flash(data);
					item.addClass("flash-loaded");
					if(options['success']) {
						options.success.apply(this)
					}
				}
			}); 
			return this; 
		}

	})();
	
	/*
	 * jQuery Plugin - lazyLoadImages
	 * Enable lazy load images
	 */
	$.fn.lazyLoadImages = (function(){
		var defaults = {},
			getData = function (image) {
				var data = (image.length > 0) ? image.metadata({type: 'class'}) : 0,
					ret = (data && 'src' in data) ? data : 0;
				return ret
			};
		
		return function (options) {
			this.length && this.each(function () {
				var item = $(this),
					data = getData(item);
					options = $.extend(defaults, options);
				if(data) {
					item.attr("src", data['src']);
					if(options['success']) {
						options.success.apply(this)
					}
				}
			}); 
			return this; 
		}
	})();

	/*
	 * jQuery Plugin - getQueryVariable
	 * 
	 * Calling method: var item = $.getQueryVariable(url,key);
	 * 
	 * url: http://www.example.com/index.html?id=1&image=awesome.jpg
	 * key: "id"
	 * - would return "1"
	 * 
	 * key: null
	 * - would return ["id=1","image=awesome.jpg"]
	 * 
	 * key: "hello"
	 * - would return false
	 * 
	 * 
	 * url: http://www.example.com/index.html?id&image
	 * key: "id"
	 * - would return undefined
	 *
	 * key: null
	 * - would return ["id","image"]
	 * 
	 * key: "hello"
	 * - would return false
	 *
	 * url: http://www.example.com/index.html
	 * key: "id"
	 * - would return false
	 *
	 * key: null
	 * - would return false
	 * 
	 * key: "hello"
	 * - would return false
	 */
	$.extend({
		getQueryVariable: function(url,key){
			var index = url.indexOf('?');
			if (index != -1){
				var query = url.substring( index + 1);
				var params = query.split("&");

				if (key){
					for (var i = 0; i < params.length; i++){
						var pair = params[i].split("=");

						if (pair[0] === key){
							return decodeURI(pair[1]);
						}
					}
				}
				else{
					return params;
				}
			}
			
			return false;
		}
	});

/* End */

})(jQuery, window, document);


/*
Author: 		Randell Quitain
File name: 		personalisation.js
Description: 	Check auth status and setup cookies
Dependencies: 	jQuery, jQuery.cookie, jquery.tinypubsub, FPS
Usage: 			
*/

var guxPersonalisation = guxPersonalisation || {};

(function($){
	guxPersonalisation.psn = {
		uuid: {},
		profile: {},
		init: function(){

			/*
			Test UserCookie
			$.cookie('dfy.u', '{"fn":"John","now":"Mustang","s":"OW","authid":"311982","authby":"005","pcode":"MUSTANG","pc":"3000"}');
			*/

			var success, error;

			// subscribe to profile-done
			$.subscribe('profile-done', (function(){
				if(typeof guxPersonalisation.components !== "undefined") {
					// console.log('Start all components.');
					guxPersonalisation.components.execute();
				}
			}));

			// when FPS success
			success = function (value, status, jqXHR) {
				guxPersonalisation.psn.setProfile(value);
			};

			// when FPS fail
			error = function (value, status, jqXHR) {
				// console.log("FPS isn't loaded, dfy.p value based on FPS will not be updated.");
				// guxPersonalisation.psn.setProfile();
				return;
			};

			// check is FPS is available
			if(typeof FPS !== "undefined") {
				FPS.get([{ 'KBA': {} }, { 'LastViewedVehicle': {} }, { 'RecentlyViewedVehicles': {} }, { 'PreferredDealer': {} }], { success: success, error: error });
			} else {
				// console.log("FPS does not exist, dfy.p value based on FPS will not be updated.");
				// guxPersonalisation.psn.setProfile();
				return;
			}

			// $(window).on('resize',function(){
			// 	guxPersonalisation.psn.init();
			// });

		},
		setUUID: function(){
			if (!$.cookie('dfy.uuid')) {
				if (typeof uuid !== "undefined"){
					var configInfo = guxPersonalisation.psn.commonConfig(),
						cookieDomain = window.location.host;
					if(configInfo !== null && configInfo.cookieDomain) {
						cookieDomain = configInfo.cookieDomain;
					}
					// temporary adobe id
					guxPersonalisation.psn.uuid = { "id": uuid.v1() };
					// expiration: 5 years
					$.cookie('dfy.uuid', JSON.stringify(guxPersonalisation.psn.uuid), { expires: 1825, path: '/', domain: cookieDomain });
				}
			} else {
				guxPersonalisation.psn.uuid = $.parseJSON( JSON.stringify($.cookie('dfy.uuid')) );
			}
		},
		setProfile: function(data){
			// check if sessionStorage is supported
			if(typeof sessionStorage !== "undefined") {
				if (sessionStorage.getItem("dfy.p") === null) {
					sessionStorage.setItem("dfy.p", JSON.stringify(this.fillProfile(data)));
					// create adobeid on first visit
					guxPersonalisation.psn.setUUID();
				} else {
					// check/update  = $.parseJSON( JSON.stringify($.cookie('dfy.uuid')) );
					guxPersonalisation.psn.setUUID();
					sessionStorage.setItem("dfy.p", JSON.stringify(this.fillProfile(data)));
				}
			} else {
				// if sessionStorage is not supported - create cookie
				if (!$.cookie('dfy.p')) {
					var configInfo = guxPersonalisation.psn.commonConfig(),
						cookieDomain = window.location.host;
					if(configInfo !== null && configInfo.cookieDomain) {
						cookieDomain = configInfo.cookieDomain;
					}
					$.cookie('dfy.p', JSON.stringify(this.fillProfile(data)), { path: '/', domain: cookieDomain });
					// create adobeid on first visit
					guxPersonalisation.psn.setUUID();
				} else {
					// check/update  = $.parseJSON( JSON.stringify($.cookie('dfy.uuid')) );
					guxPersonalisation.psn.setUUID();
					$.cookie('dfy.p', JSON.stringify(this.fillProfile(data)), { path: '/', domain: cookieDomain });
				}
			}
		},
		fillProfile: function(value) {

			// standalone check if object is empty
			function isEmpty(obj) {
				for(var prop in obj) {
					if(obj.hasOwnProperty(prop)){ return false; }
				}
				return true;
			}

			// sort via "on"
			function sortOnDesc(arr) {
				var data = arr.sort(function(a, b) {
					var _a = a.on, _b = b.on;
					return _a <= _b ? -1 : 1;
				});
				return data.reverse();
			}

			// parse cookies/common-config
			var configInfo = guxPersonalisation.psn.commonConfig(),
				cookieUUID = null,
				cookieUser = null,
				cookieDL = null;

			if($.cookie('dfy.uuid')) {
				cookieUUID = $.parseJSON( $.cookie('dfy.uuid') );
			}
			
			if($.cookie('dfy.u')) {
				cookieUser = $.parseJSON( $.cookie('dfy.u') );
			}

			if($.cookie('dfy.dl')) {
				cookieDL = $.cookie('dfy.dl');
			}

			// FPS based values
			var noi = "NoVehicle",
				kba = "",
				f = "", 
				rvv = [],
				dc = (cookieDL != null) ? cookieDL : "";
				
			// set FPS values
			if(typeof value !== "undefined" && value !== null && !isEmpty(value)) {

				// console.group('FPS data:');
				// console.log(value);

				var kbas = value[0]['KBA'],
					lastViewedVehicle = value[1]['LastViewedVehicle'],
					recentlyViewedVehicles = value[2]['RecentlyViewedVehicles'],
					preferredDealer = value[3]['PreferredDealer'];

				if(typeof kbas !== "undefined" && !isEmpty(kbas)) {
					kba = "#";
					for (var key in kbas) {
						if (kbas.hasOwnProperty(key)) {
							kba += kbas[key]._KBA + "#";
						}
					}
				}

				/* buggy */
				// if(typeof lastViewedVehicle != "undefined" && lastViewedVehicle != null && !isEmpty(lastViewedVehicle)) {
				// 	noi = lastViewedVehicle[0]._nameplate.split(':')[1];
				// }

				if(typeof recentlyViewedVehicles !== "undefined" && !isEmpty(recentlyViewedVehicles)) {
					// sort to recently viewed - temporary lastViewedVehicle
					var lastViewedVehicle = sortOnDesc(recentlyViewedVehicles);
					noi = lastViewedVehicle[0]._nameplate.split(':')[1];
					for (var key in recentlyViewedVehicles) {
						if (recentlyViewedVehicles.hasOwnProperty(key)) {
							rvv.push({ "_nameplate": recentlyViewedVehicles[key]._nameplate });
						}
					}
					rvv = JSON.stringify(rvv);
				}

				if(typeof preferredDealer !== "undefined" && !isEmpty(preferredDealer)) {
					// sort to preferred dealer
					var preferredDealer = sortOnDesc(preferredDealer);
					// override dfy.d value if FPS is available
					dc = preferredDealer[0]._paCode;
				}
			}
			
			// check tools
			var tools = "";

			// define initial value
			var authState = "",
				now = "",
				id = (cookieUUID) ? cookieUUID.id : "",
				authid = "", /*TBD - based on dfy.p*/
				fn = "";

			//console.log(sessionStorage.getItem("dfy.p"));
			// set values depending on authState
			if(this.viewport() === "mobile"){
				if (cookieUser !== null) {
					authState = cookieUser.s;
					now = cookieUser.now;
					authid = cookieUser.authid;
					fn = cookieUser.fn;
				} else if (cookieUUID === null) {
					authState = "FS";
					// assign tools depending on authState
					if(configInfo != null && configInfo.smobFsTools) {
						tools = configInfo.smobFsTools;
					}
				} else if (cookieUUID != null && cookieUser === null) {
					authState = "AN";
					// assign tools depending on authState
					if(configInfo != null && configInfo.smobAnTools) {
						tools = configInfo.smobAnTools;
					}
				}
			} else {
				if (cookieUser !== null) {
					authState = cookieUser.s;
					now = cookieUser.now;
					authid = cookieUser.authid;
					fn = cookieUser.fn;
				} else if (cookieUUID === null) {
					authState = "FS";
					// assign tools depending on authState
					if(configInfo != null && configInfo.fsTools) {
						tools = configInfo.fsTools;
					}
				} else if (cookieUUID != null && cookieUser === null) {
					authState = "AN";
					// assign tools depending on authState
					if(configInfo != null && configInfo.anTools) {
						tools = configInfo.anTools;
					}
				}
			}
			// set profile
			guxPersonalisation.psn.profile = {
				"authState"	: 	authState,
				"now"		: 	now,
				"noi"		: 	noi, 
				"id"		: 	id, 
				"authid"	:  	authid,
				"tools"		:  	tools, 
				"kba"		:  	kba,
				"fn"		:  	fn, 
				"f"			:   f,
				"rvv"		:  	rvv,
				"dc"		:  	dc
			}
			
			// profile cookie/session creation done
			$.publish('profile-done');
			

			return guxPersonalisation.psn.profile;
		},
		commonConfig: function() {
			// standalone check #common-config
			if ($('#common-config').length) {
				return $('#common-config').embeddedData();
			} else {
				return null;
			}
		},
		viewport: function() {
			var view = "";
			if ($(window).width() < 768){
				this.view = "mobile";
			}
			else {
				this.view = "tablet";
			}
			return view;
		}
	}

	$(function(){
		guxPersonalisation.psn.init();
	});

})(jQuery);


(function(){
	var ND = window.ND = window.ND || {};
			
	var fps = ND.fps = {
					
		_init: function( _fpstag ) {
			this._fpstag = _fpstag;			

		},
		
		// store links
		pageClicks : {},
		
		
		/*
		 * Track Page Views. 
		 */			
		trackPageView: function( params ) {			
			// if function is to be implemented, it will be the same as trackLink, so
			// console.log('Tracking FPS trackPageView');
			fps.trackFps(params);
		},
		
		trackLink: function( params ) {
			// console.log('Tracking FPS trackLink');
			//TODO
			//function executed when a trackable link is clicked
			// this function should track information to FPS The code should
			// call trackFps function (as links and pages are to be tracked in
			// the same way). What might differ might be a parameter format
			fps.trackFps(params);
		},
		
		

		trackFps:  function(params) {	
			// console.log('Tracking FPS');
			var kbaEvents = '';
			var setViewedVehicle = {};
			var setDelear = {};
			var setKBA = {};
			var setTool = {};
			var setAnonymous = {};
			var setOwner = {};
			var setKBARTDC = {};
			var setKBABRQC = {};
			var setKBABAPC = {};
			var setKBARAQC = {};
						
						
			var derivativeName = '';
			var derivativeID = '';
			var nameplateBrand = '';
			var nameplateYear = '';
			var nameplateName = '';
			var nameplateID = '';
			
			var bolSetFPS = false;
			
			
			// console.log('params = ' + params );
			if(typeof params !== 'undefined') {
				// console.log('params.nameplate = ' + params.nameplate );
			}
			
			if (typeof params !== 'undefined' && typeof params.nameplate !== 'undefined' ) {//'params contains nameplate information or other information relevant for FPS') {
	
				if(typeof _da !== 'undefined' && typeof _da.nameplate !== 'undefined') {
					
					
					if(params.nameplate == _da.nameplate.name) {												
						
						if(typeof _da.om.site !== 'undefined' ) {
							nameplateBrand =  _da.om.site;
						}
						
						if(typeof _da.nameplate !== 'undefined') {
							
							if(typeof _da.nameplate.name !== 'undefined') {
								nameplateName = _da.nameplate.name;
							}
							
							if(typeof _da.nameplate.id !== 'undefined') {
								nameplateID = _da.nameplate.id;
							}
							
							if(typeof _da.nameplate.year !== 'undefined' ) {
								nameplateYear =  _da.nameplate.year;
							}

						}
						
						if(typeof _da.der !== 'undefined') {
							
							if(typeof _da.der.name !== 'undefined') {
								derivativeName = _da.der.name;
							}
							
							if(typeof _da.der.id !== 'undefined') {
								derivativeID = _da.der.id;
							}

						}
						
											
						if(nameplateName != '') {
							   // console.log('FPS Set ViewedVehicle via Params');
							   setViewedVehicle = { 'ViewedVehicle': { _year: nameplateYear, _brand: nameplateBrand , _nameplate: nameplateID + ':' + nameplateName, _trim: derivativeID + ':' + derivativeName, _interior: '' , _exterior: '' }, metadata: { active: 'true' } }
							   bolSetFPS = true;
						}
					
					}
				}
	
			} else {
					
				if(typeof _da !== 'undefined') {
													
					if(typeof _da.om.site !== 'undefined' ) {
						nameplateBrand =  _da.om.site;
					}
					
					if(typeof _da.nameplate !== 'undefined') {
						
						if(typeof _da.nameplate.name !== 'undefined') {
							nameplateName = _da.nameplate.name;
						}
						
						if(typeof _da.nameplate.id !== 'undefined') {
							nameplateID = _da.nameplate.id;
						}
						
						if(typeof _da.nameplate.year !== 'undefined' ) {
							nameplateYear =  _da.nameplate.year;
						}

					}
					
					if(typeof _da.der !== 'undefined') {
						
						if(typeof _da.der.name !== 'undefined') {
							derivativeName = _da.der.name;
						}
						
						if(typeof _da.der.id !== 'undefined') {
							derivativeID = _da.der.id;
						}

					}
					
					// console.log('Nameplate = ' + nameplateName );
										
					if(nameplateName != '') {
						   // console.log('FPS Set ViewedVehicle via _da');
						   setViewedVehicle = { 'ViewedVehicle': { _year: nameplateYear, _brand: nameplateBrand , _nameplate: nameplateID + ':' + nameplateName, _trim: derivativeID + ':' + derivativeName, _interior: '' , _exterior: '' }, metadata: { active: 'true'} }
						   bolSetFPS = true;
					}

				}
			}

		
		
			if (typeof _da.events !== 'undefined') {				
				var currentEvent;
							
				
				if(typeof guxPersonalisation !== 'undefined' ) {
					
					if(typeof guxPersonalisation.psn.profile.kba !== 'undefined') {
						kbaEvents = guxPersonalisation.psn.profile.kba;
					}
				}

				
				for (var i = 0; i < _da.events.length; i++) {
				
					currentEvent = _da.events[i];
					
					if(currentEvent == 'event2') {
						
						if(kbaEvents.search('BAPC') == -1) {
						     // console.log('FPS Set KBAEvent BAPC');
							setKBABAPC = {'KBAEvent': {_KBA: 'BAPC'}, metadata: { active: 'true' } };
							bolSetFPS = true;
						}
					}

					if(currentEvent == 'event3') {
						
						if(kbaEvents.search('RAQC') == -1) {
						     // console.log('FPS Set KBAEvent RAQC');
							setKBARAQC = {'KBAEvent': {_KBA: 'RAQC'}, metadata: { active: 'true' } };
							bolSetFPS = true;
						}
					}
					
					if(currentEvent == 'event15') {
						if(kbaEvents.search('BRQC') == -1) {
							// console.log('FPS Set KBAEvent BRQC');
							setKBABRQC = {'KBAEvent': {_KBA: 'BRQC'}, metadata: { active: 'true' } };
							bolSetFPS = true;
						}
					}

					if(currentEvent == 'event20') {
						if(kbaEvents.search('RTDC') == -1) {
							// console.log('FPS Set KBAEvent RTDC');
							setKBARTDC = {'KBAEvent': {_KBA: 'RTDC'}, metadata: { active: 'true' } };
							bolSetFPS = true;
						}
					}					
					
				}
				

			}			

			
			if(typeof guxPersonalisation !== 'undefined' ) {
				
				
				if(typeof guxPersonalisation.psn.profile.authid !== 'undefined') {
					
					setOwner = {'ExternalRef': {_type: 'DFL', _id: guxPersonalisation.psn.profile.authid}, metadata: { active: 'true' } };
					bolSetFPS = true;
				}
				
				if(typeof guxPersonalisation.psn.profile.id !== 'undefined') {

					setAnonymous = {'ExternalRef': {_type: 'DFLA', _id: guxPersonalisation.psn.profile.id}, metadata: { active: 'true' } };
					bolSetFPS = true;
				}
				
				
			}			
			
			if(typeof FPS !== 'undefined') {
				
				if(bolSetFPS) {
					// Set all at once to minimized network connection
					FPS.set([ setViewedVehicle, setKBABAPC, setKBABRQC, setKBARTDC, setKBARAQC, setOwner, setAnonymous  ]);
				}

			
			}

		},
		
		trackEvent: function( params ) {
			// console.log('FPS Tracking Event');
			//TODO track favouriting dealer here and other 
			if (params.type == 'fav-dealer') {
				if(typeof FPS !== 'undefined') {
					FPS.set([ { 'PreferredDealer': { _paCode: params.code }, metadata: { active: 'true' } }]);
				}
			} else if (params.type == 'specified postcode') {
				//FPS.set( ... );
			} //else if {
				//TODO add all types here
			//}
		},
		trackSocial: function( params ) {
			// empty not needed at the current state, left here for
			// compatibility and future extensions reasons
		},			
		trackField: function( params ) {
			// empty not needed at the current state, left here for
			// compatibility and future extensions reasons
		},
		preCollection: function( options, params) {
			//this functional is called before tracking call is made.
			//TODO place here any code which has to happen before page track is made. like reading cookies or DOM metadata

		}

	};

})();


(function(){
	var ND = window.ND = window.ND || {};
	
	var omniture = ND.omniture = {
					
		_init: function( _omtag ) {
			this._omtag = _omtag;
		},
		
		// store links
		pageClicks : {},
		//store module component types
		moduleTypes : {},
		
		/*
		 * Track Page Views. 
		 */			
		trackPageView: function( params ) {
			//empty not needed at the current state, left here for compatibility reasons
			if (typeof params.login !== 'undefined') {
				s.eVar42 = 'x';
			}

		},
		createHier1 : function( hier1 ){
			if (typeof hier1 !== 'undefined') {
				s.hier1 = hier1;
			} else {
				s.hier1 = _da.hier;
			}
			
			if (typeof _da.nameplate !== 'undefined') {
				s.hier1 = s.hier1 + ':' + _da.nameplate.year + ':' + _da.nameplate.cat + ':' + _da.nameplate.name;
			}
		},
		createPageName : function( param ){
			if (typeof param !== 'undefined' && param !== '') {
				s.pageName = s.eVar11 = s.prop11 = param;
			} else {
				s.pageName = s.eVar11 = s.prop11 = _da.pname;
			}
			if (_da.funnel.stepname) {
				s.pageName = s.pageName + ':' + _da.funnel.stepname;
				s.eVar11 = s.eVar11 + ':' + _da.funnel.stepname;
				s.prop11 = s.prop11 + ':' + _da.funnel.stepname;
			}
			//lincoln2014 site search
			if (_da.pagenumber) {
				s.pageName = s.pageName + _da.pagenumber;
				s.eVar11 = s.eVar11 + _da.pagenumber;
				s.prop11 = s.prop11 + _da.pagenumber;
			}
			//sync omniture
			if (typeof _da.sync!== 'undefined'){
				if (typeof _da.sync.version  !== 'undefined') {
					s.pageName = s.pageName + ':' + _da.sync.version;
					s.eVar11 = s.eVar11 + ':' + _da.sync.version;
					s.prop11 = s.prop11 + ':' + _da.sync.version;
				}
			}
			if (typeof _da.prefix !== 'undefined') {	//set for prefix
				s.pageName = _da.prefix  + ':' + s.pageName;
				s.eVar11 = _da.prefix  + ':' + s.eVar11;
				s.prop11 = _da.prefix  + ':' + s.prop11 ;
			}
			if (typeof _da.nameplate !== 'undefined') {	//set for nameplate based templates only
				s.pageName = s.pageName + ':' + _da.nameplate.name;
			}
			
			//add radui ominture tag
			if (typeof _da.radui !== 'undefined'){
				var raduiTag=_da.radui,windowWidth=$(window).width();
				raduiTag=raduiTag.split("|");
				if (windowWidth > 976) {
					//desktop
					s.prop54 =s.eVar54=raduiTag[0]+raduiTag[1];
				} else if (windowWidth < 977 && windowWidth > 767) {
					//tablet
					s.prop54=s.eVar54=raduiTag[0]+raduiTag[2];
				} else if (windowWidth < 768) {
					//smobile
					s.prop54 =s.eVar54=raduiTag[0]+raduiTag[3];
				}
			}

		},
		
		setRegion: function() {
			if (typeof _da.region !== 'undefined') {
				s.prop2 = s.eVar2 = _da.region;
			} else {
				s.prop2 = s.eVar2 = undefined;
			}
		},
		
		trackDerivativeDetails: function() {
			//v18	"Body Model,Trim"
			//v19	"Ext:Int Color Code"
			//v20	Accessories Picked
			//v21	Veh. Options Picked	
			//v23	"Option	Pkgs Picked"
			//v24	"Engine: Trans"
			//v25 	Price
			s.eVar18 = s.eVar19 = s.eVar20 = s.eVar21 = s.eVar23 = s.eVar24 = s.eVar25 = undefined;
			if (typeof _da.der  !== 'undefined') {
				if (typeof _da.der.name !== 'undefined') {
					s.eVar18 = _da.der.name;
				} 
				if (typeof _da.der.colour !== 'undefined' && typeof _da.der.trim !== 'undefined') {
					s.eVar19 = _da.der.colour + ':' + _da.der.trim;
				} 
				if (typeof _da.der.features !== 'undefined') {
					s.eVar20 = _da.der.features;
				}
				if (typeof _da.der.options !== 'undefined') {
					s.eVar21 = _da.der.options;
				}
				if (typeof _da.der.optionpacks !== 'undefined') {
					s.eVar23 = _da.der.optionpacks;
				} 
				if (typeof _da.der.engine  !== 'undefined') {
					s.eVar24 = _da.der.engine;
				}
				if (typeof _da.der.price   !== 'undefined') {
					s.eVar25 = _da.der.price;
				}
			} 
		},
		
		trackLink: function( params ) {
			if (params === undefined) {
				return;
			}
			//need to also set channel here...there is a case in
			//build and price where pre collection is not called yet.
			s.channel = _da.funnel.name;
			s.eVar4 = s.prop4 = _da.om.lang;	//language
			s.eVar14 = s.prop14 = _da.om.client;	//client
			s.eVar15 = s.prop15 = _da.om.site;	//site	
			//set the media value undefined
			s.prop57 = s.eVar57 = undefined; 
			s.prop55 = s.eVar55 = undefined;
			//fix end
			s.linkTrackVars=_da.om.linkTrackVars;
			s.linkTrackEvents=_da.om.linkTrackEvents;
			if (_da.nameplate && _da.nameplate.name && params.nameplate === undefined) {
				params.nameplate = _da.nameplate.name;
			}	
			//track pagename
			if (typeof params.pname !== 'undefined') {
				omniture.createPageName(params.pname);
			} else {
				omniture.createPageName();
			}
			
			//set h1 based on data-hier attribute
			if (typeof params.hier1 !== 'undefined' && params.hier1 !== '') {
				omniture.createHier1(params.hier1);
			} else {
				omniture.createHier1(_da.hier);
			}
			
			if (params.intcmp){
				s.eVar13 = s.prop13 = params.intcmp;
			}else  {
				//?????	
			}			
			
			s.prop5 = params.onclicks;
			s.prop18 = params.leadtype;
			s.prop48 = s.eVar48 = params.tool;
			s.prop49 = s.eVar49 = params.tooldesc;
			
			if (typeof _da.deviceType !== 'undefined') {
                s.eVar54 = _da.deviceType;
            }
			
			s.events = params.events;
			if (params.year || typeof _da.nameplate !=="undefined") {
				if(params.year){
					s.prop12 = s.eVar12 = params.year;
				}
				if(typeof _da.nameplate !=="undefined" && !params.year){
					s.prop12 = s.eVar12 =_da.nameplate.year;
				}
			}else{
				s.prop12 = s.eVar12 = undefined;
			}
			if (params.nameplate && params.nameplate !== 'none') {
				s.prop16 = s.eVar16 = params.nameplate;
				params.title = params.titleNameplate == 'none' ? params.title : params.title + ':' + params.nameplate;
				omniture.trackDerivativeDetails();
			}else{
				s.prop16 = s.eVar16 = undefined;
			}
			
			if (params.content) {
				s.prop56 = s.eVar56 = params.content;
				if(s.prop5=="video start" || s.prop5=="video finish"|| s.prop5=="video complete"){
					
					s.prop5 = s.prop5;
					
				}else{
					
					s.prop5 = s.prop5 + ':' + params.content;
				}
				
			} else {
				s.prop56 = s.eVar56 = undefined;
			}
			omniture.setRegion();
			//add a nameplate to the link, if defined in context
			//if (_da.nameplate) {
			//	params.title += (':' + _da.nameplate.name);
			//}
	//		_.debounce( function() {
			// add freq param

			// Turn on for parameter debugging and a tree-list of the data
			//console.log("Tracking link parameters: ");
			//console.dir(params);
			
			//gux module type
			if (typeof params.moduletype !== 'undefined') {
	            s.prop24 = params.moduletype;
	        }else{
	        	s.prop24 = undefined;
	        }
	        //gux c25 module name
	        if (typeof params.modulename !== 'undefined') {
	        	 s.prop25 = params.modulename;
	        }else{
	        	s.prop25 = undefined;
	        }

			//gux c23 click
	        omniture.setModulePage(params.moduleaction);
	        //gux v35/c21
	        omniture.createSearchTag(params);
	        var linkTitle = params.title;
	        if (typeof _da.prefix !== 'undefined' && params.type !=='e') {
	        	linkTitle = _da.prefix + ":"+linkTitle;
	        }
			if(typeof params.freq === 'undefined'){
				s.tl(params.link, params.type, linkTitle);
			}else if (params.freq =="page" && !omniture.pageClicks[linkTitle]){
				s.tl(params.link, params.type, linkTitle);				
				omniture.pageClicks[linkTitle] = linkTitle;
			}else if (params.freq =="category" && (!omniture.pageClicks[params.onclicks] || (params.moduletype && !omniture.moduleTypes[params.moduletype]))){
				s.tl(params.link, params.type, linkTitle);				
				omniture.pageClicks[params.onclicks] = params.onclicks;
				if(params.moduletype) omniture.moduleTypes[params.moduletype] = params.moduletype;
			}
	//		}, 1000);
		},
		trackMedia: function( params ) {
			// begin track video			
			if (params.content) {
				s.prop56 = s.eVar56 = params.content;
			} else {
				s.prop56 = s.eVar56 = undefined;
			}
			if (params.progress && params.content) {
				s.prop57 = s.eVar57 = params.content + ":"+params.progress;
			} else {
				s.prop57 = s.eVar57 = undefined;
			}
			if (params.segment) {
				 s.eVar55 = params.segment;
			} else {
				s.eVar55 = undefined;
			}			
			if (params.content && s.pageName) {
				s.prop55 = params.content +":"+ s.pageName;
			} else {
				s.prop55 = undefined;
			}
			if (params.mediaType) {
				s.pev3 = params.mediaType;
			} else {
				s.pev3 = undefined;
			}
			if (params.linkType) {
				s.pe = params.linkType;
			} else {
				s.pe = undefined;
			}
			if (params.events) {
				s.events = params.events;
			} else {
				s.events = undefined;
			}
			if (params.onclicks) {
                s.prop5 = params.onclicks;
			} else {
			    s.prop5 = undefined;
			} 
			//gux module type
			if (typeof params.moduletype !== 'undefined') {
	            s.prop24 = params.moduletype;
	        }else{
	        	s.prop24 = undefined;
	        }
	        // gux c25 module name
	        if (typeof params.modulename !== 'undefined') {
	        	 s.prop25 = params.modulename;
	        }else{
	        	s.prop25 = undefined;
	        }

			//gux c23 click
	        omniture.setModulePage(params.moduleaction);
			//end  track video
			s.t();
		},
		trackEvent: function( params ) {
			// empty not needed at the current state, left here for
			// compatibility and future extensions reasons
		},
		trackSocial: function( params ) {
			// empty not needed at the current state, left here for
			// compatibility and future extensions reasons
		},			
		trackField: function( params ) {
			// empty not needed at the current state, left here for
			// compatibility and future extensions reasons
		},
		createSearchTag:function(params){
			
			if(typeof params!=='undefined' && params.search=='none'){
				s.eVar22 = s.prop22 = undefined;
				s.eVar35 = s.prop21 = undefined;
			}else {			
				if(typeof _da.searchKeyword !== 'undefined'){
					s.eVar22=s.prop22=_da.searchKeyword;
				}else{
					s.eVar22=s.prop22= undefined;
				}
				if(typeof params!=='undefined' && typeof params.totalresult!=='undefined' && typeof params.resultnumber!=='undefined'){
					s.eVar35= s.prop21 = params.resultnumber+ ':' +params.totalresult;
				}
				else if(typeof _da.totalresult !== 'undefined'){
						if(typeof _da.resultnumber !== 'undefined'){
							s.eVar35=s.prop21=_da.resultnumber+":"+_da.totalresult;
						}else {
							s.eVar35=s.prop21=_da.totalresult;
						}
				}else {
					s.eVar35 = s.prop21 = undefined;
				}
			}
		},
		setModulePage:function(param){
			if (typeof param!== 'undefined' && typeof _da.module!== 'undefined' && typeof _da.module.page!=='undefined' && typeof _da.module.template!=='undefined'){
				moduleAction = param;
				s.prop23 = _da.module.page +":"+ _da.module.template + ":"+moduleAction;	
			}else{
				s.prop23 = undefined;
			}
		},
		preCollection: function( options, params) {
			//set some global stuff
			s.eVar4 = s.prop4 = _da.om.lang;	//language
			s.eVar14 = s.prop14 = _da.om.client;	//client
			s.eVar15 = s.prop15 = _da.om.site;	//site
			s.prop56 = s.eVar56 = undefined;
			
			//track pagename,c11/v11 and hierarchy
			if (typeof params !== 'undefined') {
				omniture.createPageName(params.pname);
				omniture.createHier1(params.hier);
			} else {
				omniture.createPageName(undefined);
				omniture.createHier1(undefined);
			}

			s.channel = _da.funnel.name;
			s.prop39 = s.prop5 = undefined;
			
			if (typeof _da.nameplate !== 'undefined') {	//set for nameplate based templates only
				s.prop16 = s.eVar16 = _da.nameplate.name;
				s.prop12 = s.eVar12 = _da.nameplate.year;
			} else {
				s.prop12 = s.eVar12 = s.prop16 = s.eVar16 = undefined;
				s.prop36 = s.eVar34 = undefined;
			}
			omniture.trackDerivativeDetails();
			
			if (typeof params !== 'undefined' && params.tool !== 'undefined') {
				s.prop48 = s.eVar48 = params.tool;
				if (params.tooldesc !== 'undefined') {
					s.prop49 = s.eVar49 = params.tooldesc;
				}
			} else if (typeof _da.tool !== 'undefined') {
				s.prop48 = s.eVar48 = _da.tool.name;
				if (_da.tool.descriptor) {
					s.prop49 = s.eVar49 = _da.tool.descriptor;
				} else {
					s.prop49 = s.eVar49 = undefined;
				}
			} else {
				s.prop49 = s.eVar49 = s.prop48 = s.eVar48 = undefined;
			}
			
			if (typeof _da.lead !== 'undefined') {
				s.prop18 = s.eVar28 = _da.lead.type;
				if (_da.lead.optins) {
					s.prop20 = _da.lead.optins;
				} else {
					s.prop20 = undefined;
				}
			} else {
				s.prop18 = s.eVar28 = s.prop20 = undefined;
			}
			
			omniture.setRegion();
			
			if (typeof _da.events !== 'undefined') {
				s.events =  "";
				for (var i = 0; i < _da.events.length; i++) {
					if (s.events.length === 0) {
						s.events += _da.events[i];
					} else {
						s.events += ("," + _da.events[i]);
					}
				}
			} else {
				s.events = "";
			}
			//dealer info
			if (typeof _da.dealer !== 'undefined' && typeof _da.dealer.code!== 'undefined') {
                s.prop1 = s.eVar1 = _da.dealer.code;
			} else {
                s.prop1 = s.eVar1 = undefined;
			}
			
			if (typeof _da.user !== 'undefined' && typeof _da.user.loggedin !== 'undefined') {
                s.prop42 = s.eVar42 = _da.user.loggedin;
			} else {
                s.prop42 = s.eVar42 = undefined;
			}
			if (typeof _da.user !== 'undefined' && typeof _da.user.registered !== 'undefined') {
                s.prop45 = s.eVar45 = _da.user.registered;
			} else {
                s.prop45 = s.eVar45 = undefined;
			}
			if (typeof _da.onclicks !== 'undefined') {
                s.prop5 = _da.onclicks;
			} else {
			    s.prop5 = undefined;
			} 
			omniture.createSearchTag();
			//gux c23
			var moduleAction ="impress"
			omniture.setModulePage(moduleAction);
		}

	};

})();


/*
 * analytics.js
 * Author:gbaker 11/05/2011 
 *
 * #Exported API methods
 * ND.analytics.create				//Function to create Analytics Wrapper Implementation
 * ND.analytics.register			//Function to register Analytics Wrapper Implementation
 */
  
 var ND = (function(module, $) {
 
	var implementation = {},
		registrations = [];
	
	/*
	 * Omniture wrapper implementation (defined in analytics-omniture-impl.js)
	 */
	implementation.omniture = ND.omniture;
	
	
	//TODO Add fps implementation here (defined in fps-omniture-impl.js)
	implementation.fps = ND.fps;
	
	
	/*
	 * Webtrends Wrapper Implementation
	 */
	implementation.webtrends = (function(){
		
		function _dcsMultiTrack( _tag, arr ) {
			arr = arr || [];
			/*Need we clear all the cached parameters before tracking?*/
			//_tag.dcsCleanUp();
			_tag.dcsMultiTrack.apply( _tag , arr );
		}
		
		/* Helpers */
		var helpers = {
			
			// Looper
			each: function( help, arr, params) {
				$.each( help.split(','), function( i, item ) {
					helpers[item].apply( this, [arr, params] )
				});	
			},
			
			//Individuals
			title: function( arr, params ) {
				if( params && 'title' in params ) {
					$.merge( arr, ["WT.ti", params.title]);
				}			
			},
            funnel: function( arr, params ){
                if( params && 'funnel' in params) {
                    $.merge( arr, ["WT.si_n", params.funnel] );
                }
            },
            step: function( arr, params ){
                if( params && 'step' in params) {
                    $.merge( arr, ["WT.si_p", params.step] );
                }
            },
			event: function( arr ) {
				$.merge( arr, ["WT.dl", "99"]);
			},
			link: function( arr ) {
				$.merge( arr, ["WT.dl", "0"]);
			},	
			share: function( arr, params ) {
				if( params && 'socialId' in params ) {
					$.merge( arr, ["WT.z_share", params.socialId]);
				}
			},	
			uri: function ( arr, params ) {
				if( params && 'uri' in params ) {
					$.merge( arr, ["DCS.dcsuri", params.uri]);
				}
			},
			field: function( arr, params ) {
				if( params && 'field' in params) {
					var field = params.field;
					if(field.name){
						$.merge( arr, ["DCSext." + params.field.name, params.field.value || "" ]);
					}else if(field.constructor == Array){
						var r = [];
						for(var idx = field.length; --idx > -1 ; ){
							field[idx].name
								&& r.push("DCSext." + field[idx].name, field[idx].value || "");
						}
						$.merge( arr, r);
					}
				}
			},
			meta: function( a, b ) {
				return $(['<meta name="', a, '" content="', b, '"/>'].join(""));
			}
		}
			
		return {
			/*
			 * Constructor
			 */
			_init: function( _tag ) {
				this._tag = _tag;
			},
			
			/*
			 * Track Page Views. 
			 */			
			trackPageView: function( params ) {
				var arr = [];
				helpers.each( "title,uri", arr, params);					
				_dcsMultiTrack( this._tag, arr );
			},
			trackLink: function( params ) {
				var arr = [];
				helpers.each( "title,uri,link", arr, params);					
				_dcsMultiTrack( this._tag, arr );
			},
			trackEvent: function( params ) {
				var arr = [];
				helpers.each( "event,title,uri", arr, params);					
				_dcsMultiTrack( this._tag, arr );		
			},
			trackSocial: function( params ) {
				var arr = [];
				helpers.each( "event,title,uri,share", arr, params);					
				_dcsMultiTrack( this._tag, arr );
			},			
			trackField: function( params ) {
				var arr = [];
				helpers.each( "event,field,funnel,step", arr, params);					
				_dcsMultiTrack( this._tag, arr );
			},			
			/*
			 *  Before default tracking is triggered.
			 *
			 *	Function to handle when the form builder is on the page.
			 *  This function will be executed right before the Webtrends default tracking function
			 *  This gives ample time to prepare any special Meta Data require for this formpage.
			 *
			 *  Function will inject <meta> tags for WT.
			 */
			preCollection: function( options ) {
				var funnel = options.funnel || false,
					meta = $('meta:last');
				
				if( funnel && funnel.name ) {
					 meta.after( helpers.meta("WT.si_n", funnel.name ) );
				}
				if( funnel && funnel.stepname ) {
					 meta.after( helpers.meta("WT.si_p", funnel.stepname ) );
				}
				
			}
			
		};
	}());
		
	
	
	/*
	 * Exports 
	 */
	module.analytics = {

		/*
		 * Create instance of webtrends wrapper
		 */
		create: function( name, engine ) {
		
			function TrackerClass() {};
			TrackerClass.prototype = implementation[name];
			var tracker = new  TrackerClass();
		
			//var tracker = Object.create( implementation[name] )
			
			tracker._init( engine );
			delete tracker._init;
			tracker.name = name;
			return tracker;
		}, 
		
		/*
		 * Register the PUBSUB channel handlers 
		 * 
		 * PASTE this code into console if you want to see that is going on
		 *  	$.each( 'page,event,link,social'.split(',') , function( i, item ) {
		 * 			$.subscribe('/analytics/'+item+'/', function(e, data) { console.log( e.type, data ) });
		 *		})
		 */
		register: function( tracker ) {
			if( !tracker ) { return; }
			
			//check if this tracker is already registered
			for (i = 0; i < registrations.length; i++) {
				if (tracker.name === registrations[i].name) {
					//console.log("Tracker ["+registrations[i].name+"] already registered.")
					return;
				}
			}
			
			
			//TODO... use rules... 
			// -- remove track and lowercase
			var mapping =  {
				"pageview": "trackPageView",
				"link": "trackLink",
				"social": "trackSocial",
				"event": "trackEvent",
				"field": "trackField",
				"media":"trackMedia"
			}
			
			$.each( mapping, function(channel, funcName) {
				if( funcName in tracker ) {
					$.subscribe( "/analytics/" + channel + "/", (function( tracker, fn ) {
						return function( event, data ) {
							fn.apply( tracker, [data] );
						}
					})(tracker, tracker[funcName]) );
				}
			});
			
			registrations.push( tracker );
		},
		
		/*
		 *  Return a Helper function for grabbing content out of the DOM and using it in tracking.
		 */
		grabber: function() {
			
			function urlise( str ) {
				str = (str || "").toLowerCase()
					.replace(/[\s'"!@#$%\^\&\*\(\),\.<>;:\[\]{}?+/\\-_=]/g, "-")
					.replace(/(-){2,}/g, "-")
					.replace(/^-|-$/g, "");
					
				return str;
			}
			
			//Helper function
			return function( options ) {
				
				var elem, value, url, best;
				
				if( options.link ) {
					elem = $( options.link );			
					value = elem.attr("data-tracking-value") || elem.attr("title") || elem.text() || "",
					url = urlise( value );
				}
				
				if( options.meta ) {
					elem = $( options.meta );		
					value = elem.attr("content") || "",
					url = urlise( value );
				}
				
				if( options.inner ) {
					elem = $( options.inner );		
					value = elem.text() || "",
					url = urlise( value );
				}
				
				if( options.name ) {
					value = options.name,
					url = urlise( options.name );
				}

				return {
					value: value,
					url: url
				}
				
			}
			
		}
	}

	
	return module;
 
 }(window.ND || {}, jQuery));


/* shoppref.js */
/*
 * shoppref.js
 * Author:gbaker 13/12/2011 
 */

/*globals window, document, jQuery, ND, SiteConf */
ND.shoppingPreferenceManager = (function($, undefined){
	
	var 
		/*
		 * The Cookie manager for shopping preferences
		 */
		shoppingPreferenceManager = {
		
			prefix: "shopping.pref.",
	
			/*
			 * List of supported Shopping Preferences, and their short names
			 */
			list: { postcode: "pc", usage: "us", usageLabel: "us.l", region: "rg", regionLabel: "rg.l", pricezone:"pz", pricezoneLabel:"pz.l", priceformatData:"pf" },
			
			/*
			 * Constructor of sorts
			 */
			init: function() {				
				this.cache = {};
				this.store = {};
				this.listen();
				this.upgradeCookie();
			},
			
			/*
			 * Prepare the stores, executed on demand to minise overhead.
			 */
			prepare: function() {
				var self = this;
				var cookieDomain=null;
				var configInfo = (typeof $('#common-config') != 'undefined' && $('#common-config').length > 0) ? JSON.parse($('#common-config').html()) : null;			
				if(configInfo != null && configInfo.cookieDomain){
					cookieDomain=configInfo.cookieDomain;
				}
				$.each( self.list, function(type, typeShort) {
					var value, store;
					
					// Use shortname to keep the cookie small.
					store = Object.create(ND.cacheStore);
					store.key = "sp." + typeShort;
					store.expires = 365;
					if(cookieDomain){
						store.domain=cookieDomain;
					}

					// Cache locally so don't need to grab from the cookie later
					if( value = store.get() ) {
						self.cache[type] = value;
					}
					
					self.store[type] = store;
				});
				
				// When done, erase action
				self.prepare = $.noop;				
			},
			
			/*
			 * Listen to the PUBSUB channel for Shopping Prefenences
			 */
			listen: function() {
				var self = this;
				
				this.pubsub = {
					// Saving Data
					save: function(event, data) {
						data && self.setStoreData( data );
						
						//Broadcast change event (this is confirmed / complete data, as compared to the raw, possible incomplete data from ".save" )
						$.publish( self.prefix + "change", self.getStoreData() );
					},
					// Clear all
					clear: function(event, data) {
						self.clearStoreData();
						
						//Broadcast change event (this is confirmed / complete data, as compared to the raw, possible incomplete data from ".save" )
						$.publish( self.prefix + "change", self.getStoreData() );
					},
					// Retrieve
					retrieve: function(event, fn) {
						$.isFunction(fn) && fn.apply( null, [ event, self.getStoreData() ]);
					},
					//destroy, used by mobile, when changing page.
					destroy: function() {
						self.destroy();
					}
				};

				for( var channel in this.pubsub ) {
					$.subscribe( this.prefix + channel, this.pubsub[channel] );
				}
			},
			
			/*
			 * Get the shopping data
			 */
			getStoreData: function() {
				this.prepare();

				// Return a clone of the cache
				return $.extend( {}, this.cache );
			},
			
			/*
			 * Set the shopping data
			 */
			setStoreData: function( data ) {
				var self = this;
				
				self.prepare();
				
				// Manipulate the data for defaults
				data = this.checkDefaults( data );
				
				// Iterate the data and save it
				data && $.each( data, function(type, value) {
					
					if( type in self.list ) {
						
						// Store in the cookie
						self.store[type].set( value )
						
						// Cache locally so don't need to grab from the cookie later
						if( typeof value !== 'undefined' && String(value).length) {
							self.cache[type] = value;
						} else {							
							delete self.cache[type];
						}
					}
				});
			},
			
			/*
			 * Function to clear the data
			 */
			clearStoreData: function() {
				this.cache = {};
				
				$.each( this.store, function(type, store) {
					store.set();
				});
			},
			
			/*
			 * Function to insist on default values.
			 * Hot Deals, when postcode is provided, a usage is set as default.
			 */
			checkDefaults: function( data ) {
				if( data && data.postcode && !this.cache.usage && !data.usage ) {
					data.usage = 'p';
					data.usageLabel = 'Personal';
				}
				return data;
			},
			
			/*
			 * Function to upgrade the old postcode cookie into the new one.
			 * Can remove this sometime in the future after this has been live for a while.
			 */
			upgradeCookie: function() {
				var polkData, polkStore;
				
				polkStore = Object.create(ND.cacheStore);
				polkStore.key = 'price.usage';
				var configInfo = (typeof $('#common-config') != 'undefined' && $('#common-config').length > 0) ? JSON.parse($('#common-config').html()) : null;			
				if(configInfo != null && configInfo.cookieDomain){
					polkStore.domain=configInfo.cookieDomain;
				}
				
				if( polkData = polkStore.get() ) {
					// Upgrade the cookie
					$.publish( this.prefix + "save", polkData );	
					// Clear the old cookie
					polkStore.set();
				}
			},
			
			
			/*
			 * Cleanup method
			 */
			destroy: function() {
				for( channel in this.pubsub ) {
					$.unsubscribe( this.prefix + channel, this.pubsub[channel] );
				}
				this.cache = this.store = this.pubsub = this.prefix = this.list = null;
			}
			
		};
	
	
	/*
	 * Expose function that creates new shoppingPreferenceManager
	 * - ND.shoppingPreferenceManager 
	 */
	return function( arg ) {
		var manager = Object.create( shoppingPreferenceManager );
		manager.init.call( manager, arg );
		return manager;
	};
	
}(jQuery));


/**
 * @author: Sohrab Zabetian
 * @project hotdeals
 * @description: This file contains platform specific functions for hotdeals. Please refer to
 * 				 hotdeals.js for complete information.
 */
ND.platformDependentHotDeal = {
		
	regionObtainer : {	
		/**
		 * Display region link on the page. 
		 * @param model
		 */
		view : function( model ) {
			var existing = this._panel.find( '.hotdeals-postcode' ),
				// Create the HTML to be injected
				render = $.tmpl(this.tmpl, model );				
			//Either replace or inject
			if( existing.length ) {
				existing.replaceWith( render );
			} else {
				this._panel.append( render );
			}
			
		},
		
		bindAdditionalListeners: function() {},
		
		loadingStatus: function( working ) {
			
			var self = this;
			
			// Clear delay
			self._loaderTimeout && clearTimeout( self._loaderTimeout );
			
			// Delay the error
			self._loaderTimeout = setTimeout( function() {
				if( !self._form ) { return; }
				self.loader || ( self.loader = $('<span class="loader"/>').appendTo( self._form.find('.final') ) );
				self._form.toggleClass("loading", working );
				self._loaderTimeout = null;
			}, 100);
		}
	},
	
	hotDeal: {
		needPostcodeTemplate: function( selector ) {
			var hd = $(selector);
			return hd.length ? hd : null;
		}
	}
};


/*
 * hotdeals.js
 * Author: Glenn Baker
 */

/*globals window, document, jQuery, ND, SiteConf */
ND.hotDeals = (function($, undefined){
	
	var /* Generic Error string */
		genericError = "Oops! There was an internal problem",
		
		/* 
		 * Error codes for the JSON service
		 */
		errorCodes = {
			MISSING_POSTCODE: "MISSING_POSTCODE",
			INVALID_POSTCODE: "INVALID_POSTCODE",
			INCORRECT_POSTCODE: "INCORRECT_POSTCODE",
			SUCCESS: "SUCCESS"
		},
		
		/*
		 * Object: hotDeals
		 * 
		 * The Hot Deals manager, takes care of links and cookie considerations
		 */
		hotDeals = {

			/*
			 * Constructor of sorts
			 */
			init: function( options ) {
				// console.log('hotdeal.init()');
				options || ( options = {} );
			
				var self = this;
				self.enabledRedirect = true;
				
				//Required links for page
				self.elementsSelector = options.links || '.overlay-hotdeals, .force-overlay-hotdeals';
				self.elementPanelSelector = options.panel || '#hotdeals-panel';
				
				self.bindLinks();
				self.initPubsub();				
				self.render();
			},
			
			/*
			 * Listen to the PUBSUB channel for Shopping Prefenences
			 */
			initPubsub: function() {
				var self = this;
				
				this.pubsub = {
					change:function( event, data ) {
						data = data || {};
						self.postcode = data.postcode;
						self.region = data.region;
					}
				};
				
				// Get the current postcode right now.
				$.publish( "shopping.pref.retrieve", this.pubsub.change );

				// Register for the changes in the future
				$.subscribe( "shopping.pref.change", this.pubsub.change );
				
				$.subscribe( "shopping.pref.destroy", this.destroy );
			},
			
			/*
			 * Renders the tmpl
			 */
			render: function() {
				var hdPanel = needPostcodeTemplate( this.elementPanelSelector );
				if( hdPanel != null ) {
					this._template = Object.create( postcodeTemplate );
					this._template.conf = self.conf;
					this._template.init( hdPanel , this.getPostcode(), this.getRegion() );					
				}
				return this._template;
			},
			
			/*
			 * Function for getting the postcode
			 */
			getPostcode: function() {
				return this.postcode;
			},
			
			/*
			 * Function for getting the region
			 */
			getRegion: function() {
				return this.region;
			},
			
			/*
			 * Function for getting the Obtainer
			 */
			getObtainer: function() {
				return this._obtainer;
			},			
			
			/*
			 * Binds the overlay links
			 */
			bindLinks: function() {
				var self = this;
				
				$(document).on( "click", self.elementsSelector, function(e) {
					
					var region, postcode, 
						ignoreCookie = $(this).hasClass('force-overlay-hotdeals');

					//Possibly ignore the cookie.
					if( ignoreCookie ) {

						e.preventDefault();
						self.obtainRegion( this );
					
					//	Otherwise
					} else {
					
						e.preventDefault();
	
						region = self.getRegion();
						postcode = self.getPostcode();
	
						if( region || postcode ) {
							self.handleRegion( this, region, postcode );
						} else {
							self.obtainRegion( this );
						}
					}
				});
			},
			
			/*
			 * There is region in cookie, 
			 * But we still need to go and get the destination URL
			 */
			handleRegion: function( elem, region, postcode ) {
				var self = this,
					//"el.href" will return different result when href="", IE return location.host, FF return location.href;
					regionURL = this.ajaxRegionURL($(elem).attr("href") || location.href, region, postcode );

				$.when( regionURL )
					.done( function( data ) {
						
						/*
						 * Success
						 * { "region": "Region1", "regionName": "Melbourne", "regionId": "1248851195750", "url": "http://master2.ndprod.corp.nextdigital.com/en/hot-deals/victoria?sitetype=web&site=Master2", "cid": "1248851260705" } 
						 * Error
						 * { "errorCode": "INVALID_POSTCODE", "error": "There is no region for your postcode" }
						 */

						if( data ) {
						
							//Default value is success if there was no error.
							data.errorCode || ( data.errorCode = errorCodes.SUCCESS);

							if( data.errorCode === errorCodes.SUCCESS && data.region && data.url ) {
						
								// UC-01 7.1.5.	MAP POSTCODE TO REGION: Dragonfly maps the postcode value to obtain the corresponding region. The JavaScript-enabled browser will cache the postcode and set in cookie.
								
								// Confirmed Postcode and region gets set in cookie
								$.publish( "shopping.pref.save", {
									postcode: postcode,
									region: data.region,
									regionLabel: data.regionName
								});
							
								// Send user to region page
								self.doneRedirect( data.url || elem.href );
							
							} else if( data.errorCode === errorCodes.INVALID_POSTCODE )  {
								
								// UC-01 - 8.4 2. DISPLAY ERROR MESSAGE: Dragonfly displays error message advising end user that postcode chosen does not exist. End user stays on the current page being loaded.
								if (typeof self._template === 'undefined') { 
									//On home page, there is no template, hence if an invalid postcode is entered the code will break as
									//tries to find an element to display an error message on the page.
									//as a remedy, just redirect the user to national page and let them see the error message there.
									self.doneNational( elem );
								} else {
									self.doneCasualError(data.error );	
								}
								// Invalid postcode, let's remove it.
								$.publish( "shopping.pref.save", {
									postcode: undefined,
									region: undefined,
									regionLabel: undefined
								});
							
							} else {
								
								self.doneObtainerError( data.error || genericError );
							}

						} else {
							
							// Serious issue
							self.doneObtainerError( genericError );

						}
					
					})
					.fail( function() {
						self._obtainer.loadingStatus( false );					
						self.doneNational( elem );
					});
				
				//Return the promise
				return regionURL;
			},

			/* 
			 * Function to create the Region URL XHR object.
			 */
			ajaxRegionURL: function( destination, region, postcode ) {
				this.conf || ( this.conf = $("#hotdeals-data").embeddedData() );
				
				var params = {
					url: destination
				};
				
				if( postcode ) {
					params.postcode = postcode;
				}

				if( region ) {
					params.region = region;
				}
				
				var promise = $.ajax({
					url: this.conf['xhr-hotdeals-data'],
					dataType: 'json',
					cache: true,
					data: params
				});
								
				return promise;
			},
			
			/*
			 * Do what the link would normally do, but we already prevented the default behaviour.
			 */
			doneRedirect: function( href ) {
				//console.log('doneRedirect');
				if( window.location.href.indexOf( href ) < 0 ) {
					$.publish('hotdeals.redirect', {url: href});
					if( this.enabledRedirect ) {
						window.location.href = href;
					}
				} else {
					this.doneNoRedirect();
				}
			},	
			
			/*
			 *	There was a problem so error message.
			 */
			doneObtainerError: function( msg ) {
				$.publish('hotdeals.noredirect');
				if( this._obtainer ) {
					this._obtainer.loadingStatus( false );
					this._obtainer.formError( msg );
				}
			},
			
			doneNational: function(elem) {
				window.location.href =  $(elem).attr('href');
			},

			/*
			 *	There was a problem so error message.
			 */
			doneCasualError: function( msg ) {
				this.doneNoRedirect();
				this._template.setError( msg );
			},

			
			/*
			 * Function to cleanup if we are not redirecting
			 */
			doneNoRedirect: function() {
				//console.log('doneNoRedirect');
				$.publish('hotdeals.noredirect');
				if( this._obtainer ) {
					this._obtainer.destroy();
					delete this._obtainer;
				}
			},

			/*
			 * There was no region in cookie, 
			 * So let's ask the user to select from overlay
			 */
			obtainRegion: function( elem ) {
				
				var obtainer, self = this;
				
				/*
				if( self._obtainer ) {
					self._obtainer.destroy();					
				}
				*/

				obtainer = Object.create(regionObtainer);
				obtainer.conf = self.conf;
				obtainer.init( { 
					
					/*
					 * Successful form submit. That is all.
					 * Please note the overlay must still be open.
					 */
					formSubmit: function( postcode ) {
						
						//Handle the Result of the Overlay Form
						self.handleRegion( elem, false, postcode );
														
					},
					
					/*
					 * Overlay was cancelled
					 * 
					 */
					cancel: function() {
						if( $(elem).hasClass('force-overlay-hotdeals') ) {
							self.doneNoRedirect();
						} else {
							//UC-01 8.5.2: DISPLAY NATIONAL PAGE
							self.doneRedirect( elem.href );
						}
					}
					
				});				
				self._obtainer = obtainer;
			},
		
			/*
			 * Cleanup method
			 */
			destroy: function() {
				//console.log('ND.hotDeal.destroy');
				if( this._obtainer ) {
					this._obtainer.destroy();
					delete this._obtainer;
				}
				if( this._template ) {
					this._template.destroy();
					delete this._template;
				}
				
				$(document).off("click", this.elementsSelector);
				for( channel in this.pubsub ) {
					$.unsubscribe( "shopping.pref." + channel, this.pubsub[channel] );
				}
				this.pubsub = this.conf = this._template = this._obtainer = null;
			}
			
		},
		
		
		/*
		 * Object: regionObtainer
		 * 
		 * Region Obtainer. Takes it to the next level, launching the overlay and 
		 * Rendering the form
		 */
		regionObtainer = {

			/*
			 * Constructor of sorts
			 */
			init: function( options ) {
				var self = this;
				
				this._guid = +new Date();
				
				this.options = options;
				this.formSelector = options.formSelector || '#hotDeals-form';
				this.conf || ( this.conf = $("#hotdeals-data").embeddedData() );
				
				if( this.conf['xhr-hotdeals-form'] ) {
					
					//Launch overlay
					$.publish('overlay.launch', {
						url: this.conf['xhr-hotdeals-form'],
						positionType: 'window',
						name: "Hot Deals Select Region",
						//type: 'overlay-hotdeals',
						success: function() {
							self._form = $(self.formSelector);
							if( self._form.size() ) {
								self.ready();
							} else {
								self.error();
							}
						}
					});					
				}
			},
			
			/*
			 * Ready to take postcode orders!
			 * I.e the Overlay is readu
			 */
			ready: function() {
				this.bindError();
				this.bindSubmit();
				this.bindAdditionalListeners.call(this);
				this.bindCancel();
				this.loadingStatus( false );
				this.setFocus();
				$.publish('hotdeals.obtainerReady');
			},
			
			/*
			 * Obtainer to go away quietly.
			 */
			done: function() {
				// Check if the overlay is still open based on the form exist.
				if( $( this.formSelector ).length ) {
					$.publish('overlay.hide');
				}
			},
			
			setFocus: function() {
				this._form.find('input[type="text"]').first().select();
			},
			
			/*
			 *	Bind to the overlay hotdeals form submit
			 */
			bindSubmit: function() {
				var self = this;
				//console.log('hotdeals.bindSubmit()');
				
				
				$(document).off('submit', '#hotDeals-form').on('submit', '#hotDeals-form', function( e ) {
					
					e.preventDefault();					
					//console.log('hotdeal->submit');
					var form = self._form;
					
				 	//grab local 
					var $postcodeField = form.find('[name=postcode]');
					var postcode = $postcodeField.val();
					
					//Validate Form
					if( $.trim( postcode ).length === 4 && !isNaN(postcode) ) {
						//prevent multi submission
						
						self.loadingStatus( true );
						self.formSuccess( postcode );
						//clear the fields for next round
						$postcodeField.val('');
					} else {
						self.formError();
					}
					return false;
				});
				
				
				$(document).on('keydown', '#hotDeals-form #postcode', function( e ) {
					
					self._errorMsg.slideUp('fast');
				});
				
			},
			
			bindAdditionalListeners: ND.platformDependentHotDeal.regionObtainer.bindAdditionalListeners,
			
			/*
			 *	Bind to the cancel of the overlay
			 */			
			bindCancel: function() {
				this.loadingStatus( false );		
				if( this.options.cancel ) {
					$.subscribeOnce('overlay.usercancel', this.options.cancel );
				}
			},
			
			/*
			 * Bind for error
			 */
			bindError: function() {
				
				var self = this;
				self.loadingStatus( false );		
				this._errorMsg =  this._form.find('.error');
				this.standardError =  this._form.find('#standard-error').text();

				$(document).on('keydown', '#hotDeals-form #postcode', function( e ) {
					self._errorMsg.slideUp('fast');
				});
			},
			
			/*
			 * Function helper for the loading status
			 */
			loadingStatus: ND.platformDependentHotDeal.regionObtainer.loadingStatus,
			
			/*
			 * Form success
			 * - Overlay does not get closed.
			 */
			formSuccess: function( postcode ) {
				this.loadingStatus( false );		
				this.options.formSubmit.call( null, postcode );
			},
			
			/*
			 * Form error
			 */
			formError: function( msg ) {
				this.loadingStatus( false );		
				this._errorMsg
					.text( msg || this.standardError )
					.slideDown('fast');
			},
			
			/*
			 * An error
			 */
			error: function() {
				//console.log("Error: regionObtainer");
			},
			
			/*
			 * Cleanup method
			 */
			destroy: function() {
				this.done();
				$(document)
					.off('submit', '#hotDeals-form')
					.off('click', '#hotDeals-form .hotDeals-form-currentLocation')
					.off('keydown', '#hotDeals-form #postcode');				
				$.unsubscribe('overlay.usercancel', this.options.cancel );
				this._form = this.conf = null;
			}
		},
		
		
		/*
		 * Helper function to see if the postcodeTemplate object is neccessary
		 */
		needPostcodeTemplate = ND.platformDependentHotDeal.hotDeal.needPostcodeTemplate,		
		
		/*
		 * Object: postcodeTemplate
		 * 
		 * The HTML view for the postcode
		 */
		//TODO..   $.extends( Object.create( hotDealsAbstract ), {
		postcodeTemplate = {
			
			/*
			 * Constructor of sorts
			 */
			init: function( panel, postcode, region) {
				this._panel = panel;
				this._postcode = postcode;
				this._region = region;				
				
				this.conf || ( this.conf = $("#hotdeals-data").embeddedData() );
				
				//Compile main template
				this.tmpl = $('#tmpl-hotdeals-links').template();
				
				this.updatePostCode();
				
				this.subscribing();
				
				this.controller();
			},
			
			/*
			 * Listen to the PUBSUB channel for Shopping Prefenences
			 */
			subscribing: function() {
				var self = this;
				
				this.pubsub = {
					change:function( event, data ) {
						data = data || {};
						self._postcode = data.postcode;
						self._region = data.region;
						self.controller();
					}
				};

				// Register for the changes in the future
				$.subscribe( "shopping.pref.change", this.pubsub.change );
			},
			
			/*
			* Update postcode in the contents
			*/
			updatePostCode: function() {
				if(this._postcode){
					$(".user-selected-postcode").text(" " + this._postcode);
				}else{
					$(".user-selected-postcode-msg").hide();
				}
			},
			
			/*
			 * Control the render;
			 */
			controller: function() {
				
				this.view( 
					this.model( 
						this.useError()
					) 
				);
				
			},	
			
			/*
			 * The data for the tmpl
			 */
			model: function( error ) {
				var model =  {};
				
				// Current postcode
				model.postcode = this._postcode;
				
				// Is page region is different to the region in cookie
				model.wrongPostcode = ( this._postcode && this.getPageRegion() && this._region !== this.getPageRegion() );
				
				// The error (is a string or false)
				model.error = error;
				
				return model;
			},
			
			/*
			 * Render the view
			 */
			view: ND.platformDependentHotDeal.regionObtainer.view,
			
			/*
			 * Returns the region for the current page
			 */
			getPageRegion: function() {
				return this.conf["page-region"];
			},
			
			/*
			 *  Set's the error for templating
			 */
			setError: function( error ) {
				this._error = error;
			},
			
			/*
			 * Use the error once
			 */
			useError: function() {
				var err = $.type( this._error ) === 'string' ? this._error : false;
					
				//reset the error once used
				delete this._error; 

				return err;
			},
			
			/*
			 * Cleanup method
			 */
			destroy: function() {
				$.unsubscribe( "shopping.pref.change", this.pubsub.change );
			}			
		};
		 
	/*
	 * Expose function that creates new hotDeals
	 * - ND.hotDeals 
	 */
	return function( arg ) {
		var manager = Object.create( hotDeals );
		manager.init.call( manager, arg );
		return manager;
	};
	
}(jQuery));


/*
 * SYNC.js
 * Author:gbaker 11/05/2011 
 */

/*globals window, document, jQuery, ND, SiteConf */
ND.syncVersionManager = (function($, undefined){
	
		/*
		 * Store the templates
		 */
	var HTML = {
			series: '<option class="syncinj" value="%INDEX%">%MAKENAME% %MODELNAME%</option>',
			year: '<option class="syncinj" value="%INDEX%">%YEAR%</option>',
			interior: ['<div class="syncinj row">',
							'<input type="radio" name="SteeringWheel" id="SteeringWheel%INDEX%" value="%INDEX%"/>', 
							'<label for="SteeringWheel%INDEX%">',
								'<span class="iconshow"><img src="%IMAGE%" alt="SteeringWheel%INDEX%" width="130" height="68" /></span>', 
								'<span class="info">%DESCRIPTION%</span>',
							'</label>',
						'</div>'].join('')
				
		},
	
		
		/*
		 * Simple Template Helper Function
		 */
		simpleTemplate = function( name, data ) {
			return HTML[name].replace( /%([A-Z]*?)%/g, function(m, g) {
			    return data[g.toLowerCase()];
			});
		},

		/*
		 * Object: syncVersionManager
		 * 
		 * SYNC Version Manager.
		 * Adds all logic to click events of A.overlay-sync
		 */
		syncVersionManager = {
			
			/*
			 * Startup
			 */
			
			init: function( elements, prefix ) {

				var self = this;
				
				

				//Required links for page
				
				self.elementsSelector = elements || '.overlay-sync, .force-overlay-sync';
				self.elements = $(elements || '.overlay-sync, .force-overlay-sync');
		
		        $wait(function(){
				
				if($("A.overlay-sync").length > 0){
					
					
					$("A.overlay-sync").css({ "visibility": "visible" });
				}
				
				self.addsyncbackground();
				
				
				self.chooseSiteVersion();
					
				})
				
			},
			chooseSiteVersion:function(){
				
				var self = this,
					syncData = $("#sync-data").embeddedData();
					
				
				if( syncData['xhr-sync-flag']=="sync5" ) {
					
				
				self.savecookie();
				self.synclinksguide();
				self.forceoverlaysync();
				
					
				}else{
					
					//Readyness
				self.createStores();
				self.bindLinks();				
				self.readyVehicleChanges();
				
				//Check for vehicle (onload)
				self.checkForVehicle();
					
				}
			}
			,
			addsyncbackground:function(){
				
				$("body.sync_generic").parent().addClass("sync_generic");
			}
			,
			setsync5versionCookie: function(value){
				////SYNC5
				$.cookie("sync5version",value);
				
			}
			,
			getsync5versionCookie:function(){
				////SYNC5
				return $.cookie("sync5version");
			},
			savecookie:function(){
				////SYNC5
				var self = this;
				
				var params = $.deparam.querystring( window.location.href );
				var vs= params.v;
				
				if(vs !==undefined){
				self.setsync5versionCookie(vs);
				}
				
			}
			,
			forceoverlaysync:function(){
				////SYNC5
				var self = this;
				$("A.force-overlay-sync").bind("click",function(e){
					 e.preventDefault();
					 self.popoverlay();	
				})
			}
			,
			synclinksguide:function(){
				////SYNC5
				var self = this;
				
				
				
				$(".overlay-sync").click(function( e ){
					
					
					var currentahref=$(this).attr("href");
					var params = $.deparam.querystring(currentahref);
				    var vsi= params.v;
				  
				    if($(this).hasClass("sync4")){
				    	
				    	e.preventDefault();	
				    	self.obtainVersion( this );
				    }else{
				    
				    if(vsi===undefined){
				    
				   
				    	
				    if(self.getsync5versionCookie() !=null){
					
					    
					    var currenthref;
					    
					    if(currentahref.indexOf("?") === -1){
					    
					    currenthref=currentahref+"?v="+	self.getsync5versionCookie();
					    
					    }else{
					    	
					     currenthref=currentahref+"&v="+	self.getsync5versionCookie();
					    }
					   
					    e.preventDefault();	
					    e.stopPropagation();
					    window.location.href = currenthref;
					    
					    
				     }else{
				    
					//Lanch overlay
					e.preventDefault();	
					e.stopPropagation();
				    self.popoverlay();
					//track sync5
				    if(!$(this).hasClass("trackable")){
				    	self.track(this);	
				    	}
				     }
				    	
				    	
				    }
				    }
				    
				})
			},
			track:function(){
				//sync5 omniture
			     $.publish('/analytics/link/', { 
						title: "sync:change sync version",
						link: this,
						type: "o",
						onclicks: "change sync version"
					});
				 // 
			},
			popoverlay: function( ) {

				var self = this,
			
				
					syncData = $("#sync-data").embeddedData();
					
				
				if( syncData['xhr-sync-overlay'] ) {
					
					//Launch overlay
					
					$.publish('overlay.launch', {
						url: syncData['xhr-sync-overlay'],
						type:"syncoverlay5",
						positionType:'window'
						
						
					});					
					
					
				}
				
				
		
			}
			
			/*
			 * Create cookie stores
			 */
			,
			createStores: function() {
				
				var props = {};
				//Cookies
				$.each( ['Version', 'Vehicle'], function(i, name) {

					var store = Object.create(ND.cacheStore);
						store.key = "dfy.sync." + name;
						store.expires = 365;
					
					//Getter
					props[ 'get' + name ] = function ( ){
						return store.get();				
					};
					
					//Setter
					props[ 'set' + name ] = function ( value ){
						store.set( value );
					};

				});
				$.extend( this, props );				
			},
			
			/*
			 * Action taken if there is a valid version
			 */
			handleVersion: function( elem, version, canCancelForward,stopIT) {
				
				var forward = true;
				
				//Check existing version if allowed
				if( canCancelForward ) {
					//Possible cancel the forwarding
					//if they hit the back button, their cookie and their current page will not match. So must check current page.
					
					forward = this.getHrefVersion() !== version;
				}
				if(stopIT){
					
					forward=false;
					
				}
				//Save Result
				this.setVersion( version );

				//Forward URL
				if( forward ) {
					var href = elem.href;
					if(/.+[?&]v=.+/.test(href)){
						href = href.replace(/v=[^&#]+/g, "v=" + version );
					}else{
						href = href + (href.indexOf( "?" ) === -1 ?  "?" : "&") + "v=" + version;
					}
					window.location = href;
				}
			},
			
			/*
			 * Do Nothing other than Broadcast vehicle change
			 */
			handleVehicle: function( vehicle ) {
				//Save Result
				this.setVehicle( vehicle );
				//Broadcast
				$.publish("sync-applicable-vehicle", { vehicle: vehicle });
			},
			
			/*
			 * highlight the vehicle
			 */
			readyVehicleChanges: function( elem, vehicle ) { 
			
				var list = $("#sync-changevehicle li");
				var imagesList = $("#vehicleImags img");
				if( list.size() ) {				
					$.subscribe("sync-applicable-vehicle", function(event, data) {
						list
							.removeClass('current')
							.filter( function() {
								return this.id === data.vehicle;
							})
							.addClass('current')
							.prependTo("#sync-changevehicle");
						
						imagesList
							.filter(function() {
								return this.title == data.vehicle;	
							})
							.show()
							.siblings().hide();
					});
				}
			},
			
			/*
			 * Check for Vehicle now.
			 */
			checkForVehicle: function() {
				
				var vehicle = this.getVehicle();
				if( vehicle )	{
					this.handleVehicle( vehicle );
				}
			},
			
			/*
			 * Test href for v parameter
			 * Function depends on jquery.bbq
			 */
			testHref: function( href ) {
				return !!this.getHrefVersion( href );				
			},
			
			/*
			 * Get parameter from href
			 * Function depends on jquery.bbq
			 */
			getHrefVersion: function( href ) {
				var params = $.deparam.querystring( href );
				return params.v;				
			},
			
			/*
			 * Bind click events to A.overlay-sync 
			 */
			bindLinks: function() {
				var self = this;
				
				self.elements.click(function( e ){
					
					var ignoreCookie = $(this).hasClass('force-overlay-sync');
					var ischangev=$(this).hasClass('changevehicle');

						//Possibly ignore the cookie. //change here
					if( ignoreCookie ) {

						e.preventDefault();
						self.obtainVersion( this, true );
						
						
						//Test if V is already in the URL and ignore A.overlay-sync if such is the case.
					} else if( !self.testHref( this.href ) ) { 
						e.preventDefault();
						var version = self.getVersion( this );

						if( version ) {
							
							if(ischangev){
								
								self.handleVersion( this, version,false,true);
								
							}else{
								
								self.handleVersion( this, version);
								
							}
							
						} else {
							self.obtainVersion( this );
							//track sync4
							if(!$(this).hasClass("trackable")){
							self.track( this );
							}
						}
					}				
				});				
			},
			
			
			/*
			 * There was no version in cookie, 
			 * So let's ask the user to select from IOP.
			 */
			obtainVersion: function( elem, checkFowarding ) {
				var self = this;
				
				self.obtainer = Object.create(versionObtainer);
				self.obtainer.init( function( version, vehicle ) {
					
					//Handle Result
					self.handleVersion( elem, version, checkFowarding );
					self.handleVehicle( vehicle );
					
					//Delete Obtainer
					self.obtainer.destroy();
					delete self.obtainer;
					
				});
			}
			
			
			
		},
	
		/*
		 * Object: versionObtainer
		 * 
		 * Version Obtainer. Takes it to the next level, launching the overlay and 
		 * Rendering the FORM of IOP data. 
		 */
		versionObtainer = {
		
			/*
			 * Object Startup. Launches the overlay
			 */
			init: function( success ) {
		
				var self = this,
					syncData = $("#sync-data").embeddedData();
				
				if( syncData['xhr-sync-overlay'] ) {
					
					//Launch overlay
					$.publish('overlay.launch', {
						
						url: syncData['xhr-sync-overlay'],
						positionType:'window',
						name: "Sync Select Vehicle",
						type: 'overlay-sync',
						success: function() {
							self.form = $("#selectVehicle");
							if( self.form.size() ) {
								self.getData( syncData );
							} else {
								self.error();
							}
						}
					});					
					
				}
				
				self.success = success;
		
			},
			
			/*
			 * Destroy
			 */
			destroy: function() {
				this.interior.undelegate('INPUT', 'change'); 
			},
			
			/*
			 * Submit event button
			 */
			bindSubmit: function() {
				
				
				var self = this;
				self.submit.click(function( e ) {

					e.preventDefault();
					
					//Broadcast change on click.
					$.publish("sync.versionchange", {
						version: self.targetVersion
						
					});
					
					//Hide overlay.
					$.publish("overlay.hide");
					
					
					if( self.success ) {
						self.success( self.targetVersion, self.vehicleGuid );
					}
					
				});
			},
			
			/*
			 * Store cache ref to all the required elements
			 */
			cacheElements: function() {
				var self = this,
					form = self.form;
				
				//The Form Elements
				self.series = form.find('#sync-model');
				self.year = form.find('#sync-vehicle-year');
				self.interior = form.find('#sync-interior');
				
				//The Form Element Rows
				self.seriesRow = self.series.closest('.row');
				self.yearRow = self.year.closest('.row');
				self.interiorRow = self.interior.closest('.row');
				
				//All rows
				self.rows = $(self.seriesRow).add(self.yearRow).add(self.interiorRow).hide(0);
				
				//Submit
				self.buttons = form.find(".buttons").hide(0);
				self.submit = self.buttons.find(".vehicle-select");
				
			},
			
			/*
			 * Shows the button
			 */
			enableSubmit: function( sync ) {
				this.targetVersion = sync.dragonflySyncId;
				this.vehicleGuid = sync.guid;
				this.buttons.show(0);
			},
			
			/*
			 * Hides the button
			 */
			disableSubmit: function( version) {
				delete this.targetVersion;
				delete this.vehicleGuid;
				this.buttons.hide(0);
			},

			/*
			 * Get the data required for finding the SYNC version
			 */
			getData: function( syncData ) {
				
				var self = this;
				
				$.ajax({
					type: "get",
					dataType: "json",
					async: true,
					cache: false,
					url: syncData['xhr-sync-overlay-data'],
					success:function(data){
						self.cacheElements();
						self.bindFields();
						if (data && data.list && data.list.length > 0) {
							self.processMakesRenderSeries( data.list );
						} else {
							self.error();
						}
					},
					error:function (request, error) {
						self.error();
					}
				});
				
			},
			
			/*
			 * Clear field values
			 */
			resetValues: function( arr ) {
				var self = this;
				
				self.disableSubmit();
				
				$.each( arr, function( index, value ) {
					self[value].find('.syncinj').remove();
					self[value+'Row'].hide(0);
				});
			},
			
			/*
			 * Bind Events, once I might add.
			 */
			bindFields: function() {
				var self = this;
				
				self.series.change(function() {
					self.processSeriesRenderYears( );
				});

				self.year.change(function() {
					self.processYearRenderInterior();
				});

				self.interior.delegate('INPUT', 'change' ,function() {
					self.processInterior();
				});
				
				self.bindSubmit();				
			},
			
			/*
			 * Make Children Values = Series
			 */
			processMakesRenderSeries: function( makes ) {
				
				var self = this;
				
				if( !makes && !makes.length ) { 
					return self.error();
				}
				
				self.makes = makes;
				
				$.each( makes, function(i, make){
				
					var many = make.vehicleModels.length >= 1;
					if( many ) {
	
						self.series.find('.syncinj').remove();
						
						$.each( make.vehicleModels, function(index, vehicleModel){
							
							var seriesDom = $( simpleTemplate('series', {
												index: index,
												makename: make.name,
												modelname: vehicleModel.name
											}));
							
							
							
							seriesDom.data('vehicleModel', vehicleModel);

							self.series.append(seriesDom)
							
						});
						
						self.seriesRow.show(0);
						if (make.vehicleModels.length == 1){
							self.series.find('option').get(1).selected=true;
						}
						self.series.trigger('change');
					
					} else {
						//Skip years and interiors
						self.enableSubmit( make.vehicleModels[0].availableSyncYears[0].syncConnectionSystems[0] );
						
					}
					
				});				
				
			},
			
			/*
			 * Series Children Values === Years
			 */
			processSeriesRenderYears: function() {
				
				var self = this,
					seriesOption = self.series.find(":selected"),
					vehicleModel = seriesOption ? seriesOption.data('vehicleModel') : 0,
					many;
					
				self.resetValues( ['year', 'interior'] );

				if( !vehicleModel ) { return; }
				
				many = vehicleModel.availableSyncYears.length >= 1;

				if( many ) {
					$.each( vehicleModel.availableSyncYears, function(index, year) {
						
						var yearOptionElement = $( simpleTemplate('year', {
													index:index,
													year:year.year
												}));
						
						yearOptionElement.data('year', year);

						self.year.append(yearOptionElement)
						
					});
					
					self.yearRow.show(0);
					if (vehicleModel.availableSyncYears.length == 1){
						self.year.find('option').get(1).selected=true;
					}
					self.year.trigger('change');
				
				} else {
					//Skip interiors
					self.enableSubmit( series.availableSyncYears[0].syncConnectionSystems[0] );
				}
				
				
			},
			
			/*
			 * Year Children Values === Sync Interiors
			 */
			processYearRenderInterior: function() {
				
				var self = this,
					yearOption = self.year.find(":selected"),
					year = yearOption ? yearOption.data('year') : 0,
					many;
					
				self.resetValues( ['interior'] );

				if( !year ) { return; }
				
				many = year.syncConnectionSystems.length >= 1;
				
				if( many ) {
					
					$.each( year.syncConnectionSystems, function(index, sync) {
						
						var syncOptionElement =  $( simpleTemplate('interior', {
														index:index,
														description: sync.syncDescription,
														image:sync.image
													})); 
							
						syncOptionElement.find('INPUT').eq(0).data('sync', sync);

						self.interior.append(syncOptionElement)
						
					});
					
					self.interiorRow.show(0);
					if (year.syncConnectionSystems.length == 1){
						self.interior.find('input').get(0).checked=true;
						self.enableSubmit( year.syncConnectionSystems[0] );
					}
					self.interior.trigger('change');
				
				} else {
					
					self.enableSubmit( year.syncConnectionSystems[0] );

				}
	
				
			},
			
			/*
			 * Interior Values
			 */
			processInterior: function( ) {
				
				var self = this,
					syncOption = self.interior.find("INPUT:checked"),
					sync = syncOption ? syncOption.data('sync') : 0;
					
				if( !sync ) { return; }
				
				self.enableSubmit( sync );
				
			},
			
			/*
			 * Overlay Error
			 */
			error: function() {
				this.form.find('.error').show(0);
			}
			
		};
	
	/*
	 * Expose function that creates new syncVersionManager
	 * - ND.syncVersionManager 
	 */
	return function( arg ) {
		var manager = Object.create( syncVersionManager );
		manager.init.call( manager, arg );
		return manager;
	};
	
}(jQuery));


/*
 * Author: Ruiwen Qin
 * This is fullscreen overlay plugin. By triggering this plugin, simply add 'fullscreen-overlay' class onto the element.
 *
 *Instructions:
 *1. load overlay through url
 *<a href='overlay.html' class='fullscreen-overlay'/>
 *$('.fullscreen-overlay').fullScreenOverlay({... });
 *
 *2. load overlay use customize content
 *<a href='#' class='fullscreen-overlay'/>
 *$('.fullscreen-overlay').fullScreenOverlay({
 *   useCustomizeContent: true,
 *   customizedContent: "<span class='loading'></span>"
 *});
 *
 *
 */

(function($) {
	
	$.fn.fullScreenOverlay = function(options){
		var defaults = {
			overlayId: "fullscreen-overlay",
			openOverlay: false,
			close: 'CLOSE',
			backtotop: 'BACK TO TOP',
			complete: null, //callback function
			useCustomizeContent: false,   // if set as true, will load the customized content
			customizedContent: null     //customizedContent will be loaded to contentbody when useCustomizeContent=true
		};
		
		var options = $.extend(defaults, options);
		
		var fullOverlay = function(element){
			var fulloverlay = this,
				url,
				cid,
				overlayContainer,
				overlayContent,
				currentPosition,
				state = {},
				scrolltop;

			// retrieve the texts for controls
			if ($("#overlay-controls").length > 0){
				var controlTexts = $("#overlay-controls").embeddedData();
				if (!$.isEmptyObject(controlTexts)){
					options.close = controlTexts.close;
					options.backtotop = controlTexts.backtotop;
				}
			}
			
			fulloverlay.init = function () {
				url = element.attr("href");
				cid = url.match(/cid=\d+/);
				
				if (Modernizr.history){
					var index = window.location.toString().indexOf(options.overlayId);
					if (index < 0){
						history.pushState(null,options.overlayId,location+"#"+options.overlayId+"="+cid);
					}
					
				}
				else {
					if (cid){
						state[options.overlayId] = cid.toString();
						$.bbq.pushState(state);
					}
					
				}
				
				fulloverlay.injectContainer();
				fulloverlay.injectControls();
				fulloverlay.loadContent();
				
			};
			
			fulloverlay.injectContainer = function(){
				var markup = '<div class="overlay-wrap"><span class="loader"></span></div>';
				$("body").addClass("noscroll");
				$("body").append(markup); 
				overlayContainer = $(".overlay-wrap");

				/* For fixing scroll issue on mobile - ios */
				/* Disable body scroll */
				$("body").on('touchmove',function(e){
					if($(this).hasClass("noscroll")){
						e.preventDefault();
					}
				});
				/* Allow overlay scroll */
				overlayContainer.on('touchmove', function(e){
					e.stopPropagation();
				});
				/** **/
				
			};
			
			fulloverlay.injectControls = function(){
				var markup = {
					topCloseBtn: function () {
						return '<div class="top-close"><a class="close" href="#"><span>' + options.close + '</span></a></div>';
					},
					bottomControls: function () {
						return '<div class="controls"><a href="#" class="backToTop">' + options.backtotop + '</a><a href="#" class="close">' + options.close + '</a></div>';
					}
				};
				
				overlayContent = $('<div class="overlay-content"></div>').hide();
				overlayContent.prepend($(markup.topCloseBtn()));
				$(".top-close", overlayContent).after($('<div class="content"></div>'));
				overlayContent.append(markup.bottomControls());

				overlayContentBody = $(".content", overlayContent);
				
			};
			
			fulloverlay.loadContent = function () {

                //load customized content
			    if (options.useCustomizeContent) {
			        fulloverlay.injectContent(options.customizedContent);
			    }
                //load content from url
			    else {
			        $.ajax({
			            url: url,
			            success: function (data) {
			                fulloverlay.injectContent(data);
			            },
			            error: function () {
			                fulloverlay.loadError();
			            }
			        });
			    }
			};
			
			fulloverlay.injectContent = function(data){
			
				overlayContainer.imagesLoaded(function(){
					overlayContentBody.html(data);
				});
				
				overlayContainer.html(overlayContent);
				overlayContent.show();
				
				fulloverlay.eventsRegister();

				if (Modernizr.touch) {
				    var topControlHeight = $(".top-close", overlayContent).outerHeight();
				    var bodyHeight = $(".content", overlayContent).outerHeight();
				    var bottomControlHeight = $(".controls", overlayContent).outerHeight();
				    overlayContent.css("height", topControlHeight + bodyHeight + bottomControlHeight + 80 + 'px');
				}
				
			};
			
			fulloverlay.eventsRegister = function(){

				overlayContainer.on("click", function(){
					fulloverlay.unloadOverlay();
				}).children().on("click", function(e){
					e.stopPropagation();
					// e.preventDefault();
					// return false;
				});



				$(".close",overlayContainer).on("click", function(e){
					fulloverlay.unloadOverlay();
					e.preventDefault();
					return false;
				});

				$(".backToTop",overlayContainer).on("click", function(e){
					overlayContainer.animate({
						scrollTop: 0
					});
					e.preventDefault();
					return false;
				});

				// callback 
				if ($.isFunction(options.complete)){
					options.complete.call(this);
				}

				/* Overlay banner - hotspots/video/slider */
				if ($(".banner", overlayContainer).length > 0){
					var id = $(".banner", overlayContainer).attr("id");
					
					switch (id){
						case "hotspots":
							fulloverlay.hotspots()
							break;
						case "video":
							fulloverlay.video()
							break;
						case "slider":
							fulloverlay.slider()
							break;
					}

				}
				
			};
			
			fulloverlay.unloadOverlay = function(){
			    if (typeof jwplayer != "undefined" && $(".banner", overlayContainer).attr("id") === "video") {
					jwplayer().stop(); 
				}

				

				$("body").removeClass("noscroll");
				overlayContainer.fadeOut('800');
				overlayContainer.remove();

				if (Modernizr.history){

					history.replaceState(null,options.overlayId,"");
					history.back();
				}
				else {
					window.location.hash = 'nooverlay';
					$.bbq.removeState(options.overlayId);
				}

			};

			fulloverlay.removeOverlay = function(){
				overlayContainer.remove();
				$("body").removeClass("noscroll");
				$.bbq.removeState(options.overlayId);
			};
			
			fulloverlay.loadError = function(){
				
				overlayContainer = $(".overlay-wrap");
				overlayContainer.html(markup.clone());
				$("body").addClass("noscroll");
				fulloverlay.eventsRegister();
			};

			/* Bind banner contents events */
			fulloverlay.hotspots = function(){
				var spots = $(".hotspots", overlayContainer),
					data = $("#hotspots-data").embeddedData();

					$("#hotspots-template").tmpl(data).appendTo(spots);
					var spot = $(".spot .outer",spots);
					
					spot.hover(function(){
						var that = $(this),
							container = that.parent(),
							detail = that.next(".detail");
						container.siblings().removeClass("active");
						container.toggleClass("active");
						
					});

				
			};

			/* Banner video */
			fulloverlay.video = function(){
				var videoConfig = $(".banner .video-config",overlayContainer).embeddedData();
				ND.video.init(videoConfig);
			};

			/* Banner slider */
			fulloverlay.slider = function(){
				
				var slider = $(".banner-slider",overlayContainer);
				slider.bxSlider({
					mode: 'fade'
				});
				
				/* bind image carousal to careers overlay*/
				if($("body").hasClass("careers")){
					ND.rotatingBanner(".careers .overlay-wrap .bxslider",{
						controls: false,
						auto: true,
						pause : 6000,
						autoHover : true
					});
				}
			};

			
		};

		
		
		var appendOverlay = function(element){
		    var overlay = new fullOverlay(element);		    
		    overlay.init();
		};
		
		this.click(function(e){
			if (e.which == 1 || e.which == 0){
				appendOverlay($(this));
				e.preventDefault();
			}
			
			return false;
		});

		

	};
	

}(jQuery));


/*
 * Author: Ruiwen Qin
 * 
 * This is used on tech section landing page. ISOTOPE plugin is triggered at init stage.
 * 
 * 
 */

(function($) {
	
	//The create function creates the module object; It does no initialise the object
	techTiles = function () {
		var $container = $("#tiles"),
			sectionWidth = $container.width(),
			filterNav = $("#filter"),
			filterNavHeight = filterNav.height(),
			items = $(".element", $container),
			topHeight = $(".tech-section").offset().top - 15,
			exploreBtn = $(".tech-heading .btn");

	
		return {

			
			init: function( elem ) { 
				
				element = $(elem || ".tech-section");
					
				if( !element || !element.size() ) { return this; }

			
				techTiles().IsoGutterRewrite();

				// setup Isotop layout
				$container.isotope({
					itemSelector: '.element',
					transformsEnabled:false,
					masonry: {
						columnWidth:310,
						gutterWidth:15
					}
				});

				// filter
				$('#filter a').click(function(e){
					e.preventDefault();
					var that = $(this),
						parentElem = that.parent("li");

					if (parentElem.hasClass("active")){
						return;
					}
					else {
						$("#filter li").removeClass("active");
						parentElem.addClass("active");
					}

					var selector = that.attr('data-filter');
					$container.isotope({
						filter:selector
					}, function(){
						$("html, body").animate({
							scrollTop: topHeight
						});
						
					});
					
					
					return false;
				});

				$(window).scroll(function(){
					if ($(window).scrollTop() > topHeight){
						filterNav.addClass("sticky");
						filterNav.css({width:sectionWidth});
						$container.css({marginTop:filterNavHeight});
					}
					else {
						filterNav.removeClass("sticky");
						filterNav.css({width:'100%'});
						$container.css({marginTop:0});
					}
				});

				exploreBtn.click(function(){
					
					$("html, body").animate({
						scrollTop: topHeight
					});
					return false;
				});
				
				
				// tiles hover animation
				if (!Modernizr.touch){
					items.hover(function(){
						var overlay = $(this).find(".overlay"),
							image = $(this).find("img");
						
						overlay.stop().animate({
							top: 0
						});
						image.stop().animate({
							marginTop: '-20px'
						});
					}, function(){
						var overlay = $(this).find(".overlay"),
							image = $(this).find("img");
						
						overlay.stop().animate({
							top: '-100%'
						});
						image.stop().animate({
							marginTop: '0px'
						});
					});
					
					
				}
				
				

					
				return this;
			
			},

			IsoGutterRewrite: function(){
				// modified Isotope methods for gutters in masonry
				$.Isotope.prototype._getMasonryGutterColumns = function() {
				    var gutter = this.options.masonry && this.options.masonry.gutterWidth || 0;
				    containerWidth = this.element.width();

				    this.masonry.columnWidth = this.options.masonry && this.options.masonry.columnWidth ||
				    // or use the size of the first item
				    this.$filteredAtoms.outerWidth(true) ||
				    // if there's no items, use size of container
				    containerWidth;

				    this.masonry.columnWidth += gutter;

				    this.masonry.cols = Math.floor((containerWidth + gutter) / this.masonry.columnWidth);
				    this.masonry.cols = Math.max(this.masonry.cols, 1);
				};

				$.Isotope.prototype._masonryReset = function() {
				    // layout-specific props
				    this.masonry = {};
				    // FIXME shouldn't have to call this again
				    this._getMasonryGutterColumns();
				    var i = this.masonry.cols;
				    this.masonry.colYs = [];
				    while (i--) {
				        this.masonry.colYs.push(0);
				    }
				};

				$.Isotope.prototype._positionAbs = function( x, y ) {
					if ( $('BODY').hasClass('rtl') )
					{
						return{right: x, top: y}
					}
					else
					{
						return{left:x,top:y}
					}
				};

				$.Isotope.prototype._masonryResizeChanged = function() {
				    var prevSegments = this.masonry.cols;
				    // update cols/rows
				    this._getMasonryGutterColumns();
				    // return if updated cols/rows is not equal to previous
				    return (this.masonry.cols !== prevSegments);
				};
				/** End of modifying Isotop methods **/
			}
		};	
	};
	

}(jQuery));


//LABjs window.onload helper
if( window.isWindowLoaded === undefined ) {
	window.isWindowLoaded = false;
}

/* //moved to mini-plugins.js
(function($){
	/* Quits when length is Zero
	$.fn.doOnce = function(func){
	    this.length && func.apply(this);
	    return this;
	};

	/* Same as .each except it quits when length is Zero
	$.fn.forEach = function(func){
	    this.length && this.each(func);
	    return this;
	};

})(jQuery);

//Enable lazy load images
(function($){
	var getData = function (image) {
		var data = (image.length > 0) ? image.metadata({type: 'class'}) : 0,
			ret = (data && 'src' in data) ? data : 0;
		return ret
	},
	defaults = {};

	$.fn.lazyLoadImages = function (options) {
	    this.length && this.each(function () {
	    	var item = $(this),
				data = getData(item);
				options = $.extend(defaults, options);
			if(data) {
				item.attr("src", data['src']);
				if(options['success']) {
					options.success.apply(this)
				}
			}
	    });
	    return this;
	}
})(jQuery);

//Enable elements to load Flash from there class meta data
(function($){
	var getData = function(flash){
			var data = flash.length > 0 ? flash.metadata({type: 'class'}) : 0,
				ret = (data && 'swf' in data) ? data : 0;
			return ret
			},
			defaults = {};

	$.fn.metaBasedFlash = function(options){
	    this.length && this.each(function(){
	    	var item = $(this),
	    		data = getData(item);
	    		options = $.extend(defaults, options);

	    	if(data) {
	    		//extend the JSON object extracted from the class with some system wide ones.
		    	data = $.extend(true, data, options.swfobject);

				item.flash(data);
				item.addClass("flash-loaded");
				if(options['success']) {
					options.success.apply(this)
				}
			}
	    });
	    return this;
	}

	$.fn.killFlash = function(){
	    this.length && this.each(function(){
	    	var flash = $(this).flash();
			flash.remove && flash.remove();
	    });
	    return this;
	}
})(jQuery);

*/

(function($, window, undefined){

	//namespacing
	var ND = window.ND = window.ND || {};
	ND.API = ND.api || {};

	//Protect from missing SiteConf page JS errors
	window.SiteConf = window.SiteConf || {};

	/* ND.urlParams Version 0.9 - Glenn Baker */
	ND.urlParams=function(){var d=function(s){var a=s.match(/[\%][a-fA-F0-9]{2}/g);for(o=0;a&&o<a.length;o++) {var hex=/[\%]([a-fA-F0-9]{2})/i.exec(a[o]).pop();s=s.replace(a[o],String.fromCharCode(parseInt(hex,16)));}return s;};if(!window.location['param']){window.location.param={};}var qs=window.location.href.match(/([^?=&]+)(=([^&#]*))?/g);for(i=0;i<qs.length;i++){if(qs[i].indexOf("=")>-1){var c=qs[i].split('=');var v=c.pop();var n=c.pop();window.location.param[n]=d(v);}}};ND.urlParams();


	// Pad with leading zeros
	ND.pad = function(num, size) {
	    var s = num+"";
	    while (s.length < size) s = "0" + s;
	    return s;
	};

	//ND is in the window scope.
	ND.flash = {
		init: function(){
			if($.flash.version.major < 1) {return;}

			var qsParams = window.location.param, swfOptions = {flashvars:{}};

			$.each(qsParams , function(key, i){
				if(typeof key === 'string' && key.indexOf('section') === 0) {
					swfOptions.flashvars[key] = qsParams[key]
				}
			});

			if ($("body").hasClass('lincoln')==false) {
				$('#banner').removeClass('flash').metaBasedFlash({
					swfobject: swfOptions,
					success: function(){

							$("#principal").addClass("banner-flash");

					}
				});
				$('.flash').metaBasedFlash({
					swfobject: swfOptions
				});
			}
		}
	}

	ND.twitter = {
		init: function () {
			var data;
			var newsFeed = $(".newsfeed");
			var paginationContainer;
			var markup = {
				container: function () {
					return '<ul class="pagination-dots"></ul>';
				},
				item: function () {
					return '<li></li>';
				},
				current: function (number) {
					return '<span title="' + number + '">Page ' + number + '</span>';
				},
				link: function (number) {
					return '<a href="#" class="page" title="' + number + '">Page ' + number + '</a>';
				}
			};

			var injectPagination = function (pages) {
				var i;
				var container = $(markup.container());

				for (i = 1; i <= pages; i = i + 1) {
					var item = $(markup.item());
					var content;
					if (i === 1) {
						$(item).addClass("current");
						content = $(markup.current(i));
					}
					else {
						content = $(markup.link(i));
					}
					$(item).append(content);
					$(container).append(item);
				}
				$(newsFeed).after(container);

				paginationContainer = container;
			};

			var getPagination = function (page, total, perpage) {
				var pagination = {};

				pagination.from = (page * perpage - perpage) + 1;
				pagination.to = page * perpage;
				pagination.to = (pagination.to > total) ? total : pagination.to;

				return pagination;
			};

			var applyPagination = function (object) {
				var i, tags = ["LI", "DT", "DD"];

				for (i = 0; i < tags.length; i = i + 1) {
					$(tags[i], newsFeed).each(function (i) {
						if (i >= (object.from - 1) && i <= (object.to - 1)) {
							$(this).show();
						}
						else {
							$(this).hide();
						}
					});
				}
			};

			var updateCurrent = function (current, page) {
				$("LI", paginationContainer).each(function () {
					if ($(this).children("SPAN").size() > 0) {
						$(this).removeClass("current");
						var oldPage = $("SPAN", this).attr("title");
						$(this).children("SPAN").replaceWith($(markup.link(oldPage)));
					}
				});
				$(current).parent().addClass("current");
				$(current).replaceWith($(markup.current(page)));
			};

			var wireEvents = function (total, perpage) {
				$(paginationContainer).delegate("A", 'click', function () {
					var page = $(this).attr("title");
					var object = getPagination(page, total, perpage);

					updateCurrent(this, page);
					applyPagination(object);

					return false;
				});
			};

			var callback = function () {
				var length = $("LI", newsFeed).size();
				length = (length === 0) ? $("DT", newsFeed).size() : length;
				var perpage = data.perpage || 3;

				if (length > 0) {
					var pages = Math.ceil(length / perpage);
					if(pages > 1){
						injectPagination(pages);
						wireEvents(length, perpage);
						applyPagination({
							from: 1,
							to: perpage
						});
					}
				}
			};

			if (newsFeed.size() > 0) {
				data = newsFeed.metadata({type: 'class'});

				if (data.username !== undefined) {
					data.success = function () {
						callback();
					};
					newsFeed.empty();
					newsFeed.tweet(data);
				}
				else {
					callback();
				}
			}
		}
	}

	ND.selectCurrent = {
		init: function () {

			var $navs = $('#nav, #subnav, #leftnav'),

			getIds = function () {
				$("#breadcrumb LI").each(function (i) {
					if (i !== 0) {
						var id = $(this).attr("id");
						if (id !== undefined) {
							selectPage(id);
						}
					}
				});
			},

			selectPage = function (id) {

				$navs.each(function(){
					var $this = $(this),
						$UL = !$this.is('UL') ? $this.children("UL") : $this;

					$UL.children("LI").each(function (i) {
						var link = $(this).children("A"),
							title = $(this).attr("title"),
							href = $(link).attr("href");

						if (title !== "" && title == id){
							$(this).addClass("current");
							return false;
						}
					});
				});

			};

			getIds();
		}
	};

	ND.delegate = {
		init: function () {

			var simulateNativeAnchor = '_sna';

			$(document)
				.delegate('.clickable', 'click', function(e){
					var $this = $(this);
					if(!$(e.target).is('a,a *')) {
						var a = $this.find("A:eq(0)");
						//Fix [105295] - Can't trigger native event handlers.
						a.trigger('click', simulateNativeAnchor)
					}
				})
				.delegate('a', 'click', function(e, data){
					if($(this).hasClass('external')) {
						window.open(this.href);
						e.stopPropagation();
						e.stopImmediatePropagation();
						e.preventDefault();
					} else if(data === simulateNativeAnchor){
						window.location = this.href;
					}
				});
		}
	};


	ND.gcamp = {

			init:function(){
				if ($('#gcamp').length > 0){
					var gcampForm = $('#gcamp');

					gcampForm.submit(function(){
						if ($('.results').length >0){
					        $('.results').remove();
						}
						var re = new RegExp("[0-9a-zA-Z]{17}");
						if(!re.test($('#vin').val())) {
							$p = $('#message').length > 0 ? $('#message') : $('<p id="message"></p>');
							gcampForm.append($p.addClass("warning").html($('#error-msg').val()));
							return false;
						}
						else{
							return true;
						}
					})
				}
			}
		}

	// Add icons based on the media type (carousel image)
	ND.links = {
		init:function() {

			var types = [
							{selector:"A.external-disclaimer", icon:"ext-icon"},
							{selector:"A.video-indicator", icon:"video-icon"}
						];

			$.each (types, function(i, type){
				$(type.selector).each(function(){
					var $this = $(this);

					//Ensure the UI updates are queued (subtle rather than blocking)
					setTimeout(function(){

						//check parents for context.
						if ($this.closest('.ei-enabled').size() > 0) {

							//if child is IMG then icon sits over the top of it
							if ($this.children("IMG").size()) {
								$this.addClass('img-external');
							}

							//if child is a span, then insert into it, not adjacent.
							if ($this.children("SPAN").size()) {
								$this = $this.children("SPAN").first();
							}
							$this.append("<span class='" + type.icon + "'></span>");
						}
					}, 20);
				});
			});
		}
	};

	ND.floatHeader = {
		init:function() {
			if(!$(".features-grid").size()) {return;}

			var $floatHeader = $("div.package-titles");
			var $floatHeaderClone = $floatHeader.clone();
			$floatHeader.before($floatHeaderClone.hide());
			$floatHeaderClone.addClass("floatingHeader");

			$(window).scroll(function(){
				var scrollTop = $(window).scrollTop();
				var offset = $floatHeader.offset();
				//console.log(offset);
				//console.log(scrollTop);
				if((scrollTop > offset.top) ){

					$floatHeaderClone.show();
				}else{
					$floatHeaderClone.hide();

				}

			});
		}
	};

	ND.accordionModule = {
		init:function() {
			if(!$(".accordion-active").size()) {return;}

			$("div.accordion-active > UL > LI > DIV.dropdown").hide();
			$("div.accordion-active > UL > LI.active > DIV.dropdown").show();

			$("div.accordion-active > UL > LI > DIV.tab-area").click(function(){
				var $this = $(this);
				if(!$this.parent("li").hasClass("active")){
					$this.next("div.dropdown").slideDown(200);
					$this.parent("li").addClass("active");
				}else{
					$this.next("div.dropdown").slideUp(200);
					$this.parent("li").removeClass("active");
				}
			});
		}
	};




























	ND.filterTableModule = (function () {

		var $selectFilter;
		var paginationPageCount;

		var slider;
		var $campaignNav;

		var $sliderNext;
		var $sliderPrev;

		var $dataRows;

		var $dealerNetworkArticle;

		var __options;

		var module = {
			init: init
		};

		return module;

		////////////////////////////////

		function init() {

			$dealerNetworkArticle = $('#dealer-network-article').length
										? $('#dealer-network-article')
										: $('#cn-dealer-network');

			if(!$('.campaign-article').length && !$dealerNetworkArticle.length) {
				// Don't initialize ND.filterTableModule if
				// .campaign-table is not present on page
				return;
			}

			$selectFilter = $('select.campaign-filter');

			$campaignNav = $('.campaign-slider-nav');
			$dataRows = $campaignNav.find('ul').slice(); // create a copy of rows

			$sliderNext = $('.campaign-slider-next');
			$sliderPrev = $('.campaign-slider-prev');

			if ($dealerNetworkArticle.length) {
				$campaignNav.on('article-added', setDealerNetworkProvinceColumnStyle);
			}

			populateSelectBoxOption();

			/////////////////////////
			/// Set event listeners
			$selectFilter.on('change', filterTableOnChanged);

			// init slider
			generateTable();
		}

		function generateTable() {

			setPaginationPageCount();
			explodeListToArticle();

			if (slider != null) {
				slider.reloadSlider({
					controls: true,
					infiniteLoop: false,
					nextSelector: '.campaign-slider-next',
					prevSelector: '.campaign-slider-prev',
					nextText: '&gt;',
					prevText: '&lt',
					pager: true,
					pagerType: 'short',
					onSlideAfter: showHidePaginationArrow
				});
			} else {
				slider = $campaignNav.bxSlider({
					slideWidth: 960,
					infiniteLoop: false,
					controls: false,
					pager: false,
					onSlideAfter: showHidePaginationArrow
				});
			}

			showHidePaginationArrow();

		}

		/**
		 * Show only 1 province in Province column per Article
		 * Remove the border in other Province row
		 */
		function setDealerNetworkProvinceColumnStyle(event, $dataList) {
			if ($dealerNetworkArticle != null) {

				var isFirstRowInGroup, isLastRowInGroup;
				var $row, $prevRow;
				var $firstColumn;

				$.each(getOptions(), function(i, val) {

					$dataList.each(function(rowIndex, row) {

						isFirstRowInGroup = rowIndex === 0;
						isLastRowInGroup  = rowIndex === $dataList.length - 1;

						$row = $(row);
						$prevRow = $row.prev();

						if (isFirstRowInGroup) {
							$row.find('li').first().addClass('bottom-less').find('p').show();
						} else if ($prevRow.data('group') === val && $row.data('group') === val) {
							$prevRow.find('li').first().addClass('bottom-less');
							$row.find('li').first().find('p').hide();
						}

						if (isLastRowInGroup) {
							$row.find('li').first().removeClass('bottom-less');
						}

					});

				});

			}
		}

		function showHidePaginationArrow() {
			var pagerText = $('.bx-pager').text();

			$('.campaign-slider-prev, .campaign-slider-next').show();

			var isOnFirstColumn = paginationPageCount === 1 || pagerText.charAt(0) === '1';
			var isInLastColumn = pagerText.match(new RegExp(pagerText.charAt(0), 'g')).length == 2;

			if (isOnFirstColumn) $sliderPrev.hide();
			if (isInLastColumn)  $sliderNext.hide();
		}

		/**
		 * Put every 6 uls inside an article
		 */
		function explodeListToArticle() {

			var articleSet = [];
			var $rows = $campaignNav.find('ul');

			for(var i = 0; i < paginationPageCount; i++) {
				articleSet.push($rows.slice(i * 6, (i + 1) * 6));
			}

			// Add article with 6 row content
			$.each(articleSet, function(index, dataList) {
				$campaignNav.append($('<article/>').append(dataList));
				$campaignNav.trigger('article-added', [dataList]);
			});
		}

		function populateSelectBoxOption() {
			$.each(getOptions(), function(index, value) {
				$selectFilter.append($('<option />').val(value).text(value));
			});
		}

		/**
		 * Get only the rows content of the selected value.
		 */
		function filterTableOnChanged() {
			var selectedValue = this.value;
			var isDefaultSelected = !selectedValue;

			if (isDefaultSelected) return;

			var filteredRows = $dataRows.filter(function(index, ul) {
				return $.trim($(ul).data('group')) === selectedValue;
			});

			$campaignNav.empty().append(filteredRows);

			generateTable();
		}

		function setPaginationPageCount() {
			var rowsLength = $campaignNav.find('ul').length;
			paginationPageCount = Math.ceil(rowsLength / 6);
		}

		/**
		 * Get options from data-group
		 */
		function getOptions() {

			if (__options != null) return __options;

			__options = [];

			$campaignNav.find('ul').each(function(index, ul) {
				var option = $.trim($(ul).data('group'));
				__options.push(option);
			});

			__options = $.grep(__options, isUniqueOptionOnly);

			return __options;

			////////////////////////////

			function isUniqueOptionOnly(value, index) {
				return $.inArray(value, __options) === index;
			}

		}

	})();

	ND.setColumnWith = {
		init:function() {
			if(!$(".column-unknown").size()) {return;}

			var columnCount = $("div.package-titles table").eq(0).find("th.column-width").size();
			var parentWidth = 960 - $("div.package-titles table").eq(0).find("th.package-icon").outerWidth() - $("div.package-titles table").eq(0).find("th.package-heading").outerWidth();
			var columnWidth = Math.floor(parentWidth/columnCount);

			$("div.column-unknown table th.column-width").width(columnWidth);

			$("div.column-unknown table tr td:last-child, div.column-unknown table tr th:last-child").addClass("last");
		}
	};

	ND.rolloverPopup = {
		init:function() {
			if(!$(".features-grid td div.hidden-content").size()) {return;}

			function getElementLeft(element){
				var actualLeft = element.offsetLeft;
				var current = element.offsetParent;
				while (current !== null){
					actualLeft += current.offsetLeft;
					current = current.offsetParent;
				}
				return actualLeft;
			}

			function getElementTop(element){
				var actualTop = element.offsetTop;
				var current = element.offsetParent;
				while (current !== null){
					actualTop += current.offsetTop;
					current = current.offsetParent;
				}
				return actualTop;
			}

			var popupHTML = "<div style='display:none;' class ='optional-popup'><div class='top'></div><div class='middle'></div><div class='bottom'></div></div>"
			var popupHTMLMirror = "<div style='display:none;' class ='optional-popup-adjust'><div class='top'></div><div class='middle'></div><div class='bottom'></div></div>"
			$('body').append(popupHTML+popupHTMLMirror);

			$(".features-grid td div.hidden-content").each(function(){
				var icon = $(this).prev("span");
				icon.css({"cursor":"pointer"});
			});

			$(".features-grid td span.optional, .features-grid td span.checked,.features-grid td.version-tip span").live("mouseover",function(){

				if($(this).next("div.hidden-content").size() < 1){return;}

				var thisIcon = $(this)[0];
				var leftPosition = getElementLeft(thisIcon);
				var topPosition = getElementTop(thisIcon);
				var browserWidth = $(window).width();
				var rightPosition = browserWidth - leftPosition;
				var popContent = $(this).next("div.hidden-content").html();
				var dValue = 32;
				if($(this).parents("td.version-tip").size() > 0 ){dValue = 2};
				if(rightPosition < 220 && $("body").hasClass("ltr")){

					dValue = 195;

					$("div.optional-popup-adjust div.middle").html(popContent);
					var popHeight = $("div.optional-popup-adjust").height();
					var newTopPosition = topPosition - popHeight;
					var newLeftPosition = leftPosition - dValue;
					var popHeight = $("div.optional-popup-adjust").css({'left':newLeftPosition+'px','top':newTopPosition+'px'}).show();
				}else{
					$("div.optional-popup div.middle").html(popContent);

					var popHeight = $("div.optional-popup").height();
					var newTopPosition = topPosition - popHeight;
					var newLeftPosition = leftPosition - dValue;
					var popHeight = $("div.optional-popup").css({'left':newLeftPosition+'px','top':newTopPosition+'px'}).show();
				}
			});

			$('.features-grid td span.optional, .features-grid td span.checked,.features-grid td.version-tip span').live("mouseleave",function(){
				if($(this).next("div.hidden-content").size() < 1){return;}
				$('div.optional-popup, div.optional-popup-adjust').hide();
				$('div.optional-popup div.middle, div.optional-popup-adjust div.middle').html('');
			});

		}
	};

	ND.syncSlideModule = {
		init:function() {
			if(!$(".content-slider").size()) {return;}

			var pageSum = $("div.content-slider > UL > LI").size();

			$("div.content-slider > UL > LI").each(function(index,value){
				var index = index + 1;
				$(this).find("span.page-current").text(index);
				$(this).find("span.page-sum").text(" / " + pageSum);
			});

			$("div.content-slider > UL").bxSlider({
				pager:true
			});

		}
	};

	ND.alternateLines = {
		init:function() {
			var isIE8 = $.browser.msie && $.browser.version < 9;

			if(!$(".sync-p5").size() && !isIE8) {return;}

			$(".sync-p5 div.searchresults-list div.item:even").addClass("even");

		}
	};

	ND.dropdownLink = {
		init:function() {

			if(!$("div.dropdown-list").size()) {return;}

			$("div.dropdown-list > span.dropdown-list-btn").live("click",function(){
				var $this = $(this);
				if($this.next("ul.dropdown").is(":hidden")){
					$this.next("ul.dropdown").show();
				}else{
					$this.next("ul.dropdown").hide();
				}
			})

			$("div.tab-nav ul li").removeClass("active");
			$("div.tab-nav ul li.syncicon-compatibility").addClass("active");

		}
	};

	ND.sideflowModule = {
		init:function() {

			if(!$("div.sideflow").size()) {return;}

			$("div.sideflow").find("span.btn").click(function(){

				var $sideflow = $(this).parent("div.sideflow");
				if($sideflow.hasClass("active")){

					$sideflow.removeClass("active");
				}else{

					$sideflow.addClass("active");
				}
			})

		}
	};

	ND.videoLoad = {
		init:function() {

			if(!$(".inner-video").size()) {return;}

			var videoConfig = $("#video-config").embeddedData();
			//console.log(videoConfig);


			ND.video.init(videoConfig);


		}
	};

	ND.listClone = {
		init:function() {

			if(!$(".list-table").size()) {return;}

			$("table.list-table").each(function(){
				var $thisTable = $(this);
				var listLengthArr = [];
				$thisTable.find("ul.package-list").each(function(i,v){
					var $thisList = $(this);
					var listLength = $thisList.children("li").size();
					//alert(listLength);
					listLengthArr.push(listLength);
				});

				var maxColumn = Math.max.apply(null, listLengthArr);

				var listCloneContent = "<ul class='package-list'>";

				for(i=0;i<maxColumn;i++){
					listCloneContent = listCloneContent + "<li></li>";
				}

				listCloneContent = listCloneContent + "</ul>";

				$thisTable.find("td.list-clone > div").html(listCloneContent);

				/* apend some empty li tag to the list if its amount of items is less than maxColumn */
				$thisTable.find("ul.package-list").each(function(i,v){
					var $thisList = $(this);
					var itemsAmount = $thisList.children("li").size();
					if(itemsAmount < maxColumn){
						var itemGap = maxColumn - itemsAmount;
						for(i=0;i<itemGap;i++){
							$thisList.append("<li></li>");
						}
					}
				});

				$thisTable.find("ul.package-list li:nth-child(even)").addClass("even");

			});



		}
	};


	ND.lang = {
		init:function(){
			if($("#lang-toggle")){
				$("#lang-toggle").change(function(){
					window.location.href = jQuery("#lang-toggle option:selected").val();
				});
			}
		}
	};

	ND.fblike = {
		load: function() {
			var fblikeButton = $('#facebook-page-like'),
				fblike = fblikeButton.parent(),
				url = window.location.href,
				done;

			//Fade In Social Widgets
			function doneFn() {
				if( !done ) {
					fblike.parent().find('.social-widget').fadeIn(200);
					done = true;
				}
			}

			if( fblikeButton.size() &&  fblike.size() ) {
				fblike.html( fblikeButton.val().replace('##REPLACEURL##', escape(url.split('#')[0]).replace("\/", "%2F", "g") ));
				//Once the facebook like iframe is loaded.. Fade all social widgets in.
				fblike.find('iframe').bind('load', doneFn);
				//Set a timeout incase the face book iframe takes too long.
				setTimeout(doneFn, 2e3);
			}
		}
	};

	function wLoad() {
		ND.fblike.load();
	}

	if( isWindowLoaded ) {
		wLoad();
	} else {
		$(window).bind('load', wLoad);
	}



	$(document).ready(function(){

		if(typeof Number !== 'function'){
			window.Number = function(string){
			return parseInt(string);
			}
		}

		ND.rtl = $('BODY').hasClass('rtl');
		ND.ltr = !ND.rtl;
		ND.flash.init();
		ND.links.init();
		ND.twitter.init();
		ND.selectCurrent.init();
		ND.delegate.init();
		ND.gcamp.init();
		ND.lang.init();
		// moved to app.js
		// ND.syncVersionManager();
		ND.floatHeader.init();
		ND.accordionModule.init();
		ND.filterTableModule.init();
		ND.setColumnWith.init();
		ND.rolloverPopup.init();
		ND.syncSlideModule.init();
		ND.alternateLines.init();
		ND.dropdownLink.init();
		ND.sideflowModule.init();
		ND.videoLoad.init();
		ND.listClone.init();



		/******************************************
		1. Tech section tiles layout and filering
		2. Poping up the full-screen overlay by clicking tile images
		3. HTML5 history API is used for mordern browers
		4. jQuery BBQ is used for IE
		 *******************************************/
	$(function(){

		if ($(".tech-section").length > 0){
			var tiles = techTiles().init();
		}


		$(".fullscreen-overlay").fullScreenOverlay();

		var overlayId = "fullscreen-overlay",
			location = window.location.toString(),
			index = location.indexOf(overlayId);

		if ( index > -1 ){
			var url = location.substring(index + overlayId.length + 1);
			url = decodeURIComponent(decodeURIComponent(url));
			// url = decodeURI(url);

			var cid = url.match(/cid=\d+/);
			if (Modernizr.history){
				history.pushState(null,overlayId,location.substring(0,index-1));

			}


			// $("a[href*='"+cid+"']").trigger('click');
			var $link = $("a[href*='"+cid+"']");
			$link[0].click();

		}

	});

	});


	//Protect from missing LAB/loader script.
	if(window['$wait'] === undefined) {
		window['$wait'] = function(fn){
			fn();
		}
	}

})(jQuery, window);


(function($){

	var exp = /^[a-zA-Z0-9#\s.\-_\u0081-\uFFFF]+$/;

	$("form#dragonflyform").submit(
		function(){
			var doSubmit = true;
			$("input.validate-simple").each(function(i){
				var strVal = $(this).val();
				if(strVal.length > 0 && !strVal.match(exp)){
					$(".validate-simple-msg").css("display","inline").fadeOut(2000);
				    $(this).focus();
					doSubmit = false;
				}
			});
			return doSubmit;
		}
	);

	// derivative dropdown
	$(function(){

		var changemodel = $('#changemodel'),
			el = changemodel.find('ul')
			dropdownopen = false,
			speed = 100;

		//On Click
		changemodel.click(function(e){
			if( !dropdownopen ) {
				el.slideDown(speed, function() {
					dropdownopen = true;
				});
			} else {
				el.slideUp(speed, function() {
					dropdownopen = false;
				});
			}
		});

		//On Blur
		$(document).click(function(){
			dropdownopen && el.slideUp(speed, function() {
				dropdownopen = false;
			});
		});

		// handsets select
		var brandItem = $(".handsetcat");
		if (brandItem.length){
			var $modellist = $(".model-select ul");
			for(var idx = 0; idx < brandItem.length; idx++){
				var $thisTitle = $(".title h3", $(brandItem[idx]));
				var brandAnchor = "#" + $(brandItem[idx]).attr("id");

				var $item = $("<li></li>").append(
					$("<a>"+$thisTitle.text()+"</a>").attr({
						href : window.location.href.indexOf(brandAnchor) < 0 ? window.location + brandAnchor : window.location,
						title : $thisTitle.text()
			})
				);

				$modellist.append($item);
			}

			var selectAction = function(selectItem){
				selectItem.addClass("selected");

				/*if (selectItem.attr("href") == "#viewall"){
					//$(".handsets .handsetcat").show();
				}else{*/
					//to fix Media and Phone Page

//1/ Remove current js, which set the filter value on media and phone page
//http://www.ford.com.au/sync/using-sync/handset-compatibility?v=101#Huawei

					//$(".handsets .handsetcat").hide();
					//var url = selectItem.attr("href");
					//url = url.substring(url.lastIndexOf("#"));
					//$(url).show();
				/*}*/

				var url = selectItem.attr("href");
				url = url.substring(url.lastIndexOf("#"));
				//console.log("url:"+url);
				var new_position = $(url).offset();
                window.scrollTo(new_position.left,new_position.top);

				//console.log($(selectItem));
				$(".model-select > span").replaceWith("<span>"+selectItem.text()+"</span>");
			};

			$(".model-select ul li a").click(function(e){
				var selectItem = $(this);
				$(".model-select ul li a").removeClass("selected");
				selectAction(selectItem);
				el.slideUp(speed, function() {
					dropdownopen = false;
				});
				e.stopPropagation();
			});

			$(window).bind("hashchange", function(e){
				var hash = window.location.hash;
				if (hash == ''){
					$(".handsets .handsetcat").show();
					//$(".model-select > span").replaceWith("<span>Change Model</span>");
					$(".model-select ul li a").removeClass("selected");
				}else{
					//var titleValue = hash.replace( "#", '' );
					//console.log($(".model-select ul li a[href='" + hash + "']"));
					$(".model-select ul li a[href$='" + hash + "']").trigger("click");
				}
			});
			//$(window).trigger( 'hashchange' );

		}else{
			changemodel.hide();
		};
		if (!$(".handsets").length > 0){
			changemodel.show();
		}
	});

	// clear inputs with the class "clearme"
	$(function(){
		$('input.clearme').focus(function(){
			var inputVal = $(this).attr('title');
			$(this).blur(function(){
				if ($(this).val() === '') {
					$(this).val(inputVal);
				}
			});
			if ($(this).val() === '' || $(this).val() === inputVal) {
				$(this).val('');
			}
		});
	});

	$(function(){
		// popup window
		$(".popup").popupWindow({
			fullscreen: true
		});

	});

	$(function(){
		// accordion-container
		$(".accordion-container .item h4").each(function(){
			var hasContent = $(this).next(".content");
			if (hasContent.length > 0){
				$(this).parents(".item").addClass("has-content");
				$(this).click(function(){
					$(this).parents(".item").toggleClass("item-active");
				});
			}else {
				$(this).addClass("disable");
			}
		});

		$(".accordion-container .item h4 a").click(function(e){
			return false;
		});

	});

	$(function(){
		// search-pannel focus func
		$(".search-pannel").each(function(){
			var kw = $(this).find(".keyw");
			var kwVal = kw.val();
			kw.focus(function (){
				$(this).val("");
			});
			kw.blur(function (){
				var newkwVal = kw.val();
				if (newkwVal == ""){
					$(this).val(kwVal);
				}else{
					$(this).val(newkwVal);
				}
			});
		});
	});

	$(function(){
		// form validation
		$("#vehicleown").validate({
			messages: {
				Model: "Please slect your model",
				Series: "Please slect your series",
				LastName: {
					required: "Please enter your lastname"
				},
				FirstName: {
					required: "Please enter your firstname"
				},
				email: "Please enter your email"
			}
		});

	});

	$(function(){
		// sync homepage banner slider
		if(!$("body").hasClass("rotating-banner")){
		$(".slider")
			.ndslider()
			.each(function() {
				var slider = $(this);
				slider.touchwipe({
			        wipeLeft: function() {
						slider.trigger('slidenext');
			        },
			        wipeRight: function() {
			        	slider.trigger('slideprev');
			        }
			    });
			})
		}
	});

	// Feature slider
	$(function(){
		$(".slideshow").touchwipe({
			wipeLeft: function() {
				$('div.jcarousel-next').trigger('click');
			},
			wipeRight: function() {
				$('div.jcarousel-prev').trigger('click');
			}
		})
	});

	$(function(){
		// login
		$(".btn-login").click(function(){
			var $this = $(this);
			$this.toggleClass("btn-loginactive");
			$(".loginform .container").toggle();
			//page url
			var targetUrl = window.location.href;
			var targetUrlIndex;
			var targetUrlParam = "targeturl=";

			//find start & end of parameter targeturl and inject it to hidden field
			if($(".loginform .container").length == 0){


				self.location($this.attr("href"));
			}
			if (targetUrl && (targetUrlIndex = targetUrl.indexOf(targetUrlParam)) > 0 ) {




				var endOfTargetUrl = targetUrl.indexOf("&", targetUrlIndex);
				targetUrl = targetUrl.substring((targetUrlIndex + targetUrlParam.length), (endOfTargetUrl > 0 ? endOfTargetUrl : targetUrl.length));

				//update action
				var form = $("#loginform");
				var loginFormAction = form.attr('action');
				if (loginFormAction != '') {
					form.attr('action', updateTargetUrl(loginFormAction, targetUrl));
				}
				//update registration & forget password links
				$("a.loginform-targeturl-link").each(function() {
					var link = $(this);
					link.attr('href', updateTargetUrl(link.attr('href'), targetUrl));
				});
			}



			return false;
		});

		function updateTargetUrl (origUrl, targetUrl) {
			var targetUrlParam = "targeturl=";
			var targetUrlIndex;
			if ((targetUrlIndex = origUrl.indexOf(targetUrlParam)) > 0) {
				var endOfTargetUrl = origUrl.indexOf("&", targetUrlIndex);
				var linkTargetUrl = origUrl.substring((targetUrlIndex + targetUrlParam.length), (endOfTargetUrl > 0 ? endOfTargetUrl : origUrl.length));
				origUrl = origUrl.replace(linkTargetUrl, targetUrl);
			} else {
				var indexOfQM = origUrl.indexOf("?");
				var targetUrlParamValue = "?" + targetUrlParam + targetUrl;
				origUrl = indexOfQM > 0 ? origUrl.replace("?", targetUrlParamValue + "&") : targetUrlParamValue;
			}
			return origUrl;
		}

        //Feedback: If customers click in the blank part of this website page, this overlay will be folded automatically.
        var $btnlogin = $(".btn-login");
        if($btnlogin.size()){
            $(document).click(function(e){
                //Click inner from the login-form? return back.
                var target = e.target;
                do{
                    if(target.className && target.className.indexOf("loginform") > -1) return;
                }while(target = target.parentNode);

                //click outter from the login-form? Close it.
                $(".loginform .container:visible").size() && $btnlogin.click();
            });
        }
	});


	// add last class on gallery items
	$(function(){
		if ($(".gallery").length != 0){
			var parentWidth =  $(".gallery").width();

			if($("body").hasClass("ltr")){
				parentWidth = parentWidth + parseInt($(".gallery").css("marginLeft"));
			}
			else{
				parentWidth = parentWidth + parseInt($(".gallery").css("marginRight"));
			}

			$(".gallery .item").each(function(){
				var offsetRight = parentWidth - $(this).position().left;
				var itemWidth = $(this).width();

				if($("body").hasClass("ltr")){
					if (offsetRight == (itemWidth+1) || offsetRight == itemWidth){
						$(this).addClass("last");
					}
				}
				else{
					$(this).attr("rel",offsetRight);

					if(offsetRight == (parentWidth-1) || offsetRight == parentWidth){
						$(this).addClass("last");
					}
				}
			});
		}

	});

	//add print function
	$(function(){
		$(".print").click(function(){
			window.print();
		});
	});

	$(function(){
		// Apply classnames odd and even to table rows
		$("TABLE TBODY").find("TR:even").addClass("even").end().find("TR:odd").addClass("odd");
		//eyebrow width hack for IE6 and IE7
		if($.browser.msie){
			if(jQuery.browser.version == "6.0" || jQuery.browser.version == "7.0" ){
				var width = 0;
				$("#eyebrow").children().each(function(){
					width = width + $(this).outerWidth();
				});
				$("#eyebrow").width(width);
			}
		};
	});



})(jQuery);


(function($, window, undefined){

	//namespacing
	var ND = window.ND = window.ND || {};
	ND.API = ND.api || {};
	
	ND.cacheStore = {
			get:function(){
				var value = $.trim($.cookie(this.key));
				try {
					return value ? JSON.parse(value) : "";
				} catch (e) {
					return value || "";
				}			
			},
			set:function(value){
				value = $.isPlainObject(value) ? JSON.stringify(value) : value;
				if(this.get() !== value) {
					//Session cookie
					var options = {path:'/'};
					if( this.expires ) {
						options.expires = this.expires; 
					}			
					if(this.domain){
						options.domain=this.domain;
					}	
					$.cookie(this.key, value || null, options);
				}
			},
			is:function(){
				return this.get() != null ? (this.get().toString().length > 0) : false;
			},
			contains:function(value){
				return this.get().indexOf(value) > -1;
			}
		};
		
		//Quick (single callback) Deferred Implementation.
		ND.deferred = function() {

			var cb, 
				resolved,
				run = function() {
					cb && cb.call();						
				};
			
			return {
				resolve: function() {
					resolved = true;
					run();
				},
				done: function( fn ) {
					cb = fn;
					resolved && run()
				}
			};		
		};

			
	
	
	//Protect from missing LAB/loader script.
	if(window['$wait'] === undefined) {
		window['$wait'] = function(fn){
			fn();
		}
	}
	
})(jQuery, window);


/**
 * @author: szabetian
 * @project: polk
 * @description: helper methods for ND.calcprice
 * 
 * 
 * getprice.js (ND.calcPrice) uses methods in this file to perform various tasks
 * 
 */

ND.polk = {
		/**
		 * Updates the region in the DOM where vehicle prices are displayed.
		 * That subtle color fadding when a panel updates.
		 * 
		 * @param elem
		 * 
		 */
		showChangeVisually : function(elem) {
//			console.logpubsub("showChangeVisually()");
			
			var time = 1500,
				bgColor = elem.closest('.need-price').size() ?  
					//Dark Background
					['#185a78', '#111111' ] :
					//Light Background
					['#aad3e6', '#FFFFFF' ];
			
			//Run the animation, start with a solid background colour
			elem.css('backgroundColor', bgColor[0] )
				.delay(time)
				.animate({
						'backgroundColor' : bgColor[1]								
					}, time,  function() {
						$(this).css('backgroundColor', 'transparent');
					});		
		},
		
		bindAdditionalListeners: function() {},
		
		/**
		 * Placeholder callback function after postcode is changed
		 * Do not delete
		 */
		templateUpdated: function() {
		}
};


// Requires json2.js 
/*globals window, document, jQuery, ND, SiteConf */
(function($, undefined){

	var // Conf
		config = {},
		
		// Pubsub
		suffix = ".calculateprice.dfy",
		
		// Module exports 
		exports = {},
		exportsAPI = {},
		
		//not to be exposed
		internalAPI = {overlayLaunched : false};
		

		/*
		 * Object: priceUpdater
		 * 
		 * Managers the derivatives on the page that need a price.
		 *
		 * <div class="derivative-price {'derivativeid':'123412341234'}">
		 * 		<span class="price">$$$$$</span>
		 * </div>
		 */
		priceUpdater = exports.PriceUpdater = (function(){

		    var derivatives,
				defaults = {
				    priceClass: '.price',
				    hotDealClass: '.latest-offer',
				    loanCalcClass:'.loan-calc',
				    priceContainer: ".derivative-price",
				    tmpl: "#tmpl-price-main",
				    hotDealTmpl: '#tmpl-price-hotdeal-main',
				    noPriceTmpl: "#tmpl-noprice-main"
				},
                modelId = null;
			
			//Private Function
			//Store the derivative DOM elements for later recall
			function mapDerivatives( elements, priceHTML ){
			    derivatives = {};
				$( elements ).each(function( i, e ){
					var elem = $(e),
						metadata = elem.data('derivativeid');
					    
					//Read meta data and use derivativeid as key for storage
					if( metadata ) {
						derivatives[metadata] = elem;
					}
					if (!modelId && elem.data('modelid')) {
					    modelId = elem.data('modelid');
					}
				});
				return derivatives;
			}
			
			function getPriceFormatter(callback) {
			    if (config.priceformatter !== null) {
			        if (typeof callback !== 'undefined') {

			            if ($.isFunction(callback)) {
			                callback();
			            }
			        }
			    }
			    else {
			        priceUserDataManager.initPriceFormatter();
			        if ($.isFunction(callback)) {
			            callback();
			        }
			    }
			}

			//Return Obj with public methods
			return {
				init:function(elements, options){
					var that = this; 
					
					this.options = options = $.extend({}, defaults, options);
					//Store the derivative DOM elements for later recall
					mapDerivatives(this.options.priceContainer);

					//Compile main price template
					this.tmpl = $(this.options.tmpl).template();
					var $hotdealTemplate = $(this.options.hotDealTmpl);
					if ($hotdealTemplate.length > 0) {
						this.hotDealTmpl = $(this.options.hotDealTmpl).template();
					}
					//Listen to change postcode event
					$.subscribe('userchange' + suffix, function(){
						//Notify the price updater that there is impending change to prices.
						that.notifyChange();
					});
					
				},
				list: function(){
					var ret = [];
					//Create a arr of derivative ids (posted to the server web service eventually)
					$.each(derivatives, function(key, obj){
						ret.push(key);
					});
					return ret;
				},
				update:function(prices, visual){
//					console.log('priceUpdater.update()');
					var that = this;
					
					visual = visual === undefined || visual;
					
					if(derivatives) {
						
						//Just in case
						that.notifyChange();
						
					    //Loop prices returned from web service
						getPriceFormatter(function () {
						    $.each(prices, function (id, derivative) {
						        var housing = derivatives[id],
                                    prevPrice,
                                    hotDealLocationToAppend,
                                    render;

						        //Ensure the id from the prices array matches an id in the derivatives DOM storage 
						        //and that there is a displayPrice to inject
						        if (housing && derivative.displayPrice) {

						            prevPrice = housing.find(that.options.priceClass);

						            //Format price for each derivative for GUX
						            if (typeof guxApp !== 'undefined') {
						            	derivative.price = guxApp.priceFormatter.format(derivative.price);
						            }

						            //Render the template with the price data
						            render = $.tmpl(that.tmpl, derivative);


						            //for mobile we need to render the dom differently.
						            if (typeof ND.polk.renderDerivative !== 'undefined') {

						                var $liParent = housing.parents('li').filter(':visible');
						                if ($liParent != null && $liParent.length > 0) {
						                    hotDealLocationToAppend = $($liParent[0]);
						                } else {
						                    hotDealLocationToAppend = housing.parent().parent();
						                }
						                renderHotdeals = $.tmpl(that.hotDealTmpl, derivative);
						                ND.polk.renderDerivative(housing, prevPrice, hotDealLocationToAppend, render, renderHotdeals, that.options.hotDealClass);

						                if (typeof ND.polk.registerLoanBtn !== 'undefined') {
						                    ND.polk.registerLoanBtn(hotDealLocationToAppend, derivative.price, config.priceformatter, priceUserDataManager.locationValue());
						                }

						            } else {

						                //Either replace or inject a new price
						                if (prevPrice.size()) {
						                    prevPrice.replaceWith(render);
						                } else {
						                    if (housing.find('style').length>0) {
						                        housing.find('style').remove();
						                    }
						                    if (housing.find(that.options.loanCalcClass).length > 0) {
						                        housing.find(that.options.loanCalcClass).parent().remove();
						                    }
						                    housing.prepend(render);
						                }

						                $(that.options.loanCalcClass, housing).off('click').on('click', function (e) {
						                    e.preventDefault();
						                    $(this).loanCalculatorOverlay({
						                        price: derivative.price,
						                        priceformatter: config.priceformatter,
						                        location: priceUserDataManager.locationValue()
						                    });
						                });
						            }

						            if (visual) {
						                //console.log('init-> ND.polk.showChangeVisually');
						                ND.polk.showChangeVisually(housing.find(that.options.priceClass));
						            }
						            
						        }
						    });

						    if ($(that.options.noPriceTmpl).length) {
						        var nopricerender = $(that.options.noPriceTmpl).html();
						        $('.body.derivative-price').each(function (i, de) {
						            if ($(de).find('.price').length === 0) {
						                $(de).prepend(nopricerender);
						            }
						        });
						    }
							//latest offer img be publishable in model enhance detail page
							var container = $(".model-enhance .attribute-bar"),
									urls=$('#price-urls').embeddedData();
							if(container.length&&$("a.offers", container).length&&urls&&urls['latest-offer-backimg']) {
								$("a.offers", container).attr("style","background-image:url("+urls['latest-offer-backimg']+")");							
							}
							//extent model content if hot deal exists
							if($(".model-content.body.derivative-price").length && $(".model-content.body.derivative-price a.offers").length) {
								$(".model-content.body.derivative-price").addClass("extend");
							}

						});
						
					} else {
						$.publish('error' + suffix, "ND.PriceUpdater: Could not update Dom");
					}			
				},
				notifyChange: function() {
					var that = this;
					
					if( derivatives ) {
						//OMG get them prices down incase there is a timeout or an error or sometrihngf.asd fasdf !!!!! ARGH!.
					    $.each(derivatives, function (id, housing) {
					        if (typeof ND.polk.notifyChange !== 'undefined') {
					            ND.polk.notifyChange(housing);
					        }
					        else {
					            housing.find(that.options.priceClass).remove();
					            housing.find(that.options.loanCalcClass).parent().remove();
					        }
						});
					}
				},
				modelId: function () {
				    return modelId;
				}
			};
		}()),
		
		/*
		 * Object: priceUserDataManager
		 * 
		 * Managers the overlay and events around the user entering there postcode to get prices.
		 *
		 * <div class="derivative-price {'derivativeid':'123412341234'}">
		 * 		<span class="price">$$$$$</span>
		 * </div>
		 */
		priceUserDataManager = exports.userDataManager = (function(){
			
			//Private Variables
			var userData,
				defaults,			
				derivativeList,
                regionalPriceData,
				formError,
				$form = null,
				defaultFormErrorMsg = null,
				fromCookie;
		
			//Module defaults
			defaults = {
			    formid: '#calc-price-user',
			    regionformid:'#regional-price-user',
				needprice:'.need-price',
				getpostcodeusage:'.get-postcode-usage',
				tmpl:'#tmpl-price-links'
			};
			
			//Private Functions
			
			//Get Prices from web service
			function getPrices() {
				var payload = $.extend( userData, { "derivatives": derivativeList } );
				$.publish('userchange' + suffix, { "payload": payload });				
			}
			
			//Check for persistant user userData, this function is only used on page Load.
			function checkData() {
				userData = loadData();
				
				if (userData && (userData.postcode || userData.pricezone) && userData.usage) {
					fromCookie = true;
					getPrices();
				} else {
					userData = null;
				}
				return userData;
			}

			//Clear for persistant user userData (usaually because of an error)
			function clearData() {
				$.publish( "shopping.pref.clear" );
				userData = null;
			}
			
			function storeData() {
				$.publish( "shopping.pref.save", userData );
			}
			
			function loadData() {
				function userDataPubSubHandler(e, retrieveData) {
					userData = retrieveData;
				}
				// Right now
				$.publish( "shopping.pref.retrieve", userDataPubSubHandler); 
				
				return userData;
			}
			
			//Function to get and set the user userData
			function getterSetterData(postcode, usage, usageLabel, pricezone,pricezoneLabel,priceformatData) {
				if(arguments.length >= 2) {
					userData = {
						"postcode":postcode,
						"usage":usage,
						"usageLabel": usageLabel,
						"pricezone": pricezone,
						"pricezoneLabel": pricezoneLabel,
						"priceformatData": priceformatData
					};
				}
				return userData;
			}
			
			function overlaySuccessPopulateForm(options) {
			    var form = $(options.formid);
			    if (config.isPricezone) {
			        if (!regionalPriceData) {
			            var regiondata = $('#regional-price-json');
			            if (regiondata.length > 0) {
			                regionalPriceData = regiondata.embeddedData();
			            }
			        }
			        //console.log(regionalPriceData);

				    if (form.size() && typeof userData !== 'undefined' && userData != null &&
                        userData.pricezone != null && userData.pricezone !== '' && userData.usage != null && userData.usage !== '') {


				        //form.find('select[name=pricezone]').val(userData.pricezoneLabel).select();
				        for (var regionName in regionalPriceData) {
				            if (regionName && regionalPriceData[regionName]) {
				                var gotRegion = false;
				                $.each(regionalPriceData[regionName], function (i, region) {
				                    if (region.id === userData.pricezone) {
				                        form.find('select[name=pricezone]').val(regionName).select();
				                        gotRegion = true;
				                        return false;
				                    }
				                });
				                if (gotRegion) {
				                    break;
				                }
				            }
				        }
				        
				        var $usage = form.find('input[name=usage]');
				        if ($usage.length) {
				            $usage.filter('[value=' + userData.usage + ']')[0].checked = true;
				        }

				        if ($.mobile) {
				            form.find('select[name=pricezone]').selectmenu('refresh');
				            $usage.checkboxradio('refresh');
				        }
				    }				    
				}
				else {				    
				    if (form.size() && typeof userData !== 'undefined' && userData != null &&
                        userData.postcode != null && userData.postcode !== '' && userData.usage != null && userData.usage !== '') {
				        form.find('input[name=postcode]').val(userData.postcode).select();
				        var $usage = form.find('input[name=usage]');
				        if ($usage.length) {
				            $usage.filter('[value=' + userData.usage + ']')[0].checked = true;
				        }


				    }
				}
			}
            			
			//Function to get and set the user userData
			function asyncUserData(options, change) {
				var userDataChangeEvent = 'userchangesuccess' + suffix,
					userCancelOverlay = 'overlay.usercancel',
					callbacks = [],
					doneCallback;						
				
				//This function is called during events other than page load.
				fromCookie = false;
				
				//Special for Flash
				if( $.isPlainObject( options ) ) {  
					
					if( $.isFunction( options.complete ) ) {
						callbacks.push(options.complete);					
					}
					
					//isFlash implied
					if( options.flashid ) {
										
						callbacks.push(function() {
							//Line of code mutated original from jQuery.swfobject
							var toSend, elem = $('#'+options.flashid).find('object').andSelf().filter('object').get(0);
							
							try {
								//Use External JavaScript API which should be exposed by the Flash Application
								toSend = $.extend({}, userData);
								if( toSend.derivatives ) {
									delete toSend.derivatives;
								}
								elem.message('postcode', JSON.stringify(toSend));							
							} catch( e ) {
								//console.log( "Error messaging flash id = " + options.flashid );						
							}
						});
						
					}
				}

				if ((config.formURL || config.regionformURL) && (change || !userData)) {
					
					//Complete
					doneCallback = function() {
						$.unsubscribe(userDataChangeEvent, doneCallback);
						$.unsubscribe(userCancelOverlay, doneCallback);
						$.each(callbacks, function(i, fn) {
							fn.apply(fn, [loadData()]);
						});
					};				
					$.subscribe(userDataChangeEvent, doneCallback);
					$.subscribe(userCancelOverlay, doneCallback);
						
					//Launch overlay for GUX
					if (typeof guxApp !== 'undefined') {
						$.publish('overlay.launchgux', {
						    url: config.isPricezone?config.regionformURL:config.formURL,
							positionType:'window',
							name: "POLK Select Postcode", 
							success : function() {
								internalAPI.overlayLaunched = true;
							}
						});
					} else {
						$.publish('overlay.launch', {
						    url: config.isPricezone?config.regionformURL:config.formURL,
							positionType:'window',
							name: "POLK Select Postcode", 
							success : function() {
								internalAPI.overlayLaunched = true;
							}
						});
					}
					
				} else {
					$.each(callbacks, function(i, fn) {
						fn.apply(fn, [loadData()]);
					});
				}
				
			}
			
			/* Expose API method to Flash
			 * 
			 * Default usage 
			 * requestChangePriceUserData( {
			 * 		flashid:'flashid',
			 * 		complete: function() { .. }
			 * );
			 * 
			 * From Flash
			 * requestChangePriceUserData( 'flashid', true, function() { .. })
			 */
			exportsAPI.requestPriceUserData = function(optionsOrString, isFlash, complete, change) {
				
				if( isFlash && typeof optionsOrString == "string" ) {
					optionsOrString = {"flashid":optionsOrString};
					optionsOrString.complete = complete;
				}
				
				asyncUserData(optionsOrString, change);
			};

			/*
			 * Add some curry, Expose another API method to Flash
			 */
			exportsAPI.requestChangePriceUserData = function(optionsOrString, isFlash, complete) {
				exportsAPI.requestPriceUserData(optionsOrString, isFlash, complete, true);
			};
			
			/*
			 * Sohrab: Add some soup, Expose another API method for build and price
			 * 
			 * must pass a callback function as options.complete to handle result
			 */
			exportsAPI.requestChangePriceBuildAndPrice = function(options, change) {
				exportsAPI.isBuildAndPrice = ND.API.isBuildAndPrice = true;
				config.isPricezone=false;
				asyncUserData(options, change);
			};
			
			/*
			 * Sohrab: Ask the service to read the cookie and return the values
			 * 
			 */
			exportsAPI.requestCookieValuesBuildAndPrice = function(options) {
				if (options.complete) {
					$.publish( "shopping.pref.retrieve", function(e, userData) {
						options.complete.apply(options.complete, [userData]);
					}); 
				}
			};
			
			function listenForm(form){
				
				ND.polk.bindAdditionalListeners(form);
				
				//Listen for form events
				$( document ).off( 'submit', form).on( 'submit', form,  function(e) {

					var $form = $(this), postcode, usage, jUsage, usageLabel, pricezone, pricezoneLabel, pricezoneValue;
					
					working = false;
					e.preventDefault();
					//console.log('listenForm-> form submit');
					//grab local 
					postcode = $form.find('[name=postcode]').val();
					jUsage = $form.find('[name=usage]:checked');
					usage = jUsage.val();
					pricezoneValue = $form.find('[name=pricezone]').val();
					pricezoneLabel = $form.find('[name=pricezone]').find('option:selected').text();

					
				    //Validate Form
					if (config.isPricezone) {
					    if ($.trim(pricezoneValue).length > 0 && usage && regionalPriceData && regionalPriceData[pricezoneValue]) {
					        var priceformatData;
					        $.each(regionalPriceData[pricezoneValue], function (i, region) {
					            if (region.type === usage) {
					                pricezone = region.id;
					                config.priceformatter = ND.PriceFormatter;
					                config.priceformatter.initialise({
					                    data: region.priceFormat,
					                    formatString: region.currencySymbol,
					                    centsSeparator: region.monetaryDecimalSeparator,
					                    thousandsSeparator: region.groupingSeparator
					                });
					                priceformatData = region.priceFormat + "|" + region.currencySymbol + "|" + region.monetaryDecimalSeparator + "|" + region.groupingSeparator;
					                return false;
					            }
					        });
					        usageLabel = $("[for=" + jUsage.attr("id") + "]").attr('title');
					        getterSetterData(postcode, usage, usageLabel, pricezone, pricezoneLabel,priceformatData);
					        getPrices();
					    } else {
					        $.publish('usererror' + suffix);
					    }
					}
					else {
					    if ($.trim(postcode).length === 4 && !isNaN(postcode) && usage) {


					        usageLabel = $("[for=" + jUsage.attr("id") + "]").attr('title');

					        getterSetterData(postcode, usage, usageLabel);
					        getPrices();

					    } else {
					        $.publish('usererror' + suffix);
					    }
					}


					return false;
				});
				
				
			}
			
			
			//Clear for persistant user userData on error
			//$.subscribe('error' + suffix, clearData);
			
			
			//Return Obj with public methods
			return {
				init:function(dlist, options){
					var that = this;
					
					userData = null;
				
					that.options = options = $.extend({}, defaults, options, { formid: config.isPricezone ? defaults.regionformid : defaults.formid });
					
					//The housing for Need Price
					that.needprice = $(options.needprice);
					
					//Setup click events
					that.needprice.on( 'click', options.getpostcodeusage, function(e){
						e.preventDefault();
						asyncUserData(null, true);
					});
					
					//Store derivative array
					derivativeList = dlist;
					
					
					//Enable listening to the form submit events
					listenForm( options.formid );
					
					//Compile main price template
					that.tmpl = $(options.tmpl).template();

					//Listen to change postcode event
					$.subscribe('userchange' + suffix, function(event, data){
						//Notify the price updater that there is impending change to prices.
//						console.log('load in progress');
//						that.update({
//							loading:'true'
//						});
					});
			
						
					//Listening for the if the form is existing, the data will popup
					$.subscribe('overlay.success', function(){
						//overlaySuccessPopulateForm(options.formid);
						overlaySuccessPopulateForm(options);
						ND.polk.bindAdditionalListeners(options.formid);
					});
					
					//used for mobile to unsubscribe events and remove listeners
					$.subscribe('destroy' + suffix, function() {
						//console.log('ND.CalcPrice.destroy');
						for( var channel in that.pubsub ) {
							$.unsubscribe( channel + suffix, that.pubsub[channel] );
						}
						
						$( document ).off('submit', $(that.options.formid));
						that.needprice.off( 'click', that.options.getpostcodeusage);
						that.needprice.empty();
						
					});
					
					
					if (derivativeList.length === 0) {
						return;
					}
					//Check if the page load data exists
					if(!checkData()) {
						//There was no data so initialise the "Want to see prices"
						that.update();
					}

			
				},
				initPriceFormatter: function () {
				    if (userData && userData.priceformatData && config && !config.priceformatter && ND.PriceFormatter) {
				        var pfdata = userData.priceformatData.split('|');
				        if (pfdata.length === 4) {
				            config.priceformatter = ND.PriceFormatter;
				            config.priceformatter.initialise({
				                data: pfdata[0],
				                formatString: pfdata[1],
				                centsSeparator: pfdata[2],
				                thousandsSeparator: pfdata[3]
				            });
				        }
				    }
				},

				update:function(otherData, visual){
//					console.log('priceUserDataManager.update()');
					var that = this, render,
						//Use the error data or the postcode data in the tmpl
						tmplData = otherData || userData;
					
					if( that.needprice ) {
						
						//Render the tempalte with user data
						render = $.tmpl(that.tmpl, tmplData);
						
						if( that.previousLinks && that.previousLinks.length ) {

							//Replace It (had an issue with $.fn.replaceWith function)
							that.previousLinks.remove();
							that.needprice.append(render);
							that.previousLinks = render;
							
						} else {
							
							//Inject a new element
							if (typeof guxApp !== 'undefined') {
								that.needprice.html(render);
							} else {
								that.needprice.append(render);
							}
							that.previousLinks = render;
							
						}
						
						if( visual && !fromCookie) {
							// Was getting the following error. "Error: uncaught exception: [Exception... "Could not convert JavaScript argument arg 0 [nsIDOMViewCSS.getComputedStyle]"  nsresult: "0x80570009 (NS_ERROR_XPC_BAD_CONVERT_JS)"  location: "JS frame :: http://ftd-trunk-carve.local/themes/ftd/js/live/dev.debug.js :: anonymous :: line 5491"  data: no]"
							// So I get the element in a new jQuery selection
							ND.polk.showChangeVisually($(that.previousLinks.get(0)));
						}
						
						ND.polk.templateUpdated(that.needprice);
					}				
				},
				visualUpdate: function( otherData ) {
//					console.log('priceUserDataManager.visualUpdate()');
					this.update( otherData, true );
				},
				fromCookie: function() {
					return !!fromCookie;
				},
				//error validation
				displayMsg: function(msg) {
					$form = $(priceUserDataManager.options.formid);
					formError = $form.find('.error');
					

					
					
					if (defaultFormErrorMsg == null) {
						defaultFormErrorMsg = $form.find('#standard-error').text();
					}
					formError.text(msg ? msg : defaultFormErrorMsg);
					formError.filter(":hidden").slideDown('fast');
				},
				loading: function(show) {
					$form = $(priceUserDataManager.options.formid);
					if (show) {
						$form.find('.error').hide();
						$form.find('.loading').filter(":hidden").slideDown('fast');
						$form.find('button[type=submit]').attr('disabled', true);
					} else {
						$form.find('.loading').hide();
						$form.find('button[type=submit]').removeAttr('disabled');
					}
					
				},
				locationValue: function () {
				    if (userData) {
				        if (config.isPricezone) {
				            return userData.pricezoneLabel + ' ' + userData.usageLabel;
				        }
				        else {
				            return userData.postcode + ' ' + userData.usageLabel;
				        }
				    }
				    return '';
				},
				getData: loadData,
				setData: storeData
			};
		
		}()),	// end priceUserDataManager
		
	
		/*
		 * Global Pubsub channels for this module
		 */
		pubsub = {
		
			/* Subscribe
			 * @input Object - {"postcode": "3000","usage": "p"}
			 * eg. $.publish('userchange.calculateprice.dfy', {"postcode": "3000","usage": "p"});
			 */	
			userchange: function(event, data){
				
				//Integritry Check
			    if (!config.dataURL && !config.isPricezone) {
					$.publish('error' + suffix, 'There was a problem.');
					//console.log("Missing config.dataURL");
					return;
				}
				
				
				function error( text ) {
					$.publish('change' + suffix, {error:true, errorMessage:'System error.'});
					$.publish('error' + suffix, text);
				}

				
				if( data && data.payload ) {
					priceUserDataManager.loading(true);
					//If there is no derivatives on the page. Skip the AJAX call
//					if ( data.payload.derivatives && data.payload.derivatives.length ) {
				    //We have enough information to calculate the prices

					if (config.isPricezone) {
					    
					    if ($('#rest-services').length > 0) {
					        var dataURL = $('#rest-services').embeddedData()['pricezone.derivatives'];
					        if (dataURL) {
					            $.ajax({
					                type: 'GET',
					                url: dataURL.replace('{site}', config.site).replace('{pricezoneId}', data.payload.pricezone).replace('{modelId}', priceUpdater.modelId()),
					                dataType: 'json',
					                complete: function (xhr, text) {
					                    $.publish('get' + suffix, text);
					                },
					                success: function (data) {
					                    var results = {};
					                    if (data && data.length > 0) {
					                        if (!config.priceformatter) {
					                            priceUserDataManager.initPriceFormatter();
					                        }
					                        var list = $.map(data, function (d) {
					                            if (!d.displayPrice) {
					                                if (config.priceformatter) {
					                                    d.displayPrice = config.priceformatter.format(d.price);
					                                }
					                            }
					                            return d;
					                        });
					                        results.error = false;
					                        results.derivatives = list;
					                    }
					                    else {
					                        results.error = true;
					                        results.errorMessage = $('form.calc-price-user p.error').html();
					                    }
					                    $.publish('change' + suffix, results);
					                },
					                error: function (xhr, text) {
					                    error(text);
					                }
					            });
					        }
					    }
					}
					else {

					    $.ajax({
					        type: 'POST',
					        url: config.dataURL,
					        cache: false,
					        headers: {
						        'Cache-Control': 'no-cache'
						    },
					        data: {
					            "data": JSON.stringify(data.payload)
					        },
					        complete: function (xhr, text) {
					            $.publish('get' + suffix, text);
					        },
					        success: function (data) {
					            $.publish('change' + suffix, data);
					        },
					        error: function (xhr, text) {
					            error(text);
					        },
					        dataType: 'json'
					    });
					}


//					} else {
//						$.publish('change' + suffix);
//					}
			
				} else {
					error("no payload");
				}
			},
			
			/*
			 * Subscribe Price changes
			 */
			change: function(event, data){
				data = data || {};
				priceUserDataManager.loading(false);
				//Data Integrity check
				if( !data.error ) {
					
					$.publish('userchangesuccess' + suffix, data);

					//hide the overlay only if polk overlay is open.
					if (internalAPI.overlayLaunched) {
						//Hide overlay for GUX
						if (typeof guxApp !== 'undefined') {
							$.publish('overlay.hidegux');
						} else {
							$.publish('overlay.hide');
						}
					}
					
				} else {
					
					//Update with the error data (Normalise the error).
					//priceUserDataManager.visualUpdate({error:data.errorMessage});
					//priceUpdater.notifyChange();
					$.publish('usererror' + suffix, data.errorMessage || 'Error');
				}
				
			},
			
			userchangesuccess: function(event, data) {
				//Normalise the prices object for ND.priceUpdater
				var prices = {};
				$.each(data.derivatives || [], function(i, obj){
					prices[obj.id] = obj;
				});
				
				//Update the disclaimer links
				priceUserDataManager.visualUpdate();
				
				//Update the prices on the page
				priceUpdater.update(prices, !priceUserDataManager.fromCookie());
				priceUserDataManager.setData();
			},
			
			usererror: function(event, data){
				//console.log('usererror: ' + data);
				priceUserDataManager.displayMsg(data );
				
			},
			
			loading: function(event, data) {
				//console.log('loading: show: ' + data);
				priceUserDataManager.loading(data);
			}
			
		};			

	// Initalise pubsub!
	for( var channel in pubsub ) {
		$.subscribe( channel + suffix, pubsub[channel] );
	}
	
	// Dynamic confi URLs
	exports.conf = function(obj) {
		var urls = obj || $('#price-urls').embeddedData();
		config.dataURL = urls['xhr-calcprice-data'] || config.dataURL;
		config.formURL = urls['xhr-calcprice-form'] || config.formURL;

		config.regionformURL = urls['xhr-regionalprice-form'] || config.regionformURL;
		config.isPricezone = (config.regionformURL && config.regionformURL.length > 0);

		config.site = $('#common-config').embeddedData().site;
		config.priceformatter = null;
	};
	
	// Constructor of sorts
	exports.init = function() {
		//console.log('ND.CalcPrice.init()');
		this.conf();
		// Init Dynamic URLs AND (Check make sure not in test suite);
		if ((!config.isPricezone && !config.dataURL && !config.formURL) || (config.isPricezone && !config.regionformURL)) {
			return; 
		}
		
		//Objects are singleton (single-use-only)
		priceUpdater.init();
		var derivativeList = priceUpdater.list();
		priceUserDataManager.init(derivativeList);
	};
	
	/* end */
	
	//Expose Price Calculator
	ND.CalcPrice = exports;

	//Expose Price Calculator API methods
	ND.API = $.extend(ND.API, exportsAPI);
	
}(jQuery));


/**
 * @author Sohrab Zabetian
 * 
 * added a utility that contains utility methods accessible across the site
 * 
 */

var ND = window.ND = window.ND || {};

ND.Utils = window.ND.Utils = window.ND.Utils || {};
/**
 * 
 * @returns if the device is an ipad/ipod/iphone
 */
ND.Utils.isTouchDevice = function() {
	if (/iPhone|iPad|iPod/.test(navigator.platform) || 
	   (Modernizr !== undefined && Modernizr.touch)) {
		return true;
	}
	return false;
}

/**
 * 
 * lazily loads an image. Requires the following setup
 * <div data-src="image url" data-alt=" optional name" class="thumb-lazy" >&nbsp;</div>
 * An image tag is created and injected into the div.
 * 
 */
ND.Utils.lazyLoadImage = function(selector) {
	$(selector ? selector : 'div.thumb-lazy').each(function() {
	    var $div = $(this);
	    var src = $div.data('src');
	    var img = new Image();
		
		// call this function after it's loaded
		img.onload = function() {
			// make wrapper fully visible
			$div.html(img);
			img.alt = $div.data('alt');
		};
		// begin loading the image from www.flickr.com
		img.src = src;
		
	});
}




//create by biaoqu

ND.expandTable = ( function($, undefined) {

		expandTable = {

			init : function() {

				//this.repositionlinks();
				var self=this;
				$wait(function(){
				self.expandinit();
				self.expanddivinit();
				self.splitedivcolor();
				self.divexpandall();
				self.collapseall();
				self.initreset();
				self.syncdropdown();
				self.spliterow();
				self.reHeightsublogo();
				})
				
				

			},
			
			reHeightsublogo : function() {
				var sublogoTd = $("td.align-bottom");
				var slheight = 0;
				var sublogo;
				for(var i = 0; i < sublogoTd.size(); i++) {

					
					
					sublogo = $("span.sub-logo", sublogoTd.eq(i));

					if(sublogo.length > 0) {
						
						
						if(sublogo.height() > slheight) {

							slheight = sublogo.height();
						}

					} else {
						$("span.logo", sublogoTd.eq(i)).after("<span class=\"sub-logo\"></span>");
						
					}
				}
				
				$("td.align-bottom .sub-logo").height(slheight);

			},
			repositionlinks : function() {
				var self = this;
				var allbtns = $("#allfeatures .links").children('div');
				var totalRow = Math.ceil(allbtns.size() / 3);
				var divheight=0;
				console.log("number of links: " + allbtns.size());
				for(var i = 0; i < allbtns.size(); i++) {

					var $divs = allbtns.eq(i);
					var diva = $("a", $divs);
					var divspan = $("span", $divs);
					var divArrowSpan = $("span.link-arrow", $divs);
					var divaspan = $("span", diva);
						console.log($divs.height());
					
					if($divs.height()>divheight){
						divheight=$divs.height();
					}

					if($("body").hasClass("ltr")) {
						divArrowSpan.css({
							"left" : divaspan.width() + 48
						});
					} else if($("body").hasClass("rtl")) {
						divArrowSpan.css({
							"right" : divaspan.width() + 58
						});
					}
				}
				allbtns.height(divheight);

				allbtns.children("a").height(divheight);

				for (var n = 0; n < allbtns.size(); n++) {
					
					var $divs = allbtns.eq(n);
					var diva = $("a", $divs);
					var divspan = $("span", $divs);
					var divArrowSpan = $("span.link-arrow", $divs);
					var divaspan = $("span", diva);
					
					var mtop = Number(diva.height() - divspan.height()) / 2+1;
					divspan.css({
						"margin-top" : mtop
					});
				}
				self.addsyncdropdownwidth();

			},
			addsyncdropdownwidth:function(){
				var allbtns = $("#allfeatures .links").children('div');
				for (var n = 0; n < allbtns.size(); n++) {
				
					if(n%3!==2){
						if ($("body").hasClass("ltr")) {
							allbtns.eq(n).css({
								"margin-right": 52.5
							})
						}else if ($("body").hasClass("rtl")) {
							allbtns.eq(n).css({
								"margin-left": 52.5
							})
						}
					}
				
				}
			},
			spliterow : function() {
				var self = this;
				var cols2row = $(".cols2>div");
				for(var i = 0; i < cols2row.size(); i++) {

					self.reHeightCols(cols2row.eq(i), 2, 10);

				}

				var cols3row = $(".cols3>div");

				for(var n = 0; n < cols3row.size(); n++) {

					self.reHeightCols(cols3row.eq(n), 3, 0);

				}
			},
			reHeightCols : function(divs, cols, space) {

				var self = this;
				var allclos = $(".top", divs);
				var totalcolsrow = Math.ceil(allclos.size() / cols);

				for(var n = 0; n < totalcolsrow; n++) {

					self.reheightdivs(n, cols, allclos, space);
				}

			},
			reheightdivs : function(rowindex, cols, allbtns, space) {

				var divsheight = 0;
				var tempcols = cols;
				if((rowindex + 1) * cols > allbtns.size()) {
					tempcols = allbtns.size() - rowindex * cols;
				}

				for(var i = 0; i < tempcols; i++) {
					var $divindex = i + i * rowindex;
					var $div = allbtns.eq($divindex);
					if($div.height() > divsheight) {
						divsheight = $div.height();
					}

				}
				divsheight = divsheight + space;

				for(var m = 0; m < tempcols; m++) {
					var $divindex = m + m * rowindex;
					var $div = allbtns.eq($divindex);

					$div.height(divsheight);
					$div.children("a").height(divsheight);
				}
			},
			syncdropdown : function() {
				var self = this;
				$("#allfeatures").bind("click", function(e) {

					if($("#allfeatures .links").is(":hidden")) {

						$("#allfeatures .links").show();
						$("#allfeatures .header>span").removeClass("closed");
						$("#allfeatures .header>span").addClass("expand");
						self.repositionlinks();

					} else {

						$("#allfeatures .links").hide();
						$("#allfeatures .header>span").removeClass("expand");
						$("#allfeatures .header>span").addClass("closed");
					}

				})
			},
			nIntervId : Number,
			initreset : function() {

				var self = this;

				self.spliteswitch();
			},
			spliteswitch : function() {
				var self = this;
				var $switch = $(".sync_generic .switch");
				for(var i = 0; i < $switch.size(); i++) {

					self.resetswitchPosition($switch.eq(i));
				}
			},
			resetswitchPosition : function($switch) {

				

				var self = this;
				//var $switch=$(".sync_generic .switch");
				var nubs =$("li", $switch).size(); 
				
				var lis = $("li", $switch);
				var totalwid = 0;

				for(var n = 0; n < nubs; n++) {

					totalwid += Number($(lis).eq(n).width());

				}
				

				if(totalwid > 0) {

					

					var pading = Math.round((960 - totalwid) / (nubs - 1));

					for(var m = 0; m < nubs - 1; m++) {

						lis.eq(m).attr("style", "margin-right:" + pading + "px");

					}

				}

			},
			divexpandall : function() {

				var self = this;
				$("#divexpandall").bind("click", function(e) {

					var expandObj = $(".comparator_content");
					var expandicon = $(".expanddiv .head.c-table-title");

					expandObj.show();
					expandicon.removeClass("comparator_icon_right");
					expandicon.addClass("comparator_icon_down");

				})
			},
			collapseall : function() {

				var self = this;
				$("#divcollapseall").bind("click", function(e) {

					var expandObj = $(".comparator_content");
					var expandicon = $(".expanddiv .head.c-table-title");

					//console.log(expandicon);

					expandObj.hide();
					expandicon.removeClass("comparator_icon_down");
					expandicon.addClass("comparator_icon_right");

				})
			},
			splitedivcolor : function() {

				/*var $colordiv=$(".comparator_content .derivative");
				 for(var i=0;i<$colordiv.length;i++){

				 $curcs=$colordiv.eq(i);

				 var $colorsdiv= $("*",$curcs);

				 for(var n=0;n<$colorsdiv.length; n++){
				 if(n%2==1){

				 $colorsdiv.eq(n).addClass("comparator2bgcolor");
				 }

				 }

				 }*/

			},
			expandinit : function() {
				var self = this;
				$(".expandtable>thead").bind("click", function(e) {

					var $this = $(this).parent();
					var $head = $(this);
					var expandObj = $("tbody", $this);
					var expandicon = $("th", $head);

					//console.log(expandicon);

					if(expandObj.is(":hidden")) {

						expandObj.show();
						expandicon.removeClass("comparator_icon_right");
						expandicon.addClass("comparator_icon_down");

					} else {

						expandObj.hide();

						expandicon.removeClass("comparator_icon_down");
						expandicon.addClass("comparator_icon_right");

					}

				})
			},

			expanddivinit : function() {
				var self = this;
				$(".expanddiv .head.c-table-title").bind("click", function(e) {

					var $this = $(this).parent();

					var expandObj = $(this).next("div");
					var expandicon = $(this);

					if(expandObj.is(":hidden") == true) {

						expandObj.show();
						expandicon.removeClass("comparator_icon_right");
						expandicon.addClass("comparator_icon_down");

					} else {

						expandObj.hide();

						expandicon.removeClass("comparator_icon_down");
						expandicon.addClass("comparator_icon_right");

					}

				})
			}
		};

		return function(arg) {
			var expand = Object.create(expandTable);
			expand.init.call(expand, arg);
			return expand;
		};

	}(jQuery)); 


/**
 * @author biaoq
 */




ND.ResizeHeadline = (function($, undefined){



ResizeHeadline={
	

	
	init: function() {
	
	var myhdline=$(".leftpanel");
	
	for(var i=0;i<myhdline.length;i++){
		
		var myhead=$("h3",$(myhdline[i]))
		//console.log(myhead.height());
		if(myhead.height()>39){
		
		myhead.parent().addClass("c520featuretwoline");
	}
	}
	
	
	
	}
	
};

return function( arg ) {
		var rehd = Object.create( ResizeHeadline );
		rehd.init.call( rehd, arg );
		return rehd;
	};

}(jQuery));


ND.fleetTabs = ( function($, undefined) {
	
	 fleetTabs = {
    
        init: function(){
			
			var self=this;
			self.inittabscss();
			self.tabscontrol();
			self.closeTabs();
			self.repositionThumbs();
			
        },
		repositionThumbs:function(){
            
            if ($("#thumbs").length > 0) {
               
				var totalsize=$(".fleet_tabs_content>div").size();
                for (var n = 0; n < totalsize; n++) {
                
				    var currentThumb=$(".fleet_tabs_content>div").eq(n);
					
                    var thumbs = $("#thumbs li",currentThumb);
                    var tbindex = 0;
                    for (var i = 0; i < thumbs.size(); i++) {
                        tbindex++;
						
                        if (tbindex % 4 == 0) {
							
                            thumbs.eq(i).css("margin-right", "0px");
                            thumbs.eq(i).css("margin-left", "0px");
                        }
                        
                    }
                    
                }
                
                
                
            }
			
		}
		,
		inittabscss:function(){
			
			$("#fleet_tabs>ul>li").eq(0).addClass("tab_blue");
			$("#fleet_tabs>ul>li").eq(1).addClass("tab_grey");
			$("#fleet_tabs>ul>li").eq(2).addClass("tab_yellow");
			$("#fleet_tabs>ul>li").eq(3).addClass("tab_dark");
			
			$("#fleet_tabs .fleet_tabs_content>div").eq(0).addClass("tab_blue");
			$("#fleet_tabs .fleet_tabs_content>div").eq(1).addClass("tab_grey");
			$("#fleet_tabs .fleet_tabs_content>div").eq(2).addClass("tab_yellow");
			$("#fleet_tabs .fleet_tabs_content>div").eq(3).addClass("tab_dark");
		}
		,
		tabscontrol:function(){
			
			$("#fleet_tabs>ul>li").bind("click",function(){
				
				var curelmts=$(this);
				var currentID=curelmts.attr("id");
				var contents=$(".fleet_tabs_content>DIV");
				var curcontID="DIV#"+currentID;
				var btns=$("#fleet_tabs>ul>li");
				var currentContent=$(curcontID);
				btns.removeClass("active");
				contents.removeClass("active");
				currentContent.addClass("active");
				curelmts.addClass("active");
				
				$("#fleet_tabs SPAN.close").css({"visibility":"visible"});
				
				
			})
		},
		closeTabs:function(){
			$("#fleet_tabs SPAN.close").bind("click",function(){
				var contents=$(".fleet_tabs_content>DIV");
				var btns=$("#fleet_tabs>ul>li");
				contents.removeClass("active");
				btns.removeClass("active");
				$("#fleet_tabs SPAN.close").css({"visibility":"hidden"});
			})
		}
    };
    
    
    return function(arg){
        var ftabs = Object.create(fleetTabs);
        ftabs.init.call(ftabs, arg);
        return ftabs;
    };
	
}(jQuery)); 


/*
 * Description: B299 Experience
 * Project: B299
 * Author: Biao Qu
 */
ND.Experienceb299 = (function($,Number, undefined){

    Experienceb299 = {
    
        init: function(){
        
        
            var self = this;
			
			//self.removeVideo();
			
			$(".experienceb299 #hotspot>#video-inner").remove();
			$wait(function(){ 
			
			//self.ckvideoready();
			self.pageGuide();
			
			})
           
			
            
        },
		initcssthing:function(){
			
			
			
		},
		isclickvideo:false,
		ckvideoready:function(){
			var self=this;
			var isckvideono=setInterval(function(){
				
				if(typeof jwplayer!== 'undefined'){
					
					clearInterval(isckvideono);
					self.removeVideo();
					
					
					
				}
			},10);
			
		}
		,
		initLanding:function(){
			var self=this;
			
			$('.kwicks').kwicks({
                    size: 231,
                    maxSize : 372,
					//minSize:231,
					duration:500,
                    spacing : 0,
                    behavior: 'menu',
					easing:'swing',
					autoResize:false
                });
				
			$(".video-indicator").bind("click",function(){
            
			   
					self.removeVideo();
					
					
				
			})
			$('.kwicks').on('expand.kwicks', function(e, data) {
				var curentget=$(".kwicks li").eq(data.index);
				
				
			})
			
			
			
			$('.kwicks>li').hover(function(){
					
                if ($(this).index() != 0) {
                    $(this).addClass("hover");
                    $('.kwicks>li').eq($(this).index() + 1).addClass("hover");
                }else{
					
					$('.kwicks>li').eq($(this).index() + 1).addClass("hover");
				}
				
				$('.kwicks>li').removeClass("active");
				self.updateLdHoverdir($(this).index());
			},function(){
				
				$('.kwicks>li').removeClass("hover");
				self.kwicksactive();
				//self.updatekwiksDir(self.timezone);
			})
			
			$(".kwicks>li").live("click",function(){
				
				if(self.hasClickedLi==false){
				self.hasClickedLi=true;
				self.initSilderPage($(this).index());
				
				}
			})/*end click*/
			
			self.kwicksactive();
			
			///goto deep link page
				
            var pagelink = window.location.href;
            if (pagelink.indexOf("#expage") != -1) {
            
               self.isdeeplink = true;
			   self.gotoDeeplink();
               
            }
            else {
            
                self.isdeeplink = false;
            }
				
			
			
			
		}
		,
		hasClickedLi:false
		,
		updateLdHoverdir:function(index){
		
		  var selectedindex=$(".kwicks-selected").index();
		  if(selectedindex==1 || selectedindex==2){
		     if(index>selectedindex){
			 
			 $(".kwicks-selected .pagetip>img").css({"float":"right"});
			 
			 }else if(index<selectedindex){
			 
			 $(".kwicks-selected .pagetip>img").css({"float":"left"});
			 
			 }
		  }
		}
		,
		initSilderPage:function(index){
			var self=this;
			$('.kwicks>li').removeClass("active");
            $('.kwicks>li').eq(index).addClass("active");
				
			self.timezone=index;
			
             //$('.kwicks>li').unbind("hover");
			self.initbxslider();
			self.showSilderPage();
			self.updatekwiksDir(index);
		}
		,
		showSilderPage:function(){
			var self=this;
			var deepsetInterval = window.setInterval(function(){
               
                if (self.isloaded === true) {
                    window.clearInterval(deepsetInterval);
                    $("#leftanimate").animate({
                        "top": "-580px"
                    }, 500, function(){
                        $(".experienceb299 #pager").show();
                        
                    });
                }
                
            }, 100)
			
			
			
		}
		,
		kwicksactive:function(){
			
			$(".kwicks>li").each(function(index){
				
				if($(".kwicks>li").eq(index).hasClass("kwicks-selected")){
					
					$(".kwicks>li").eq(index).addClass("active");
					$(".kwicks>li").eq(index+1).addClass("active");
				}
				
			})
		}
		,
		updatekwiksDir:function(index){
			
			$(".kwicks>li").removeClass("right");
			
            
            if (index == 3) {
            
                //$(".kwicks>li").eq(2).addClass("right");
                $(".kwicks>li").eq(3).addClass("right");
                
            }
            else if (index == 2) {
                $(".kwicks>li").eq(3).addClass("right");
                
                }
                else if (index == 1) {
                        $(".kwicks>li").eq(2).addClass("right");
                        $(".kwicks>li").eq(3).addClass("right");
                    }
                    else if (index == 0) {
                            $(".kwicks>li").eq(1).addClass("right");
                            $(".kwicks>li").eq(2).addClass("right");
                            $(".kwicks>li").eq(3).addClass("right");
                            
                        }
		},
        pageIndex: Number = 0,
        thumbIndex: Number = 0,
        thumbgroupIndex: Number = 0,
        slider: {},
        deepthumb: {},
        dtgroup: {},
        isdeeplink: false,
        ispreClick: false,
        isloaded: false,
        isend: false,
        isfirst: false,
        contentslider: {},
		epreslider:{},
        isNext: false,
        isPre: false,
		timezone:Number=0
		,
		gototilePage:function(){
			var self=this;
			//self.initbxslider();
			$(".experienceb299 .kwicks").fadeOut(function(){
				
				$(".experienceb299 .kwicks").remove();
			});
			
			$(".experienceb299 #titleslider").fadeIn();
			
			
			
			
			
		},
        initbxslider: function(){
        
            var self = this;
            
            self.slider = $('#titleslider').bxSlider({
            
                mode: "vertical",
                pager: false,
                controls: false,
                preloadImages: 'all',
                //easing:"ease",
				touchEnabled:false,
				startSlide:self.timezone,
                onSlideAfter: function(){
                
                    
					
					var currentcs = self.slider.getCurrentSlide() + 1;
                    var elmts = $("#contentslider", $(this));
					
					//$(".experienceb299 #hotspot").hide();
					
                    $("#sliderconatiner>div.bx-wrapper>div.bx-controls>DIV.bx-controls-direction").hide();
                    
                    /*if (self.contentslider.destroySlider) {
                        self.contentslider.destroySlider();
                    }
					
                    self.initcontentslider(currentcs);*/
					if (self.epreslider.destroySlider) {
                        self.epreslider.destroySlider();
                    }
					self.ispagerclicked=false;
					self.updatepager();
					self.pageIndex=self.slider.getCurrentSlide();
					
					
					///switch thumbs on top charome fix
					var ctspre=self.contentslider.parent().parent().parent();
					var ctwrap=self.contentslider.parent().parent();
					$(".thumbs",ctspre).before(ctwrap);
					$(".experienceb299 .thumbs").show();
					$("#sliderbtnsnext").show();
					$("#sliderbtnspre").show();
;					self.buildeeplink();

                },
                onSlideBefore: function(){
                    
                    //self.removeVideo();
					$("#sliderbtnsnext").hide();
					$("#sliderbtnspre").hide();
					$("#sliderbtnspre .bx-prev").remove();
					$("#sliderbtnsnext .bx-next").remove();
					$(".experienceb299 .thumbs").hide();
					$(".experienceb299 #hotspot").unbind("hover");
					
                    $("#sliderconatiner>div.bx-wrapper>div.bx-controls>DIV.bx-controls-direction").show();
                    var currentcs = self.slider.getCurrentSlide() + 1;
                    /*if (self.contentslider.destroySlider) {
                        //self.contentslider.destroySlider();
                    }*/
					self.epreslider=self.contentslider;
					self.pageIndex=self.slider.getCurrentSlide();
                    self.initcontentslider(currentcs);
					
                },
                onSliderLoad: function(){
                    
                    var currentcs = parseInt(self.slider.getCurrentSlide()) + 1;
                    var elmts = $("#contentslider", $(this));
                    self.pageIndex=self.timezone;
					self.initpager();
                    self.initcontentslider(currentcs);
                    
					
                   
					
                },
                onSlidePrev: function(){
                   
                    self.isNext = false;
                    self.isPre = true;
                    
                   
                },
                onSlideNext: function(){
                
                   
                    
                   //$(".pageitem").show();
                    self.isNext = true;
                    self.isPre = false;
                }
                
            })
        },
		ispagerclicked:false,
		initpager:function(){
			var self=this;
			
			var pageritem="<li></li>";
			$(".experienceb299 #pager li").remove();
			
			for(var i=0;i<self.slider.getSlideCount();i++){
				
				$(".experienceb299 #pager").append(pageritem);
			}
			self.updatepager();
			$(".experienceb299 #pager>li").click(function(e){
			  
               if (($(e.currentTarget).hasClass("active") == false) &&  (self.ispagerclicked==false)) {
			    self.ispagerclicked=true;
			   	$(".thumb>span").removeClass("active");
			   	$(".thumb .rollstate").removeClass("active");
			   	$(".experienceb299 #hotspot").hide();
			   	//$(".pageitem").show();
				self.removeVideo();
				self.slider.goToSlide(parseInt($(this).index()));
				
				}
			})
			$(".experienceb299 .logo").click(function(){
				if (self.slider != {}) {
                        self.slider.destroySlider();
                    }
				if (self.contentslider !={}) {
                        self.contentslider.destroySlider();
                    }
				self.removeVideo();
				//unbind event
				$(".experienceb299 #hotspot").unbind("hover");
				$(".experienceb299 #hotspot .video").unbind("click");
				$("#e299videooverlay .close").unbind("click");
				$(".thumb").unbind("click");
				$(".experienceb299 .bx-prev").unbind("click");
				$(".experienceb299 .bx-next").unbind("click");
				$(".experienceb299 #pager>li").unbind("click");
				$(".experienceb299 .logo").unbind("click");
				$(".experienceb299 #hotspot").unbind("mouseover");
				$(".experienceb299 #hotspot").unbind("mouseleave");
				$("#sliderbtnspre .bx-prev").remove();
				$("#sliderbtnsnext .bx-next").remove();
				$(".experienceb299 #hotspot .video>a").unbind("click");
				//
				$("#leftanimate").animate({
                        "top": "0px"
                    }, 500,function(){
					
					self.hasClickedLi=false;
					self.ispagerclicked=false;
					$(".experienceb299 #pager").hide();
					self.removedeepLink();
					//self.slider.destroySlider();		
					//self.contentslider.destroySlider();	
					
					self.isloaded=false;
                    
                    self.thumbIndex = 0;
                    self.thumbgroupIndex = 0;
                    //self.slider = {};
                    self.deepthumb = {};
                    self.dtgroup = {};
                    self.isdeeplink = false;
                    self.ispreClick = false;
                    self.isloaded = false;
                    self.isend = false;
                    self.isfirst = false;
                    //self.contentslider = {};
                    self.isNext = false;
                    self.isPre = false;
                    //self.timezone = 0;
					
					});
				
			})
			
			
		},
		updatepager:function(){
			var self=this;
			
			var currentPager = self.slider.getCurrentSlide();
			
			$(".experienceb299 #pager>li").removeClass("active");
			$(".experienceb299 #pager>li").eq(currentPager).addClass("active");
			
		},
		clicktrack:function(elment){
                
                    $omidata = $(elment);
                    var $opname = $omidata.attr("data-pname");
                    var $oname = $omidata.attr("data-name");
                    var $otype = $omidata.attr("data-type");
                    var $oclick = $omidata.attr("data-onclicks");
                    var $ohier = $omidata.attr("data-hier");
					var $otool = $omidata.attr("data-tool");
					var $otooldesc = $omidata.attr("data-tooldesc");
                    
                    ND.analyticsTag.trackOmniturePage({
                        pname: $opname,
                        hier: $ohier,
                        onclicks: $oclick,
                        type: $otype,
                        name: $oname,
						tool: $otool,
						tooldesc:$otooldesc
                    });
                    
                
         }
		,
        initcontentslider: function(elmts){
            var self = this;
            
            var ctsld = $('.contentpage').eq(elmts);
            var ctumbs = $('.thumbs').eq(elmts);
            var startindex = 0;
			var dir="pre";
            if (self.ispreClick === true) {
                startindex = 6;
				dir="next";
				
            }
            else {
                startindex = 0;
            }
			if(self.isdeeplink===true){
			   startindex=self.thumbIndex;
			   self.isdeeplink=false;
			}
			//$(".pageitem").show();
			
			
			
            self.contentslider = ctsld.bxSlider({
                //mode: "horizontal",
                pager: false,
                infiniteLoop: false,
                controls: true,
                preloadImages: 'all',
                startSlide: startindex,
				touchEnabled:false,
				nextSelector:$("#sliderbtnsnext"),
				prevSelector:$("#sliderbtnspre"),
				autoDirection:dir,
                // easing:"ease-in-out",
                onSliderLoad: function(currentIndex){
					
                    $("#sliderconatiner>div.bx-wrapper>div.bx-controls>DIV.bx-controls-direction").hide();
                    
					
					self.initcssthing();
				    self.ispreClick = false;
                    self.isloaded = true;
					
                    self.csliderprevent();
                    self.csnextEvent();
                    self.thumbclickevent();
					self.thumbMouseDownup();
                   
					if(startindex==0){
						
						self.hidepreImgs();
					}
					$(".experienceb299 #hotspot .video").unbind("click touchend");
					
                    self.hotspotevt();
                    //self.removeVideo();
                    self.activeCss();
                    
					self.thumbIndex=startindex;
                    self.buildeeplink();
					$(".experienceb299 #hotspot").show();
					var currentelmts=$(".pageitem",self.contentslider).eq(currentIndex);
					self.clicktrack(currentelmts);
					
                },
                onSlidePrev: function(){
                
                
                },
                onSlideBefore: function(){
				
                self.removeVideo();
				self.activeCss();
                },
                onSlideAfter: function(){
					
                    self.isloaded = false;
					$(".experienceb299 #hotspot").show();
					
                    var CurrentS = (self.contentslider.getCurrentSlide());
                    var SlideC = (self.contentslider.getSlideCount() - 1);
                    
                    if (CurrentS == SlideC) {
                    
                        self.isend = true;
                        
                    }
                    else {
                    
                        self.isend = false;
                    }
                    if (CurrentS == 0) {
                    
                        self.isfirst = true;
						
						self.hidepreImgs();
                    }
                    else {
                    
                        self.isfirst = false;
                    }
                    
                   
                    self.removeVideo();
					
                    self.thumbIndex=self.contentslider.getCurrentSlide();
					self.buildeeplink();
					var currentelmts=$(".pageitem",self.contentslider).eq(self.contentslider.getCurrentSlide());
					self.clicktrack(currentelmts);
                }
            });
            
        },
		thumbMouseDownup:function(){
			
			$(".thumb").bind("mousedown", function(event){
				
				
				$(".rollstate",$(this)).addClass("mousedown");
			})
			
			$(".thumb").bind("mouseup", function(event){
				
				
				
			})
		},
		unbindMouseDown:function(){
			
			$(".thumb").unbind("mousedown");
		}
		,
		hidepreImgs:function(){
			var self=this;
			var prentslider=0;//self.slider.getCurrentSlide();
			
			var precontent=$(".contentpage").eq(prentslider);
			var prelastpage=$(".pageitem",precontent).size()-1;
			var clone1=$(".experienceb299 #titleslider .bx-clone").eq(0);
			
			$(".pageitem",clone1).eq(6).show();
			
			
			
		}
		,
        hotspotevt: function(){
        
            var self = this;
            $(".experienceb299 #hotspot").mouseover(function(e){
                e.stopPropagation();
                e.preventDefault();
				$(".experienceb299 #hotspot").removeClass("noopacity");
				var currenthot = $(this);
				var parenthold=$(this).parent();
				
				var currentindex=$(e.currentTarget).index();
				var $small=$("#small", currenthot);
				var $large=$("#large", currenthot);
				
				if ($small.size() > 0) {
                    currenthot.addClass("noopacity");
					$small.stop(true,true).hide(0,function(){
						$large.fadeIn(500);
					});
                    $("#hotspot", parenthold).stop(true,true).animate({
                        'opacity': 0.4
                    }, 500);
                   
                }
            }
			
			)
			
			$(".experienceb299 #hotspot").mouseleave(function(e){
				e.preventDefault();
				e.stopPropagation();
				
				var currenthot = $(this);
				var $small=$("#small", currenthot);
				var $large=$("#large", currenthot);
				$large.stop(true,true).hide(0,function(){
					$small.fadeIn(500);
				});
				
				$(".experienceb299 #hotspot").stop(true,true).animate({
                    'opacity': 1
                }, 500);
			})
			
			
            ///video event
            $(".experienceb299 #hotspot .video>a").bind("click touchend"),function(e){
				e.preventDefault();
				e.stopPropagation();
                
				
			}
            $(".experienceb299 #hotspot .video").bind("click touchend", function(e){
                e.preventDefault();
				e.stopPropagation();
				
				var overlaydiv = '<div id="overlay-ex299"><div id="e299videooverlay">'+'<span class="bg"></span>'+
				'</div></div>';
				var sharebtn=$("#b299videoshare");
				var videodiv='<div id="videopanel"><span class="close"></span><div id="video-inner" class="video inner-video"></div></div>';
                
				var parentDIV =$(".experienceb299 #pager");
				
				var videoConfig = $(".video-config", $(this).parent()).embeddedData();
                self.removeVideo();
				
				var disccont=videoConfig["disclaimer"];
				
				if(typeof disccont === 'undefined'){
					
					disccont="";
				}
				var disclamerp="<p>"+disccont+"</p>"
				$("#e299videooverlay").hide();
				
				
				var exp299overlay=$(".experienceb299 #overlay-ex299");
				
				if(exp299overlay.size()>0){
					
					exp299overlay.remove();
				}
				var ex299vpanel=$(".experienceb299 #videopanel");
				if(ex299vpanel.size()>0){
					
					ex299vpanel.remove();
				}
				var ex299shareDIV=$(".experienceb299 #b299videoshare");
				if(ex299shareDIV.size()>1){
					
					ex299shareDIV.remove();
				}
				var panelpc=$("#videopanel>p");
				if(panelpc.size()>0){
					panelpc.remove();
				}
				
                parentDIV.after(overlaydiv);
				
				$("#e299videooverlay").css({"top":"-700px",'opacity': 0}).show().animate({"top":"0px",'opacity': 1},500,"easeOutQuart",function(){
				
				$("#overlay-ex299").css({"overflow":"visible"});
				parentDIV.after(videodiv);
				$("#videopanel .close").before($(sharebtn).clone());
				$("#videopanel #b299videoshare").before(disclamerp);
                ND.video.init(videoConfig);
				self.videoConrolevnt();
				self.isclickvideo=true;	
				});;
				
                
                
            })
            
        },
		videoConrolevnt:function(){
			var self=this;
			
			
			$("#videopanel .close").click(function(){
					
					$("#overlay-ex299").css({"overflow":"hidden"});
					$("#videopanel").remove();
					$("#e299videooverlay").animate({"top":"-700px",'opacity': 0},500,"easeOutQuart",function(){
						
						$("#overlay-ex299").remove();
						self.removeVideo();
					})
					
					
				});
		}
		,
        activeCss: function(){
        
            var self = this;
            var sindex = parseInt(self.slider.getCurrentSlide()) + 1;
			
			
            var csindex =self.contentslider.getCurrentSlide().toString();
            var csld = $(".experiencepage #contentslider").eq(sindex);
            var ctarget = $(".thumb", csld).eq(csindex);
            $(".thumb>span").removeClass("active");
            $(".thumb>span").removeClass("prechild");
            $(".thumb .rollstate").removeClass("active");
            $(".thumb .rollstate").removeClass("mousedown");
            $(".thumb>span", csld).eq(parseInt(csindex)+1).addClass("prechild");
            
            $(">span", ctarget).addClass("active");
            $(".rollstate", ctarget).addClass("active");
            
            
            ctarget.unbind("mousedown");
            
            
        },
        thumbclickevent: function(){
            
            var self = this;
            $(".thumb").bind("click", function(event){
                event.preventDefault();
                event.stopPropagation();
				
                var $target = $(this);
                var sindex = $("a", $target).attr("data-slide-index");
				self.thumbMouseDownup();
                $target.unbind("mousedown");
                self.isloaded = false;
                
                
                self.contentslider.goToSlide(sindex);
                var CurrentS = (parseInt(self.contentslider.getCurrentSlide()));
                var SlideC = (self.contentslider.getSlideCount() - 1);
                
				if (CurrentS == SlideC) {
                
                    self.isend = true;
                    
                }
                else {
                
                    self.isend = false;
                }
            })
            
        },
        csnextEvent: function(){
            var self = this;
            
            $(".experienceb299 .bx-next").bind("click", function(){
				self.removeVideo();
				var isgocontent=true;
				
                if ((self.contentslider.getCurrentSlide() == (self.contentslider.getSlideCount() - 1)) && (self.isloaded == true)) {
                
				    isgocontent=false;
                    self.isNext = true;
                    self.isPre = false;
                    self.slider.goToNextSlide();
                   
                }
				
				if (self.isend == true) {
                    isgocontent=false;
                    self.isNext = true;
                    self.isPre = false;
                    self.slider.goToNextSlide();
                    self.isend = false;
                    self.isfirst = false;
                    
                }
				
				
				
				
            })
            
            
            
        },
        csliderprevent: function(){
            var self = this;
            
            
            $(".experienceb299 .bx-prev").bind("click", function(){
				self.removeVideo();
				var gocontent=true;
				
                if (self.contentslider.getCurrentSlide() == 0 && self.isloaded == true) {
                
				    gocontent=false;
                    self.ispreClick = true;
                    self.isNext = false;
                    self.isPre = true;
					
                    self.slider.goToPrevSlide();
                }
				if (self.isfirst == true) {
                
                    gocontent=false;
                    self.ispreClick = true;
                    self.isNext = false;
                    self.isPre = true;
                    self.slider.goToPrevSlide();
                    self.isend = true;
                    self.isfirst = false;
                }
				
				
            })
        },
        pageGuide: function(){
        
            var self = this;
            self.getTimezonePage();
            
        },
        /**timezone select*/
        
        getTimezonePage: function(){
            var cd = new Date();
            var ch = cd.getHours();
            var self = this;
            
            
            if (ch >= 4 && ch < 10) {
            
                self.timezone=0;
            }
            else 
                if (ch >= 10 && ch < 16) {
                
                
                    self.timezone=1;
                    
                }
                else 
                    if (ch >= 16 && ch < 22) {
                    
                    
                        self.timezone=2;
                        
                    }
                    else {
                    
                    
                        self.timezone=3;
                    }
			 $('.kwicks>li').eq(self.timezone).addClass("kwicks-selected");
			 self.updatekwiksDir(self.timezone);
			 self.initLanding();
            //
        
        },
        
        /**silder deeplink*/
        
        gotoPage: function(slideindex, thumbindex){
        
            var self = this;
            self.timezone = slideindex;
            self.thumbIndex = thumbindex;
		    
			//$(".kwicks>li").eq(self.timezone).trigger("click");
            self.initSilderPage(self.timezone);
        },
        
        /** deeplink*/
        buildeeplink: function(){
            var self = this;
            var thishref = window.location.href;
            var dpstr = "#expage" + self.pageIndex  + "-" + self.thumbIndex + "b299exp";
            
            if (thishref.toLowerCase().indexOf("#expage") >= 0) {
                //update deep link
                
                var thislink = thishref.substr(0, thishref.indexOf("#expage"));
                var endlink = thishref.substr((thishref.indexOf("b299exp") + 7));
                window.location = thislink + dpstr + endlink;
            }
            else {
            
                //create deep link
                window.location = thishref + dpstr;
            }
            
        },
		removedeepLink:function(){
			
			var self = this;
			var thishref = window.location.href;
			if (thishref.toLowerCase().indexOf("#expage") >= 0) {
			    var thislink = thishref.substr(0, thishref.indexOf("#expage"));
                var endlink = thishref.substr((thishref.indexOf("b299exp") + 7));
				thislink=thishref.substr(0, thishref.indexOf("#exhome"));	
				window.location = thislink +"#exhome"+ endlink;
			}
		}
		,
        gotoDeeplink: function(){
        
            var self = this;
            var pagelink = window.location.href;
            var dstart = pagelink.indexOf("#expage") + 7;
            var dend = pagelink.indexOf("b299exp");
            var deeplinkstr = pagelink.substring(dstart, dend);
            var pages = deeplinkstr.split("-");
            
            self.gotoPage(pages[0], pages[1]);
        },
        /**remove video*/
        removeVideo: function(){
        
            /*if ($(".experienceb299 #video-inner").size() > 0) {
            
                $(".experienceb299 #video-inner").remove();
                
            }
            if ($(".experienceb299 #video-inner_wrapper").size() > 0) {
            
                $(".experienceb299 #video-inner_wrapper").remove();
            }*/
			var vidinner=$("#videopanel #video-inner");
			if (vidinner.size() > 0) {
            
                vidinner.remove();
                
            }
			var vidinnerwrap=$("#videopanel #video-inner_wrapper");
            if (vidinnerwrap.size() > 0) {
            
                vidinnerwrap.remove();
            }
			var vidoex299=$(".experienceb299 #overlay-ex299");
			if(vidoex299.size()>0){
					
					vidoex299.remove();
			}
			var videx299pannel=$(".experienceb299 #videopanel");
			if (videx299pannel.size() > 0) {
			videx299pannel.remove();
			}
            
        },
        /** image loaded callback*/
        imageLoaded: function(){
            var self = this;
            
            
            var currentgroup = $(".thumbgroup").eq(self.thumbgroupIndex);
            var currentDIV = $("#showpanel>div", currentgroup);
            var currentpanel = $("#showpanel", currentgroup);
            //currentpanel.show();
            currentDIV.slideDown(500, function(){
            
            
                $("#showpanel #img>img").undelegate("load");
                
            });
        }
        
    };
    
    return function(arg){
        var experience = Object.create(Experienceb299);
        experience.init.call(experience, arg);
        return experience;
    };
    
}(jQuery, Number));


/* 
 * App.js has been seperated from global.js to avoid bloat.
 * App.js will load modules but never do it's own work
 */
(function($, win, doc){
	
	// If  in Qunit test suite, then we stall.
	if(!!window.QUnit) { return; }

	$(doc).ready(function(){
		// shoppref.js
		
		ND.shoppingPreferenceManager();
		// hotdeals.js
		ND.hotDeals();
		
		// sync.js
		ND.syncVersionManager();
		// getprice.js
		ND.CalcPrice.init();
		
		ND.expandTable();
		
		ND.ResizeHeadline();
		
		ND.fleetTabs();
		
		ND.Experienceb299();
		
	});
	
})(jQuery, window, document);


/* context.js */
/**
 * @author szabetian
 * @project VOI prepopulation/Form builder/dealer locator
 * @description pre-populates model/series drop downs on forms if form is
 *              associated with proper context (by publisher). It also adds
 *              context param to links with ctx-voi class
 * 
 * @depends on shoppref.js (to read cookie and add pc param)
 */
ND.Context = (function($) {
	
	var 
	
	voiConfig = {
			excludedModels : ''
	},
	
	privateFunctions = {
			
		restServices : {
			fetchVOIData : function(url) {
				privateFunctions.restServices.ajaxCall(url, function(jqXHR) {
					privateFunctions.displayVehicleBanner(jqXHR);
					privateFunctions.displayDisclaimer(jqXHR);
					privateFunctions.populateModelDropdown(jqXHR);
                    privateFunctions.populateVehicleDropdown(jqXHR);
				});
			},
			fetchColorData: function(url, callback) {
				
				privateFunctions.restServices.ajaxCall(url, function(jqXHR) {
					var i = 0,
						colors = [];
					
					for (i = 0; i < jqXHR.length; i++) {
						colors.push({
							name: jqXHR[i].name,
							order: jqXHR[i].order,
							code: jqXHR[i].code
						});
					}
					
					callback(colors);
					
				});
			},
			ajaxCall : function(url, successCallback) {
				$.ajax({
					url: url,
					dataType: 'json', 
					success: function(jqXHR, textStatus, textResponse) {
						if (typeof jqXHR !== 'undefined' && jqXHR != null) {
							successCallback(jqXHR);
						}
					}, 
					error : function(jqXHR, textStatus, textResponse) {
						//console.log('Could not fetch voi rest data');
					}
				});
			}
			
		},
	
		
	   /**
         * Extracts context param (ctx=m:1178856483523;d:1178856483570) from URL
         */
		extractContext : function(idx, url) {
			idx += 4;
			var lastParam = url.indexOf('&', idx);
			return url.substring(idx, lastParam > idx ? lastParam : url.length );
		},
		
		addContextToHref : function(elmnt, ctx) {
	        var href = elmnt.attr('href'),
	            ctxIdx;
	        if (typeof href !== 'undefined') {
		        if ((ctxIdx = href.indexOf('ctx=')) > 0) {
		             // if there is already a ctx, compare it with new one
		            var indexOfLastAnd = href.lastIndexOf('&');
		            if (indexOfLastAnd < ctxIdx) {
		                indexOfLastAnd = href.length;
		            }
		
	            var oldCtx = href.substring(ctxIdx, indexOfLastAnd);
	            if (oldCtx !== ctx) {
	               href = href.replace(oldCtx, ctx);
	               elmnt.attr('href', href).attr('data-ajax', 'false');
	            }
	
	        } else if (href.length > 1) {  // don't add to # hrefs
	            if(href.indexOf('?') > 0) {
	                href +='&';
	            } else {
	                href += '?';
	            }
	            elmnt.attr('href', href + ctx).attr('data-ajax', 'false');
		        }
	        }
	    },
	    
		addDropdownChangeListeners: function($modelDD, voiRestData) {
			
			var $seriesDD = $('#voi-series-name'),
				$colorDD = $('#voi-colour-dd');
			if ($seriesDD.length > 0) {
				var $firstOption;
				if (privateFunctions.firstTime) {
					$firstOption = $seriesDD.html();
					privateFunctions.firstTime = false;
				}
				
				$modelDD.on('change', function (e) {
				    e.stopImmediatePropagation();
					var result = privateFunctions.findIdForName($modelDD.val(), null, voiRestData);
					
					if (result.m != null) {
						privateFunctions.setModelDropDownValue(result);
						privateFunctions.populateSeriesDropdown($seriesDD, voiRestData[result.mIdx].derivatives, $firstOption, $colorDD);
					} else {
						privateFunctions.populateSeriesDropdown($seriesDD, [], $firstOption, $colorDD);
					}
				});
				
				$seriesDD.on('change', function() {
					var result = privateFunctions.findIdForName($modelDD.val(), $seriesDD.val(), voiRestData);
					
					if (result.d != null) {
						privateFunctions.setDerivativeDropDownValue(result);
					}
					if ($colorDD.length > 0) {
						privateFunctions.populateColorDropdown($seriesDD, $('#voi-colour-dd'));
					}
				});
				
				
				if ($colorDD.length > 0) {
					$colorDD.on('change', function() {
						privateFunctions.setColorDropDownValue($colorDD);
					});
				}
			}
		},

        addDealerDropDownListeners: function($modelDD, voiRestData){
            var $versaoDD = $('#FormSales_Derivative'),
                $corDD = $('#FormSales_Color');

            var $firstOption = $versaoDD.html();

            $modelDD.on('change',function(){
                if($modelDD.get(0).selectedIndex !== 0){
                    $versaoDD.parent().css('display', 'block');
                }else{
                    $versaoDD.parent().css('display', 'none');
                    $corDD.parent().css('display', 'none');
                }
                var result  = privateFunctions.findIdForName($modelDD.val(), null, voiRestData);

                if(result.m != null){
                    //privateFunctions.setVehicleDropDownValue(result);
                    privateFunctions.populateSeriesDropdown($versaoDD, voiRestData[result.mIdx].derivatives,$firstOption, $corDD);
                }else{
                    privateFunctions.populateSeriesDropdown($versaoDD, [], $firstOption, $corDD);
                }
            });

            $versaoDD.on('change', function(){
                if($versaoDD.get(0).selectedIndex !== 0){
                    $corDD.parent().css('display', 'block');
                }else{
                    $corDD.parent().css('display', 'none');
                }
                var result = privateFunctions.findIdForName($modelDD.val(), $versaoDD.val(), voiRestData);

                if(result.d != null){
                    //privateFunctions.setDerivativeDropDownValue(result);
                }
                if($corDD.length > 0){
                    privateFunctions.populateColorDropdown($versaoDD, $corDD);
                }
            });

            if($corDD.length > 0){
                $corDD.on('change', function(){
                    privateFunctions.setColorDropDownValue($corDD);
                });
            }

        },
		
		findIdForName: function(modelName,derivativeName,voiRestData) {
			var i,j, derivative;
			var result = { m : null, d : null,//ids 
					mIdx : -1, dIdx : -1, 
					dy: null,//derivative year
					dcks: null,//derivative cks code
					mcks: null,//model cks code
					dqcode: null,//derivative quote code
					dtdcode: null,//derivative test drive code
					dbcode: null//derivative brochure code
					};
	
			for (i = 0; i < voiRestData.length; i++) {
				if (modelName === voiRestData[i].name) {
					
					result.m = voiRestData[i].id;
					result.mcks = voiRestData[i].modelCode;
					result.mIdx = i;
					if (derivativeName != null) {
						for (j = 0; j < voiRestData[i].derivatives.length; j++) {
							derivative = voiRestData[i].derivatives[j];								
							if (derivativeName === derivative.name) {
								result.dcks = derivative.derivativeCode;
								result.dy = derivative.year;
								result.d = derivative.id;
								result.dIdx = j;
								result.dqcode = derivative.quoteFulfilmentCode;
								result.dtdcode = derivative.testdriveFulfilmentCode;
								result.dbcode = derivative.brochureFulfilmentCode;
								break;
							}
						}
					}
					break;
				}
			}
			
			return result;
		},
		
		firstTime : true,
		
		displayVehicleBanner: function(voiRestData) {
			var ctx = publicFunctions.toJSONFromUrl();
			if (ctx != null && typeof ctx.m !== 'undefined' && ctx.m != null) {
				// consider using ND.Utils.lazyLoadImage
				var $bannerCFF = $('#voi-banner'),
					$banners = $('.voi-banner'),
					bannerUrl,
					$bannerDiv;
				if ($bannerCFF.length > 0 && $banners.length > 0) {
					for (i = 0; i < voiRestData.length; i++) {
						if (ctx.m === voiRestData[i].id) {
							bannerUrl = voiRestData[i][voiConfig.formRequestType + 'Banner'];
							if (typeof bannerUrl !== 'undefined' && bannerUrl != null && bannerUrl !== '') {
								// display loader
								
								// show loading image
								$banners.each(function() {
									$(this).removeAttr('style');
								});
								
								var img = new Image();
								// call this function after it's loaded
								img.onload = function() {
									// make wrapperformbuilder.data.EmailHandler
                                    // fully visible
									$banners.each(function() {
										$(this).find('img').attr('src',bannerUrl);
									});
								};
								// begin loading the image from ...
								img.src = bannerUrl;
							}
							break;
						}
					}
				}
			}
		},
		
		displayDisclaimer: function(voiRestData) {
			var ctx = publicFunctions.toJSONFromUrl();
			if (ctx != null && typeof ctx.m !== 'undefined' && ctx.m != null) {
				// consider using ND.Utils.lazyLoadImage
				var $disclaimer = $('#voi-disclaimer'),
					disclaimerText = null,
					foundDrv = false,
					i,j;
				if ($disclaimer.length > 0) {
					for (i = 0; i < voiRestData.length; i++) {
						if (ctx.m === voiRestData[i].id) {
							if (typeof ctx.d !== 'undefined' && ctx.d != null) {
								for (j = 0; j < voiRestData[i].derivatives.length; j++ ) {
									if (ctx.d === voiRestData[i].derivatives[j].id) {
										disclaimerText = voiRestData[i].derivatives[j]['derivative' + voiConfig.formRequestTypeUppercase + 'Disclaimer'];
										if (typeof disclaimerText !== 'undefined' && disclaimerText != null) {
											$disclaimer.hide().html(disclaimerText).fadeIn('fast');
											foundDrv = true;
										}
										break;
									}
								}
							}
							
							if (!foundDrv) {
								disclaimerText = voiRestData[i][voiConfig.formRequestType + 'Disclaimer'];
								if (typeof disclaimerText !== 'undefined' && disclaimerText != null) {
									$disclaimer.hide().html(disclaimerText).fadeIn('fast');
								}
							}
						} 
					}
				}
			}
		},
		
		populateModelDropdown: function(voiRestData) {
			var $dd = $('#voi-model-name');
			
			if ($dd.length > 0) {
				var options = [],
					excludedSerEl = $("#modelseries"),
					filterList = [],
					optionList = voiRestData.slice(0),
					i;
				//if there is excludedSeries defined, remove from option list	
				if(excludedSerEl.length>0){
					var excludeSerJson = $.parseJSON(excludedSerEl.html()),
						excludeModel = excludeSerJson.excludedModels;
					if(excludeModel&&excludeModel.length>0){
						var excludeModelArr = excludeModel.split(",");//convert excluded list from string to array
						for(var k = 0; k < voiRestData.length; k++){
							var count = 0;
							//if there is excludedSeries defined, remove from option list
							if(excludeModelArr && excludeModelArr instanceof Array && excludeModelArr.length>0){
								for(var j = 0; j < excludeModelArr.length; j++){
									if($.trim(voiRestData[k].name)==$.trim(excludeModelArr[j])){
										count++;//record as a flag if match exclude element
									}
								}
								//filter the array element, store those not in the exclude list
								if(count==0){
									filterList.push(voiRestData[k]);
								}
							}
						}
					}
				}
				//update list if has filter element
				if(filterList.length > 0){
					optionList = filterList.slice(0);
				}
				
				for (var i = 0; i < optionList.length; i++) {
					options.push('<option value="' + optionList[i].name + '">' + optionList[i].name + '</options>');
				}
				$dd.append(options.join(''));
				if (ND.FormBuilder && ND.FormBuilder.styleSelectOptions) {
					ND.FormBuilder.styleSelectOptions($dd);
				}
				privateFunctions.addDropdownChangeListeners($dd, voiRestData);
			
				var ctx = publicFunctions.toJSONFromUrl();
				if (ctx != null && (typeof ctx.m !== 'undefined' && ctx.m != null) ) {
					for (i = 0; i < voiRestData.length; i++) {
						if (ctx.m === voiRestData[i].id) {
							$dd.val(voiRestData[i].name);
							privateFunctions.setModelDropDownValue(ctx);
							//trigger change only if ctx exists
							$dd.trigger('change');
							break;
						}
					}
				}
				privateFunctions.refreshMobileDropdown($dd);
			}
		},

        populateVehicleDropdown: function(voiRestData) {
            var $vehicleDropdown = $('#FormSales_Model');
            var options = [];
            var optionList = voiRestData.slice(0);
            for(var i = 0; i < optionList.length; i++){
                options.push('<option value="' + optionList[i].name + '">'+ optionList[i].name +'</option>');
            }
            $vehicleDropdown.append(options.join(''));
            privateFunctions.addDealerDropDownListeners($vehicleDropdown, voiRestData);
        },
		
		
		setHiddenInputValue: function(selector, value) {
			if (value != undefined) {
				var $hiddenInput = $(selector);
				if ($hiddenInput.length > 0) {
					$hiddenInput.val(value);
				}
			}
		},
		
		setModelDropDownValue: function(value) {
			privateFunctions.setHiddenInputValue('#voi-model-id', value.m);
			privateFunctions.setHiddenInputValue('#voi-model-cks-code', value.mcks);
		},

		populateSeriesDropdown: function($dd, modelDerivatives, $firstOption, $colorDD) {
			
			if (typeof modelDerivatives !== 'undefined' && modelDerivatives != null && modelDerivatives.length > 0) {
				var options = [],
				i;	
				for (i = 0; i < modelDerivatives.length; i++) {
					options.push('<option value="' + modelDerivatives[i].name + 
								 '" data-derivativeid="' + modelDerivatives[i].id + '">' + modelDerivatives[i].name + '</options>');
				}
				$dd.empty().html($firstOption).append(options.join(''));
				if (ND.FormBuilder && ND.FormBuilder.styleSelectOptions) {
					ND.FormBuilder.styleSelectOptions($dd);
				}
				var ctx = publicFunctions.toJSONFromUrl(),
					derivative;
			
				if (ctx != null && ((typeof ctx.d !== 'undefined' && ctx.d != null))) {
					for (i = 0; i < modelDerivatives.length; i++) {
						derivative = modelDerivatives[i];
						if (ctx.d === derivative.id) {
							$dd.val(derivative.name);
							// /console.log('setting value of dropdown: ' +
                            // select + ' to ' + derName);
							privateFunctions.setDerivativeDropDownValue(ctx);
							
							$dd.trigger('change');
							break;
						}
					}
				} else {
					privateFunctions.populateColorDropdown($dd, $colorDD);
				}
				
			} else {
				$dd.html($firstOption);
				privateFunctions.populateColorDropdown($dd, $colorDD);
				
			}
			privateFunctions.refreshMobileDropdown($dd);
		},
		setDerivativeDropDownValue : function(value) {
			privateFunctions.setHiddenInputValue('#voi-series-id', value.d);
			privateFunctions.setHiddenInputValue('#voi-series-cks-code', value.dcks);
			privateFunctions.setHiddenInputValue('#voi-series-year', value.dy);
			privateFunctions.setHiddenInputValue('#voi-series-quote-code', value.dqcode);
			privateFunctions.setHiddenInputValue('#voi-series-brochure-code', value.dbcode);
			privateFunctions.setHiddenInputValue('#voi-series-testdrive-code', value.dtdcode);			
		},
		
		colorDropdownFirstOption : null,
		
		populateColorDropdown: function($seriesDD, $dd) {
			if ($dd.length > 0) {
				
				if (privateFunctions.colorDropdownFirstOption == null) {
					privateFunctions.colorDropdownFirstOption = $dd.html();
				}
			
				// call ajax service
				
				var derivativeId = $seriesDD.find(':selected').data('derivativeid');
				
				if (typeof derivativeId !== 'undefined' && derivativeId != null) {
					var colorUrl = voiConfig.colorUrl.replace('{site}', voiConfig.site)
					  .replace('{priceZone}', voiConfig.priceZone)
					  .replace('{derivative}', derivativeId);

					$dd.empty().html('<option value="">' + voiConfig.pleaseWaitMsg + '</options>');

					privateFunctions.restServices.fetchColorData(colorUrl, function(colorData) {
						var options = [],
							i;
						for (i = 0; i < colorData.length; i++) {
							options.push('<option value="' + colorData[i].code + '">' + colorData[i].name + '</options>');
						}
						$dd.empty().html(privateFunctions.colorDropdownFirstOption).append(options.join(''));
						if (ND.FormBuilder && ND.FormBuilder.styleSelectOptions) {
							ND.FormBuilder.styleSelectOptions($dd);
						}
						privateFunctions.refreshMobileDropdown($dd);
					});
				}
//                if (typeof derivativeId !== 'undefined' && derivativeId != null) {
//                    $dd.empty().html('<option value="">wait</options>');
//                    privateFunctions.restServices.fetchColorData('../../../../latest-offers-2014-client/carve/RAD2013/rest/dealer-color.js', function(colorData) {
//                            var options = [],
//                                i;
//                            for (i = 0; i < colorData.length; i++) {
//                                options.push('<option value="' + colorData[i].code + '">' + colorData[i].name + '</options>');
//                            }
//                            $dd.empty().html(privateFunctions.colorDropdownFirstOption).append(options.join(''));
//                            if (ND.FormBuilder && ND.FormBuilder.styleSelectOptions) {
//                                ND.FormBuilder.styleSelectOptions($dd);
//                            }
//                            privateFunctions.refreshMobileDropdown($dd);
//                    });
//                }
                else {
					$dd.empty().html(privateFunctions.colorDropdownFirstOption);
				}
				privateFunctions.refreshMobileDropdown($dd);
			}
		},
		
		refreshMobileDropdown: function($dd) {
			if ( $.mobile ) {
				$dd.selectmenu('refresh', true);
			}
		},
		
		setColorDropDownValue : function(colourDropdown) {
			privateFunctions.setHiddenInputValue('#voi-colour-code', colourDropdown.find(':selected').val());
			privateFunctions.setHiddenInputValue('#voi-colour-name', colourDropdown.find(':selected').text());
		},
			
		
		/**
         * if we have a form and config, make an ajax call and retrieve the VOI
         * list
         */
	    init : function() {
	    	
	    	var $restConfig = $('#rest-services'),
	    		$modeSeriesConfig = $('#modelseries'),
	    		$commonConfig = $('#common-config'),
	    		$form = ('form');
	    	// if there is at least one form on the page
            $('#FormSales_Derivative').parent().css('display','none');
            $('#FormSales_Color').parent().css('display','none');
	    	if ($form.length > 0) {
	    		
	    		// from legacy code...can't move it
		    	publicFunctions.legacyDisplayVehicleBanner();
				publicFunctions.legacyDisplayVehicleDisclaimer();
	    			
	    		if ($restConfig.length > 0 && $modeSeriesConfig.length > 0) {
		    		$.extend(voiConfig, JSON.parse($modeSeriesConfig.html()),
					    				JSON.parse($restConfig.html()),
					    				JSON.parse($commonConfig.html()));
		    		
		    		if (voiConfig.formRequestType) {
		    			var firstChar = voiConfig.formRequestType.charAt(0);
		    			voiConfig.formRequestTypeUppercase = voiConfig.formRequestType;
		    			voiConfig.formRequestType = voiConfig.formRequestType.replace(firstChar, firstChar.toLowerCase());
		    		}
		    		
		    		voiConfig.voiUrl = voiConfig.voiUrl.replace('{site}', voiConfig.site).replace('{makeName}', voiConfig.make);
		    		voiConfig.voiUrl += voiConfig.excludedModels;
		    		
		    		privateFunctions.restServices.fetchVOIData(voiConfig.voiUrl);
	    		}
                //privateFunctions.restServices.fetchVOIData('../../../../latest-offers-2014-client/carve/RAD2013/rest/dealer-vehicle.js');
	    	}
	    }
	    
	    
	},
	
	publicFunctions = {
			
		//used to prevent smob logic from double firing 
		//once after page init and once after document ready.
		isContextInitialised : false,
		
		startUp : function() {
	    	
	    	if (!publicFunctions.isContextInitialised) {
				// need to do this check on every page regardless
				publicFunctions.addContextToLinks();
				publicFunctions.addPostcodeContextToLinks();
				
				// if we have a form and config, make an ajax call and retrieve the
	            // VOI list
				privateFunctions.init();
				publicFunctions.isContextInitialised = true;
	    	}
	    },
		/**
         * Converts parameterised context to JSON
         * 
         * d:<derivativeid>;m:<modelid>
         */
		toJSON : function(contextParam) {
			var result = {};
			if (typeof contextParam !== 'undefined') {
				params = contextParam.split(";");
				for (var i = 0; i < params.length ; i++) {
					var nameValuePair = params[i].split(':');
					if (nameValuePair.length == 2) {// ensure it's a name value
                                                    // pair
						result[nameValuePair[0]] = nameValuePair[1];
					}
				}
			}
			return result;
		},
		
		/**
         * builds the context param (ctx=m:1178856483523;d:1178856483570)
         */
		buildContext: function(additionalParams) {
			var params = new Array();
			if ((typeof _da !== 'undefined') && (typeof _da.nameplate !== 'undefined') && (typeof _da.nameplate.id !== 'undefined') && _da.nameplate.id != '') {
				
				params.push( 'm:' + _da.nameplate.id);
			} 
			if	((typeof _da !== 'undefined') && (typeof _da.der !== 'undefined') && (typeof _da.der.id !== 'undefined') && _da.der.id != '') {
				params.push( 'd:' + _da.der.id);
			}
            if (typeof additionalParams !== 'undefined' && additionalParams != null) {
                for (key in additionalParams) {
                    params.push( key + ':' + additionalParams[key]);
                }
            }
// console.log('built ctx=' + params.join(';') + ' context');
			return params.length > 0 ? ('ctx=' + params.join(';')) : '';
		},

		/**
         * if the url does not contain the context variable, it might still
         * exist (if we are on a smart mobile site). in that case check for a
         * div with data-role page; if that div has a data-url with ctx param
         * then call this method with the new url.
         */
		toJSONFromUrl: function(url) {
			url = decodeURIComponent(url || window.location.href);
			
			// console.log('looking for ctx in url ' + url);
			var idx = url.indexOf('ctx=');
			var ctx = null;
			if (idx > 0) {
				ctx = privateFunctions.extractContext(idx, url);
			} else {
				// perhaps we are on a mobile site
				var mobileUrl = null;
				var page = null;
				if ((page = $('div[data-role="page"]').filter(':visible')) != null && 
					(mobileUrl = page.attr('data-url')) != null) {
					if ((idx = mobileUrl.indexOf('ctx=')) > 0) {
						ctx = privateFunctions.extractContext(idx, url);
					} 	
				}
			}
			if (ctx != null) {
				ctx = publicFunctions.toJSON(ctx);
			}
			// console.log('ctx is = ' + ctx);
			return ctx;
		},
		
		/**
         * adds context param (ctx=m:1178856483523;d:1178856483570) to links
         * with 'ctx-voi' class
         */
		addContextToLinks: function() {
			var ctx = publicFunctions.buildContext();
// console.log('addContextToLinks');
			$('a.ctx-voi').each(function() {
                privateFunctions.addContextToHref($(this), ctx);
			});
		},
        /**
         * If postcode cookie exists, add ctx=pc:3000 to links with class ctx-pc
         */
        addPostcodeContextToLinks: function() {
            $.publish('shopping.pref.retrieve', function(e, postcodeData) {
                if (typeof postcodeData !== 'undefined' && postcodeData != null &&
                    typeof postcodeData.postcode !== 'undefined' && postcodeData.postcode != null)  {
                    var ctx = publicFunctions.buildContext({pc : postcodeData.postcode });
                    $('a.ctx-pc').each(function() {
                        var link = $(this);
                        // we have to add a class to the link to make sure we
                        // don't
                        // add the param twice, as page DOM still remains part
                        // of the page after page change.
                        if (!link.hasClass('ctx-pc-added')) {
                            privateFunctions.addContextToHref(link, ctx);
                            // for smob. adding data-ajax="false" to ensure form
                            // reloads properly
                            // since it's a form post, it shouldn't be captured
                            // in history anyways.
                            link.attr('data-ajax', 'false');
                        }
                    });
                }
            });
        },
		
		/**
         * inserts a banner image on forms that have been properly setup for VOI
         * prepopulation
         */
		legacyDisplayVehicleBanner: function() {
			var ctx = publicFunctions.toJSONFromUrl();
			if (ctx != null && typeof ctx.m !== 'undefined' && ctx.m != null) {
				// consider using ND.Utils.lazyLoadImage
				var $bannerCFF = $('#voi-banner'),
					$data = $('#model-context-banner');
				if ($bannerCFF.size() && $data.size()) {
					var content = JSON.parse($data.html());
					// console.log('legacyDisplayVehicleBanner');
					if (typeof content[ctx.m] !== 'undefined') {
						 var url = content[ctx.m];
						 // console.log('legacyDisplayVehicleBanner: found
                            // url for model[' + ctx.m + ']: ' + url);
						 $bannerCFF.html('<img src="' + url + '" />');
						
					}
				}
			}
		},
		
		/**
         * inserts a derivative disclaimer text on confirmation page that have
         * been properly setup for VOI prepopulation
         */
		legacyDisplayVehicleDisclaimer : function() {
			var ctx = publicFunctions.toJSONFromUrl(),
				$disclaimer = $('#voi-disclaimer');
			if (ctx != null && $disclaimer.size()) {
				var $derivativeData = $('#derivative-context-disclaimer');
				if ((typeof ctx.d !== 'undefined' && ctx.d != null) && $derivativeData.size()) {
					var derivativeDisclaimer = $derivativeData.embeddedData();
					if (derivativeDisclaimer[ctx.d] != null) {
						var disclaimerText = derivativeDisclaimer[ctx.d];
						// console.log('legacyDisplayVehicleDisclaimer: found
                        // disclaimer for derivative[' + ctx.d + ']: ' +
                        // disclaimerText);
						$disclaimer.hide().html(disclaimerText).fadeIn('fast');
					} else {
						publicFunctions.legacyDisplayNameplateDisclaimer(ctx, $disclaimer);
					}
				} else {
					publicFunctions.legacyDisplayNameplateDisclaimer(ctx, $disclaimer);
				} 
			}
		},
		
		/**
         * inserts a disclaimer text for namteplates on confirmation page that
         * have been properly setup for VOI prepopulation
         */
		legacyDisplayNameplateDisclaimer : function(ctx, $disclaimer) {
			var $modelData = $('#model-context-disclaimer');
			if ((typeof ctx.m !== 'undefined' && ctx.m != null) && $modelData.size()) {
				var modelDisclaimer = $modelData.embeddedData();
				if (modelDisclaimer[ctx.m] != null) {
					var disclaimerText = modelDisclaimer[ctx.m];
					// console.log('legacyDisplayVehicleDisclaimer: found
                    // disclaimer for model[' + ctx.m + ']: ' + disclaimerText);
					$disclaimer.hide().html(disclaimerText).fadeIn('fast');
				}
			}
		},
		
		/**
         * Populates nameplate dropdown on any form that has a valid ctx=m:<modelId>
         */
		legacyPopulateModelDropdown: function(select, hiddenInput, modelNameList) {
			var ctx = publicFunctions.toJSONFromUrl(),
				$dd = $('#' + select);
			if (ctx != null && ((typeof ctx.m !== 'undefined' && ctx.m != null) && $dd.length > 0)) {
				var modelName = modelNameList[ctx.m];
				if (modelName && modelName != null) {
					$dd.val(modelName);
					$dd.trigger('change');
					// console.log('setting value of dropdown: ' + select + ' to
                    // ' + modelName);
					var $hi = $('#' + hiddenInput);
					if ($hi.size()) {
						$hi.val(ctx.m);
					}
				}
			}
		},
		
		/**
         * Populates derivative dropdown on any form that has a valid ctx=m:<modelId>;d:<derivativeId>
         */
		legacyPopulateSeriesDropdown: function(select, hiddenInput, derivativeNameList) {
			var ctx = publicFunctions.toJSONFromUrl(),
				$dd = $('#' + select);
			
			if (ctx != null && ((typeof ctx.d !== 'undefined' && ctx.d != null) && $dd.length > 0)) {
				var derName = derivativeNameList[ctx.d];
				if (derName && derName != null) {
					$dd.val(derName);
					$dd.trigger('change');
					// /console.log('setting value of dropdown: ' + select + '
                    // to ' + derName);
					var $hi = $('#' + hiddenInput);
					if ($hi.size()) {
						$hi.val(ctx.d);
					}
				}
			}
		}
		
		
	};
	
	/**
     * Execute voi-prepopulation for web
     */
	$(document).ready(publicFunctions.startUp);
	
	return publicFunctions;
	
})(jQuery);


/*
 * A place for Tracking code when there is no other.
 */
var ND = (function(module, $, window, document) {
	
	trackWebtrendFields = function() {
		/*
         * Tracking that implement by DOM ready.
         */
        var _da = window._da;
        if(_da === undefined) {
        	return;
        }
        var trackFields = _da.trackFields;
        if(trackFields !== undefined){
            var fields = [], key;
            for(key in trackFields){
                fields.push({
                    name: key,
                    value: trackFields[key]
                });
            }

            $.publish('/analytics/field/', { field : fields });
        }
	}	
	
	module.analyticsBinder = {
			
		/*
		 * Create instance of webtrends wrapper
		 */
		bind: function() {
			$(document).ready(function(){
				
				// Localise a grabber function. Grabber function helps with content values and urls
				var grabber = ND.analytics.grabber();
				
				/*
				 * <meta name="dfy.title" content="Focus" />
				 */
				master = grabber( { meta: "meta[name='dfy.title']" } );
			
				/*
				 * Social Links
				 */
				$('.socialmedia-wrapper').delegate('.socialmedia a', 'click', function(e){
				
					var link = grabber( { link: this } ),
						data = { 
							title: 'Follow ' + master.value + ' on ' + link.value,
							uri: '/follow/' +  link.url
						};
						
					$.publish('/analytics/social/', data);
					
				});
	
				
				/*
				 * When an Overlay opens.. 
				 * It is not based on the <A> tag because overlays are a complex beast.
				 * It's based on the overlay itself regardless of what trigger the event that opened it.
				 * See Unit Tests for example variations
				 */
				$.subscribe( "overlay.done", function( e, eventData ){
					var heading, link, name, data = {}, 
						blind = true,
						excludeClass = ".country-overlay"; //exclude select country overlay.
	
					if( eventData && eventData.contents && $(excludeClass, eventData.contents).size() < 1) {
	
						//Grab content
						heading = eventData.contents ? grabber( { link: eventData.contents.find(".head h1") } ) : {};
						link = grabber( { link: eventData.anchor } )
						name = grabber( { name: eventData.name } )
						
						//If no values are usable, then we are Blind tracking this overlay
						blind = !heading.value && !link.value && !name.value && !eventData.assetid;
						
						data = { 
							title: master.value + ' | ' + (name.value || heading.value || link.value || eventData.assetid),
							uri: '/' + master.url + '/overlay/' +  (name.url || heading.url || link.url || eventData.assetid)
						};
	
						if ( blind ) {
							data = { 
								title: master.value + ' | Overlay',
								uri: '/' + master.url + '/overlay'
							};
						}
						
						$.publish('/analytics/event/', data);
					
					}
				}); 
	
				/* 
				 * TBD: RSS
				 */
				$(".rss").delegate("a", "click", function(e){
					var link = grabber( { link: this } ),
						data = { 
							title: 'RSS',
							uri: link.url
						};
	
					$.publish('/analytics/event/', data);
				});
	
				/* 
				 * AddThis: 
				 * When click on AddThis link
				 * The add this layout is insert to body by script.
				 * Create a delegate event on document.
				 */
				$(document).delegate(".at_item", "click", function(e){
					var link = grabber( { link: this } ),
						data = { 
							title: ' Send to ' + link.value,
							uri: '/share/' + link.url,
							socialId: link.value
						};
	
					$.publish('/analytics/social/', data);
	
				});
	
				/*
				 * AddThis China
				 */
				$(document).delegate(".addlist a", "click", function(e){
					var link = grabber( { link: this } ),
						data = { 
							title: ' Send to ' + link.value,
							uri: '/share/' + link.url,
							socialId: link.value
						};
	
					$.publish('/analytics/social/', data);
	
				});
	
				/* 
				 * TBD: Like button 
				 */
				/*
				$(".fb-like").mouseover(function(e){
					var target = e.target; 
					if(e.tagName == "IFRAME"){
						
					}
				})
				*/;
	
				/*
				 * TBD: Google Plus Button
				 */
				/*
				$(".addthis_button_google_plusone").mouseover(function(e){
					var target = e.target; 
					if(e.tagName == "IFRAME"){
						
					}
				});
				*/
	
				/*
				 * TBD: Form Field Drop Off
				 */
				$('#dragonflyform').delegate('.ff-track-drop-off', 'focusout', function(e) {
	
					var field = $(this),
						data = {
							field: {
								name: field.attr('name') || this.id,
								value: field.val()
							}
						};
	
					//TBD: "parameters about the prefix "DCSext.xxx"
					$.publish('/analytics/field/', data);
				});
	
				/*
				 * VOI
				 */
				$('#dragonflyform').submit(function(e){
					var $model = $("#VOI_ModelSeries_Model", form);
					var $services = $("#VOI_ModelSeries_Series", form);
	
					if(!$model.size() && !$services.size()){
						return;
					}
	
					var form = $(this),
						data = {
							field: [
								{
									name: "model",
									value: $model.val()
								},
								{
									name: "series",
									value: $services.val()
								}
							]
						};
	
					$.publish('/analytics/field/', data);
				});
	
				/*
				 * View 360 Button: 2.8.1
				 */ 
				$('.view360-button a').click(function(e){
					
					var link = grabber( { link: this } ),			
						data = { 
							title: master.value + ' | ' + link.value,
							uri: '/' + master.url + '/360-view'
						};
						
					$.publish('/analytics/event/', data);
					
				});
	
				/* 
				 * Switch(Flash): 2.8.2
				 * */ 
				$("#car-swapper a").click(function(e){
					var link = grabber( { link: this } ),
						data = { 
							title: master.value + ' | ' + link.value,
							uri: '/' + master.url + '/switch-to-super-cab'
						};
	
					$.publish('/analytics/event/', data);
				});
	
				/*
				 * Switcher(banner): 2.8.3
				 */
				$('.slider .next, .slider .prev').click(function(e){
	
					var link = grabber( { link: this } ),
						data = { 
							title: master.value + ' | ' + link.value,
							uri: '/' + master.url + '/switch-to-banner'
						};
	
					$.publish('/analytics/event/', data);
				});
				
				/*
				 */ 
				$('.download').click(function(e){
					data = { 
						title: 'this is my link',
						link: this,
						type: 'd'
					};
	
					$.publish('/analytics/link/', data);			
				});
				/*$wait(function(){
					$(".trackable,.external-disclaimer").live({mouseover:function(e){},mousedown:function(){alert("live-mousedown")}});
					//$(".trackable,.external-disclaimer").on('click',function(e){alert('on')});
				})*/
				
				//$('.trackable,.external-disclaimer').click(function(e){
				//$(document).delegate(".trackable,.external-disclaimer","click",function(e){
				//$(document).on("click",'.trackable,.external-disclaimer',function(e){
				$(".trackable,.external-disclaimer").live('mouseup',function(e){
					if($('.staging-wrap .trackable').size()>0){
						return;
					}
					//if(!e.target||!e.target.id||!e.target.tagName||e.target.tagName!='SELECT'||(e.target.id!='state'&&e.target.id!='city')) e.preventDefault();
					//if(!e.target||!e.target.tagName||e.target.tagName!='OPTION'||!e.target.parentElement||!e.target.parentElement.id||(e.target.parentElement.id!='state'&&e.target.parentElement.id!='city'))
					if(!e.target||!e.target.tagName||e.target.tagName!='OPTION'||!e.target.parentElement||!e.target.parentElement.tagName||e.target.parentElement.tagName!='SELECT')
					{
					e.preventDefault();
					}
					if(!$(this).hasClass("overlay")&&!$(this).closest("ul").hasClass("gallery")&&!$(this).hasClass("service-booking-overlay")&&!$(this).hasClass("open-video-flip") && !$(this).hasClass("collapse-btn")&&!$(this).hasClass("save-dealer-btn")&&!$(this).hasClass("bing-directions")&&!$(this).hasClass("filter-toggler")&&!$(this).hasClass("viewSaved")&&!$(this).hasClass("accordion-next")&&!$(this).hasClass("open-vid")&&!$(this).hasClass("open-modal")&&!$(this).hasClass("save-continue")&&!$(this).hasClass("pdf-btn")&&!$(this).hasClass("finish-btn")&&!$(this).hasClass("tab-area")&&!$(this).closest(".predelivery-new")){
						$(this).trigger('click');
					}
					var $link = $(this);
					var img, name, type, onclick, trigger = false, nameplate, leadtype, tool, events, year, pname,intcmp,hier,tooldesc,content,freq,moduletype,modulename,moduleaction;
					//link has omniture tracking data, capture the data and publish to pubsub
					if ((name = $link.attr('data-name')) && 
						(type = $link.attr('data-type'))) {
						onclick = $link.attr("data-onclicks");
						nameplate = $link.attr("data-nameplate");
						year = $link.attr("data-nameplate-year");
						leadtype = $link.attr("data-leadtype");
						tool = $link.attr("data-tool");
						tooldesc = $link.attr("data-tooldesc");
						events = $link.attr("data-events");
						pname = $link.attr("data-pname");
						intcmp = $link.attr("data-intcmp");
						hier = $link.attr("data-hier"); 
						content = $link.attr("data-content"); 
						freq = $link.attr("data-freq"); 
						moduletype = $link.attr("data-moduletype");
						modulename = $link.attr("data-modulename");
						
					} 
					//look for images inside the link, if the img has any omniture tracking data, publish to pubsub
					else if ((img = $link.find('img').first()) &&
								(name = img.attr('data-name')) && 
								(type = img.attr('data-type'))){
						onclick = img.attr("data-onclicks");
						nameplate = img.attr("data-nameplate");
						year = img.attr("data-nameplate-year");
						leadtype = img.attr("data-leadtype");
						tool = img.attr("data-tool");
						tooldesc = img.attr("data-tooldesc");
						events = img.attr("data-events");
						pname = img.attr("data-pname");
						intcmp = img.attr("data-intcmp");
						hier = img.attr("data-hier"); 
						content = img.attr("data-content"); 
						freq = img.attr("data-freq"); 
						moduletype = $link.attr("data-moduletype");
						modulename = $link.attr("data-modulename");
						
					}
					
					//check the type
					if ($link.hasClass('external-disclaimer')) { type = 'e'};
					//if name not set by data-name attribute, get the link name
					if (!name) {
						var link = grabber( { link: this } )
						name = link.value;
					}
					//check personalisation click
					if (!($(this).hasClass("open-video-flip")) && ($link.closest("section").hasClass('personalisation') || $link.closest("section").hasClass('smartnextsteps'))){						
						moduleaction = 'click';
					}
					//gux Popular Accessories /Get to Know Your Vehicles			
					if ($link.closest("section").data('psn-module')=='knowvehicle' || $link.closest("section").data('psn-module')=='accessories'){						
						if(typeof $.cookie('dfy.u') !== "undefined" && typeof $.cookie('dfy.u') !== "function") {
							cookieUser = JSON.parse($.cookie('dfy.u'));
						}
						if (cookieUser != null) {
							modulename = cookieUser.now;
						 }
					}
					
					//moduleaction
					$.publish('/analytics/link/', { 
						title: name,
						link: this,
						type: type,
						onclicks: onclick,
						leadtype: leadtype,
						tool: tool,
						tooldesc: tooldesc,
						events: events,
						year: year,
						nameplate: nameplate,
						pname: pname,
						intcmp: intcmp,
						hier1:hier,
						content:content,
						freq:freq,
						moduletype:moduletype,
					    modulename:modulename,
					    moduleaction:moduleaction
					});	
				
				});
				
				// add omniture on gux billboard next/prev,billboard bullet
				$(".billboard  .flex-next,.billboard .flex-prev,.billboard .flex-control-paging a").live("click",function(e){					
					var $link = $(this);
					if(typeof _da!=="undefined" && _da.om.mobileApp==true &&($(this).hasClass("flex-prev")||$(this).hasClass("flex-next"))) return;
					var name,onclicks,modulename,moduletype;
					var $section = $link.closest("section");
					name = $section.data('name');
					onclicks = $section.data('onclicks');
					modulename = $section.data('modulename');
					moduletype = $section.data('moduletype');
					//moduleaction
					$.publish('/analytics/link/', { 
						title: name,
						link: this,
						type: "o",
						onclicks: onclicks,
						moduletype: modulename,
					    modulename: moduletype,
					    moduleaction:"click"
					});	
				});				
				//gux dealer omniture
				$(".view-all-dealers",$("section.dealer-locator")).live("mouseup",function(e){
					e.preventDefault();
					$(this).trigger('click');
					if (window._da && window._da.om && ND && ND.omniture) {
						_da.funnel.stepname='results';
						_da.events = "event1,event43".split(',');	
						_da.dealer = {};
					}
				});
				
				$.subscribe('dealers-done', (function(){
					if (window._da && window._da.om && ND && ND.omniture) {
						_da.funnel.stepname='results';
						_da.events = "event1,event43".split(',');	
						_da.dealer = {};						
						var totalNum = $('.dealer-result-container .count .num').text();
						if(totalNum){
							var totalResult = Number(totalNum);
							var perPage = 5;
							var totalPage = Math.floor((totalResult + perPage - 1 ) / perPage);
							var postcode = $('.dealer-result-container .result-list .dealer-result:first-child').data("postcode");
							_da.region = postcode;
							ND.analyticsTag.trackOmniturePage({
								tool:'event:find dealer',
								tooldesc:'find dealer:1 of '+totalPage
							});	
						}
						//only track once
						$.unsubscribe('dealers-done');
					}
				}));
				
				$("section.dealer-locator .dealer-result .dealer-heading a,section.dealer-locator .dealer-result .details").live("click",function(e){					
					var dealerId = $(this).closest(".dealer-result").data("dealerid");
					var postcode = $(this).closest(".dealer-result").data("postcode");
					if (window._da && window._da.om && ND && ND.omniture) {
						_da.funnel.stepname='dealer:info';
						_da.events = '';
						_da.dealer = {code:dealerId};
						_da.region = postcode;
						ND.analyticsTag.trackOmniturePage();
					}
				});
				//add ominture on per 360 movement
				$("#overlay .vr-container .360trackable").live("slide",function(e){
					if($('.staging-wrap .trackable').size()>0){
						return;
					}
					e.preventDefault();
					$(this).trigger('click');
					var $link = $(this);
					var img, name, type, onclick, trigger = false, nameplate, leadtype, tool, events, year, pname,intcmp,hier,tooldesc,content,freq;
					//link has omniture tracking data, capture the data and publish to pubsub
					if ((name = $link.attr('data-name')) && 
						(type = $link.attr('data-type'))) {
						onclick = $link.attr("data-onclicks");
						nameplate = $link.attr("data-nameplate");
						year = $link.attr("data-nameplate-year");
						leadtype = $link.attr("data-leadtype");
						tool = $link.attr("data-tool");
						tooldesc = $link.attr("data-tooldesc");
						events = $link.attr("data-events");
						pname = $link.attr("data-pname");
						intcmp = $link.attr("data-intcmp");
						hier = $link.attr("data-hier"); 
						content = $link.attr("data-content"); 
						freq = $link.attr("data-freq"); 
						
					} 
					//look for images inside the link, if the img has any omniture tracking data, publish to pubsub
					else if ((img = $link.find('img').first()) &&
								(name = img.attr('data-name')) && 
								(type = img.attr('data-type'))){
						onclick = img.attr("data-onclicks");
						nameplate = img.attr("data-nameplate");
						year = img.attr("data-nameplate-year");
						leadtype = img.attr("data-leadtype");
						tool = img.attr("data-tool");
						tooldesc = img.attr("data-tooldesc");
						events = img.attr("data-events");
						pname = img.attr("data-pname");
						intcmp = img.attr("data-intcmp");
						hier = img.attr("data-hier"); 
						content = img.attr("data-content"); 
						freq = img.attr("data-freq");
					}
					
					//check the type
					if ($link.hasClass('external-disclaimer')) { type = 'e'};
					//if name not set by data-name attribute, get the link name
					if (!name) {
						var link = grabber( { link: this } )
						name = link.value;
					}
					$.publish('/analytics/link/', { 
						title: name,
						link: this,
						type: type,
						onclicks: onclick,
						leadtype: leadtype,
						tool: tool,
						tooldesc: tooldesc,
						events: events,
						year: year,
						nameplate: nameplate,
						pname: pname,
						intcmp: intcmp,
						hier1:hier,
						content:content,
						freq:freq
					});
					$("#overlay .vr-container .360trackable").die("slide");//only need to trigger once
				})
				
				// predelivery phase 3 personalisation omniture
				var personalisationTrack = function(){
					var $panel = $(this).closest(".panel");
					var name,onclicks,pname;
					name = $panel.data('name');
					onclicks = $panel.data('onclicks');
					pname = $panel.data('pname');
					
					$.publish('/analytics/link/', { 
						title: name,
						link: this,
						type: "o",
						onclicks: onclicks,
					    pname: pname,
					    moduleaction:"click",
					    freq: "category"
					});	
				}
				
				$(".predelivery-new .last-step .panel").on("click","input,select,textarea", personalisationTrack);		
				
				//This solution should fire the ambient lighting omniture. This bypasses the return false that is triggered by the color link event listener
				$(".predelivery-new .last-step .color-palette a").on("click", personalisationTrack);		
				
				/* for B515 experience tracking */
				$('.staging-wrap .trackable, .staging-wrap .external-disclaimer').live("click",function(e){
					var $link = $(this);
					var img, name, type, onclick, trigger = false, nameplate, leadtype, tool, events, year, pname,intcmp,hier,tooldesc;
					//link has omniture tracking data, capture the data and publish to pubsub
					if ((name = $link.attr('data-name')) && 
						(type = $link.attr('data-type'))) {
						onclick = $link.attr("data-onclicks");
						nameplate = $link.attr("data-nameplate");
						year = $link.attr("data-nameplate-year");
						leadtype = $link.attr("data-leadtype");
						tool = $link.attr("data-tool");
						tooldesc = $link.attr("data-tooldesc");
						events = $link.attr("data-events");
						pname = $link.attr("data-pname");
						intcmp = $link.attr("data-intcmp");
						hier = $link.attr("data-hier"); 
					} 
					//look for images inside the link, if the img has any omniture tracking data, publish to pubsub
					else if ((img = $link.find('img').first()) &&
								(name = img.attr('data-name')) && 
								(type = img.attr('data-type'))){
						onclick = img.attr("data-onclicks");
						nameplate = img.attr("data-nameplate");
						year = img.attr("data-nameplate-year");
						leadtype = img.attr("data-leadtype");
						tool = img.attr("data-tool");
						tooldesc = img.attr("data-tooldesc");
						events = img.attr("data-events");
						pname = img.attr("data-pname");
						intcmp = img.attr("data-intcmp");
						hier = $link.attr("data-hier"); 
					}
					
					//check the type
					if ($link.hasClass('external-disclaimer')) { type = 'e'};
					//if name not set by data-name attribute, get the link name
					if (!name) {
						var link = grabber( { link: this } )
						name = link.value;
					}
					$.publish('/analytics/link/', { 
						title: name,
						link: this,
						type: type,
						onclicks: onclick,
						leadtype: leadtype,
						tool: tool,
						tooldesc: tooldesc,
						events: events,
						year: year,
						nameplate: nameplate,
						pname: pname,
						intcmp: intcmp,
						hier1:hier
					});	
					
				});
	
		        /*
		         * Email tracking: Email Link Tracking Handler
		         * Attach an event (on click) to all emailto links. [ Design P12 ]
		        */
		        var mailHandler = function(e){
		            var anchorHref = e.target.href || '';
		                anchorFormat = anchorHref.toLowerCase();
	
		            if(anchorHref && anchorFormat.indexOf("mailto:") > -1){
		                anchorFormat = anchorFormat.replace(/[^\w]+/g, '-');
		                var data = { 
		                        title: anchorHref + ' | Email',
		                        uri: '/' + master.url + '/email/' + anchorFormat
		                    };
	
		                $.publish('/analytics/event/', data);
		            }
		        };
	
		        /*
		         * External dealer website tracking:
		         * Attach an event to all external links(click out). [ Design P12 ]
		        */
		        var externalHandler = function(e){
		            var anchor = e.target, anchorClass = anchor.className;
	
		            //There will be 2 case: 1) It's in the external-disclaimer overlay. 2) It's an external link whout popup overlay
		            if(anchorClass && typeof(anchorClass)==="string" &&
		                (anchorClass.indexOf("external") > -1 || anchorClass.indexOf("external-disclaimer ") > -1)){
	
		                var href = $(anchor).attr("href"),
		                	hrefFormat ="";
		                if(typeof(href)!="undefined"){
		                	hrefFormat = href.replace(/[^\w]+/g, '-');
		                }
		                var data = {
		                        title: "Offsite:" + href,
		                        uri: '/' + master.url + '/external/' + hrefFormat
		                    };
	
		                $.publish('/analytics/event/', data);
		            }
		        };
	
		        //Handles all Omniture tracking links in an overlay
		        var trackingHandler = function(e) {
		        	var anchor = e.target, anchorClass = anchor.className;
	
		            //fullscreen button
					 if(anchorClass && typeof(anchorClass)==="string" && anchorClass.indexOf("btn-fullscreen") > -1) {
		            	//gallery view full screen button
		        		var linkName = s.eVar11 + ':full screen' //link name from a page name
		        		$.publish('/analytics/link/', { 
		        			title: linkName,
		        			link: this,
		        			type: 'o',
		        			onclicks: 'view full screen'
		        		});		
		        	}
		        }
		        
		        if ((_da.nameplate !== undefined && _da.nameplate.id !== undefined) || 
		        	(_da.derivative !== undefined && _da.derivative.id !== undefined)) {
		        	//delegate to context
		        	ND.Context.addContextToLinks();
		        } 
		        	
	
		        /*
		         * Global Click Tracking Listener
		         * One event listener intead of binding on every link, 
		         * In order to let it work on dynamic anchors that injected by Javascript.
		         */
		        $(document).bind("click", "a", function(e){
		        	//some listener may prevent/cancel the event listener.
		            if(e && e.target){
		                externalHandler(e);
		                mailHandler(e);
		                trackingHandler(e);
		            }
		        });
		        
		        trackWebtrendFields();
		        
			})
		}			
	}
	
	return module;
	
	
}(window.ND || {}, jQuery, window, document));



/*
		<!-- Configuration, must come from site wide configuration -->
		<script type="text/javascript">
		var _da = {}, _tag = _da.wt = {};
		// Web Trends ID, same ID for whole publication.
		_tag.dcsid="dcs3e9phnudz5bdfu8tzlamfrh_8n7o";
		// The hostname of the website.. Notice the DOT..  -> ".ford.com.au"
		_tag.fpcdom=".hostnamegoeshere.com";
		// The Time Zone
		_tag.timezone=10;
		</script>
*/

 (function(globals, $){

  /**
   * Private functions
   */
	var _isAnalyticsConfigured = function() {
		// Minimum variables required
		if( !globals._da ||
			!globals.ND ||
			!globals.ND.analytics ) {
			return false;
		}
		return true;
	};
	
	var _isWebTrendsConfigured = function() {
		if( globals._tag && 
				globals._da.wt && 
				globals._tag === globals._da.wt &&
				globals.WebTrends ) {
			return true;
		}
		return false;
	};
	
	/**
	 * Do not track single page applications(such as build and price)/mobile applications.The flag is set 
	 * in the view of the single page application.
	 */
	var _isNonSpecialWebAppOmnitureConfigured = function() {
		if(globals._da.om && 
		  (typeof globals._da.om.singlePageApp === 'undefined' || 
		   globals._da.om.singlePageApp === false) &&
		   (globals._da.om.mobileApp === undefined ||
		   globals._da.om.mobileApp === false)) {
			return true;
		}
		return false;
	};
	
	/**
	 * Tracks single page applications only as they need to set omniture variables manually (such as build and price).
	 * The flag is set in the view of the single page application.
	 */
	var _isSinglePageAppOmnitureConfigured = function() {
		if(!_isAnalyticsConfigured()) {
			return false;
		}
		if(globals._da.om && 
		   globals._da.om.singlePageApp === true) {
			return true;
		}
		return false;
	};
	
	/**
	 * Tracks mobile applications using jquery mobile.
	 * The flag is set in the view of the mobile application.
	 */
	var _isMobileAppOmnitureConfigured = function() {
		if(!_isAnalyticsConfigured()) {
			return false;
		}
		if(globals._da.om && 
		   globals._da.om.mobileApp === true) {
			return true;
		}
		return false;
	};
	
	

	//
	// TODO added new trackFps function here, something along these lines:
	//
	
	//var _trackFps = function(_tag, options, wtTracker, params) {
	var _trackFps = function(params) {
		

		//TODO not sure about this if - but likely we also need it here 
		if (_da.skipTracking == undefined || globals._da.skipTracking === false) {
			
			//Create Dragonfly FPS Tracking implementation
			var fpsTracker = ND.analytics.create( 'fps', s );
			
			//Register the DFY tracker implementation for custom activities
			ND.analytics.register( fpsTracker );
			
			//TODO Not sure what parameters are needed in these 2 calls ...
			
			//Give dragonfly a chance to inject meta tags dynamically
			fpsTracker.preCollection(_da, params);
			
			//Execute the normal default page load tracking function.
			//fpsTracker.trackPageView( _da, params);
			fpsTracker.trackPageView( params);
		}		
	};
	
	
	
	var _trackWebTrends = function(_tag, options, wtTracker) {
		//Initalise
		_tag = new WebTrends();

		//Extend.. Similiar as $.extend
		$.extend( _tag, options );
		
		//Further Initalise
		_tag.dcsGetId();
		
		//Create Dragonfly Tracking implementation
		wtTracker = ND.analytics.create( 'webtrends', _tag );
		
		//Register the DFY tracker implementation for custom activities
		ND.analytics.register( wtTracker );
		
		//Copy object
		var choice = $.extend( {}, _da );
		delete choice.wt;
	
		//Give dragonfly a chance to inject meta tags dynamically
		wtTracker.preCollection( choice );
		
		//Execute the normal default page load tracking function.			
		_tag.dcsCollect();
		
		//Expose the parameter
		ND.analytics._tag = _tag;
	};
	
	var _trackOmniture = function(params) {
		
		if (_da.skipTracking == undefined || globals._da.skipTracking === false) {
			//Create Dragonfly Tracking implementation
			var omTracker = ND.analytics.create( 'omniture', s );
			
			//Register the DFY tracker implementation for custom activities
			ND.analytics.register( omTracker );
			
			var _counterField = $('.searchresults-list .no-of-results');// for lincoln result page only. need send out the total No of results
			if(_counterField.length>0){
				_da.pname = _da.pname +':' + $.trim(_counterField.html());
			}
			//Give dragonfly a chance to inject meta tags dynamically
			//module page will need profile is ready
			if (typeof _da.module!=='undefined' && typeof _da.module.page!=='undefined' && typeof _da.module.template=='undefined'){
				var cookieUser = null,cookieUUID = null,moduleTemplate=null;
				if($.cookie('dfy.u')) {
					cookieUser = $.parseJSON($.cookie('dfy.u'));
				}
				if($.cookie('dfy.uuid')) {
					cookieUUID = $.parseJSON($.cookie('dfy.uuid'));
				}
				// set values depending on cookie
				if (cookieUser !== null) {
					moduleTemplate = "owner";					
				} else if (cookieUUID === null) {
					moduleTemplate = "new";
				} else if (cookieUUID != null && cookieUser === null) {
					moduleTemplate = "return";
				}				
				if (moduleTemplate!=null){
					_da.module.template = moduleTemplate;
					$("section.personalisation a[href*='intcmp='],section.smartnextsteps a[href*='intcmp='],section.personalisation form[action*='intcmp=']").each(function(idx){
						var attrName="",attrValue="";
						var attrHref = $(this).attr("href");
						var attrAction = $(this).attr("action");
						if(attrHref!= null && typeof attrHref!=='undefined'){
							attrName = "href";
							attrValue = attrHref;
						}else if(attrAction!= null && typeof attrAction!=='undefined'){
							attrName = "action";
							attrValue = attrAction;
						}
						var temp = "STATUS";
						if(attrValue.indexOf(temp)!=-1){	
							$(this).attr(attrName,attrValue.replace(temp,moduleTemplate));
						}	
					});
				}
				omTracker.preCollection( _da, params);
				//Execute the normal default page load tracking function.
				s.t();	
			}else{
				omTracker.preCollection( _da, params);
				//Execute the normal default page load tracking function.
				s.t();
			}
			
		}
	};
	 
	
	var _track = function() {
		// Minimum variables required
		if(!_isAnalyticsConfigured()) {
			return;
		}
	
	
		/* WEBTRENDS ONLY
	     * This if block represnets the integration of Webtrends only
		 */
		if(_isWebTrendsConfigured()) {
				
				//Create the real Tag
			var _tag,
				//The _tag configuration
				options = globals._tag,
				//Other
				wtTracker;
			
			//When the DOM is ready.
			$(document).ready(function() {
				_trackWebTrends(_tag, options, wtTracker);
				ND.analyticsBinder.bind();
			});
	
			
			//Export the _tag into the global space so that it looks like a normal webtrends tag in the DOM inspector
			globals._tag = globals._da.wt = _tag;
			
		}
	
		/* 
		 * The following is an example of how another implementation might work
		 * Google Analytics
		 * /
		if( globals._gaq && 
			globals._da.ga && 
			globals._gaq === globals._da.ga ) {
				
			//Create Dragonfly Tracking implementation
			var gaTracker = ND.analytics.create( 'google', _gaq );
			
			//Register the DFY tracker implementation for custom activities
			ND.analytics.register( gaTracker );
	
			// When the DOM is ready and analytics is ready.
			$(document).ready(function() {
				//Give dragonfly a chance to inject meta tags dynamically
				gaTracker.preCollection( _da );
				
				//Execute the normal default page load tracking function.
				_gaq.push(['_trackPageview']);
			});		
		}
		 */
	
			
		/* 
		 * Omniture implmentation
		 */
		if(_isNonSpecialWebAppOmnitureConfigured()) {
	 
			// When the DOM is ready and analytics is ready.
			$(document).ready(function() {
				if(_isNonSpecialWebAppOmnitureConfigured()) {

					_trackOmniture();
					_trackFps(); // added
					ND.analyticsBinder.bind();
				}
			});
			
			//TODO add similar code for FPS here
			globals._tag_om = globals._da.om;
			
		}  if(_isMobileAppOmnitureConfigured()) {
			
			/* 
			 * Omniture mobile implmentation
			 */
			
			/**
			 * if this method gets called we are on a mobile device that's using jquery mobile
			 */
			$(document).bind("mobileinit", function(){
				$(document).bind('pagechange', function() {
					
					_trackOmniture();
					//TODO wherever we have _trackOmniture() called, we also have to add trackFps();
					_trackFps();
					ND.analyticsBinder.bind();
				});
				//TODO add similar code for FPS here
				globals._tag_om = globals._da.om;
			});
		}
	}
	
	_track();
	
	/**
	 * WARNING: must be called explicitly every time page changes in single page app
	 */
	ND.analyticsTag = ND.analyticsTag || {
		
		trackOmnitureSinglePageApp : function() {
			if(_isSinglePageAppOmnitureConfigured()) {
				_trackOmniture();
				_trackFps(); // added by remjo
				//DO NOT bind more than once (ND.analyticsBinder.bind()), it's called in _setOnce
				//we want to set globals._da.om only once so remove the method after it's set.
				if (ND.analyticsTag._setOnce !== undefined) {
					ND.analyticsTag._setOnce();
					delete ND.analyticsTag._setOnce;
				}
			}
		},

		trackOmniturePage : function(params) {

			_trackOmniture(params);
			_trackFps(params); // added by remjo
		},
		
		_setOnce : function() {
			globals._tag_om = globals._da.om;
			ND.analyticsBinder.bind();
		},
		
		isSinglePageAppOmnitureConfigured: _isSinglePageAppOmnitureConfigured
	};
	
	
	
}(window, jQuery));

// Now that this code is executed  ->  _tag instanceof WebTrends




/*
Author: 		Ivy/Brett
File name: 		brightcoveTrack.js
Description: 	track brightcove event  video start/video finish
Dependencies: 	jQuery,brightcove
Usage: 			
*/

var ND = window.ND = window.ND || {};

(function($){

	var newWidth, year, modulename, mediaName,ts25,ts50,ts75,ts100,
		currWidth = window.innerWidth,
		trackPos = { "0" : 1, "0.25" : 1, "0.5" : 1, "0.75" : 1, "1" : 1},
		settings= {"track":"11111"};

	ND.Brightcove = {

		//template loaded event handler
		onTemplateLoad: function (experienceID) {
		  	// get references to the player and API Modules and Events
			ND.Brightcove.player = brightcove.api.getExperience(experienceID);
			ND.Brightcove.APIModules = brightcove.api.modules.APIModules;
			trackPos = { "0" : 1, "0.25" : 1, "0.5" : 1, "0.75" : 1, "1" : 1};
		},

		// template ready event handler
		onTemplateReady: function (evt) {
			ND.Brightcove.videoPlayer = ND.Brightcove.player.getModule(ND.Brightcove.APIModules.VIDEO_PLAYER);
			ND.Brightcove.experienceModule = ND.Brightcove.player.getModule(ND.Brightcove.APIModules.EXPERIENCE);
			ND.Brightcove.cuePointsModule = ND.Brightcove.player.getModule(ND.Brightcove.APIModules.CUE_POINTS);
			
			ND.Brightcove.videoPlayer.getCurrentVideo(function(video){
				var videoLengthEightyPercent = video.length/1000 * 0.8;
				ND.Brightcove.cuePointsModule.addCuePoints(video.id, [videoLengthEightyPercent]);
			});
			
			ND.Brightcove.resizeVideo();
			ND.Brightcove.videoPlayer.addEventListener(brightcove.api.events.MediaEvent.PROGRESS,function(e){				
				 var omTitle, omEvents,omType,omProgress,omSegment;				
				 var percent = Math.round(e.position / e.duration *100) / 100;
				 if (trackPos[percent]) {
			          switch (percent) {
			            case 0:
			              if (settings.track.charAt(0) == "1") {
			                omTitle = "video start";
			                omEvents = "event56";
			                mediaName = e.media.displayName; 
			                omType = "m_s";
			                omProgress = "0%";
			                omSegment = "1:M:0-25";
			              }
			              break;
			            case 0.25:
			              if (settings.track.charAt(1) == "1") {	
			            	omTitle = "video 25%";
			            	ts25 = Math.round(e.position);
			                omEvents = "event58,event61="+ts25+",event62";
			                omType = "m_i";
			                omProgress = "25%";
			                omSegment = "1:M:0-25";
			              }
			              break;
			            case 0.5:
			              if (settings.track.charAt(2) == "1") {
			            	omTitle = "video 50%";
			            	ts50 = Math.round(e.position);
			                omEvents = "event59,event61="+(ts50 - ts25)+",event62";
			                omType = "m_i";
			                omProgress = "50%";
			                omSegment = "2:M:25-50";
			              }
			              break;
			            case 0.75:
			              if (settings.track.charAt(3) == "1") {
			            	omTitle = "video 75%";
			            	ts75 = Math.round(e.position);
			                omEvents = "event57,event61="+(ts75 - ts50)+",event62";
			                omType = "m_i";
			                omProgress = "75%";
			                omSegment = "3:M:50-75";
			              }
			              break;
			            case 1:
			              if (settings.track.charAt(4) == "1") {
			                omTitle = "video finish";
			                ts100 = Math.round(e.position);
			                omEvents = "event60,event61="+(ts100 - ts75)+",event62";
			                omType = "m_i";
			                omSegment = "4:M:75-100";
			              }
			              break;
			          }
			          trackPos[percent] = 0;
//			          console.log("omTitle="+omTitle);
//			          console.log("omEvents="+omEvents);
//			          console.log("mediaName="+mediaName);
//			          console.log("omType="+omType);
//			          console.log("omProgress="+omProgress);
//			          console.log("omSegment="+omSegment);
			          if (omType) { 
			        	  ND.Brightcove.trackEvent(omEvents,omType,omProgress,omSegment);
			          }
				 }
			});
//			ND.Brightcove.videoPlayer.addEventListener(brightcove.api.events.MediaEvent.PLAY,function(e){
//				if (e.position == 0) {
//					mediaName = e.media.displayName; 
//					omTitle = "video start";
//					omEvents = "event56";
//					ND.Brightcove.trackEvent();
//				}
//			});
//			ND.Brightcove.videoPlayer.removeEventListener(brightcove.api.events.MediaEvent.PLAY);
//			
//			ND.Brightcove.videoPlayer.addEventListener(brightcove.api.events.CuePointEvent.CUE,function(e){
//				omTitle = "video finish";
//				omEvents = "event57";
//				ND.Brightcove.trackEvent();
//			})
//			ND.Brightcove.videoPlayer.removeEventListener(brightcove.api.events.CuePointEvent.CUE);
			ND.Brightcove.videoPlayer.addEventListener(brightcove.api.events.MediaEvent.COMPLETE, function(e){
				/*mediaName = e.media.displayName; 
				omTitle = "video finish";
				omEvents = "event57";
				ND.Brightcove.trackEvent();
				*/
				//For replaying.
				trackPos = { "0" : 1, "0.25" : 1, "0.5" : 1, "0.75" : 1, "1" : 1};
			});
			//ND.Brightcove.videoPlayer.removeEventListener(brightcove.api.events.MediaEvent.COMPLETE);

			// HTML5 iframe resize fix
			// Code taken from: http://docs.brightcove.com/en/video-cloud/smart-player-api/samples/responsive-sizing.html#HtmlMode
			ND.Brightcove.videoPlayer.getCurrentRendition(function(renditionDTO) {
			
				if (renditionDTO) {
					ND.Brightcove.calulateNewPercentage(renditionDTO.frameWidth, renditionDTO.frameHeight);
				} else {
					ND.Brightcove.videoPlayer.addEventListener(brightcove.api.events.MediaEvent.PLAY, function(event) {
						ND.Brightcove.calulateNewPercentage(event.media.renditions[0].frameWidth, event.media.renditions[0].frameHeight);
					});
				}
			});

			var evt = document.createEvent("UIEvents");
			evt.initUIEvent("resize",true,false,0);
			window.dispatchEvent(evt);
		},

		trackEvent: function(omEvents,omType,omProgress,omSegment){
			if (mediaName && omType && window._da && window._da.om && ND && ND.omniture ) {
			    var  data ={
				    "events":omEvents,
				    "linkType":omType,
				    "content":mediaName,
				    "progress":omProgress,
				    "segment":omSegment,
				    "mediaType":"video"
			    };
				ND.omniture.trackMedia(data);			    
			}
		},

		calulateNewPercentage: function(width,height) {
			var newPercentage = ((height / width) * 100) + "%";
			document.getElementById("videocontainer").style.paddingBottom = newPercentage;
		},

		resizeVideo: function() {
			window.onresize = function(evt) {
				newWidth = window.innerWidth;

				// only run this code if the browser width changes
				if (currWidth !== newWidth) {
					var resizeWidth = $(".BrightcoveExperience").width(),
						resizeHeight = $(".BrightcoveExperience").height();

					if (ND.Brightcove.experienceModule.experience.type == "html") {
						ND.Brightcove.experienceModule.setSize(resizeWidth, resizeHeight);
					}

					currWidth = window.innerWidth;
				}
			};
		}
	};

})(jQuery);


(function($){
	
	var MegaMenu = function (container) {
		var menu = this;
		menu.container = container;
		menu.timeout = 100;
		menu.interval = 100;
		menu.sensitivity = 2;
		
		//hide li title bug 167937 Internal image ID will be shown up when mouse rollover to the extreme right of the vehicle image on the top navigation bar
		
		$("#nav>li").attr('title','');
		//end hide
		
		this.showMenu = function () {
			$(menu.container).addClass("active");
			$("DIV.mega-menu", menu.container).show();
		};
		
		this.hideMenu = function () {
			$(menu.container).removeClass("active");
			$("DIV.mega-menu", menu.container).hide();
		};
		
		
		//hide li title bug 167937 Internal image ID will be shown up when mouse rollover to the extreme right of the vehicle image on the top navigation bar
		
		$("#nav>li").attr('title','');
		//end hide
		
		this.init = function () {
			// Hover over/out
			$(this.container).hoverIntent({
				over: this.showMenu,
				out: this.hideMenu,
				interval: this.interval,
				sensitivity: this.sensitivity,
				timeout: this.timeout
			});
			/*
			// Click
			$(this.container).bind("click", function () {
				menu.showMenu();
				return false;
			});
			*/
			// Close button
			$("DIV.close-button A").bind("click", function () {
				menu.hideMenu();
				return false;
			});
		};
	};
	
	$(function(){
		$("#nav > LI").each(function () {
			if ($(this).children("DIV.mega-menu").size() > 0) {
				var megaMenu = new MegaMenu(this);
				megaMenu.init();
			}
			else if ($(this).children("DIV.menu").size() > 0) {
				$(this).hover(
					function() {
						$(this).addClass("active");
					},
					function() {
						$(this).removeClass("active");
					}
				);
			}
		});
	});
	
})(jQuery);


/*slideshow.js*/
(function($){
	// 
	jQuery.easing['easeInQuint'] = function(p, t, b, c, d) {
		return c * Math.pow (t/d, 5) + b;
	};
	
	var SlideShow = function($slideContainer){
		
		var slideShow = this;

		var $carousel;
		var $slidesContainer;
		var $slides;
		var cur = 0;
		var pos = 0;
		
		slideShow.init = function(){
			
			$carousel = $("ul", $slideContainer);
			$slidesContainer = $('<div class="btns"></div>')
				.appendTo($slideContainer);

			$("li", $carousel).each(function(idx){
				$("<a></a>")
					.attr({data: idx, href: "javascript:void(0)"})
					.appendTo($slidesContainer);
			});

			$slides = $(".btns a", $slideContainer);

			$carousel.jcarousel({
				easing: 'easeInQuint',
				wrap: 'circular',
				scroll: 1,
				itemVisibleInCallback: {
					onAfterAnimation: function(carousel, item, idx, state){
						$carousel = carousel;
						pos = idx;
						slideShow.resetBtns();
					}
				}
			});
			
			$slides.each(function(idx){
				$(this).click(function(e){
					var idx = parseInt($(this).attr("data"));
					var nav = idx - cur + pos;
					$carousel.scroll(nav);
				});
			});
		}

		slideShow.resetBtns = function(){
			var len = $slides.length;
			cur = (pos + len * 100 - 1) % len;
			$slides.removeClass("cur");
			$($slides[cur]).addClass("cur");
		}
	}

	$(function(){
		
		$(".slideshow").each(function(){
			var slideShow = new SlideShow($(this));
			slideShow.init();
		});
	});

	
})(jQuery);


(function($, undefined){
	
	/*
	 * Overlay URL. This reproduces the URL that Facebook URL Linter creates.
	 * eg. http://developers.facebook.com/tools/lint/?url=http%3A%2F%2Fwww.ford.com.au%2Fservlet%2FSatellite%3Fc%3DDFYPage%26cid%3D1248884660596%26pagename%3DFOA%252Fcontroller%26site%3DFOA%23overlay%3D1234567890BD
	 */
	function overlayURL( url, assetid ) {
		url = url || "";
		return escape(url.split('#')[0] + '#overlay=' + assetid).replace("\/", "%2F", "g")			
	}
	
	/*
	 * Overlay Object.
	 */
	var Overlay = function (list, text, rtl) {
		var overlay = this,
			positionNameXaxis = rtl ? 'left' : 'right',
			cacheStore = {};
		
		overlay.container;
		overlay.text = text || {close: "Close",of: "of",prev: "Previous",next: "Next",loading: "Loading Content...",error: "There seems to be a problem."};
		overlay.list = list;
		overlay.fadeSpeed = 200;
		overlay.timeout = 8000;
		overlay.view360Class = "view-360";
		overlay.lightClass = "overlay-light";
		overlay.disclaimerClass = "external-disclaimer";
		
		overlay.init = function (curElem) {
			
			overlay.prepareBannerModes(curElem);			
			overlay.injectContainer();
			overlay.injectControls();
			overlay.registerLiveEvents();
		};
		
		//** INIT FUNCTIONS
		
		//INIT: Events register once
		overlay.registerLiveEvents = function () {
			$(".close-button A, .close-overlay", overlay.container).live("click", function () {
				
				overlay.hide();
				
				$(".overlayblackbg").remove();
				addedBlackbg=false;
				if (overlay.asset != null){
					$.bbq.removeState("overlay");
				}
				
				if($("#overlay").hasClass("syncsltoverlay")==true){
					
					$("#overlay").removeClass("syncsltoverlay");
					
				}
				$.publish('overlay.usercancel');	
				return false;
			});
			
			$(".controls .previous:not(.disabled)", overlay.container).live("click", function () {
				var prevPage = overlay.currentPage * 1 - 1;
				overlay.moveTo(prevPage);
				$.publish('overlay.userprevious');
				return false;
			});
			
			$(".controls .next:not(.disabled)", overlay.container).live("click", function () {
				var prevPage = overlay.currentPage * 1 + 1;
				overlay.moveTo(prevPage);
				$.publish('overlay.usernext');
				return false;
			});
			
			
			$(".click-out A", overlay.container).live("click", function () {
				overlay.hide();
			});			
			
			$(".controls .disabled", overlay.container).live("click", function () {
				return false;
			});
			
			
			
		};
		
		//INIT: Inject Overlay Base mark-up
		overlay.injectContainer = function () {
			var emptyDiv, loading,
			markup = {
				container: function () {
					return '<div id="overlay" class="overlay-box"></div>';
				},
				emptyDIV: function () {
					return '<div class="overlay-box-inner"></div>';
				},
				loading: function () {
					return '<div class="loading"><div class="image"></div><p>' + overlay.text.loading + '</p></div>';
				}
			};
			overlay.jcontainer = $(markup.container())
			overlay.container = overlay.jcontainer.get(0);
			emptyDiv = $(markup.emptyDIV());
			loading = $(markup.loading());
			
			overlay.innerWrapper = emptyDiv; 
			
			overlay.jcontainer.append(emptyDiv).append(loading);
			$("body").append(overlay.container);	
			
							
		};	
		
		//INIT: Decypher if there is a banner
		overlay.setPositionMode = function(type) {
			overlay.modePosition =  type && overlay.positions[type] ? overlay.positions[type] : overlay.defaultPosition
		};
		
		//INIT: Decypher if there is a banner
		overlay.prepareBannerModes = function(curElem) {
			var jbanner = $('#banner'),
				jhero = $('.principal-hero'),
				offset = '',
				banner = false,
				positions = overlay.positions = {};

			
				
			if( (banner = jhero.size()) ) {
				offset = '0 30';
			} else if ( (banner = jbanner.size())) {
				offset = '0 -5';
			}
			
			//Open overlay in window mode if anchor has class centeroverlay
			if (curElem) {
				
				if (curElem.srcElement)  var currentClasses = curElem.srcElement.className;
 					else if (curElem.target) var currentClasses = curElem.target.className;

 				if (currentClasses.toLowerCase().indexOf("centeroverlay") >= 0)
					banner = false;
 			}			
				
			//C520 feature page, so overlay can open in window mode
			if ($('.featuregeneric .principal-hero').size() > 0)
				banner = false;
						
			positions.banner = {
				of: $('#body'),
				my: 'center bottom',
				at: 'center top',
				offset: offset, 
				collision: 'none',
				//Extra prop for overlay
				scrollTop:true
			};
			
			positions.window = {
				of: window,
				my: 'center',
				at: 'center',
				collision: 'none',
				using: function(hash){
					hash[positionNameXaxis] = (hash[positionNameXaxis] >= 0 ? hash[positionNameXaxis] : 0); 
					$(this).css(hash);
				}
			};

			// Current Position	& Default		   
			overlay.modePosition = overlay.defaultPosition = banner ? positions.banner : positions.window;
			
		};
		
		//INIT: Inject the close button and pagination
		overlay.injectControls = function () {
			var controls, closeButton, markup = {
					closeButton: function () {
						return '<div class="close-button"><span><a href="#">' + overlay.text.close + '</a></span></div>';
					},
					controls: function (item) {
						return '<div class="controls"><ul><li class="pagination"><p><span class="current">1</span> ' + overlay.text.of + ' <span class="total">1</span></p></li><li class="previous"><a href="#" title="' + overlay.text.prev + '">' + overlay.text.prev + '</a></li><li class="next"><a href="#" title="' + overlay.text.next + '">' + overlay.text.next + '</a></li></ul></div>';
					}
				};
			
				//The Close Button
				overlay.closeButton = $(markup.closeButton());

				//Hide Pagination for later showing
				controls = $(markup.controls()).hide();
				
				//Insert into the document
				overlay.jcontainer.append(overlay.closeButton).append(controls);
				
				//View Gallery Button
				if($(".view-gallery").length > 0){		
					var viewGalleryButton = $(".view-gallery").clone(false);	
					overlay.jcontainer.append(viewGalleryButton);
					viewGalleryButton.hide();
				}

				
				//
				if($("#overlay").parent().hasClass("lincoln")==true){
					ND.lincolnResetOl();
				}
				
				
		};
		
		// Push state to history (jQuery.bbq.js)
		overlay.pushState = function(){
			var state = {}, asset;
			
			if ($(overlay.anchor).attr("class")){
				asset = $(overlay.anchor).attr("class").match(/asset-\d+/);
			}
			
			if (asset != null){
				overlay.asset = asset;
				overlay.assetid = asset[0].substr(6);
				state["overlay"] = overlay.assetid;
				$.bbq.pushState(state);
			}
		};
		
		
		var socialCache = {};
		
		// Inject Facebook and Add This Button
		overlay.injectSocial = function(){
			
			var share = $("#overlay .share"),
				parent = share.parent(),
				template,
				render,
				done;
			
			//Fade In Social Widgets
			function doneFn() {
				if( !done ) {
					share.fadeIn(200);
					
					//Special initaliser code for add this.
					window.addthis && window.addthis.button( '.addthis-overlay');
					
					done = true;
				}
			}
			
			
			if( share.size() > 0 && overlay.assetid ) {
				
				if( socialCache[overlay.assetid] ) {
					
					share = socialCache[overlay.assetid];
					
				} else {
					
					//Remove it from the DOM
					share.remove();
					
					//Compile Template
					template = overlay.socialTemplate || (overlay.socialTemplate = $('#tmpl-overlay-share').template());
					
					//Render the Template
					render = $.tmpl(template, {replaceURL: overlayURL( window.location.href, overlay.assetid) });
					
					//using html as tmpl plugin is Beta. html will at least create new DOM elements
					share.html(render.html());
				}
					
				parent.prepend( share.hide() )
				
				//Once the facebook like iframe is loaded.. Fade all social widgets in.
				share.find('iframe').bind('load', doneFn);
				
				//Set a timeout incase the face book iframe takes too long.
				setTimeout(doneFn, 5e2);
				
				//Cache the share DOM element
				socialCache[overlay.assetid] = share;
			}
				
		};
		
		var vrCache = {};
		
		// Support VR in the overlay
		overlay.enableVR = function(){
			
			var vrContainer = overlay.jcontainer.find(".vr-container");
			
			var currentIndex = 0, nextIndex = 1;
			var compareNames = [];
			var cacheData = []; // There appears to be a design flaw somehwere in this system.  I need to re-visit it later.
			
			// Set the overlay's position to absolute for this particular overlay, since we want it to stay in place
			// And I didn't want to change it in the CSS lest it break any other overlay functionality
			$("#overlay").css("position", "absolute");
			
			var pad = function(num, size) {
				    var s = num+"";
				    while (s.length < size) s = "0" + s;
				    return s;
				};
			
			
			
			vrContainer.each(function(index){
				var container = $(this);
				
				var vr = container.find('.vr'), data, images, imagesData;
				
				/**
				 * 
				 * JSON spec
				 * 
				 * {
				 * 	"name": "Focus",
				 * 	"vrImages": {
				 * 		"location": http://faptest.edgesuite.net/test-dir/360demo/C346/, // Forward-slash must be included at the end
				 * 	
				 * 	}
				 * }
				 * 
				 */
				// Useful data and images
				data = vr.length > 0 ? vr.parent().find(".vr-data").embeddedData() : 0;
				imagesData = (data && 'vrImages' in data) ? data.vrImages : {};
				
				cacheData.push(data);

				// Cache vehicle data for toggle button
				overlay.jcontainer.data("cache", cacheData);
				
				// Set the initial image source, for great justice
				if (index === 0) {
					vr.attr("src", imagesData.location + imagesData.filenamePrefix + pad(0, imagesData.counterFormat.length) + "." + imagesData.extension)
				}
				
				// If the vr already exists then replace the placeholder with the existing vr.
				// Had to be moved due to automagic above being required and making this entirely ineffective in its old position :(
				/*
				if( vrCache[ vr.attr('src') ] ) {
									vr.replaceWith( vrCache[ vr.attr('src') ] );
									return;
								}*/
				
				
				// Populate the parent array of names with this one, too!  So that we may add them to our button.
				compareNames.push(data.name);
				vr.parent().data("name", data.name);
				
				// Create the overlay dynamically
				$("<span class='car-info'>"+data.name+"</span>").appendTo(container);
				
				images = [];
				
				for (var i=imagesData.start; i<=imagesData.end; i++){
					images.push(imagesData.location + imagesData.filenamePrefix + pad(i, imagesData.counterFormat.length) + "." + imagesData.extension);
				}
				
				if( images.length ) {
					vr.reel({
						revolution: 500,
						frames: images.length,
						images: images
					}); 
				}
			})

			// VR Cursor
			$('.jquery-reel-interface').on('mousedown', function() {
				if (!$.support.optSelected) {
				    $(this).removeClass('reel-cursor').addClass('grab-cursor-ie');
				} else {
					$(this).addClass('grab-cursor');
				}
			});
			$('.jquery-reel-interface').on('mouseup', function() {
				if (!$.support.optSelected) {
					$(this).removeClass('grab-cursor-ie').addClass('reel-cursor');
				} else {
					$(this).removeClass('grab-cursor');
				}
			});

			// display directions  
           $('.reeldirections').fadeTo(1500, 0.7); 
	
			// Create the toggle button
			if (vrContainer.length > 1) {
				
				var currentElem = vrContainer.eq(currentIndex); // little bit hacky but that's ok
				var vrToggleButton = $("<button class='vr-toggle'>" + overlay.jcontainer.data("cache")[nextIndex].name + "</button>")
					.on("click", function(e){
						var elem = vrToggleButton;
						currentIndex++;
						nextIndex++;
						if (currentIndex >= vrContainer.length) currentIndex = 0;
						if (nextIndex >= vrContainer.length) nextIndex = 0;
						// Change the inner text of this button to correspond with the next car to be toggled.
						// Here comes a repetition of code
						elem.html(vrContainer.eq(nextIndex).find("span.car-info").html()); // Word Display should probably be left to the template for i18n considerations
						// This could probably be cleaned up a bit but it works right at this moment.
						currentElem.css("display", "none");
						// Switch to the next element
						currentElem = vrContainer.eq(currentIndex);
						
						currentElem.css("display", "block");
						
					})
					.appendTo(vrContainer);
			}

			overlay.moveToPosition();
		};
		
		// Save the VR from being trashed
		overlay.storeVR = function() {
			var vr = overlay.jcontainer.find('.vr')
			vrCache[ vr.attr('src') ] = vr;
			vr.detach();
		};
		
		//** EVENT FUNCTIONS
		
		//Reposition the overlay.. Especially on window resize.
		overlay.moveToPosition = function(){
			if (overlay.shown) {
				overlay.jcontainer.position(overlay.modePosition);
				if($("#overlay").position().top<0){
					
					$("#overlay").css("top", "0");
					
				}
				// fixing ipad position issue
				if ( /iPhone|iPad|iPod/.test( navigator.platform ) ) {
					overlay.jcontainer.css("left", "10px");
				}
			}
			
		};
			
		/*
		 * Load the URL.. delegates to 
		 * 	.loadContent() or .loadDisclaimerContent()
		 */
		overlay.load = function (anchor, type, url, options) {
			options = options || {};
			
			//Patch for analytics
			overlay.namedTitle = options.name || "";
			
			//Protect Repeat calls. This will fix the issue of Two ajax calles that occurs when the hash change event
			//calls the overlay to load again. We can fix this by checking that the overlay is already in the same State
			//that the repeat call is asking of it. Why send open and send an Ajax call when the overlay is already open
			//on the same URL and same <a> tag.
			if( overlay.shown ) {
				if( anchor !== null && typeof anchor !== 'undefined' && overlay.anchor === anchor ) { return ; }
				if( (anchor === null || typeof anchor === 'undefined') && overlay.contentUrl === url ) { return ; }
			}
			
			//Try to prevent too much flash execution.
			if( overlay.flashLoadTimer ) {
				clearTimeout( overlay.flashLoadTimer );								
			} 

			// Support disabling the clsoe button for SYNC
			overlay.closeButtonEnabled = (typeof options.disableClose === 'undefined') || !options.disableClose
			
			// Optionsl position Type
			overlay.setPositionMode(options.positionType);				
			
			// Scroll up to the top of the page
			if (overlay.modePosition.scrollTop) {
				$('html, body').animate({scrollTop:0}, 'fast');
			}
			
			// Store ref to the Anchor and a ref to the URL
			overlay.anchor = anchor;
			overlay.contentUrl = $(anchor).attr("href");

			// Support Hash Urls
			overlay.asset = ($(anchor).attr("class") || "").match(/asset-\d+/);
			if (overlay.asset != null){
				overlay.pushState(overlay.asset[0]);
			}

			// Clear settings
			overlay.resetType();

			// Config new settings
			if (type === "urlOnly") {
				overlay.contentUrl = url;
				overlay.loadContent( options.success );
			}
			else if (type === "disclaimer") {
				overlay.loadDisclaimerContent();
				overlay.updateClassDisclaimer();
			}
			else if (type === "overlay-sync"){
				overlay.contentUrl = url;
				$("#overlay").addClass("overlay-sync");
				overlay.loadContent( options.success );
				
			}
			else if(type==="syncoverlay5"){
				
				$("#overlay").addClass("syncsltoverlay");
			    if(addedBlackbg==false){
					
					var pheight=$(document).height(); 
					var pwidth=$(document).width(); 
					$("#overlay").before("<div class='overlayblackbg' style='height:"+pheight+"px;width:"+pwidth+"px;' ></div>");
					$("#overlay").addClass("syncsltoverlay");
					addedBlackbg=true;
				}
				
				overlay.contentUrl = url;
				overlay.loadContent();
				
			}else {
				overlay.loadContent();
				overlay.updateClassOnOverlay();
			}
			
			// Display the overlay on the screen of the user to see.
			overlay.show();			
			overlay.moveToPosition();
		};
		
		
		/* Flexible size of overlay
		 * This function was added very late in the game to try and ease the strict size of the overlay
		 */
		overlay.checkSize = function() {
			var padding = parseInt(overlay.innerWrapper.css('padding-left')) * 2,
				contents = overlay.innerWrapper.children().first(),
				width = contents.outerWidth(),
				height = contents.outerHeight();
			
			if($(".view-gallery").length > 0){
				height = height + 30;
				overlay.jcontainer.find(".secondary").css("min-height","385px");
			}
			overlay.previousWidth = overlay.jcontainer.css('width');
			overlay.previousHeight = overlay.jcontainer.css('height');
			overlay.jcontainer.css({'width':width + padding, 'height':height + padding});			
			overlay.moveToPosition();
			

		};
		
		/*
		 * Reset some CSS that is required for smooth functioning
		 */
		overlay.resetCSS = function() {
			
			overlay.jcontainer.css({
				'display':'block',
				'top':'',
				'left':'',
				'width':overlay.previousWidth,
				'height':overlay.previousHeight
			});
		};
		
		/*
		 * SHOW OVERLAY
		 */
		overlay.show = function (callback) {
			overlay.shown = overlay.shown || false;
			if (!overlay.shown) {
				overlay.shown = true;
				overlay.jcontainer.fadeIn(overlay.fadeSpeed, callback);
			}
			overlay.moveToPosition();			
			
		};

		/*
		 * HIDE OVERLAY
		 */		
		overlay.hide = function () {
			overlay.shown = false;
			overlay.updateClassnames("removeActive");
			
			overlay.storeVR();
			
			//Empty the contents of the overlay
			overlay.empty();
			
			//Hide Pagination
			overlay.jcontainer.find(".controls").hide();
			overlay.jcontainer.find(".view-gallery").hide();
			
			//Hide it will effect;
			overlay.jcontainer.fadeOut(overlay.fadeSpeed, function(){
				//Restore display block (must use Left)
				overlay.resetCSS();				
			})
			
			
		};
		
		
		/*
		 * EMPTY OVERLAY
		 * We do this so we can kill the flash.. Damn Flash!
		 */		
		overlay.empty = function () {
			
			//Kill that damned flash.
			overlay.jcontainer && overlay.jcontainer.find('.flash').killFlash();
			
			//Empty the contents of the overlay
			overlay.innerWrapper.empty();
		};
		
		/*
		 * When overlay is all done and loaded
		 */
		overlay.done = function() {
			$.publish('overlay.done', { contents: overlay.innerWrapper, assetid: overlay.assetid, name: overlay.namedTitle });
			// And yes, we're gonna call this here too, because I said so.  Rationality not included.  If symptoms persist, seek psychiatric attention.
			setTimeout(overlay.moveToPosition, 1000); // After one second, because this is still failing on silly old firefox.
		}
		
		//External Disclaimer Click Content
		overlay.loadDisclaimerContent = function () {
			var markup = {
				link: function (link) {
					return '<p class="click-out"><a href="' + link.href + '" title="' + link.text + " " + link.href + '" target="_blank">' + link.text + " " + link.href + '</a></p>';
				}
			}
			var link = {
				text: overlay.text.externalLink,
				href: overlay.contentUrl
			};
			var html = overlay.text.disclaimer;
			html = '<div class="ext-disc">' + html + markup.link(link) + "</div>";
			overlay.innerWrapper.html(html);
			overlay.checkSize();
			
		};
		
		
		//Fill the overlay with content
		overlay.loadContent = function ( successFn ) {
			var jcontainer = overlay.jcontainer,
				overlayContentArea = overlay.innerWrapper,
				overlayLoading = $(".loading",jcontainer),
				success,
				noGutsNoGlory,
				pageEnabled = "pagination-enabled";
			
			// Show or Hide the close button
			if( overlay.closeButtonEnabled ) {
				overlay.closeButton.show();
			} else {
				overlay.closeButton.hide();
			}
			
			jcontainer.addClass("loading");
			overlayLoading.children("P").text(overlay.text.loading);
			overlayLoading.children("DIV.image").show();
						
			//Had to group all these actions so that they could be executed a couple of times.
			noGutsNoGlory = function(fn) {
				overlay.empty();
				if(arguments.length > 0) {
					fn.apply(overlay);
				}
				overlay.updateClassnames();
				
				if (overlay.list.totalCount > 0) {
					jcontainer.addClass(pageEnabled);
					overlay.pagination();
				} else {
					jcontainer.removeClass(pageEnabled);
				}
				
				overlay.customScrollBar();
			}
			
			//Store timestamps so we can compare in the success
			var thisRequest = +new Date();
			overlay.activeRequest = thisRequest;
			
			//Ajax success
			success = function(data, status, xhr) {

				//If this callback is not the latest Overlay AJAX request, then cancel
				if( thisRequest !== overlay.activeRequest ) {
					return; 
				}
				
				noGutsNoGlory(function(){
					jcontainer.removeClass("loading");
					overlayContentArea.html(data);
					
					//Load flash in a timer so that it can be delayed and a little better managed.
					overlay.flashLoadTimer = setTimeout(function() {
						//If this callback is not the latest Overlay AJAX request, then cancel
						if( thisRequest !== overlay.activeRequest ) { return; }
						jcontainer.find('.flash').metaBasedFlash();
					}, 300);
					
					overlay.checkSize();
					overlay.injectSocial();
					overlay.enableVR();
					overlay.done();
				});
				cacheStore[overlay.contentUrl] = data;
				
				//Publish.
				$.publish('overlay.success');
				
				//Callback too
				if( successFn ) {
					successFn.call();
				}
				else {
					overlay.moveToPosition(); // Seriously, we have to call this everywhere now for some reason, as a failsafe measure.  Might as well be infinite looping.  *sigh*
				}
			};

			overlay.pushState();
			
			//Store the Response so that the next click doesn't return to the server
			if(cacheStore[overlay.contentUrl]) {
				success(cacheStore[overlay.contentUrl]);
				return;
			}
			
			//Clear the contents so that it is free of content if there is an error.
			noGutsNoGlory();
			
			$.ajax({
				url:overlay.contentUrl,
				timeout:overlay.timeout,
				success: success,
				dataType:'html',
				error: function (request, error) {
					//Add the buttons in again... :S .
					noGutsNoGlory();
					overlayLoading.children("DIV.image").hide();
					overlayLoading.children("P").text(overlay.text.error);
					delete cacheStore[overlay.contentUrl];					
				}
			});
			
			
		};
		
		/*
		 * Prefetch the URL and store it in cache
		 * Call this method in advance, if you want to avoid the user seeing the *Loading* Dialog
		 * This change was added for the SYNC USB transfer process which uses abuot 6 overlays in sequence.
		 */
		overlay.prefetch = function( url ) {
			
			// Check if already fetched
			if( cacheStore[url] ) { return; }
			
			// Fetch and store in the local cache store for Overlays.
			$.ajax({
				url: url,
				timeout: overlay.timeout,
				success: function(data) {
					cacheStore[ url ] = data;
				}
			});
		};
		
		/*
		 * Function to initalise of re-inialise the custom scrollbar within the overlay.
		 */
		overlay.customScrollBar = function() {
			//Scroll bars
			overlay.jcontainer
				.find('.secondary .body, .custom-scroll')
				.doOnce(function(){
					$(this)
						.jScrollPane({showArrows:false, scrollbarWidth: 13, scrollbarOnLeft:rtl});
				});
		};
		
		/*
		 * Function to initalise of re-inialise anything with the overlay that needs to be
		 */
		
		overlay.reinitalise = function() {
			overlay.customScrollBar();
		};
		$.subscribe('overlay.reinitalise', overlay.reinitalise );
		
		/*
		 * 	Modify classes for updateClassOnOverlay mode
		 */
		overlay.updateClassOnOverlay = function () {
			var link = $(overlay.anchor);
			overlay.jcontainer.toggleClass( overlay.view360Class, link.hasClass(overlay.view360Class) );
			overlay.jcontainer.toggleClass( overlay.lightClass, link.hasClass(overlay.lightClass) );
		};
		
		/*
		 * 	Modify classes for updateClassDisclaimer mode
		 */
		overlay.updateClassDisclaimer = function () {
			if ($(overlay.anchor).hasClass(overlay.disclaimerClass)) {
				overlay.jcontainer.addClass(overlay.disclaimerClass);
			}
			else {
				overlay.jcontainer.removeClass(overlay.disclaimerClass);
			}
		};

		/*
		 * It frustrates me that in order to support a different size overlay I need to modify the overlay script.
		 * Modify classes for updateClassDisclaimer mode
		 
		overlay.updateClassCalcPrice = function () {
			if ($(overlay.anchor).hasClass(overlay.disclaimerClass)) {
				overlay.jcontainer.addClass(overlay.disclaimerClass);
			}
			else {
				overlay.jcontainer.removeClass(overlay.disclaimerClass);
			}
		};*/
		
		overlay.resetType = function () {
			//Actions that must occur to reset the overlay every time it is shown.
			overlay.jcontainer.removeClass(overlay.lightClass);
			overlay.jcontainer.removeClass(overlay.view360Class);
			overlay.jcontainer.removeClass(overlay.disclaimerClass);			
		};
		
		overlay.updateClassnames = function (method) {
			if (overlay.anchor !== undefined) {
				var overlayType = ".overlay" + (overlay.listType() ? "-" + overlay.listType() : "");
				
				$(overlayType).closest(".item.active").removeClass("active");
				
				if (method !== "removeActive") {
					$(overlay.anchor).closest(".item").addClass("active");
				}
			}
		};
		

		
		overlay.listType = function () {
			var type;
			var classname = $(overlay.anchor).attr("class") || "";
			
			if (classname !== undefined) {
				if (classname.match(/overlay-group/) !== null) {
					var group = classname.match(/group[0-9]*/);
					type = group[0];
				}
				else {
					type = "";
				}

				return type;
			}
			
			return "";
			
		};
		
		overlay.pagination = function () {
			var type = overlay.listType();
			var innerChild = overlay.innerWrapper.children("div");
			var height = innerChild.outerHeight();
			if (type !== "") {
				overlay.updateCurrentPage = overlay.setPagination(overlay.list[type].count);
				overlay.updateCurrentPage(overlay.list[type].items[overlay.contentUrl].order);
				//to stop control displaying with loader
				if ((innerChild.length > 0) && (height > 100 )) {
					overlay.jcontainer.find(".controls").show();
					overlay.jcontainer.find(".view-gallery").show();
				}
				
			}
		};
		
		overlay.setPagination = function (total) {
			// Total
			$(".pagination .total", overlay.container).text(total);
			
			return function (current) {
				// Current
				overlay.currentPage = current;
				$(".pagination .current", overlay.container).text(current);
				overlay.disablePaginationButtons(current, total);				
			};
		};
		
		overlay.disablePaginationButtons = function (current, total) {
			if (current === 1) {
				$(".controls .previous", overlay.container).addClass("disabled");
			}
			else {
				$(".controls .previous", overlay.container).removeClass("disabled");
			}
			if(current === total) {
				$(".controls .next", overlay.container).addClass("disabled");
			}
			else {
				$(".controls .next", overlay.container).removeClass("disabled");
			}
		};
		
		overlay.moveTo = function (prevPage) {
			var type = overlay.listType();
			var items = overlay.list[type].items;
			var href, node;
			
			for (var item in items) {
				if (items[item]["order"] === prevPage) {
					node = items[item]["node"];
					href = items[item]["href"];
				}
			}
			
			overlay.anchor = node;
			overlay.contentUrl = href;
			
			overlay.asset = ($(overlay.anchor).attr("class") || "").match(/asset-\d+/);
			if (overlay.asset != null){
				overlay.pushState(overlay.asset[0]);
			}
			
			overlay.loadContent();
		};
		
		//redundant
		//overlay.wireEvents = function(){};
		
	};
	
	var populatePaginationList = function () {
		var list = {},
		totalCount = 0,
		count, i, max = 50;
		
		for (i = 1; i < max; i = i + 1) {
			
			if ($("A.overlay-group" + i).size() > 0) {
				count = 0;
				
				list["group"+i] = {};
				$("A.overlay-group" + i).each(function (j) {
					var node = this;
					var href = $(node).attr("href");
					if (href.indexOf("#") == 0){
						href = href.substr(1);
						
					}
					list["group"+i]["items"] = (j === 0) ? {} : list["group"+i]["items"];
					
					if (! list["group"+i]["items"][href]) {
						list["group"+i]["items"][href] = {
							href: href,
							node: node,
							order: count + 1
						};
						totalCount = totalCount + 1;
						count = count + 1;
					}
				});
				list["group"+i]["count"] = count;
				
			}
			else {
				break;
			}
		}
		list["totalCount"] = totalCount;
		
		return list;
	};
	
	
	var appendOverlay = function (curElem) {
		if ($("#overlay").size() === 0) {
			
			var textContainer = $("#javascript-text"),
				text = $(textContainer.html()),
				getText = function( key ) {
					return text.find("."+key).html();
				},				
				textVals = textContainer.size() ? {
					close: getText("close"),
					of: getText("of"),
					prev: getText("prev"),
					next: getText("next"),
					loading: getText("loading"),
					error: getText("error"),
					disclaimer: getText("disclaimer-text"),
					externalLink: getText("disclaimer-link")
				} : null;

			var overlay = new Overlay(populatePaginationList(), textVals, window.ND && ND.rtl);
			
			overlay.init(curElem);

			$(window).bind('resize', function(){
				overlay.moveToPosition();
			}).bind('scroll', function(){
				overlay.moveToPosition();
			});
			
			return overlay;
		}
	};
	
	// This function is called by child window to retrieve the current item information
	getCurrentItem = function(){
		var item = $("#overlay .controls .current").text();
		return item;
	};
	addedBlackbg=false;
	;
	
	$(function(){
		
		var overlay;
		
		//Open the overlay if the id exists in URL
		$(window).bind('pageLoadedWithOverlay', function(e){
			if( overlay === undefined) { return;}
			
			var url;

			if( window.location.toString().indexOf("#") > 0 ) {
				
				url = $.bbq.getState("overlay") || "";
				//if( url && $("#overlay").is(':hidden')){
				if( url ){
					$('a[class*=' + url + ']').filter('.overlay').eq(0).trigger("click");
				}
			}

			if ( !url && overlay.shown ) {
				overlay.hide();
			}
		});
		
		$wait(function(){
		
		if ($("A.overlay, A.external-disclaimer,A.overlay-sync,A.overlay-light").size() > 0) {
				
			if(window.location.toString().indexOf("#overlay")!=-1){
				//overlay = overlay || appendOverlay();
				if ($("#overlay").size() === 0) {
				//console.log("append");
				overlay =  appendOverlay();
				}else{
				//console.log("overlay");	
				overlay =  overlay;
				}
			}	
			
				
			$("A.overlay").bind("click", function (e) {
				
				if ($("#overlay").size() === 0) {
				
				overlay =  appendOverlay(e);
				}else{
					
				overlay = overlay;
				}
			     
				

				//toggle the custom class of the container.
				var reg = /overlay-[^\s$]+/,
                    $this = $(this);
					$overlay = $("#overlay"),
					newClass = $this.attr("class").match(reg);
				if(newClass){
					oldClass = $overlay.attr("class").match(reg);
					oldClass && $overlay.removeClass(oldClass.join(' '));
					$overlay.addClass(newClass[0] + " overlay-box");
				}
				
				if($this.hasClass("blackbackground")){
					
					if(addedBlackbg==false){
					
					var pheight=$(document).height(); 
					var pwidth=$(document).width(); 
					$("#overlay").before("<div class='overlayblackbg' style='height:"+pheight+"px;width:"+pwidth+"px;' ></div>");
					$("#overlay").addClass("syncsltoverlay");
					addedBlackbg=true;
					}
				}
				

                //inject the custom contents if link contains data attributes that start with "tmpl-"
                var tmplData = $this.attr("data");
                if(tmplData && tmplData.indexOf("tmpl-") == 0){
                    overlay.load(null, "urlOnly", $this.attr("href"), {
                        success: function(){
                            var template = $('#' + tmplData).template();
                            $('#' + tmplData.substr(5)).append( $.tmpl( template ) );
                            //reset the scrollbar, since the content has been changed.
                            overlay.reinitalise();
                        }
                    });
                }else{
                    overlay.load(this);
                }

				e.preventDefault();
				e.stopPropagation();
				flag = true;
				return false;
			});
			
			
			$("A.overlay-light").bind("click", function (e) {
				
				if ($("#overlay").size() === 0) {
				
				overlay =  appendOverlay(e);
				}else{
					
				overlay =  overlay;
				}
				
				overlay.load(this);
				$("#overlay").addClass();
				e.preventDefault();
				e.stopPropagation();
				flag = true;
				return false;
			});
			
			$("A.external-disclaimer").live("click", function (e) {
				if ($("#overlay").size() === 0) {
				
				overlay =  appendOverlay(e);
				}else{
					
				overlay =  overlay;
				}
				var href = $(this).attr("href");
				overlay.load(this, "disclaimer")
				e.preventDefault();
				e.stopPropagation();
				return false;
			});
			
			$(".overlay-parent").bind("click", function (e) {
				if ($("#overlay").size() === 0) {
				
				overlay =  appendOverlay(e);
				}else{
					
				overlay =  overlay;
				}
				var link = $(this).find("A:eq(0)");
				if (link.size() > 0) {
					overlay.load(link);
				}
				e.preventDefault();
				e.stopPropagation();
				return false;
			});
			
			if (!ND.API || !ND.API.isBuildAndPrice) {
			    $(window).trigger('pageLoadedWithOverlay');
			}
			
			
		}})//end 
		
		//ND.API for Flash
		ND.API.launchOverlay = ND.launchOverlay = function(url, options) {
			overlay = overlay || appendOverlay();

			if(!options) options = {};
			var type = options.type || "urlOnly";

			if (url !== undefined) {
				
				overlay.load(null, type, url, options);
			}

			//implement custom class
			if(options.customClass){
				var reg = /overlay-[^\s$]+/,
					$overlay = $("#overlay"),
					oldClass = $overlay.attr("class").match(reg);
				oldClass && $overlay.removeClass(oldClass.join(' '));
				$overlay.addClass(options.customClass + " overlay-box");
			};
		};
		
		$.subscribe('overlay.launch', function(event, options){
			options && ND.launchOverlay(options.url, options);
		});
		
		
		$.subscribe('overlay.hide', function(event){	
			overlay && overlay.hide();
		});
		
		$.subscribe('overlay.prefetch', function(event, options){
			overlay = overlay || appendOverlay();
			overlay.prefetch( options.url );
		});
		
		ND.API.getOverlay = function(){
			overlay = overlay || appendOverlay();
			return 	overlay;
		};
		
		
		if (ND.API && ND.API.isBuildAndPrice) {
		    $(window).trigger('pageLoadedWithOverlay');
		}
		
	});
	
})(jQuery);


(function($){
	var Carousel = function (object, text, mode, currentItem) {
		var carousel = this;
		
		carousel.id = object.options.id || '' ;
		carousel.impl = object;
		carousel.text = text || {next:{label:"Next Page",title:"Go to next page"},prev:{label: "Previous Page",title: "Go to prev page"},page:{label:"Page",title:"Go to page"}};
		carousel.visibleItems = object.options.visible;
		carousel.currentPage = 1;
		carousel.currentItem = currentItem || 0;
		carousel.totalLength = object.size();
				
		carousel.init = function () {
			carousel.injectControls();
			carousel.wireEvents();
			
			
			if (mode == "fullscreen"){


				if( carousel.impl instanceof TouchCarousel ) {
					var imageLoad = carousel.imageLoad;
					carousel.imageLoad = function( index ) {
						carousel.impl.imageLoad( index )
						carousel.updateCurrent( index );
					}
				}
				
				carousel.imageLoad(carousel.currentItem);
				carousel.imageControls();
			}
		};
		
		carousel.injectControls = function () {
			var controlsContainer, prevButton, nextButton, page, pageLength,
			markup = {
				container: function () {
					return '<ul class="controls"></ul>';
				},
				prevButton: function () {
					return '<li class="previous"><a title="' + carousel.text.prev.title + '" href="#">' + carousel.text.prev.label + '</a></li>';
				},
				nextButton: function () {
					return '<li class="next"><a title="' + carousel.text.next.title + '" href="#">' + carousel.text.next.label + '</a></li>';
				},
				page: function (item) {
					return '<li class="page page-' + item.count + ' ' + item.current + '"><a href="#" title="' + carousel.text.page.title + ' ' + item.count + '" index="' + item.count + '">' + carousel.text.page.label + ' ' + item.count + '</a></li>';
				}
			};
			controlsContainer = $(markup.container());
			prevButton = $(markup.prevButton());
			nextButton = $(markup.nextButton());
			
			pageLength = carousel.pageLength();
			
			$(controlsContainer).append(prevButton);
			
			for (var i = 1; i <= pageLength; i = i + 1) {
				var item = {}
				item.count = i
				item.current = (i === 1) ? 'current' : '';
				page = $(markup.page(item));
				$(controlsContainer).append(page);
			}
			
			$(controlsContainer).append(nextButton);
			
			$(carousel.id + " .featurecarousel").append(controlsContainer);
			
			
			
			
		};
		
		carousel.updateCurrentPage = function (pageNum) {
			if (pageNum < 1 || pageNum > carousel.pageLength()) {
				return;
			}
			else {
				$(carousel.id + ' .featurecarousel UL.controls .page').removeClass("current");
				$(carousel.id + ' .featurecarousel UL.controls .page-'+pageNum).addClass("current");
				
				carousel.currentPage = pageNum;
			}
		};
		
		carousel.pageLength = function () {
			return Math.ceil((carousel.totalLength / carousel.visibleItems));
		};		
		
		carousel.wireEvents = function () {
			var 
				// For jumping pages
				pageHandler = function() {
					if (carousel.impl.locked || carousel.impl.animating) { return false; }
					var pageNum = parseInt($(this).attr("index"));
					var itemNum = pageNum * carousel.visibleItems - carousel.visibleItems + 1;
					carousel.impl.scroll(jQuery.jcarousel.intval(itemNum));
					carousel.updateCurrentPage(pageNum);
					return false;
				},
			
				// For moving to the next page
				nextHandler = function() {
					if (carousel.impl.locked || carousel.impl.animating) { return false; }
					carousel.impl.next();
					var pageNum = carousel.currentPage + 1;
					carousel.updateCurrentPage(pageNum);
					return false;
				},
				
				// For moving to the previous page
				prevHandler = function() {
					if (carousel.impl.locked || carousel.impl.animating) { return false; }
					carousel.impl.prev();
					var pageNum = carousel.currentPage - 1;
					carousel.updateCurrentPage(pageNum);
					return false;
				}, featureCarousel, featureCarouselControls;
				
				// Cache the DOM elements for attaching event handlers
				if (carousel.id != '') {
					featureCarousel = $(carousel.id + ' .featurecarousel');
				} else {
					featureCarousel = carousel.impl.container.closest('.featurecarousel');
				}
				//featureCarouselList = carousel.impl.list,
				featureCarouselControls = featureCarousel.find('UL.controls');
				
				
						
			// Attach the next and prev handlers to wipe 
			featureCarouselControls.find('.page A').on('click', pageHandler);
			featureCarouselControls.find('.next A').on('click', nextHandler);
			
			// Attach the page handler to wipe 
			featureCarouselControls.find('.previous A').on('click', prevHandler);			
			
		};
		
		// Loading the big image in fullscreen mode
		carousel.imageLoad = function (index) {
			
			var imageContainer = $(carousel.id + ".image-container .large-image");
			imageContainer.empty();
			var item = carousel.getItemByIndex( index, carousel.id + " .carousel-wrapper UL.items li" );
			var url = $("a",item).attr("href");
			var caption = $("img",item).attr("alt");
			
			var img = $("<img />").attr('src',url)
							  .css('display','none')							  
							  .load(function(){
								if(this.complete || typeof this.naturalWidth != "undefined" || this.naturalWidth != 0){
									imageContainer.append(img);
									$(this).fadeIn('fast');
								}
							  })
							  .hover(
									function(){
										$(".gallery-fullscreen .image-container .caption").show();
									},
									function(){
										$(".gallery-fullscreen .image-container .caption").hide();
									}
								);
			
			carousel.imageUpdate( caption, index + 1, carousel.totalLength );
			carousel.updateCurrent(item);
		}
		
		carousel.imageUpdate = function(caption, current, total) {
			
			$(".gallery-fullscreen .image-container .caption p").text( caption );
			$(".gallery-fullscreen div.controls .current").text( current );					 
			$(".gallery-fullscreen div.controls .total").text( total);

		}
		
		// Update the current state of the carousel in fullscreenmode
		carousel.updateCurrent = function(currentItem){
			
			var elem = $.type( currentItem ) === 'number' ? 
							carousel.getItemByIndex( currentItem, carousel.id + " .carousel-wrapper UL.items li" ) : 
							$(currentItem),
				siblings = elem.siblings();
				
			if( carousel.impl.getItems ) {
				siblings = carousel.impl.getItems();
			}
			siblings.removeClass("current");
			elem.addClass("current");
			
			return false;
		};
		
		// Delegate to carousel impl if needed
		carousel.getItemIndex = function( elem ) {
			if( carousel.impl.getItemIndex ) {
				return carousel.impl.getItemIndex( elem );
			} else {
				return $(elem).index();
			}
		};
		
		// Delegate to carousel impl if needed
		carousel.getItemByIndex = function( index, selector ) {
			if( carousel.impl.getItemByIndex ) {
				return carousel.impl.getItemByIndex( index );
			} else {
				return $(selector).eq( index );
			}
		};
		
		// The image scrolling controls
		carousel.imageControls = function(){
			
		
			$(carousel.id + " .carousel-wrapper UL.items LI").click(function(){
				var index = carousel.getItemIndex( this )
				carousel.imageLoad( index );
				carousel.navStateUpdate( index );
				return false;
			});
			
			$(carousel.id + ".gallery-fullscreen div.controls .next").click(function(){
				var $this = $(this);
				carousel.navState($( ".gallery-fullscreen div.controls .previous"),"remove");
				index = carousel.getItemIndex( $(".carousel-wrapper UL.items LI.current") );				
				index++;

				if(index < carousel.totalLength - 1){
					if(index % carousel.visibleItems == 0){
						carousel.impl.next();
						var pageNum = parseInt($('.featurecarousel UL.controls .current A').attr("index"));
						carousel.updateCurrentPage(++pageNum);
					}
					carousel.imageLoad(index);
				}
				else if (index == carousel.totalLength - 1){
					carousel.imageLoad(index);
					carousel.navState($this,"add");
				}
				
				var pageNum = parseInt(index / carousel.visibleItems);
				var currentPageNum = $(".carousel-wrapper .controls .current").attr("index");
				
				if (pageNum != currentPageNum){
					var itemNum = ++pageNum * carousel.visibleItems - carousel.visibleItems + 1;
					carousel.impl.scroll(jQuery.jcarousel.intval(itemNum));
					carousel.updateCurrentPage(pageNum);
				}
				
			});
			
			$(".gallery-fullscreen div.controls .previous").click(function(){
				var $this = $(this);
				carousel.navState($(".gallery-fullscreen div.controls .next"),"remove");
				index = carousel.getItemIndex( $(".carousel-wrapper UL.items LI.current") );
				index--;
				
				if(index > 0){
					if(index % carousel.visibleItems == 3){
						if((index+2) != carousel.totalLength){
							carousel.impl.prev();
						}
						var pageNum = parseInt($('.featurecarousel UL.controls .current A').attr("index"));
						carousel.updateCurrentPage(--pageNum);
					}
					carousel.imageLoad(index);
				}
				else if (index == 0){
					carousel.imageLoad(index);
					carousel.navState($this,"add");
				}
				
				var pageNum = parseInt(index / carousel.visibleItems);
				var currentPageNum = $(".carousel-wrapper .controls .current").attr("index");
				
				if (pageNum != currentPageNum){
					var itemNum = ++pageNum * carousel.visibleItems - carousel.visibleItems + 1;
					carousel.impl.scroll(jQuery.jcarousel.intval(itemNum));
					carousel.updateCurrentPage(pageNum);
				}
			});	
			
			$(".gallery-fullscreen .image-info").hover(
				function(){
					$(".gallery-fullscreen .image-container .caption").show();
				},
				function(){
					$(".gallery-fullscreen .image-container .caption").hide();
				}
			);
		}
		
		carousel.navState = function (button,action) {
			if(action == "remove"){$(button).removeClass("disabled");}
			if(action == "add"){$(button).addClass("disabled");}
		}
		
		carousel.navStateUpdate = function (index){
			var item = $(".gallery-fullscreen div.controls li");
			var preBtn = $(".gallery-fullscreen div.controls .previous");
			var nextBtn = $(".gallery-fullscreen div.controls .next");
			
			if (index > 0 && index < (carousel.totalLength - 1)){
				$(item).each(function(){
					if ($(this).hasClass("disabled")){
						carousel.navState($(this),"remove");
					}
				});	
			}
			else if (index == 0) {
				carousel.navState(preBtn,"add");
				if (nextBtn.hasClass("disabled")){
					carousel.navState(nextBtn,"remove");
				}
			}
			else if (index == (carousel.totalLength - 1)) {
				carousel.navState(nextBtn,"add");
				if (preBtn.hasClass("disabled")){
					carousel.navState(preBtn,"remove");
				}
			}
		}
		
	};
	
	
	var carousel_initCallback = function (object) {
		var text = {
			next: {
				label: "Next Page",
				title: "Go to next page"
			},
			prev: {
				label: "Previous Page",
				title: "Go to prev page"
			},
			page: {
				label: "Page",
				title: "Go to page"
			}
		};
		
		var mode = "carousel";
		var carousel = new Carousel(object, text, mode, object.start);
		carousel.init();
		return carousel;
	};
	
	// This initCallback is for gallery fullscreen page
	var carouselFullscreen_initCallback = function (object) {
		var text = {
			next: {
				label: "Next Page",
				title: "Go to next page"
			},
			prev: {
				label: "Previous Page",
				title: "Go to prev page"
			},
			page: {
				label: "Page",
				title: "Go to page"
			}
		};
		var currentItem = window.opener ? window.opener.getCurrentItem() : 1;
		currentItem = currentItem - 1;
		var mode = "fullscreen";
		var carousel = new Carousel(object, text, mode, currentItem);
		carousel.navStateUpdate(currentItem);
		carousel.init();
		return carousel;
	};
	
	var carousel_buttonNextCallback = function (object, element, flag) {
		var element = $(object.options.id + " .featurecarousel UL.controls LI.next");
		if (!flag) {
			$(element).addClass("unclickable");
		}
		else {
			$(element).removeClass("unclickable");
		}
	};
	
	var carousel_buttonPrevCallback = function (object, element, flag) {
		var element = $(object.options.id + " .featurecarousel UL.controls LI.previous");
		if (!flag) {
			$(element).addClass("unclickable");
		}
		else {
			$(element).removeClass("unclickable");
		}
	};

	//Wrap jcarousel in minimun number check.
	$.fn.carouselCustom = function(data){ 
	    if(this.find("li").length <= data.visible) {
	    	this.parent().addClass('no-carousel');
		}
		if( this.length && Modernizr.touch && Modernizr.csstransforms ) {
			data.container = this;
			new TouchCarousel(data);
		} else {
		    this.jcarousel(data); 
		}
	    
	    return this; 
	}
	
	//gbaker@TouchCarousel
	function TouchCarousel() {
		this.init.apply( this, arguments );
	}
	
	//gbaker@TouchCarousel$prototype
	TouchCarousel.prototype = {
	
		constructor: TouchCarousel,
		
		init: function( options ) {
			this.options = options;			
			this.el = options.el;
			// Vars
			this.container = $( this.options.container )
			this.items = this.container.children('LI');
			
			this.subGallery();
			
			// Call super class 
			this.container = this.container;
			this.length = this.items.length;
			this._super = this.options.initCallback( this );
	
			// Pages
			this._pageIndex = 0;
			this._pages = 0;
			
			// Touch
			this.container.addClass('touch-items');
			//debugger;
			this.build();
			
			// Other init fn's
			this.calcWidth();
			this.initScroll();
			this.fireCallbacks();

			// other 
			this.updateGallery()			
		},
		
		build: function() {
			
			// New scrolling wrapper
			this.container.wrap('<div class="featurecarousel-scroller"><div class="featurecarousel-group"></div></div>');
			
			// Ref
			this._group = this.container.parent();
			this._scroller = this._group.parent();
			
			// Remove this because it will be replaced
			this.container.detach();
			
			// Vars
			var group = $('<ul class="items touch-items"></ul>'),
				start = 0,
				visible = this.options.visible,
				offset = this.length % visible,
				pages = $();
			
			// Cache indexes
			this.items.each(function(i){
				$(this).data('carousel-index', i);
			});
			
			// Group items by visible
			while( start < this.length ) {
				
				// How many to slice
				var tempVisible = offset !== 0 && start === 0 && this.options.rtl ? offset : visible; // RTL trick
				
				// Create a page 
				var pageItems = this.items.slice( start, start + tempVisible );
				var page = group.clone(false).append(pageItems);
				
				// Append to the DOM
				this._group.append( page );
				
				// Maintain collection
				pages = pages.add( page );
				
				// Increment pages counter
				start += tempVisible;
				this._pages++;
			}
			
			// Something to refer to.
			this.container = pages;
			this.items = this.container.children('li');
			

		},
		
		// Width of items in on the scroller
		calcWidth: function() {
			var width = 0;
			this._scroller.find('ul').each(function() {
				width += $(this).outerWidth(true);
			})
			this._group.css('width', width);			
		},
		
		// The scroller
		initScroll: function() {
			var self = this;
			var to = this._scroller.get(0);
			this.iscroll = new iScroll( to, {
				snap: 'ul',
				momentum: false,
				hScrollbar: false,
				onScrollEnd: function(e) {
					self._pageIndex = this.currPageX;
					self._super.updateCurrentPage( self.fauxIndex() + 1 );
					self.fireCallbacks();
				}
			});
			this.iscroll.scrollToPage( this.fauxIndex(), 0 );
		},
		
		// Trigger callbacks that the Carousel needs to update the controls	
		fireCallbacks: function() {
			this.options.buttonNextCallback( this, null, this.fauxIndex() !== (this._pages - 1) );
			this.options.buttonPrevCallback( this, null, this.fauxIndex() !== 0 );
		},
		
		// LTR or RTL page index
		fauxIndex: function() {
			return ( this.options.rtl ? (this._pages - (1 + this._pageIndex)) : this._pageIndex )
		},
		
		// Move a page
		scrollToIndex: function() {
			this.iscroll.stop();
			this.iscroll.scrollToPage( this.fauxIndex(), this.options.animation );
			this.fireCallbacks();
		},
		
		subGallery: function() {
			// Gallery
			this.largeImage = $(".image-container .large-image");
			if( this.largeImage.length ) {
				this.previewCarousel = new PreviewTouchCarousel({
					largeimage: this.largeImage, 
					rtl: this.options.rtl,
					items: this.items,
					onChange: $.proxy( this.subGalleryChange, this )
				});
			}
		},
		
		// When the large image is swiped
		// Update the thumbnail carousel and the controls.
		subGalleryChange: function( pos ) {
			this._pageIndex = Math.floor(pos / this.options.visible);
			
			// Move the thumbnail carousel
			if( this.iscroll ) {
				this.iscroll.stop();
				this.iscroll.scrollToPage( this.fauxIndex(), this.options.animation );
			}
			
			// Update the gallery controls etc.
			if( this._super ) {
				this._super.navStateUpdate( pos );
				this._super.imageUpdate( this.items.eq(pos).find('img').attr('alt'), pos + 1, this.items.length );
				this._super.updateCurrent( pos )
			}
			this.fireCallbacks();
		},
		
		// Numbers
		updateGallery: function() {
			if( this.largeImage.length ) { 
				this._super.imageUpdate( this.items.eq( this.fauxIndex() ).find('img').attr('alt'), this.fauxIndex() + 1, this.items.length );
			}
		},
		
		/* Implement same jCarousel Functions */
		
		size: function() {
			return this.length;
		},
		
		scroll: function( pos ) {
			this._pageIndex = Math.floor(pos / this.options.visible);
			this.scrollToIndex();			
		},

		prev: function() {
			this._pageIndex = this.fauxIndex() - 1;
			this.scrollToIndex();
		},

		next: function() {
			this._pageIndex = this.fauxIndex() + 1;
			this.scrollToIndex();
		},
		
		// Helper functions
		
		getItemIndex: function( item ) {
			return $(item).data('carousel-index');
		},
		
		getItems: function() {
			return this.items;
		},

		// Return the faux index of the item or return the real index.
		// Object can be in either state.
		getItemByIndex: function( index ) {
			var self = this,
				item;
			this.items.each(function(i) {
				if( self.items.eq(i).data('carousel-index') === index ) {
					item = self.items.eq(i);
					return false;
				}
			});
			return item || this.items.eq(index);
		},
		
		imageLoad: function( index, callback ) {
			this.previewCarousel.loadIndex( index , callback );			
		}
	};
	
	//gbaker@PreviewTouchCarousel
	function PreviewTouchCarousel() {
		this.init.apply( this, arguments );
	}
	
	//gbaker@PreviewTouchCarousel$prototype
	PreviewTouchCarousel.prototype = {
	
		constructor: PreviewTouchCarousel,
	
		init: function( options ) {
			this.options = options;			
			this.el = options.el;
			// vars
			this.container = $( this.options.largeimage ).empty();
			
			// images
			this._imageIndex = 0;
			this._images = [];
			
			// html
			this.build();
			
			// start
			this.idxHelper = new FauxIndex( this._images.length, 0, this.options.rtl );
			if( this._images.length ) {
				//this.toggleVisibility( this._images.eq( this.idxHelper.getIndex() ), true );
			}
			
			// Scroll
			this.calcWidth();
			this.initScroll();
			
		},
		
		build: function() {
			
			// New scrolling wrapper
			this.container.html('<div class="large-image-scroller"><div class="large-image-group"></div></div>');
			
			// Ref
			this._scroller = this.container.children();
			this._group = this._scroller.children();
			
			// vars
			var largeImage = $('<img class="preview-image" />'),
				items = this.options.items,
				images = $();
			
			// images creation
			items.each(function(i){
				
				//vars
				var item = items.eq(i),
					href = item.find('a:first').attr('href'),
					image = largeImage.clone();
				
				// Save for later
				image.data('imageUrl', href)
				
				// Maintain collection
				images = images.add( image );
			});
			
			
			this._images = images;
			this._group.append( images );
		},
		
		// Width of items in on the scroller
		calcWidth: function() {
			var width = 0;
			this._images.each(function(i) {
				width += $(this).outerWidth(true);
			})
			this._group.css('width', width);			
		},

		// The scroller
		initScroll: function() {
			var self = this;
			var to = this._scroller.get(0);
			this.iscroll = new iScroll( to, {
				snap: true,
				momentum: false,
				hScrollbar: false,
				onScrollStart: function() {
					self.idxHelper.setIndex( this.currPageX );
					self.optimiseIndex( self.idxHelper.getIndex() );
				},
				onScrollEnd: function(e) {
					self.idxHelper.setIndex( this.currPageX );
					self.optimiseIndex( self.idxHelper.getIndex() );
					self.options.onChange( self.idxHelper.getIndex() );					
				}
			});
			this.iscroll.scrollToPage( this.idxHelper.getIndex(), 0, 0 );
		},				
				
		loadIndex: function( index ) {
			this.idxHelper.setIndex( index );
			this.imageDownload( this.idxHelper.getIndex() )
			this.optimiseIndex( this.idxHelper.getIndex() );
			this.iscroll.scrollToPage( this.idxHelper.getIndex(), 0, 600 );
		},
		
		optimiseIndex: function( index ) {
			var images = this._images;
			images.each(function( i ){
				var image = images.eq(i);
				if( i === index || i === index + 1 || i === index - 1) {
					image.css('visibility', 'visible');
				} else {
					image.css('visibility', 'hidden');
				}
			});
			this.imageDownload( index - 1);
			this.imageDownload( index );
			this.imageDownload( index + 1 );

		},
		
		imageDownload: function( index ) {
			var image = this._images.eq( index ),
				imageUrl = image.data('imageUrl');
			
			if( image.attr('src') != imageUrl ) {
				image.attr('src', imageUrl);
			}
		}
	};
	
	//gbaker@FauxIndex
	function FauxIndex() {
		this.init.apply( this, arguments );
	}
	
	//gbaker@FauxIndex$prototype
	FauxIndex.prototype = {
	
		constructor: FauxIndex,
		
		init: function( length, start, rtl ) {
			this.length = length;
			this._index = start;
			this._rtl = rtl || false;
		},
		
		// Get the faux index
		getIndex: function() {
			return ( this._rtl ? (this.length - (1 + this._index)) : this._index )
		},
		
		// Set the true index
		setIndex: function( index ) {
			this._index = index;
		}
		
	};
	
	$.fn.buildComparatorCarousel = function(id) {
		var $carousel = $(id);
		var $featureCarousel =  $carousel.find("UL.items");
		if ($featureCarousel.length > 0) {
			var carouselOptions = {
				id : id,
				rtl: window.ND && ND.rtl,
				visible: 5,
				scroll: 5,
				animation: 8e2,
				initCallback: carousel_initCallback,
				buttonNextCallback: carousel_buttonNextCallback,
				buttonPrevCallback: carousel_buttonPrevCallback
			};
			carouselOptions.itemFallbackDimension = 300;//Sohrab : ie8 fix for build and price
			$featureCarousel.carouselCustom(carouselOptions);
		}
	}
	
	$.fn.buildCarousel = function(options) {
		var scrollNum = $(".featurecarousel-wrapper.buildmodel").size() ? 5 : 6;

		var $featureCarousel =$(".featurecarousel-wrapper UL.items");
		if ($featureCarousel.length > 0) {
			var carouselOptions ={
				rtl: window.ND && ND.rtl,
				visible: scrollNum,
				scroll: scrollNum,
				animation: 8e2,
				initCallback: carousel_initCallback,
				buttonNextCallback: carousel_buttonNextCallback,
				buttonPrevCallback: carousel_buttonPrevCallback
			} ;
			if (scrollNum === 5) {//TODO: update this and replace it with options.isBuildandprice
				carouselOptions.itemFallbackDimension = 300;//Sohrab : ie8 fix for build and price
			}
			$featureCarousel.carouselCustom(carouselOptions);
		}
		
		$carouselWrapper = $(".carousel-wrapper UL.items");
		if ($carouselWrapper.length > 0) {
			$carouselWrapper.carouselCustom({
				rtl: window.ND && ND.rtl,
				visible: 4,
				scroll: 4,
				animation: 8e2,
				initCallback: carouselFullscreen_initCallback,
				buttonNextCallback: carousel_buttonNextCallback,
				buttonPrevCallback: carousel_buttonPrevCallback
			});	
		}
		
		if (options && options.start) {
			carousel.updateCurrentPage(options.start);
		}
	};
	
	$(function(){
		$.fn.buildCarousel();
	});
	
})(jQuery);


(function($){
	
	var ColourPicker = function (banner, bannerCloneId, coloriser, swapper, foregroundCar, backgroundCar) {
		var picker = this;
		picker.banner = banner;
		picker.bannerCloneId = bannerCloneId;
		picker.coloriser = coloriser;
		picker.swapper = swapper;
		picker.foregroundCar = foregroundCar;
		picker.backgroundCar = backgroundCar;
		picker.items = [];
		picker.selectedClassname = "current";
		picker.loaderMarkup = '<div id="pickerLoader"></div>',
		picker.tooltipMarkup = function(colorName) {
			return "<span class='tooltip'><span>" + colorName + "</span></span>";
		};
		
		picker.init = function () {
			picker.defineItems();
			picker.wireEvents();
		};
		
		picker.defineItems = function () {
			picker.items = $("li:not(.label)", picker.coloriser);
			(picker.items).each(function() {
				var colorName = $(this).find("span").html();
				$(this).append(picker.tooltipMarkup(colorName));
			});
		};
		
		picker.updateBanner = function (imagePath) {
			var done = false,
				loader = setTimeout(function(){
					if(!done) {picker.loader("show");}
				},100);
			
			picker.preLoadImage(imagePath, function () {
				done = true;
				picker.loader("hide");
				picker.bannerClone = $(picker.banner).clone().attr("id", picker.bannerCloneId);
				$(picker.banner).after(picker.bannerClone);
				picker.bannerClone.animate({opacity:0}, 400, function() {
					$(this).remove();
				});
				$(picker.banner).css('background-image', 'url(' + imagePath + ')');
			});
		};
		
		picker.updateSelected = function (anchor) {
			$(picker.items).removeClass(picker.selectedClassname);
			$(anchor).parent().addClass(picker.selectedClassname);
		};
		
		picker.preLoadImage = function (imagePath, callback) {
			$("<img src='" + imagePath + "' />").bind("load", function() {
				callback();
			});
			};
		
		picker.loader = function (state) {
			if (state === "show") {
				$(picker.coloriser).before(picker.loaderMarkup);
			}
			else if (state === "hide"){
				$("#pickerLoader").remove();
			}
		};
		
		picker.wireEvents = function () {
			if ( /iPhone|iPad|iPod/.test( navigator.platform ) ) {
				$("li a", picker.coloriser).on("mouseover", function(e) {
					//console.log("Derp");
					var imagePath = $(this).attr("href");
					picker.updateBanner(imagePath);
					picker.updateSelected(this);
					//return e.preventDefault();
				});
			}
			$("li a", picker.coloriser).bind("click", function (e) {
				//console.log("click");
				var imagePath = $(this).attr("href");
				picker.updateBanner(imagePath);
				picker.updateSelected(this);
				return e.preventDefault();
			});
			// swapper clicked
			$("li", picker.swapper).bind("click", function(e) {
				var carType = $(this).attr("class");
				var firstAnchor = $("." + carType + " a", picker.coloriser).first();
				var imagePath = firstAnchor.attr("href");
				
 				$("li:not(:visible)", coloriser).hide();
				$("ul", coloriser).toggle();
				picker.updateSelected(firstAnchor);
				$("ul:visible li", coloriser).fadeIn(300);
				$("li", picker.swapper).slideToggle("fast");
				picker.updateBanner(imagePath);
				e.preventDefault();
			});
			// foreground car clicked - same as clicking on the next color on the coloriser
			picker.foregroundCar.bind("click", function(e) {
				var currentLI = picker.items.filter("." + picker.selectedClassname);
				if (!currentLI.is(":last-child"))
					currentLI.next().find("a").trigger("click");
				else{
					//picker.items.filter(":visible").first().find("a").trigger("click");
					
					currentLI.parent().children(":first").find("a").trigger("click");
				}
					
			});
			// background car clicked - same behaviour as when swapper clicked
			picker.backgroundCar.bind("click", function(e) {
				$("li:visible", picker.swapper).trigger("click");
			});
		};
		
	};
	
	
	// On Load
	$(function(){
		var banner = $("#banner");
		var bannerCloneId = "banner-clone";
		var coloriser = $("#coloriser");
		var swapper = $("#car-swapper");
		var backgroundCar = $("#background-car");
		var foregroundCar = $("#foreground-car");
		
		if ($(banner).size() > 0 && $(coloriser).size() > 0) {
			var colourPicker = new ColourPicker(banner, bannerCloneId, coloriser, swapper, foregroundCar, backgroundCar);
			colourPicker.init();
		}
	});
	
})(jQuery);


/*
 * This file combine 2 versions of bing map together for each market to switch between these 2 versions
 */
(function($) {
	//Adds up the values of all the selected elements
	jQuery.fn.totalValString = function() {
		var total = '';
		this.each(function() {
			total = total + jQuery(this).val().replace(/[\s\t\n]/g, '');
		});
		return total;
	};
})(jQuery);

(function($) {
	var ND = window['ND'] || {};

	ND.loadScript = function(url, callback) {

		var script = document.createElement("script")
		script.type = "text/javascript";

		if (script.readyState) {//IE
			script.onreadystatechange = function() {
				if (script.readyState == "loaded" || script.readyState == "complete") {
					script.onreadystatechange = null;
					callback();
				}
			};
		} else {//Others
			script.onload = function() {
				callback();
			};
		}

		script.src = url;
		document.body.appendChild(script);
	};

	/*
	 * BingMap has the depandence of document.attachEvent, it may not ready when called by $wait in Firefox.
	 * only use for version6 . version7 doesnt have this issue
	 */
	var isReady = function(func) {
		if ( (typeof (Microsoft) == "undefined" || typeof (Microsoft.Maps) == "undefined") && $.browser && $.browser.mozilla) {
			$ready("document.attachEvent", func);
		} else {
			func();
		}
	};

	ND.dealerLocator = {
		data : [],
		dl : [],
		init : function(zoom, lng, lat, key, country) {
			var self = this;
			var args = arguments;

			isReady(function() {
				if (args.length > 0) {
					self.dl = new DealerLocator({
						mapId : "dealer-map",
						lng : lng,
						lat : lat,
						zoom : zoom,
						key : key,
						country : country
					});
					//eg. 133.769531, -25.244696, 4
				} else {
					self.dl = new DealerLocator({
						mapId : "dealer-map",
						lng : 0,
						lat : 0,
						zoom : 0
					});
				}
				self.dl.setSearch(self.data);
				self.domInit();
			});
		},
		directions : function(endPoint, lang) {
			var self = this;
			var working = false;

			isReady(function() {
				$(function() {
					var holder = document.createElement("div");
					holder.innerHTML = document.getElementById('get_directions').innerHTML;
					var $getDir = $(holder);
					var $miniForm = $('.mini-dealer-form');
					/* For Owner */
					if ($(".owner-map").size()) {
						$getDir.addClass("dealer-route");
						$miniForm = $(".dealer-details");
					}

					$getDir.insertAfter($miniForm);
					$getDir.find('form').submit(function(e) {
						var $this = $(this);
						var $mapDirectionsStart = $('#map-directions-start');
						var jmsg = $this.find('.message').length > 0 ? $this.find('.message') : $('<p class="message">' + $('#directions-failed-message').val() + '</p>');
						if ($mapDirectionsStart.val().length > 0) {
							jmsg.hide(0);
							if (!working) {
								working = true;
								self.dl.findRoute($mapDirectionsStart.val(), endPoint, lang, function() {
									working = false;
								});
							}
						} else {
							$this.prepend(jmsg.hide(0));
							jmsg.slideDown();
						}
						e.preventDefault();
					});
					$('a.VE_PlaceList_Close').live('click', function() {
						$('#map-directions-panel').parent().removeClass("loading");
						working = false;
					});
				});
			});
		},
		add : function(obj) {
			var self = this;
			self.data.push(obj);
			//fixed asyn issue
			if(self.dl.setSearch && obj.islast && obj.islast=="true"){
				self.dl.setSearch(self.data);
			}
		},
		domInit : function() {
			$(function() {
				$dealerResultsMap = $('#dealer-results-map');

				$dealerResultsMap.each(function() {
					lastSelected = $('');
					$(this).find('TBODY TR.dealer TD').hover(function() {
						$(this).closest('TR').addClass('hover');
					}, function() {
						$(this).closest('TR').removeClass('hover');
					});
				});

				// Populate cookie postcode.
				$('#dl_location').each(function() {
					var loc = $(this);
					loc.each(function() {
						if ($.trim(loc.val()) === "") {
							$.publish("shopping.pref.retrieve", function(e, data) {
								if (data && data.postcode) {
									loc.val(data.postcode);
								}
							});
						}
					});
				});

				//Form Builder Submit Version
				$('#dealer-search-button').each(function() {

					if ($('div.webshim-validation').size() != 0) {
						return;
					}

					$('#dragonflyform').submit(function(e) {
						var jform = $(this);

						if ($('INPUT[type=text], SELECT', jform).totalValString().length < 1) {
							var jmsg = jform.find('.message').length > 0 ? jform.find('.message') : $('<p class="message">' + $('#submission-failed-message').val() + '</p>');
							jform.prepend(jmsg.hide(0));
							jmsg.slideDown();
							e.preventDefault();
						}
					});
				});

				//Form Builder Submit Version
				$('#submit-dealer').each(function() {
					$('#dragonflyform').submit(function(e) {
						if ($(this).find('INPUT:checked').length <= 0) {
							$('#dealer-error').hide().addClass("error").fadeIn("slow");
							e.preventDefault();
							return false;
						}
					});
				});

				$dealerResultsMap.find('TBODY TR').click(function(event) {
					var $input = (this.nodeName == "INPUT" ? this : $("INPUT.dealerinfo", this));
					if (event.target.nodeName != "INPUT" && event.target.nodeName != "LABEL" && event.target.nodeName != "A") {
						if (!$input.is(":checked")) {
							$input.attr("checked", true)
						}
					}
					if ($input.is(":checked")) {
						$(this).siblings(".selected").removeClass("selected");
						$(this).addClass("selected");
					}
				});
				$dealerResultsMap.find("INPUT.dealerinfo:checked").closest("TR").addClass("selected");

				$('.dealer-popup').live('click', function(e) {
					ND.anchors.storage.popup.apply(this);
					e.preventDefault();
				});
				$('.dealer-external').live('click', function(e) {
					ND.anchors.storage.external.apply(this);
					e.preventDefault();
				});
			});
		},
		selectById : function(id, dealerinfo) {
			$tr = $('#' + id);
			$tr.siblings(".selected").removeClass('selected');
			$tr.addClass('selected');
			$input = $('#' + dealerinfo);
			$input.attr("checked", true)
			var targetOffset = $tr.offset().top - 200;
			$('html,body').animate({
				scrollTop : targetOffset
			}, 1000);
		}
	};

	var InteractiveMap = function(options) {
		if (options.isVersion7) {
			this.initV7(options);
		} else {
			this.init(options);
		}
	};
	/**
	 * the following prototype contains 2 different versions of bingmap.
	 */
	InteractiveMap.prototype = {
		/**
		 * use the following methods for bing map Version 7.0
		 */
		initV7 : function(options) {
			this.country = options.country;
			this.resetMarkers();
			this.loadMapV7(options);
		},
		loadMapV7 : function(options) {
			var map = this.map = new Microsoft.Maps.Map(document.getElementById(options.mapId), {
				credentials : options.key,
				center : new Microsoft.Maps.Location(options.lat, options.lng),
				zoom : parseInt(options.zoom),
				mapTypeId : Microsoft.Maps.MapTypeId.road,
				enableSearchLogo : false
			});
		},
		resetMarkers : function() {
			this.shapes = {};
		},
		//add pushpin and info box on the map
		addMarkerV7 : function(data, selectable) {
			var scope = this, pushpinIcon, jdealer = $('#' + data.id),
			//create current dealer location
			location = new Microsoft.Maps.Location(data.lat, data.lng), infoboxOption = {
				id : "infoDesc_" + data.pinid,
				width : 265,
				showCloseButton : false,
				offset : new Microsoft.Maps.Point(77, -117)
			};
			//add custom pushpin icon
			if (jdealer.find('.dealer-icon').length > 0) {//pushpin element can be found from dealer-result list
				pushpinIcon = '<span class="' + jdealer.find('.dealer-icon').attr("class") + ' ' + data.pinid + '">' + data.pinid + '</span>';
			} else {// for those dealer-result list which doesnt have pushpin icon definded
				pushpinIcon = '<span class="dealer-icon cat1 ' + data.pinid + '">' + data.pinid + '</span>';
			}
			//create pushpin
			var shape = new Microsoft.Maps.Pushpin(location, {
				htmlContent : pushpinIcon,
				width : 20,
				typeName : "customDealerPin"
			});

			if ($(".owner-map").size()) {
				infoboxOption.description = '<div class="dealer-flyout" id="infoDesc_' + data.pinid + '">' + ( selectable ? '<p class="selectdealer"><a href="javascript:void(0)" onclick="ND.dealerLocator.selectById(\'' + data.id + '\',\'' + data.dealerinfo + '\')">' + data.selectDealer + '</a></p>' : '' ) + '<h3>' + jdealer.find(".dealername").html() + "</h3><p>" + jdealer.find(".address").html() + "</p><p>" + jdealer.find(".contact").html() + "</p></div>";
			} else {
				if ($(".dealer-map-pagination").size()) {
					infoboxOption.description = '<div class="dealer-flyout" id="infoDesc_' + data.pinid + '">' + ( selectable ? '<p class="selectdealer"><a href="javascript:void(0)" onclick="ND.dealerLocator.selectById(\'' + data.id + '\',\'' + data.dealerinfo + '\')">' + data.selectDealer + '</a></p>' : '' ) + jdealer.find(".dealername").html() + jdealer.find(".contact").html() + "</div>";
				} else {
					infoboxOption.description = '<div class="dealer-flyout" id="infoDesc_' + data.pinid + '">' + ( selectable ? '<p class="selectdealer"><a href="javascript:void(0)" onclick="ND.dealerLocator.selectById(\'' + data.id + '\',\'' + data.dealerinfo + '\')">' + data.selectDealer + '</a></p>' : '' ) + '<h3>' + jdealer.find(".dealername").html() + "</h3><p>" + jdealer.find(".contact").html() + "</p></div>";
				}
			}
			//create info box for pushpin, set the default location to the infobox, the default location should be the same with its pushpin location
			var infobox = new Microsoft.Maps.Infobox(location, infoboxOption);
			//display infobox
			scope.displayInfobox(shape, infobox, location, data.pinid);
			//add info box to map
			scope.map.entities.push(infobox);
			//add pushpin to the map
			scope.map.entities.push(shape);
			scope.shapes[data.pinid] = data;
		},
		/**
		 * To switch the infobox position from pushpin left to pushpin right if the pushpin is located at the right of the map
		 * To switch the infobox position from bottom of the pushpin to the top if the pushpin is located at the bottom of the map
		 * the idea is find the center of the map, compare with the pushpin location, reset the related infobox location
		 *
		 * @param shape, current pushpin object
		 * @param infobox, current infobox object
		 * @param location, defalut infobox location
		 * @param pinId, unique id to identify the current pushpin
		 */
		displayInfobox : function(shape, infobox, location, pinId) {
			var scope = this, thisInfobox = {};
			//add event to pushpin, a tricky way to show the info box while mouseovering pushpin.
			Microsoft.Maps.Events.addHandler(shape, 'mouseover', function() {
				//set to the default location before each show , as the location will be overrided under specific case (eg, map offset to the right, override infobox location to show it at left of the map center)
				infobox.setLocation(location);
				//find the current info box
				thisInfobox = $(".MicrosoftMap #infoDesc_" + pinId).closest(".Infobox");
				//find mapCenter and transform it to pixel
				//find pushPinLocation and transform it to pixel
				//define infobox offset, the entire infobox offset should be include: "infobox width(that is infoboxWidth)", "infobox arrow width(that is infoarrowWidth)", "pushpin width(that is pushpinWidth)" and infobox itself default offset
				var mapCenter = scope.map.tryLocationToPixel(scope.map.getCenter(), Microsoft.Maps.PixelReference.control), pushPinLocation = scope.map.tryLocationToPixel(shape.getLocation(), Microsoft.Maps.PixelReference.control), infoboxLocation = infobox.getLocation(), infoboxPixel = scope.map.tryLocationToPixel(infoboxLocation, Microsoft.Maps.PixelReference.control), infoarrowWidth = thisInfobox.find(".infobox-stalk").outerWidth(), pushpinWidth = shape.getWidth(), infoboxWidth = thisInfobox.outerWidth(), hasLeftClass = false, hasTopClass = false,
				//define infobox offset
				infoboxHeight = thisInfobox.outerHeight();
				//map offset right, should display infobox on the left of pushpin
				if (pushPinLocation.x > mapCenter.x) {
					infoboxPixel.x = infoboxPixel.x - infoarrowWidth - pushpinWidth - infoboxWidth - 24;
					var infoboxDestinationLocationX = scope.map.tryPixelToLocation(new Microsoft.Maps.Point(infoboxPixel.x, infoboxPixel.y), Microsoft.Maps.PixelReference.control);
					//class will be removed after reset the location
					infobox.setLocation(infoboxDestinationLocationX);
					hasLeftClass = true;
				}
				//map offset bottom, should display infobox on the top of pushpin
				if (pushPinLocation.y > mapCenter.y) {
					infoboxPixel.y = infoboxPixel.y - infoboxHeight + 55;
					var infoboxDestinationLocationY = scope.map.tryPixelToLocation(new Microsoft.Maps.Point(infoboxPixel.x, infoboxPixel.y), Microsoft.Maps.PixelReference.control);
					//class will be removed after reset the location
					infobox.setLocation(infoboxDestinationLocationY);
					hasTopClass = true;
				}

				if (hasLeftClass) {
					thisInfobox.addClass("left");
				}
				if (hasTopClass) {
					thisInfobox.addClass("top");
				}

				thisInfobox.css("visibility", "visible");
			});
			Microsoft.Maps.Events.addHandler(shape, 'mouseout', function() {
				thisInfobox.css("visibility", "hidden");
			});
			Microsoft.Maps.Events.addHandler(infobox, 'mouseenter', function() {
				thisInfobox.css("visibility", "visible");
			});
			Microsoft.Maps.Events.addHandler(infobox, 'mouseleave', function() {
				thisInfobox.css("visibility", "hidden");
			});
			//hide infobox when map veiw change
			Microsoft.Maps.Events.addHandler(scope.map, 'viewchangestart', function() {
				$(".MicrosoftMap .Infobox").css("visibility", "hidden");
			});
		},
		setMapViewV7 : function(data) {
			var collectionCordindates = new Array();
			for (var i = 0; i < data.length; i++) {
				collectionCordindates.push(new Microsoft.Maps.Location(data[i].lat, data[i].lng));
			}
			//only one dealer found
			if (collectionCordindates.length == 1) {
				this.map.setView({
					center: collectionCordindates[0],
					zoom: 16
				});
			}else if (collectionCordindates.length > 1){
				this.map.setView({
					bounds: Microsoft.Maps.LocationRect.fromLocations(collectionCordindates)
				});
			}
			
		},
		/**
		 * define search, add and display routine on the map
		 *
		 * @param startPoint, start place string entered by user.
		 * @param endPoint, current destination coordinates
		 * @param lang, object contains information for search (eg, error message)
		 * @param callbackfn, run after loadRoute function excute success, set "working" flag back to false
		 */
		loadRouteV7 : function(startPoint, endPoint, lang, callbackfn) {
			$('#map-direction-list').html('');

			var im = this;
			//define RequestOptions
			var requestOptions = {
				avoidTraffic : true,
				routeDraggable : false
			}
			//define renderOptions
			var renderOptions = {
				itineraryContainer : document.getElementById("map-direction-list"),
				displayManeuverIcons : false,
				displayPostItineraryItemHints : false,
				displayPreItineraryItemHints : false,
				displayRouteSelector : false,
				displayStepWarnings : false,
				displayTrafficAvoidanceOption : false,
				displayWalkingWarning : false
			}
			Microsoft.Maps.loadModule('Microsoft.Maps.Directions', {
				callback : function() {

					if (!im.directionsManager) {
						im.directionsManager = new Microsoft.Maps.Directions.DirectionsManager(im.map);
					}
					//remove all waypoints and routine before each search
					im.directionsManager.resetDirections();
					//define start and end point
					var startWaypoint = new Microsoft.Maps.Directions.Waypoint({
						address : startPoint + " " + im.country
					});
					var endWaypoint = new Microsoft.Maps.Directions.Waypoint({
						location : new Microsoft.Maps.Location(endPoint.lat, endPoint.lng)
					});

					//add start and end point
					im.directionsManager.addWaypoint(startWaypoint);
					im.directionsManager.addWaypoint(endWaypoint);
					//Reset distance unit in options(Route Table);
					lang.unit = $('#dealer-locator-maps').embeddedData()["xhr-distance-unit"] == "miles" ? "mi" : "km";
					//Reset distance unit in Bing Map
					requestOptions.distanceUnit = lang.unit == "mi" ? Microsoft.Maps.Directions.DistanceUnit.miles : Microsoft.Maps.Directions.DistanceUnit.kilometers;
					// Set request options
					im.directionsManager.setRequestOptions(requestOptions);
					// Set the render options
					im.directionsManager.setRenderOptions(renderOptions);
					// define error messages when error occurs (eg, 2 destinations can not be reached)
					Microsoft.Maps.Events.addHandler(im.directionsManager, 'directionsError', function() {
						alert(lang.fail);
					});
					// display the route on the map
					im.directionsManager.calculateDirections();
					callbackfn();
				}
			});
		},
		loadDirections : function(route, lang) {
			var legs = route.RouteLegs;
			var turns = '<tr><td class="total" colspan="3"><span>' + lang.total + '</span> ' + route.Distance.toFixed(1) + ' ' + lang.unit + '</td></tr>';
			var numTurns = 0;
			var leg = null;
			// console.log(legs.length, route.Distance);
			if (legs.length > 60 || route.Distance > 1000) {
				this.map.DeleteRoute();
				this.map.ShowMessage(lang.tofar);
			} else if (legs.length > 0) {
				//this.map.DeleteAllShapes()
				//this.addMarker(this.shapes[0]);
				for (var i = 0; i < legs.length; i++) {
					leg = legs[i];
					var turn = null;
					turns += '<tr>';
					for (var j = 0; j < leg.Itinerary.Items.length; j++) {

						turn = leg.Itinerary.Items[j];
						turns += '<td class="num">' + (numTurns == 0 ? '' : numTurns) + '</td>';
						turns += '<td>' + turn.Text + '</td>';
						turns += '<td class="dist">' + turn.Distance.toFixed(1) + ' ' + lang.unit + '</td>';
						if (j + 1 < leg.Itinerary.Items.length) {
							turns += '<tr></tr>';
						}
						numTurns++;
					}
					turns += '</tr>';
				}
				$('#map-direction-list').html('<table class="map-directions">' + turns + '</table>');
			} else {
				this.map.ShowMessage(lang.fail);
			}
		},

		/**
		 * use the following methods for bing map Version 6.2
		 */
		init : function(options) {
			this.country = options.country;
			var map = this.map = new VEMap(options.mapId);
			this.resetMarkers();

			if (options['key'] != undefined) {
				map.SetCredentials(options.key);
			}

			//Distance Unit: Kilometers or Miles?
			this.unit = $('#dealer-locator-maps').embeddedData()["xhr-distance-unit"] == "miles" ? VEDistanceUnit.Miles : VEDistanceUnit.Kilometers;

			map.SetDashboardSize(VEDashboardSize.Small);
			map.LoadMap(new VELatLong(options.lat, options.lng), options.zoom, VEMapStyle.road, false);
			map.SetScaleBarDistanceUnit(this.unit);
		},
		loadMap : function(options) {
			this.map.LoadMap(new VELatLong(options.lat, options.lng), options.zoom, VEMapStyle.road, false);
		},
		addMarker : function(data, selectable) {
			var jdealer = $('#' + data.id);
			var shape = new VEShape(VEShapeType.Pushpin, new VELatLong(data.lat, data.lng));

			if (jdealer.find('.dealer-icon').length > 0) {//pushpin element can be found from dealer-result list
				shape.SetCustomIcon('<span class="' + jdealer.find('.dealer-icon').attr("class") + ' ' + data.pinid + '">' + data.pinid + '</span>');
			} else {// for those dealer-result list which doesnt have pushpin icon definded
				shape.SetCustomIcon('<span class="dealer-icon ' + data.pinid + '">' + data.pinid + '</span>');
			}

			if ($(".owner-map").size()) {
				shape.SetDescription('<div class="dealer-flyout">' + ( selectable ? '<p class="selectdealer"><a href="javascript:void(0)" onclick="ND.dealerLocator.selectById(\'' + data.id + '\',\'' + data.dealerinfo + '\')">' + data.selectDealer + '</a></p>' : '' ) + '<h3>' + jdealer.find(".dealername").html() + "</h3><p>" + jdealer.find(".address").html() + "</p><p>" + jdealer.find(".contact").html() + "</p></div>");
			} else {
				if ($(".dealer-map-pagination").size()) {
					shape.SetDescription('<div class="dealer-flyout">' + ( selectable ? '<p class="selectdealer"><a href="javascript:void(0)" onclick="ND.dealerLocator.selectById(\'' + data.id + '\',\'' + data.dealerinfo + '\')">' + data.selectDealer + '</a></p>' : '' ) + jdealer.find(".dealername").html() + jdealer.find(".contact").html() + "</div>");
				} else {
					shape.SetDescription('<div class="dealer-flyout">' + ( selectable ? '<p class="selectdealer"><a href="javascript:void(0)" onclick="ND.dealerLocator.selectById(\'' + data.id + '\',\'' + data.dealerinfo + '\')">' + data.selectDealer + '</a></p>' : '' ) + '<h3>' + jdealer.find(".dealername").html() + "</h3><p>" + jdealer.find(".contact").html() + "</p></div>");
				}
			}
			this.map.AddShape(shape);
			this.shapes[shape.GetID()] = data;
		},
		setMapView : function(data) {
			var collectionCordindates = new Array();
			for (var i = 0; i < data.length; i++) {
				collectionCordindates.push(new VELatLong(data[i].lat, data[i].lng));
			}

			if (collectionCordindates.length != 0) {
				this.map.SetMapView(collectionCordindates);
			}
		},
		loadRoute : function(startPoint, endPoint, lang, callback) {
			// console.log("loadRoute");
			$('#map-direction-list').html('');
			$('#map-directions-panel').parent().addClass("loading");
			var im = this;
			var options = new VERouteOptions();

			//Reset distance unit in options(Route Table);
			lang.unit = $('#dealer-locator-maps').embeddedData()["xhr-distance-unit"] == "miles" ? "mi" : "km";
			//Reset distance unit in Bing Map
			options.DistanceUnit = lang.unit == "mi" ? VERouteDistanceUnit.Kilometer : VERouteDistanceUnit.Kilometer;

			options.RouteColor = new VEColor(0, 55, 134, 1);
			options.RouteWeight = 3;
			options.RouteCallback = function(route) {
				$('#map-directions-panel').parent().removeClass("loading");
				if (route != undefined) {
					im.loadDirections.apply(im, [route, lang]);
				}
				callback.call();
			};
			this.map.GetDirections([startPoint + " " + this.country, new VELatLong(endPoint.lat, endPoint.lng)], options);
		}
	};

	var DealerLocator = function(options) {
		this.init(options)
	};
	DealerLocator.prototype = {
		init : function(options) {
			//detemine whether the bing map version is 7
			this.isVersion7 = true;
			if ( typeof (Microsoft) == "undefined" || typeof (Microsoft.Maps) == "undefined") {
				this.isVersion7 = false;
			}
			options.isVersion7 = this.isVersion7;
			this.options = options;
			this.load();
		},
		load : function() {
			this.map = new InteractiveMap(this.options);
		},
		setSearch : function(data) {
			if (data.length > 0) {
				this.load();
				this.map.resetMarkers();
				this.isVersion7 ? this.map.setMapViewV7(data) : this.map.setMapView(data);
				var selectable = data.length > 1;
				for (var i = 0; i < data.length; i++) {
					this.addDealer(data[i], selectable);
				}
			}
		},
		addDealer : function(dealer, selectable) {
			//the "select this dealer" needs to be publishble, get it from translation
			dealer.selectDealer = "Select this dealer";
			if($("#dealer-translations").length > 0){
				var selectDealer = $("#dealer-translations").embeddedData().SelectThisDealer;
				if(selectDealer){
					dealer.selectDealer = selectDealer;
				}
			}
			this.isVersion7 ? this.map.addMarkerV7(dealer, selectable) : this.map.addMarker(dealer, selectable);
		},
		findRoute : function(startPoint, endPoint, lang, callback) {
			if (startPoint != undefined && endPoint != undefined) {
				this.isVersion7 ? this.map.loadRouteV7(startPoint, endPoint, lang, callback) : this.map.loadRoute(startPoint, endPoint, lang, callback);
			}
		}
	};

})(jQuery);

// pre-populate the service type on dealer locater page - Ford China
(function($) {
	var serviceTypePopulate = function() {

		var url = window.location.href;
		var key = "serviceType";

		var type = $.getQueryVariable(url, key);

		if (type) {
			$(".dealer-form-siderbar select[name='specialities']").val(type);
		}

	};

	$(function() {
		if ($(".dealer-form-siderbar select[name='specialities']").length > 0) {
			serviceTypePopulate();
		}
		/**
		 * due to increasing spacing between the relative ".print" button and ".dealer-results-map",
		 * set the spacing dynamically will fix the lack of spacing issue of relateive ".print" btn in the future
		 */
		var printBtn = $(".content-high > .hardpanel + .dealer-results-map > .print");
		//identify deeply to prevent conflict with other "print" btn in other pages if have
		dealerRsIllustrator = $(".content-high > .hardpanel .dealer-results-illustrator");
		if (printBtn.length > 0 && dealerRsIllustrator.length > 0) {// if both of them exist
			var spacing = dealerRsIllustrator.outerHeight(true);
			printBtn.css("top", "-=" + spacing);
		}

	});
})(jQuery);


// feedback Url
(function($){
	var ND = window['ND'] || {};
	ND.feedbackURL = function(exurl){				
		if ($("#feedback").length > 0){
			var mark = "";
			if (exurl.length > 0 && (exurl.indexOf("?") != -1)){
				mark = "&";
			}
			exurl +=  mark + "fbdata=";
			var currentUrl = window.location;
			var param = encodeURIComponent("feedback_url=" + currentUrl);
			exurl += param;			
			var feedbackMarkup = "<iframe id='feedbackwrap' src = '"+exurl+"' scrolling='no' frameborder='0' style='border:none; overflow:hidden; width:100%;'></iframe>";
			$("#feedback").append(feedbackMarkup);
		}					
	};
})(jQuery);


/*globals jQuery */
(function($){
	$(function(){
		$("#comparingModels").doOnce(function(){
			
			
			
			var comparer = $(this),
				tables = $(".specification-table"),
				checkboxes = comparer.find("input"),
				cacheStore,
				transformInputs,
				updateCookie,
				toggleColEach,
				toggleColEvent,
				toggleCol,
				createCol,
				injectWarningMsg,
				checkExistingCookie,
				warningMessage = $([]),
				cols = {},
				max = 4,
				min = 1;
			


			//Cookie Object abstraction
			cacheStore = {
				key:"specChecks",
				get:function(){
					return $.cookie(this.key) || "";
				},
				set:function(value){
					if(this.get() !== value) {
						//Session cookie
						$.cookie(this.key, value, {path:'/', expires:-1});
					}
				},
				is:function(){
					return this.get().length > 0;
				},
				contains:function(value){
					return this.get().indexOf(value) > -1;
				}
			};
			
			transformInputs = function () {
				checkboxes.each(function () {
					var $this = $(this),
						$parent = $this.parent(),
						attributes = {
							'id': this.id,
							'name': $this.attr("name"),
							'class': this.className,
							'value': this.value,
							'type': 'checkbox'
						};
					$this.remove();
					
					$parent.prepend(function () {
						return $("<input/>").attr(attributes).get(0);
					});
				});
				checkboxes = $("input", comparer);
			};
			
			//Associations
			createCol = function(){
				//assumes checkboxes and cols are same order and count.
				checkboxes.each(function(index){
					var col = {};
					col.checkbox = $(this);
					col.cells = tables.find('td:nth-child(' + (index+2) + ')');
					cols[this.id] = col;
				});
				
			};
			
			checkExistingCookie = function(){
				if(!cacheStore.is()) { return; }
				
				var matches = $(this).filter(function(){
					return cacheStore.contains(this.id);
				}).size();
				
				if(matches <= 0) {
					cacheStore.set("");	
				}
			};
			
			//On Load first time
			toggleColEach = function(index, element){
				//this is checkbox
				toggleCol.apply(this, [(cacheStore.is() && cacheStore.contains(this.id)) || (!cacheStore.is() && index < 4)])
			};
			
			//Per checkbox click
			toggleColEvent = function() {
				//this is checkbox
				var current = checkboxes.filter(':checked'),
					length = current.size();
				
				//If we are within the number of allowed checked items. then go ahead
				if(length <= max && length >= min ) {
					warningMessage.hide();
					toggleCol.apply(this, [$(this).is(":checked")]);
					updateCookie(current);
				} else {
					//We have hit a boundary so allow or disallow the check action.
					if(length > max) {
						$(this).removeAttr("checked");
						warningMessage.show();
					}else{
						$(this).attr("checked", "checked");
					}
				}
				
			};
			
			//Shows or hides the column.
			toggleCol = function(action){
				//this is checkbox
				var $this = $(this),
					cells = cols[this.id].cells;

				if(action) {
					$this.attr("checked", "checked");
					cells.show();
				} else {
					$this.removeAttr("checked");
					cells.hide();
				}
			};
			
			//Sets the checkboxes passed into the cookie
			updateCookie = function(current){
				var cookieValue = [];
				current = current || checkboxes.filter(':checked');
				current.each(function(){
					cookieValue.push(this.id);
				});
				cacheStore.set(cookieValue.join());
			};
			
			injectWarningMsg = function () {
				var warning = $("INPUT#limitReached");
				var markup = {
					messageContainer: function (message) {
						return '<p class="warning">' + message + '</p>';
					}
				};
				if ($(warning).size() > 0) {
					var message = $(warning).val();
					warningMessage = $(markup.messageContainer(message));
					$(comparer).prepend(warningMessage);
					$(warningMessage).hide();
					$(warning).remove();
				}
			};
			
			//Init effectively
			transformInputs();
			createCol();
			injectWarningMsg();
			checkboxes.doOnce(checkExistingCookie).each(toggleColEach);
			checkboxes.bind('click.sd', toggleColEvent);
			
		});		
	});
})(jQuery);


(function($){
	var AccessData = function (accessContainer, dropdown) {
		var accessData = this;
		accessData.container = accessContainer;
		accessData.dropdown = dropdown;
		accessData.modelAccessoryClass = "model-accessory-container";
		accessData.modelHeadingClass = "model-heading";
		accessData.cookie = {
			name: "accessData"
		};
		
		accessData.init = function () {
			var selection = accessData.findSelected();
			accessData.showSelectedOption(selection)
		//	accessData.loadSelectedContainer(selection);
			accessData.showSelectedContainer(selection);
			accessData.removeHeadings();
			accessData.wireEvents();
		};
		
		accessData.findSelected = function () {
			var selection;
			if ($.cookie(accessData.cookie.name) !== null) {
				selection = $.cookie(accessData.cookie.name);
			}
			else {
				selection = $("option:selected", accessData.dropdown).attr("value");
			}
			
			return selection;
		};
		
		accessData.removeHeadings = function () {
			$("." + accessData.modelAccessoryClass + " DIV." + accessData.modelHeadingClass, accessData.container).remove();
		};
		
		accessData.showSelectedOption = function (selection) {
			if ($.cookie(accessData.cookie.name) !== null) {
				$("option", accessData.dropdown).each(function () {
					if ($(this).attr("value") === selection) {
						$(this).attr("selected", "selected");
					}
				});
			}
		};
		
		accessData.showSelectedContainer = function (selection) {
			$("#" + selection).find("IMG").lazyLoadImages();
			
			$("." + accessData.modelAccessoryClass, accessData.container).hide();
			$("#" + selection).show();
		};
		
		accessData.updateCookie = function (selection) {
			//session cookie
			$.cookie(accessData.cookie.name, selection, {path:'/', expires:-1});
		};
		
		accessData.wireEvents = function () {
			$(accessData.dropdown).bind("change", function () {
				var selection = $("option:selected", this).attr("value");
				accessData.updateCookie(selection);
				accessData.showSelectedContainer(selection);
			});
		};
	};
	
	$(function(){
		var accessContainer = $(".accessories-container");
		var dropdown = $("#modelName");

		if($(accessContainer).children("DIV").size() > 0 && $(dropdown).size() > 0) {
			var accessData = new AccessData(accessContainer, dropdown);
			accessData.init();
			accessData.dropdown.trigger("change");
		}
	});
	
})(jQuery);


(function($){
	
	var Tooltip = function (container, link, parent) {
		var tooltip = this;
		tooltip.container = container;
		tooltip.link = link;
		tooltip.parent = parent;
		tooltip.interval = 50;
		tooltip.timeout = 50;
		tooltip.sensitivity = 2;
		tooltip.itemheight = $(tooltip.parent).height() + parseInt($(tooltip.parent).css("margin-bottom"));
		
		tooltip.showTooltip = function () {
			var tiptop = $(tooltip.parent).offset().top - $(window).scrollTop();
			var tipbottom = $(window).height() - $(tooltip.parent).height() - tiptop;
			if (tipbottom <= tooltip.itemheight){
				$(tooltip.container).addClass("tooltip-top");
			}
			$(tooltip.container).show();
			$(tooltip.parent).css("z-index","1000");
		};
				
		tooltip.hideTooltip = function () {
			$(tooltip.container).removeClass("tooltip-top").hide();
			$(tooltip.parent).css("z-index","");
		};
		
		tooltip.init = function () {
			$(tooltip.link).hoverIntent({
				over: tooltip.showTooltip,
				out: tooltip.hideTooltip,
				interval: tooltip.interval,
				sensitivity: tooltip.sensitivity,
				timeout: tooltip.timeout
			});
		};
	};
	
	
	$.fn.tooltip = function() {
		var $links = $("a.tooltip");
		if ($links.size() > 0) {
			$links.each(function () {
				var $link = $(this);
				var $parent = $link.parent();
				var $container = $("div.tooltip", $parent);
				if ($container.size() === 1) {
					$parent.removeClass("hover");
					var tooltip = new Tooltip($container, $link, $parent);
					tooltip.init();
				}
				
			});
		}
	}
	
	$(function(){
		$.fn.tooltip();
	});
	
	$(function(){
		var $galleryLink = $(".gallery a.tooltip");
		if ($galleryLink.size() > 0) {
			$galleryLink.each(function () {
				var $gLink = $(this);
				if ( /iPhone|iPad|iPod/.test( navigator.platform ) ) {
					$gLink.bind("mouseover", function(){
						$gLink.trigger("click");
					});
				}
			});
		}
	});
	
})(jQuery);


(function($) {
	var ComparatorContainer = function(compContainer) {
		var comparatorContainer = this;

		comparatorContainer.init = function() {
			var tables = $(compContainer).children("TABLE");
			if (tables.size() > 0) {
				tables.each(function() {
					var links = $(this).find("a.button");
					links.each(function() {
						$(this).click(function(event) {
							event.preventDefault();
							comparatorContainer.removeColumn(this);
						});
					});
				});
			}
		};

		comparatorContainer.removeColumn = function(linkButton) {
			var index = $(linkButton).parent("td").prevAll().length;
			var tables = $(compContainer).children("TABLE");
			var colCount = $(tables).eq(0).find('TR').eq(1).find("TD").size() - 1;

			tables.each(function() {
				if (colCount > 2) {
					var cells = $(this).find(
							'td:nth-child(' + (index + 1) + ')');
					cells.remove();
					if (colCount == 3) {
						$(this).find('TR').eq(2).remove();
						$(this).find("TBODY TR:even").removeClass("odd");
						$(this).find("TBODY TR:odd").removeClass("even");
						$(this).find("TBODY TR:even").addClass("even");
						$(this).find("TBODY TR:odd").addClass("odd");
					}
				}
			});
		};
	};

	$(function() {
		var comparatorContainer = new ComparatorContainer($(".compa"));
		comparatorContainer.init();
	});

})(jQuery);


/* sync the height of the table rows*/
(function($) {
	var SyncTable = function(syncContainer) {
		var syncTable = this;

		syncTable.sync = function() {
			var tables = $(syncContainer).children("TABLE");

			if (tables.size() == 2) {
				var list1 = $(tables[0]).find("tbody>tr");
				var list2 = $(tables[1]).find("tbody>tr");

				//only need to sync up with the smaller one
				var len = list1.length > list2.length ? list2.length : list1.length;

				for(var idx = 0;idx<len;idx++){
					var height1 = $(list1[idx]).height();
					var height2 = $(list2[idx]).height();

					if(height1 != height2){
						if(height1>height2){
							$(list2[idx]).css({height:height1});
						}else{
							$(list1[idx]).css({height:height2});
						}
					}
				}
			}
		};
	};

	$(document).ready(function() {
		var syncTable = new SyncTable($(".tabc"));
		syncTable.sync();
	});

})(jQuery);


(function($){

	var Locale = function(){
		var locale = this;

		//locale code array
		var localeArr = [],
			COUNTRY = 1,
			CONFIRMED = 2;

		//locale cookie store
		var cookieKey = "dfy.fme.locale", domain;

		var commonConfig = $("#common-config").embeddedData(),
			cookieDomain = commonConfig.cookieDomain,
			localeName = commonConfig.locale;


		locale.checkLocale = function(){
			var self = this;
			var url = window.location.href;
			var location = [];

			
			if ($.cookie(cookieKey)){
				location = $.cookie(cookieKey).split('-');

				if (url.indexOf(location[1]) < 0){
					locale.clearFPSinfo();
					
					locale.setGTUID();
				}

				if (url.indexOf(locale[2]) === "1"){
				// true: locale confirmed
					self.updateCookie(url,true);
				}
				else {
					self.updateCookie(url,false);
				}
			}
			else {
				// false: locale not confirmed
				self.updateCookie(url,false);
			}
			
		};

		//check if there existing confirmed locale cookie
		//if not popup the overlay
		locale.checkCookie = function(url){
			var cookieVal = $.cookie(cookieKey);
			if(cookieVal){
				localeArr = cookieVal.split('-');
			}

			var json = $("#locale-data").embeddedData();
			var url = json["locale-overlay"];
			domain = json["domain"];

			



			//if the locale is confirmed, will not popup overlay.
			if(localeArr[CONFIRMED]=="1"){
				return;
			}

			if (url) {
				$.publish("overlay.launch", {
					url: url,
					success: function() {
						locale.bindOverlay();
					}
				});
			}
		};

		//bind event to overlay, force redirection and change cookie
		//whern user submit the form.
		locale.bindOverlay = function(){
			if($("#overlay .controls").size()){
				$("#overlay .controls").hide();
			}
			$(".country-overlay select").change(function(e){
				$(this).parent("form").attr({"action":$(this).val()});
			}).trigger("change");		//rise change event on default

			$(".country-overlay form").submit(function(e){
				var $this = $(this);
				var value = $("select",$this).val();

				if($this.attr("action")){
					$this.attr({"action": value});
				}

				if (value.indexOf(localeName) < 0){
					locale.clearFPSinfo();
				}

				//if current submit data match the current current url
				//cancel the submit redirection and hide the overlay
				if(!locale.updateCookie(value,true)){
					e.preventDefault();
					$.publish("overlay.hide");
					return false;
				}
			});
			
			var country = localeArr[COUNTRY];
			if (country) {
				$(".country-overlay select option").each(function(idx){
					var $options = $(this);
					var val = $options.attr("value");
					if (val && val.indexOf(country) > 0) {
						$options.attr({"selected" : "selected"});
					}
				});
			}
		};

		//init the tab menu, has dependence of the checkCookie
		locale.initMenu = function(){
			var $current = $(".countrytab .current");
			var $anchors = $(".country li a");

			//Update Menu text
			if(localeArr[CONFIRMED] == "1"){
				//convert ["bh", "ar", "1"] => "bh/ar"
				var key = localeArr.slice(0,2).join('/');
				$anchors.each(function(){
					var $this = $(this);
					var href = $this.attr("href");
					if(href.indexOf(key) >-1 ){
						$current.text($this.text());
					}
				});
			}

			//bind event to top menu update cookie when click on the anchors
			$anchors.click(function(e){
				var value = $(this).attr("href");
				if(!locale.updateCookie(value)){





				if (value.indexOf(localeName) < 0){
					locale.clearFPSinfo();
				}

				if(!locale.updateCookie(value,true)){
					e.preventDefault();
				}
			}
				
			});
		};

		//update locale cookie: convert url "/bh/ar/homeXXX#**" => bh-ar-1
		//return 0 means selected locale match the current url
		locale.updateCookie = function(value,confirmed){
			if (value) {
				//remove the host name,  get the relative path, etc "/en/irq/xxx"
				var host = location.host, i = value.indexOf(host);
				value = i > 0 ? value.substr(i + host.length) : value;
				//remove the first '/' if nessary.
				value = value.charAt(0) == '/' ? value.substr(1) : value;

				//get the locale array, like [ "en", "irq", "0" ]
				var localeArr = value.split('/').slice(0,2);

				if (confirmed){
					localeArr[CONFIRMED] = "1";
				}
				else{
					localeArr[CONFIRMED] = "0";
				}
				

				$.cookie(cookieKey, localeArr.join('-'), {
					expires: 365,
					path: '/',
					domain: domain
				});

				

				// Whether current url contains sth like "/bh/ar"?
				if(location.href.indexOf('/' + localeArr.slice(0,2).join('/')) > 0){
					return 0;
				}

			}

			return 1;
		};

























		locale.clearFPSinfo = function(){
			if($.cookie('dfy.uuid')){
				$.removeCookie('dfy.uuid', {path:'/', domain:cookieDomain});
			}

			if($.cookie('gt_uid')){
				var dmArray = [];
				dmArray = cookieDomain.split('.');

				var dmStr = "." + dmArray[dmArray.length - 2] + "." + dmArray[dmArray.length - 1];
				
				$.removeCookie('gt_uid', {path:'/', domain:dmStr});
			}

			if($.cookie('dfy.p')){
				$.removeCookie('dfy.p', {path:'/', domain:cookieDomain});
			}

			if(sessionStorage.getItem("dfy.p") !== null){
				sessionStorage.removeItem("dfy.p");
			}

		};

		locale.setGTUID = function(){
			//gt_uid is the cookie used by FPS to check user status
			var setCookie = function (sKey, sValue, vEnd, sPath, sDomain, bSecure) {
		        if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) { return false; }
		        var sExpires = "";
		        if (vEnd) {
		            switch (vEnd.constructor) {
		                case Number:
		                    sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
		                    break;
		                case String:
		                    sExpires = "; expires=" + vEnd;
		                    break;
		                case Date:
		                    sExpires = "; expires=" + vEnd.toUTCString();
		                    break;
		            }
		        }
		        document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
		        return true;
		    };
		    var readCookie = function (name) {
		        var nameEQ = name + "=";
		        var ca = document.cookie.split(';');
		        for (var i = 0; i < ca.length; i++) {
		            var c = ca[i];
		            while (c.charAt(0) == ' ') c = c.substring(1, c.length);
		            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
		        }
		        return null;
		    }
			var UUIDV4 = function b(a) { return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, b) };
		    var uid = readCookie('gt_uid') || UUIDV4();

		    var now = new Date();
		    var domain = (function () {
		        var i = 0, domain = document.domain, p = domain.split('.'), s = '_gd' + now.getTime();
		        while (i < (p.length - 1) && document.cookie.indexOf(s + '=' + s) == -1) {
		            domain = p.slice(-1 - (++i)).join('.');
		            document.cookie = s + "=" + s + ";domain=" + domain + ";";
		        }
		        document.cookie = s + "=;expires=Thu, 01 Jan 1970 00:00:01 GMT;domain=" + domain + ";";
		        return domain;
		    })();
		    setCookie('gt_uid', uid, new Date(now.getTime() + (365 * 86400000)), '/', domain);
		};

		locale.init = function(){
			locale.checkLocale();
			locale.checkCookie();
			locale.initMenu();
		};
	};

	$(document).ready(function(){
		// if ($("#locale-data").size()) {
		// 	window.setTimeout(function(){
		// 		var locale = new Locale();
		// 		locale.init();
		// 	}, 1000);
		// }
		if ($("#locale-data").size()){
			window.setTimeout(function(){
			var locale = new Locale();
			locale.init();
			}, 1000);
		}
		
	});

})(jQuery);


/*
Add a clickable area on principal image.
*/

(function ($) {

	var defaults = { x: 100, y: 100, w: 100, h: 100, style: "", url: "", href: "", target: "_self" };
	var hover = "<a style=\"display:block;position:absolute;z-index:10;\"><span style=\"background:url('{0}') no-repeat;visibility:hidden;display:block;height:100%\">&nbsp;</span></a>";

	$.fn.rollOver = function (options) {
		var settings = $.extend(true, {}, defaults, options);

		return this.each(function () {
			var $container = $(this);

			var $hover = $(hover.replace("{0}", settings.url));
			//Alternative background image.
			var $alter = $("SPAN", $hover);

			$hover.attr({
					href: settings.href,
					target: settings.target
				})
				.mouseenter(function(){
					$alter.css({ visibility: "visible" });
				})
				.mouseleave(function(){
					$alter.css({ visibility: "hidden" });
				})
				.appendTo($container);

			if(settings.style){
				$hover.attr({
					style: settings.style
				});
			}else{
				$hover.css({
					top: settings.y,
					left: settings.x,
					width: settings.w,
					height: settings.h
				});
			}
		});
	}

	$.fn.rollOver.defaults = defaults;

})(jQuery);


//change the current css to print mode
(function($){
	var PrintView = function(){
		var printView = this;

		printView.print = function(){
			var $styles = $("link");
			
			for(var idx=$styles.length; idx-- > 0;){
				var $style = $($styles[idx]);

				/* switch the CSS type */
				if($style.attr("media") && $style.attr("media").toLowerCase().indexOf("print") >= 0){
					$style.clone()
						.attr({"media": "screen, projection"})
						.appendTo($("head"));
				}else{
					$style.remove();
				}
			}
		};
		
	};

	$(function(){
		var viewmode = $.bbq.getState( "viewmode" );

		if (viewmode == "print") {
			var printView = new PrintView();
			printView.print();
		}
	});
})(jQuery);


//switch rows for pts
(function(){
	var RowSwitch = function(){
		var rowSwitch = this;

		rowSwitch.init = function(){
			var brandIndex = -1,
				$models = $(".ptslist .models ul"),
				brands = [];
				brandClass = "brand0";

			// Is video player table?
			var $isVideo = $(".ptslist.player");

			$(".ptslist tbody tr").each(function(idx){
				var $this = $(this),
					$brand, brand;
				
				if ($isVideo.size()) {
					$brand = $($(".alleft", $this)[0]);
				} else {
					$brand = $(".carr", $this);
				}

				if ($brand.size() && brands.join().indexOf(brand = $brand.text()) < 0) {
					brandIndex++;
					brandClass = "brand" + brandIndex;
					
					$("<li><a href='#' class='" + brandClass + "' title='" + brand + "' >" + brand + "</a></li>").appendTo($models);
					
					brands.push(brand);
				}

				$this.addClass(brandClass);
			});
		};

		rowSwitch.bind = function(){
			$(".ptslist li a").click(function(e){
				e.preventDefault();
				var $this = $(this);

				$.bbq.pushState({
					"brand" : $this.attr("class"),
					"brandname" : $this.text()
				});

			});

			$(window).bind("hashchange", function(){
				var brand = $.bbq.getState("brand");
				var split = $.bbq.getState("splittable");

				if (brand) {
					//reset rows
					rowSwitch.reset(brand);

					//reset text of select models
					$(".ptslist .model-select span").text($.bbq.getState("brandname"));

					//reset deep link of print view
					var $printview = $(".ptslist .printview");
					$printview.attr({
						"href": $.param.fragment(
									$printview.attr("href"),
									$.deparam.fragment()
								)
					});
				}

				if(split == "1"){
					rowSwitch.split();
				}
			});
		};

		rowSwitch.reset = function(className){
			$(".ptslist tbody tr").each(function(){
				var $this = $(this);

				if (className == "brandall" || $this.hasClass(className)) {
					$this.show();
				}else{
					$this.hide();
				}
			});
		};

		//remove cells: including the colgroup, th and td
		rowSwitch.removeCell = function($table, begin, end){
			$("colgroup col", $table).each(function(idx){
				if(idx >= begin && idx <= end ){
					$(this).remove();
				}
			});

			$("tr th", $table).each(function(idx){
				if(idx >= begin && idx <= end ){
					$(this).remove();
				}
			});

			$("tr", $table).each(function(){
				$("td", $(this)).each(function(idx){
					if(idx >= begin && idx <= end ){
						$(this).remove();
					}
				});
			});
		};

		rowSwitch.split = function(options){
			//prepare to split the table
			$(".ptslist h1").before($("#header #badge"));

			if (!options) {
				options = {
					start: 4, /* start index, 0~n */
					split: 0  /* split index, it should be bigger than start index */
				};
			}

			var $table1 = $(".ptslist");
			var $table2 = $table1.clone().insertAfter($(".ptslist"));

			//caclue the mid-value of table coloumns
			options.split =  Math.round(($("col", $table1).size() + options.start) / 2);

			rowSwitch.removeCell($table1, options.split, 1000);
			rowSwitch.removeCell($table2, options.start, options.split - 1);

			$table1.after($table2);
		};
	};

	$(function(){
		var rowSwitch = new RowSwitch();
		rowSwitch.init();
		
	    $(window).load(function(){
             rowSwitch.bind();
		});

		//trigger the hashchange event on page load
		$(window).trigger("hashchange");
	});

})(jQuery);


/* Validate User Profile */
(function(window, document){
	
	var ND = window.ND = window.ND || {};

	/*
	 * ExpandBox: When user click on an anchor,
	 * Expand/Close the closet element of ".group", via add/remove the class of ".add";
	 */
	var ExpandBox = ND.ExpandBox = function($btns){
		/*Expose the api to other application*/
		ExpandBox.expand = function($btn, flag){
			var $group = $btn.closest(".group");
			if(arguments.length < 2){
				$group.toggleClass("close");
			}else{
				flag ? $group.removeClass("close") : $group.addClass("close");
			}
		};

		$btns.live("click",function(e){
			e.preventDefault();
			e.stopPropagation();
			ND.ExpandBox.expand($(this));
		});
	};

	var Validate =  ND.Validate = function(){

		var validate = this, $form;

		//validate result
		validate.result = true;
		//validate fields
		validate.array = [];

		/*
		 * Check username is existing via ajax
		 * Etc. <a class="icon-check" target="#uaername" href="SYNC-User-data.js"></a>
		 * Post the data: username =  $("#username").val();
		 * Handle the callback: $("#msg-username").text(callbackdata);
		 */
		validate.isExist = function($inputs){
			$inputs.each(function(){
				var $input = $(this),
					$tip = $input.data("vtip"),
					$chk = $input.data("vchk"),
					$msg = $input.data("vamsg"),
					json = $input.data("vjson");

				//When target field changed, change the icon back to "check" state.
				$input.keyup(function(e){
					$chk.removeClass("hide")
						.addClass("icon-check");
					$msg.addClass("hide");
				});

				var exist = function(e){
					//If other error message aviliable, skip the ajax check.
					if($(".alert:visible", $input.parent()).size() > 0){
						return;
					}

					var //$field = $(this).parent().find("input"),
						//$chk = $field.data("vchk"),
						//$tip = $input.data("vtip"),
						data = {},
						href = $chk.attr("href");

					var dataAry = json.data.split(',');
					for(var i in dataAry){
						data[dataAry[i]] = $("[name='" + dataAry[i] + "']", $form).val();
					}

					if (href) {
						$.ajax({
							type: "POST",
							url: href,
							data: data,
							dataType: 'json',
							success: function(msg){
								if (msg){
									if(msg.valid) {
										$chk.addClass("hide");
										//$chk.removeClass("icon-check icon-wrong").addClass("icon-right");
										$msg.addClass("hide");
									} else {
										$chk.removeClass("hide");
										$tip.addClass("icon-wrong");
										//$chk.removeClass("icon-check icon-right").addClass("icon-wrong");
										validate.result = false;
										ND.ExpandBox.expand($input, true);

										if(msg.message){
											$msg.removeClass("hide")
												.addClass("tips")
												.text(msg.message);
										}
									}
								}
							},
							error: function(e){
								//console.log("error", data);
							}
						});
					}
				};

				//delay some time to execute the validate progress, in order to let other validation complete.
				var delay = function(e){
					e.preventDefault();
					setTimeout(function(){
						exist(e);
					}, 100);
				};

				//When user click the "check" btn,  or jump from the input fields
				$input.focusout(delay);
				$chk.click(delay);
				//we will not check aajax on submit event
				//validate.array.push([$btns, "click"]);
			});
		};
		
		/*
		 * Etc: <input type="text" id="email" name="email" />
		 * Alert Msg: <p id="msg-email">Alert Information</p>
		 */
		validate.isMatch = function($fields){
			$fields.focusout(function(e){
				var $field = $(this),
					json = $field.data("vjson"),
					$tip = $field.data("vtip"),
					$msg = $field.data("vmsg");

				var regExp = new RegExp(json.reg);

				if($field.val() !="" && !regExp.test($field.val()) || json.required =="true" && $field.val() =="" ){
					$tip.removeClass("icon-right hide")
						.addClass("icon-wrong");
					$msg.removeClass("hide");
					$msg.html(json.regmsg);
					$field.css('border','1px solid red');
					validate.result = false;
					ND.ExpandBox.expand($field, true);
				}else{
					$tip.removeClass("icon-wrong hide")
						.addClass("icon-right");
					$msg.addClass("hide");
					$field.css('border','');
				}
			});
			validate.array.push([$fields, "focusout"]);
		};

		/*
		 * Etc: Check 2 password is equal
		 * or Check new password and old password should not be equal.
		 */
		validate.isEqual = function($repasswords){
			$repasswords.focusout(function(e){
				var $repassword = $(this),
					json = $repassword.data("vjson"),
          tags = $repassword.data("tags") || [],
					$password = $repassword.closest("form").find("input[name='" + json.target + "']"),
					$tip = $repassword.data("vtip"),
					$msg = $repassword.data("vmsg");

				//If other error message aviliable, skip the ajax check.
				if($(".alert:visible", $repassword.parent()).size() && tags.join().indexOf("fields") >= 0 ){
					return;
				}

				var condition = function(){
					if(json.different){
						return $repassword.val() == $password.val();
					}
					return $repassword.val() != $password.val();
				};

				if(condition() || $password.val() == ""){
					$tip.removeClass("icon-right hide")
						.addClass("icon-wrong");
					$msg.removeClass("hide");
					$msg.html(json.eqmsg);

					validate.result = false;
					ND.ExpandBox.expand($repassword, true);
				}else{
					$tip.removeClass("icon-wrong hide")
						.addClass("icon-right");
					$msg.addClass("hide");
				}

			});
			validate.array.push([$repasswords, "focusout"]);
		};

		/*
		 * Etc: Check if user accept the terms and privacy.
		 */
		validate.isAccepted = function($items){
			$items.change(function(e){
				var $item = $(e.target),
					$msg = $item.data("vmsg"),
					json = $item.data("vjson");

				if($item.attr("checked") == "checked"){
					$msg.addClass("hide");
				}else{
					$msg.html(json.acpmsg);
					$msg.removeClass("hide");
					validate.result = false;
				}
			});
			validate.array.push([$items, "change"]);
		};

		validate.flexfield = function(json){

			//event handler
			var handler = function(e){
				e.preventDefault();

				var cfg = {}, data={}, paraname, href;
				for(paraname in json){
					cfg = json[paraname];
					href = cfg.url;
				}
				var $container = $(this).closest(".flexfield")
					, $field = $("input[name^='" + cfg.data + "']", $container)
					, $msg = $("p.alert", $container)
					, $chk = $(".icon-check", $container)
					, $tip = $(".icon-wrong, .icon-right", $container);

				data[paraname] = $field.val();

				if (href && $field.val()) {
					$.ajax({
						type: "POST",
						url: href,
						data: data,
						dataType: 'json',
						success: function(msg){
							if (msg){
								if(msg.valid) {
									$chk.addClass("hide");
									$tip.removeClass("icon-wrong hide")
										.addClass("icon-right");
									$msg.addClass("hide");
									//$field.attr({"readonly":"readonly"});
								} else {
									$chk.removeClass("hide");
									$tip.removeClass("icon-right hide")
										.addClass("icon-wrong");
									validate.result = false;

									if(msg.message){
										$msg.removeClass("hide")
											.addClass("tips")
											.text(msg.message);
									}
								}
							}
						},
						error: function(e){
							//console.log("error", data);
						}
					});
				}
			};

			//delegate event
			//$(".double", $form).delegate("input", "focusout", handler);
			$(".double", $form)
				.delegate(".icon-check", "click", handler)
				.delegate("input[name^='vehicle_vin']", "focusout", handler);
		};

		/*
		* Check All the validations in Array, by trigger the validate event.
		*/
		validate.check = function(){
			validate.result = true;
			for(var len = validate.array.length; len--;){
				validate.array[len][0].trigger(validate.array[len][1]);
			}
			return validate.result;
		};

		/*
		  * Add tip information and
		  * 0001 : has the msg icon
		  * 0010 : has the right/wrong icon, this is hidden by default
		  * 0100 : has the refresh icon, this is visibility by default
		  * 1000 : has the ajax msg icon
		  * <a class="tip icon-check"></a>
		  * <a class="tip hide"></a>
		  */
		var MESSAGE = 1,
			TIP = 10,
			CHECK = 100,
			AJAXMSG = 1000;

		validate.prepare = function(jsoncfg, flag, fuc, tag){
			//store the json configration
			//$input.data({ validate:cfg });

			for(var i in jsoncfg){
				//console.log(i);
				var $input = $("[name='" + i + "']", $form),
					$vtip = $input.data("vtip"),
					$vmsg = $input.data("vmsg"),
					$vchk = $input.data("vchk"),
					$vamsg = $input.data("vamsg"),
					$temp;

				if($input.size()){
					//merge the former validations.
					var vjson = $input.data("vjson") || {},
              		tags = $input.data("tags") || [];


					$.extend(vjson, jsoncfg[i]);
					tags.push(tag);
					$input.data({"vjson" : vjson, "tags" : tags});

					if(typeof $vchk == "undefined"){
						if(flag & CHECK){
							$temp = $('<a class="icon-check" href="{0}"></a>'.replace('{0}', jsoncfg[i].url));
							$input.after($temp);
							$input.data({ vchk: $temp });
						}
					}
					if(typeof $vtip == "undefined"){
						if(flag & TIP){
							$temp = $('<a class="icon-wrong hide"></a>');
							$input.after($temp);
							$input.data({ vtip: $temp });
						}
					}
					if(typeof $vmsg == "undefined"){
						if(flag & MESSAGE){
							$temp = $('<p class="alert hide"></p>');
							$input.parent().append($temp);
							$input.data({ vmsg: $temp });
						}
					}
					if(typeof $vamsg == "undefined"){
						if(flag & AJAXMSG){
							$temp = $('<p class="alert hide"></p>');
							$input.parent().append($temp);
							$input.data({ vamsg: $temp });
						}
					}

					//validate function
					fuc($input);
				};
			}
		};

		/*praw json interface*/
		validate.parseJson = function(formjson){
			/*validate configuration from the json*/
			if(formjson.ajax){
				validate.prepare(formjson.ajax, "1110", validate.isExist, "ajax");
			}
			if(formjson.fields){
				validate.prepare(formjson.fields, "0011", validate.isMatch, "fields");
			}
			if(formjson.equal){
				validate.prepare(formjson.equal, "0011", validate.isEqual, "equal");
			}
			if(formjson.accept){
				validate.prepare(formjson.accept, "0001", validate.isAccepted, "accept");
			}
			if(formjson.flexfield){
				validate.flexfield(formjson.flexfield);
			}
		};

		validate.parseConfig = function(config){
			switch(typeof config){
				//if it's a json object
				case "object":
					validate.parseJson(config);
					break;
				//if it's a string url
				case "string":
					$.ajax({
						type: "GET",
						data: {},
						url: config,
						dataType: 'json',
						success: function(data){
							validate.parseJson(data);
						},
						error: function(e){
							//console.log("error", e);
						}
					});
					break;
			}
		};

		/*checked all matched fields*/
		validate.init = function(form){
			$form = $(form);
			var cancel = false;

			var config = window[$form.attr("name")];
			//console.log($form.attr("name"));
			if(config){
				validate.parseConfig(config);

				//when user click on the submit button, one error message displayed by "focusout", the position moved, 
				//so user will not release on that button, so the submit event canceled in IE.
				$("input[type='submit']", $form).mousedown(function(e){
					validate.check();
					//If no error message submit the form
					if($(".alert:visible", $form).size() < 1){
						//remove grey options before submit.
						$(".flexfield.grey:visible").remove();
						//submit manually
						cancel =  false;
						$form.submit();
					}

					cancel = true;
				});

				$form.submit(function(e){
					if(cancel){
						//152786	Bug	Start	User Profile - QA FOA - Reset Password Request page - On the browser IE9, the request email will sent twice when user clicks the "reset my password" button.
						//cancel the submit event by stopping propup the mousedown event.
						e.preventDefault();
						e.stopPropagation();
						return false;
					}else{
						return true;
					}
				});

				//clear all the error messages.
				$("input[type='reset']", $form).mousedown(function(e){
					$(".alert:visible", $form).each(function(){
						$(this).addClass("hide");
					});

					//#152753 User Profile - QA FOA - Reset button - If the registration form has a error message and some input data then user clicks the reset buton, the error message is disappeared but the data is still there.
					$form[0].reset && $form[0].reset();
				});
			}
		};

	};


	/*
	* Add add/remove button on fields
	*/
	var FlexField = ND.FlexField = function(){
		var flexField = this;

		flexField.defaults = {
			container: "form .double",
			fieldsTmpl: ".flexfield.tmpl",
			addBtn: ".icon-add",
			removeBtn: ".icon-remove"
		};

		flexField.init = function(options){
			var settings = $.extend(flexField.defaults, options);

			var $fieldsTmpl = $(settings.fieldsTmpl).first(),
				$container = $(settings.container);

			//$(htmlRemove).appendTo($fieldsGroup);
			var $fieldsTemp = $fieldsTmpl.clone().removeClass("tmpl");

			var $btnAdd = $(settings.addBtn).click(function(e){
					e.preventDefault();
					var $flexFields = $(this).closest(".double").find(".flexfield");

					if($flexFields.size() < 10){
						$fieldsTemp.clone().insertBefore($btnAdd.parent());
					}

					//rename the queue, skip the template,  retain the flexfield group first
					$flexFields = $(this).closest(".double").find(".flexfield");
					for(var i=2;i <= $flexFields.size(); i++){
						//+1 of the name
						$("input", $flexFields.eq(i-1)).each(function(){
							var $input = $(this);
							$input.attr({
								"name": $input.attr("name").replace(/\d+$/g, i)
							});
						});
					}
				});

			/*remove the grey tips*/
			$container.delegate("input", "click", function(e){
				var $flexField = $(this).closest(".flexfield");
				if($flexField.hasClass("grey")){
					$flexField.removeClass("grey");
					$("input", $flexField).val("");
				}
			});

			$container.delegate(settings.removeBtn, "click", function(e){
				e.preventDefault();
				$(this).parents(".flexfield").remove();
			});
		}
	};

	$(function(){

        
          
		new ExpandBox($(".ibtn"));
        (new FlexField()).init();

		/*validate each form*/
		$(document).ready(function(){
			$(".validate").each(function(){
				var validate = new Validate();
				validate.init($(this));
			});
		});
	});

})(window, document);


//Enhance HTML5 video player
(function(window, document) {
  var ND = window.ND = window.ND || {};
  var settings;

  var video = ND.video = {
    // the deeplink only works when user open the page by default,
    // when user click sth. in video list, it will be false.
    deepLink : 1,
    fromLink : 0,

    defaults : {
      width : 593,
      height : 348,
      modes : [
          // Bug #146204: Enhanced Video Player - 30 box FOA - IE 8 - The
          // second time user clicks the video player, a js error will be
          // displayed.; html5 mode is not stable, disable it.
          {
            type : 'html5',
            config : {
              skin : "/themes/ftd/skin/glow/glow.xml"
            }
          }, 
          {
            type : 'flash',
            src : '/themes/ftd/swf/player.swf',
            config : {
              skin : "/themes/ftd/skin/glow.zip"
            }
          } ],
      // Close tracking by default (begin, 25, 50, 75, finish)
      track : "00000",
      play : false
    },

    init : function(options) {
      
      settings = $.extend( {}, video.defaults, options);

      video.load("jwplayer-js", "/themes/ftd/js/lib/jwplayer.js");

      $ready("jwplayer", video.setup);

    },

    //load script dynamicly
    load: function(id, src){
      if(document.getElementById(id)) return;

      var js, fjs = document.getElementsByTagName("script")[0];
      js = document.createElement("script");
      js.id = id;
      js.src = src;
      fjs.parentNode.insertBefore(js, fjs);
    },

    setup2: function(){
      //alert("inner test");
    },

    // set up jwplayer
    setup: function(){
      // setup video list
      var $listlinks = $(".feature-overlay .video-list li").bind("click", function(e) {
          e.preventDefault();

          var $this = $(this);

          if (!video.deepLink) {
            vpos = $(".video-list ul").data('jcarousel').first;
            vcur = $this.index() + 1;

                // remember the the first and active position of
            // carsouel
            // if the value is the same, it will not change.
            $.bbq.pushState( {
              vpos : vpos,
              vcur : vcur
            });
          }

          // disable deeplink after the first time fired.
          video.deepLink = 0;
          // disable the carousel and videoplayer the next time: overlay
          // opened by deeplink.
          video.fromLink = 1;

          // when a new fragement parameter to the url, the parent overlay
          // will be reopened, so delay some time to load.
          window.setTimeout(function() {
            // enable the carousel and videoplayer
              video.fromLink = 0;

              // $.publish("overlay.launch",{url: $(this).attr("href")});
              var overlay = ND.API.getOverlay();
              overlay.load($("a", $this)[0]);
          }, 100);
      });

      if (!video.fromLink) {
        // get the video player list
        var vpos = $.bbq.getState("vpos"), vcur = $.bbq.getState("vcur");
        // default means play current video not in play list.
        var pos = vpos ? Number(vpos) : 1, cur = vcur ? Number(vcur) : 100001;
        var $list = $(".video-list ul");

        // add a custom class to fix the layout
        if ($list.size()) {
          $(".feature-overlay").addClass("has-videolist");
        }

        // Is user enter the video by deeplink?
        if (cur < 100001 && video.deepLink) {
          $listlinks.eq(cur - 1).trigger("click");
        } else {
          // alternative image
          var imageUrl = $(".video-image img").attr("src");

          if($("div.staging-wrap").size()>0){
            imageUrl = settings.image;
          }

          // customize post image
          if (settings.image){
            imageUrl = settings.image;
          }

          // setup playlist
          $list.jcarousel( {
            start : pos,
            scroll : 1,
            // Feedback: Using "hover" event instead of "click".
            buttonNextEvent : "mouseenter click",
            buttonPrevEvent : "mouseenter click"
          });

          // customize skin for html5 video player
          if (settings.skin){
            for (var i = 0; i < settings.modes.length; i++){
              if (settings.modes[i].type == "html5"){
                settings.modes[i].config.skin = "/themes/ftd/skin/"+settings.skin+"/"+settings.skin+".xml";
              }
              
            }
          }

          var playerOption = {
            image : imageUrl,
            modes : settings.modes,
            //controlbar: "none",
            levels : [ {
              type : 'video/mp4',
              file : settings.file
            } ],
            width : settings.width,
            height : settings.height,
            'plugins' : {}
          }

          if(settings.controlbar){
            playerOption.controlbar = "none";
          }


          if (settings.caption) {
            playerOption["plugins"]["captions-2"] = {
              "file" : settings.caption
            };
          }

          // setup video player
          
          jwplayer("video-inner").setup(playerOption);

          // hide the controls only at preview image stage
          if (settings.hideControls){
            jwplayer().onReady(function(){
              jwplayer().getPlugin("controlbar").hide();
            });
            
            jwplayer().onPlay(function(){
              jwplayer().getPlugin("controlbar").show();
              jwplayer().resize(jwplayer().getWidth(),jwplayer().getHeight());
              
            });
          }

          // tracking impl
          settings.track != "00000" && video.track(settings);

          // autoplay interface
          settings.play && jwplayer().play();

          // Bug #146214 Enhanced video player - 30 box FOA - The shared
          // URL is wrong.
          var overlay = ND.API.getOverlay();
          overlay.injectSocial();
        }
      }
    },

    // track video
    track : function(settings) {
      // tracking flag
      var trackPos = { "0" : 1, "0.2" : 1, "0.5" : 1, "0.7" : 1, "0.8" : 1},
          ti = settings.title || "",
          dcsuri = settings.url || "",
          pname = settings.pname || "",
          hier = settings.hier|| "";

      jwplayer().onTime(function(e) {
        var percent = Math.round(e.position / e.duration * 10) / 10, action;
        var omTitle, omEvents;
        
        
        if (trackPos[percent]) {
          switch (percent) {
            case 0:
              if (settings.track.charAt(0) == "1") {
                action = "Play";
                omTitle = "video start";
                omEvents = "event56";
              }
              break;
            case 0.2:
              if (settings.track.charAt(1) == "1") {
                action = "Play 25";
              }
              break;
            case 0.5:
              if (settings.track.charAt(2) == "1") {
                action = "Play 50";
              }
              break;
            case 0.7:
              if (settings.track.charAt(3) == "1") {
                action = "Play 75";
              }
              break;
            case 0.8:
              if (settings.track.charAt(4) == "1") {
                action = "Finish";
                omTitle = "video finish";
                omEvents = "event57";
              }
              break;
          }

          trackPos[percent] = 0;

          if (omTitle && omEvents) {
        	  
        	  if( window._da && window._da.om && ND && ND.omniture ) {
        		  
        		  var clip_n = settings.clip_n || ti;
        		 
        		  ND.omniture.trackLink({
        			  	'link':true,
        			  	'onclicks':omTitle,
        			  	'events':omEvents,
        			  	'type':'o',
        			  	'content':clip_n,
        			  	'title':omTitle,
        			  	'nameplate':'none',
        			  	'pname':pname,
        			  	'hier1':hier
        			  	}
                );
//        		  $.publish('/analytics/link',{
//              			  	'link':true,
//              	      	  	'onclicks':omTitle,
//              			  	'events':omEvents,
//              			  	'type':'o',
//              			  	'content':clip_n,
//              			  	'title':omTitle,
//              			  	'nameplate':'none',
//              			  	'pname':pname,
//              			  	'hier1':hier
//              			  	});
        		  
        		  
    		  }
          }          
          
          if (action) {
            var clip_n = settings.clip_n || (ti + (e.duration>>0)) ;
          
            
            // Tracking implementation
            ND.analytics._tag.dcsMultiTrack(
                "WT.ti", ti + action,
                "DCS.dcsuri", (dcsuri + action.replace(/ /g, '')).toLowerCase().replace(/ /g, '-'),
                "WT.clip_ev", action.replace(/ /g,''),
                "WT.clip_n", clip_n,
                "WT.dl", 7
              );
          }
          
          
        }

      });

      // For replaying.
      jwplayer().onComplete(function(){
          trackPos = { "0" : 1, "0.2" : 1, "0.5" : 1, "0.7" : 1, "0.8" : 1};
      });
    }

  };

})(window, document);


//create the fblike button
(function($, window, document){

	//callback function
	window.fbAsyncInit = function() {
		FB.init({
			appId      : '277451909039945', // App ID
			channelUrl : '//WWW.YOUR_DOMAIN.COM/channel.html', // Channel File
			status     : false, // check login status
			cookie     : true, // enable cookies to allow the server to access the session
			xfbml      : true  // parse XFBML
		});

		// Localise a grabber function. Grabber function helps with content values and urls
		var grabber = ND.analytics.grabber();
		master = grabber({meta:"meta[name='dfy.title']"});

		/*
		Tracking like event
		api: https://developers.facebook.com/docs/reference/javascript/FB.Event.subscribe/
		edge.remove,  comment.create,  comment.remove
		*/
		FB.Event.subscribe('edge.create', function(href, widget) {
			var	data = { 
					title: 'Facebook',
					uri: '/like/facebook',
					socialId: 'Facebook'
				};

			$.publish('/analytics/social/', data);
		});
	};

	var fbLike = ND.fbLike = {
		init: function(){
			if(document.getElementById("facebook-jssdk")) return;
			var api = $(".fb-like").eq(0).attr("title");
			if(!api || api=="") return;

			var js, fjs = document.getElementsByTagName("script")[0];
			js = document.createElement("script");
			js.id = "facebook-jssdk";
			js.src = api;
			fjs.parentNode.insertBefore(js, fjs);
		}
	};

	$(document).ready(function(){
		fbLike.init();
	});

})(jQuery, window, document);


(function(window, document){
	var ND = window.ND = window.ND || {};

	var selectOption = ND.selectOption = {

		init : function(json, options){
			var mainOption = $(options.parentSelector)[0];
			var subOption = $(options.childrenSelector);

			var cities = window[json];

			if(!mainOption || !cities){
				return;
			}

			var optionObj = {}, i, len;

			//create country options list
			//selectOption.clearOption(mainOption);
			var countries = cities.list;
			for(i=0, len=countries.length;i<len;i++){
				var key = countries[i].name,
					val = countries[i].code;
				optionObj[val] = countries[i].states;
				//selectOption.addOption(mainOption, key, val);
			}

			//create cities option list
			mainOption.onchange = function(e){
				selectOption.clearOption(subOption[0]);
				var city = optionObj[mainOption.value];
				if(!city){
					return;
				}

				
				//selectOption.addOption(subOption[0], "Select", "");
				for(i=0, len=city.length;i<len;i++){
					var key = city[i].name,
						val = city[i].code;
					selectOption.addOption(subOption[0], key, val);
				}
			};
		},

		addOption : function(select, txt, value){
			if (select && select.options) {
				var opts = select.options;
				opts[opts.length] = new Option(txt, value);
			}
		},

		//clear all the options except the first one
		clearOption : function(select){
			if (select && select.options) {
				select.options.length = 1;
			}
		}
	};

	$(document).ready(function(){
		selectOption.init("countryStates", 
			{
				parentSelector:"#country",
				childrenSelector:"#state"
			}
		);
	});
})(window, document);


/*
 * Description: Change select option, doesn't have depandence of jQuery 
 */
(function(window, document){
	var ND = window.ND = window.ND || {};

	var selectOption = ND.selectCity = {

		init : function(citieName, mainSelector, subSelector ){
			var mainOption = $(mainSelector)[0],
                subOption = $(subSelector);
                // cities = window[citieName];

            var $cities = $("#cityDropdownData");
            var cities;

			if($cities.length > 0) {
                  cities = JSON.parse($cities.html());
            }

			if(!cities || !mainOption){
				return;
			}

			//create states option list
			var states, optionObj = {}, i, j, len;

			selectOption.clearOption(mainOption);
            for(i=0, leni = cities.list.length; i<leni; i++){
                states = cities.list[i].states;
                for(j=0, lenj = states.length; j<lenj; j++){
                    var val = states[j][0];
                    optionObj[val] = states[j][1].cities;
                    selectOption.addOption(mainOption, val, val);
                }
            }

			//create cities option list
			mainOption.onchange = function(e){
				var city = optionObj[mainOption.value];
				
				selectOption.clearOption(subOption[0]);
				
				if(!city){
					return;
				}
				
				for(i=0, len=city.length;i<len;i++){
					selectOption.addOption(subOption[0], city[i][0] , city[i][0]);
				}
			};

            //Trigger change in order to set default option.
            selectOption.selected(mainOption);
            window.setTimeout(function(){
                selectOption.selected(subOption);
            }, 300);
		},

		addOption : function(select, txt, value){
			if (select && select.options) {
				var opts = select.options;
				opts[opts.length] = new Option(txt, value);
			}
		},

		clearOption : function(select){
			if (select && select.options) {
				select.options.length = 1;
			}
		},

        /*Set selected option by value in the data*/
        selected : function(select){
            var $select = $(select),
                value = $select.attr('data');

            if(value != $select.val()){
                $select.val(value).trigger("change");
            }
        }
	};

    //the jason data may rednered very slow, so init it after DOM is ready.
    $(document).ready(function(){
        selectOption.init("cities", "#state", "#city");
    });

})(window, document);


var FAP = (function(exports) {

	exports.syncPrimer = function( script ) {

		// Store promises for further clicks attempts.
		var scriptPromise, appletPromise;

		$(document).ready(function(){
			var transferData = $('#sync-transfer-data').embeddedData();
			if(transferData.ENABLE_ZIPHANDLER === 'true' && transferData.ZIPHANDLER_STATUS.length > 0){
				var btn = $('.sync_download');
				btn.attr('data-status','requested');
				if (transferData.ZIPHANDLER_STATUS.toLowerCase() === 'available'){
					btn.parents('.col').prev().children('div').html(transferData.DOWNLOAD_REQUESTED_COPY);
					
					$.ajax({
						type: 'GET',
						cache: false,
						url:  '/servlet/mgmsynchandler/selectinstallhandler?type=all'
					}).done(function(data){
						$.ajax({
						type: 'GET',
						cache: false,
						url:  transferData["xhr-step-downloadstatus"]+"&isReady=Y"
						}).done(function(data){
							if(data){
								
								 var returnJson=$.parseJSON(data);
								 if(returnJson["download-status"]==="ready"){
									$('.sync_start_download').attr("data-download","ready");
									$("#sync_zipdownload_url").attr("href",unescape(transferData.ZIPHANDLER_DOWNLOAD_URL));
								}
							}
						});
					
					});
					
					
				}
			}
			
		});

		
		// Click 'Let's Start'
		$(document).on('click', '.sync-transfer-primer', function(e) {

			// Vars
			var hasActiveX, x64,
				report = $(this).hasClass('sync-report-installation') ,
				statusChecker = $(this).hasClass('sync-lets-start-status-checker'),
				downloadAll = $(this).hasClass('sync-lets-start'),
				startDownload = $(this).hasClass('sync_start_download'),
				transferData = $('#sync-transfer-data').embeddedData();

			if ( statusChecker ) {
				
					$.ajax({
						type: 'GET',
						cache: false,
						url:  '/servlet/mgmsynchandler/selectinstallhandler?type=schecker'
					});
				
				// select the tmpl-sync-updates-available-statusChecker content to be displayed in overlay
			}
		
			if ( downloadAll ) {
				
				
				// select the tmpl-sync-updates-available content to be displayed in overlay
				
					$.ajax({
						type: 'GET',
						cache: false,
						url:  '/servlet/mgmsynchandler/selectinstallhandler?type=all'
					});
					
					if(transferData.ENABLE_ZIPHANDLER === 'true'){
						$(this).text(transferData.DOWNLOAD_REQUESTED_TXT);
						$(this).parents('.col').prev().children('div').html(transferData.DOWNLOAD_REQUESTED_COPY);
						$(this).attr('data-status','requested');
					}
			}
			
			// Cancel default event
			e.preventDefault();
			
			// Previous attempts
			if( scriptPromise && scriptPromise.isResolved()) {
			
				if( report ) {
					$.publish('/sync-transfer/report');
				}else if(statusChecker){
					$.publish('/sync-transfer/statusChecker');
				} else  if(downloadAll){
					$.publish('/sync-transfer/start');
				}else if(startDownload){
					
					$.publish('/sync-transfer/startDownload');
				}
			
			// First Attempt to load the control
			} else if (transferData.ENABLE_ZIPHANDLER === 'true'){
				// Require the script for this
				scriptPromise = $.getScript( script );

				// Check that the script and the applet a ready, then move ahead
				$.when( scriptPromise )
					.done(function() {
						// Open Overlay with Start
						if( report ) {
							$.publish('/sync-transfer/report');
						}else if(statusChecker){
					      $.publish('/sync-transfer/statusChecker');
				        } else if(downloadAll){
							$.publish('/sync-transfer/start');
						}else if(startDownload){
							$.publish('/sync-transfer/startDownload');
						}
					})
					.fail(function() {
						$.publish('/sync-transfer/fail');
					});
			}

			else {
			
				// Check for Active X support
				hasActiveX = ( "ActiveXObject" in window );
				
				// Check for 64bit IE user agent (http://blogs.msdn.com/b/ie/archive/2009/01/09/the-internet-explorer-8-user-agent-string-updated-edition.aspx)
				x64 = navigator.userAgent.indexOf("x64") > 0;
				
				// Remove any injected code if this is the second or third try
				$('#sync-transfer-applet').remove();
				
				// Inject the Applet or ActiveX control
				$('<div id="sync-transfer-applet" />').append($(
					$( '#sync-tranfser-config' + (hasActiveX ? ( x64 ? '-ie64' : '-ie' ) : '') ).html()
				)).appendTo('body');
				// PLG testing $("#TransferApplet").attr('CLASSID', 'CLSID:90EA49B3-039A-4F02-A34E-3EBA417BE44C');
				
				// Require the script for this
				scriptPromise = $.getScript( script );
				//alert("scriptPromise:"+scriptPromise);
				// Create a crude Deferred that will check for the existence of the Applet
				appletPromise = (function() {
					
					var def = $.Deferred();
					
					// Function to check if the Applet is avaliable
					function checkReadyApplet() {
						try {
						
							// Try to call the applet (throws excpetion if not loaded) 
							document.TransferApplet.getSControlStatus();
							
							// Exception not throw, then resolve the Deferred
							def.resolve();
							
						} catch(e) {
							
							//Check again
							setTimeout(checkReadyApplet, 100);
						}
					}
					
					// Start checking now
					checkReadyApplet();
					
					// Return the promise (Deferred is encapsulated so that nothing else can resolve it)
					return def.promise();
				}());
				
				// Open Overlay with Prepare content
				$.when( scriptPromise )
					.done(function(){
						$.publish('/sync-transfer/prepare');
					});
				
				// Check that the script and the applet a ready, then move ahead
				$.when( scriptPromise )
					.done(function() {
						// Open Overlay with Start
						if( report ) {
							$.publish('/sync-transfer/report');
						}else if(statusChecker){
					      $.publish('/sync-transfer/statusChecker');
				        } else if(downloadAll){
							$.publish('/sync-transfer/start');
						}else if(startDownload){
							$.publish('/sync-transfer/startDownload');
						}
					})
					.fail(function() {
						$.publish('/sync-transfer/fail');
					});
			
			}

				
		});
	};
	
	return exports;

}( window.FAP || {} ));


/*
Description: Change select vehicle
*/
/*
Description: Change select vehicle
*/
(function(document){
  ND.selectList = {
    init: function(selector){
      $(document).on("click", ".selectlist li", function(e){
        e.preventDefault();
        var $this = $(this);
        if(!$this.hasClass("cur") && !$this.hasClass("selected")){
          $("li", $this.parent()).removeClass("selected");
          $this.addClass("selected");
          $(selector).val($this.children().attr("data"));
                 
        }
      });
    }
  };
})(document);


/* Update date time on page */
(function(document) {

  //format GMT date to short format: mm:ss yyyy:MM:dd
	// note, the methods to extract the time elements from the Date object 
	// work in local time (not GMT) 
  var formatGMT = function(date){
    var o = function (n){
      return n.toString().length == 1 ? ('0' + n) : n;
    };

    return o(date.getHours())
      + ':' + o(date.getMinutes())
      + ' ' + date.getFullYear()
      + '-' + o(date.getMonth() + 1)
      + '-' + o(date.getDate());
  };
  
  //change the report status datetime format and convert it to local time.
  $(document).ready(function() {
  
    $report = $(".report");
    $cnt = $report.length;
    $i = 0;
    while ($i < $cnt) {
		$val = $report.eq($i);
        var reg = /\d.+/g, date = new Date($val.text().match(reg)[0] + " GMT");
        date.getTime() && $val.html($val.html().replace(reg, formatGMT(date) ));
            
        $i++;
    }
  });

})(document);


/*
 * shopping-tools: nameplate page, switch the vehicles.
 */
window.ND.BuildList = (function(window, document, $){

	/*
	* build List behavior
	*/
	var BuildList = function(){
		var self = this,
			$container = $(".buildlist"),
			$content = $(".buildlist .buildview"),
			$list = $(".buildlist .row"),
			$item = $(".buildlist .derivative"),
			width = $container.width();

		/*
		* etc: reset the content's width;
		*/
		self.init = function(){
			$content.css({ "width" : width * $list.size(), "position":"relative" });
			$item.click(function(e){
				$item.removeClass("cur");
				$(this).addClass("cur");
			});
		};

		/*
		* switch to specfic tab in the list
		*/
		self.moveTo = function(idx){
			var left = 0 - idx * width;
			$content.animate({"left":left});
		};
	};

	/*
	* build selector behavior
	*/
	var BuildSelect = function(options){

		var self = this,
			$buildselect = $(".buildselect"),
			$builditem = $(".buildselect li"),
			$current = $(".buildselect li.cur"),
			$arrowContainer = $(".buildselect ul"),
			//required to adjust the current tab indicator based on the size of the
			//indicator used. Build and price uses a different offset
			offset = (options && options.offset) ? options.offset : 144;

		//delegate eent interface.
		self.onChange;

		self.init = function(){
			//remember the index number;
			$builditem.each(function(idx){
				$(this).data({"idx": idx});
			});

			//bind clic event
			$builditem.click(function(e){
				e.preventDefault();
				$current = $(e.currentTarget);

				self.reset();
			});

			//reset the position of arrow immediately
			self.reset();
		};

		/*
		* reset the position of arrow
		*/
		self.reset = function(){
			var left = $current.offset().left - $buildselect.offset().left,
				width = $current.width(),
				pos = ((left + width / 2) >> 0) - offset,
				stypos = pos + "px 34px";

			$arrowContainer.animate({"background-position" : stypos}, "fast");
			$builditem.removeClass("cur");
			$current.addClass("cur");

			self.onChange && self.onChange($current.data("idx"));
		};

	};

	/*
	* initialization
	*/ 
	$(document).ready(function(){
		if($(".buildlist .row").size()){
			initBuildList();
		}
	});
	
	var initBuildList = function(options) {
		var buildList = new BuildList();
		buildList.init();

		var buildSelect = new BuildSelect(options);
		/*Bind event*/
		buildSelect.onChange = buildList.moveTo;
		/*Init*/		
		buildSelect.init();
	};
	
	return {
		create: function(){
			initBuildList({offset : 152});
		}
	}; 

})(window, document, jQuery);


//Try to resolve app loader.
if( window.resolve$wait ) {
	resolve$wait();	
}


/**
 * 
 */
(function($,undefined) {	
	if (!ND) var ND = window.ND = window.ND || {};
	/***
	 * WARNING: SINGLETON ALERT!  SINGLETON ALERT!  CODE: BLACK!
	 */
	ND.PriceFormatter = {
		
		/**
		 * true,0 -> true means use delimiter or not. , means use comma as delimitor for prices, 0 means how many decimal places should be displayed
		 * 
		 * for example if we have true,0 
		 * 
		 * input 2000.00 -> output 2,000
		 *
		 * if we have false,2
		 * 
		 * input 2000 -> output 2000.00
		 * input 2000.999 -> output 2000.99
		 * 
		 * if we have true/2
		 * 
		 * input 2000 -> output 2/000.00
		 * input 2000.999 -> output 2/000.99
		 * 
		 * $ %1
		 * 
		 * 
		 * Internal methods for priceFormatter, shamelessly borrowed from jquery.priceformat.js version 1.7 <http://jquerypriceformat.com>
		 * Originally created By Eduardo Cuducos cuducos [at] gmail [dot] com, and maintained by Flavio Silveira flavio [at] gmail [dot] com
		 * 
		 * usage: var PF = new ND.PriceFormatter({"prefix": "$", thousandsSeparator: ", ", centsLimit: 2});
		 * PF.format("2000.00");
		 */
		initialise: function(options) {
			var defaults =
			{
				data: 'true,0',
				formatString: '',
				prefix: '',
	            suffix: '',
				centsSeparator: '.',
				thousandsSeparator: '',
				limit: false,
				centsLimit: 0,
				clearPrefix: false,
	            clearSufix: false,
				allowNegative: false,
				forceDecimal: false
			};
			
			ND.PriceFormatter.options = $.extend({},defaults, options);
			// Deals with parsing the data options passed to the constructor
			var s = ND.PriceFormatter.options.data.match(/\W+/g);
			var d = ND.PriceFormatter.options.data.split(s);
			if (d[0] === "true") {
				ND.PriceFormatter.options.thousandsSeparator = ND.PriceFormatter.options.thousandsSeparator;
			} else {
				ND.PriceFormatter.options.thousandsSeparator = defaults.thousandsSeparator;
			}
			if (parseInt(d[1]) > 0) {
				ND.PriceFormatter.options.forceDecimal = true;
				ND.PriceFormatter.options.centsLimit = parseInt(d[1]);
			} 
		},
			
			// pre defined options
		internalFormatter: function(value) {
				var obj = value;
				var is_number = /[0-9]/;
		
				// load the pluggings settings
				var prefix = ND.PriceFormatter.options.prefix;
		        var suffix = ND.PriceFormatter.options.suffix;
				var centsSeparator = ND.PriceFormatter.options.centsSeparator;
				var thousandsSeparator = ND.PriceFormatter.options.thousandsSeparator;
				var limit = ND.PriceFormatter.options.limit;
				var centsLimit = ND.PriceFormatter.options.centsLimit;
				var clearPrefix = ND.PriceFormatter.options.clearPrefix;
		        var clearSuffix = ND.PriceFormatter.options.clearSuffix;
				var allowNegative = ND.PriceFormatter.options.allowNegative;
		
				// skip everything that isn't a number
				// and also skip the left zeroes
				function to_numbers (str)
				{
					var formatted = '';
					for (var i=0;i<(str.length);i++)
					{
						char_ = str.charAt(i);
						if (formatted.length==0 && char_==0) char_ = false;
		
						if (char_ && char_.match(is_number))
						{
							if (limit)
							{
								if (formatted.length < limit) formatted = formatted+char_;
							}
							else
							{
								formatted = formatted+char_;
							}
						}
					}
		
					return formatted;
				}
		
				// format to fill with zeros to complete cents chars
				function fill_with_zeroes (str)
				{
					while (str.length<(centsLimit+1)) str = '0'+str;
					return str;
				}
		
				// format as price
				function price_format (str)
				{
					// formatting settings
					var formatted = fill_with_zeroes(to_numbers(str));
					var thousandsFormatted = '';
					var thousandsCount = 0;
		
					// split integer from cents
					var centsVal = formatted.substr(formatted.length-centsLimit,centsLimit);
					var integerVal = formatted.substr(0,formatted.length-centsLimit);
		
					// apply cents pontuation
					formatted = integerVal+centsSeparator+centsVal;
		
					// apply thousands pontuation
					if (thousandsSeparator)
					{
						for (var j=integerVal.length;j>0;j--)
						{
							char_ = integerVal.substr(j-1,1);
							thousandsCount++;
							if (thousandsCount%3==0) char_ = thousandsSeparator+char_;
							thousandsFormatted = char_+thousandsFormatted;
						}
						if (thousandsFormatted.substr(0,1)==thousandsSeparator) thousandsFormatted = thousandsFormatted.substring(1,thousandsFormatted.length);
						formatted = thousandsFormatted+centsSeparator+centsVal;
					}
		
					// if the string contains a dash, it is negative - add it to the begining (except for zero)
					if (allowNegative && str.indexOf('-') != -1 && (integerVal != 0 || centsVal != 0)) formatted = '-' + formatted;
		
					// apply the prefix
					if (prefix) formatted = prefix+formatted;
		            
		            // apply the suffix
					if (suffix) formatted = formatted+suffix;
		
					return formatted;
				}
		
				// filter what user type (only numbers and functional keys)
				function key_check (e)
				{
					var code = (e.keyCode ? e.keyCode : e.which);
					var typed = String.fromCharCode(code);
					var functional = false;
					var str = obj;
					var newValue = price_format(str+typed);
		
					// allow key numbers, 0 to 9
					if((code >= 48 && code <= 57) || (code >= 96 && code <= 105)) functional = true;
		
					// check Backspace, Tab, Enter, Delete, and left/right arrows
					if (code ==  8) functional = true;
					if (code ==  9) functional = true;
					if (code == 13) functional = true;
					if (code == 46) functional = true;
					if (code == 37) functional = true;
					if (code == 39) functional = true;
					if (allowNegative && (code == 189 || code == 109)) functional = true; // dash as well
		
					if (!functional)
					{
						e.preventDefault();
						e.stopPropagation();
						if (str!=newValue) obj = newValue;
					}
		
				}
		
				// inster formatted price as a value of an input field
				function price_it ()
				{
					var str = obj;
					var price = price_format(str);
					if (str != price) obj = price;
				}
		
				// Add prefix on focus
				function add_prefix()
				{
					var val = obj;
					obj = prefix + val;
				}
		        
		        function add_suffix()
				{
					var val = obj;
					obj = val + suffix;
				}
		
				// Clear prefix on blur if is set to true
				function clear_prefix()
				{
					if($.trim(prefix) != '' && clearPrefix)
					{
						var array = obj.split(prefix);
						obj = array[1];
					}
				}
		        
		        // Clear suffix on blur if is set to true
				function clear_suffix()
				{
					if($.trim(suffix) != '' && clearSuffix)
					{
						var array = obj.split(suffix);
						obj = array[0];
					}
				}
				
				price_it();
				return obj;
			},
			
			// Pad with leading zeros
			pad : function(num, size) {
			    var s = num+"";
			    while (s.length < size) s = "0" + s;
			    return s;
			},
		
			format: function(value) {
				var result = value = value.toString();
				try {
					if (ND.PriceFormatter.options === undefined) {
						throw 'Priceformatter not initialized';
					}
					
					//first replace the . coming from the server with centsSeperator
					value = value.replace('.', ND.PriceFormatter.options.centsSeparator);
					
//					console.log('value before : ' + value);
					
				    var length = 0;
				    var centsLimit = ND.PriceFormatter.options.centsLimit;
				    var decimalIdx = value.indexOf(ND.PriceFormatter.options.centsSeparator);
				    //if centsLimit is greater than zero but value has no decimal for instance if we have 500 but 
				    //centLimit = 3 then this line will convert 500 to 500.000
					if (centsLimit > 0 && decimalIdx === -1) {
						value += ND.PriceFormatter.options.centsSeparator + ND.PriceFormatter.pad("0", centsLimit);
						
//						console.log('value += ND.PriceFormatter.options.centsSeparator + ND.PriceFormatter.pad("0", centsLimit) : ' + value);
						
					} else if (decimalIdx > 0 && ((length = value.substring(decimalIdx + 1, value.length).length) < centsLimit)) {
						
//						console.log('value.substring(decimalIdx + 1, value.length): ' + value.substring(decimalIdx + 1, value.length));
						
						value += ND.PriceFormatter.pad("0", centsLimit - length);
						
//						console.log('value += ND.PriceFormatter.pad("0",  - length) : ' + value);
						
					} else if (length > centsLimit) { //value = 100.00000  but cent limit is 2 
						 value = value.substring(0, decimalIdx + 1 + centsLimit);
						 
//						 console.log('value = value.substring(0, decimalIdx + 1 + centsLimit): ' + value);
					}
					var output = ND.PriceFormatter.internalFormatter(value);
					if (!ND.PriceFormatter.options.forceDecimal) {
//						console.log('index of ' + ND.PriceFormatter.options.centsSeparator + ' in ' + output + ' is (output.indexOf(ND.PriceFormatter.options.centsSeparator)): ' + output.indexOf(ND.PriceFormatter.options.centsSeparator));
						output = output.substring(0,output.indexOf(ND.PriceFormatter.options.centsSeparator));
						
//						console.log('output = output.substring(0,output.indexOf(ND.PriceFormatter.options.centsSeparator)); ' + output);
					}
					result = ND.PriceFormatter.options.formatString.replace("%1", output);
					
//					console.log('result: ' + result);
					
				} catch(e) {
					throw e;
				}
				
				return result;
			}
	}; // End of Price Formatter singleton
	
})(jQuery);


/**
 * The amazing, incredible, life-saving loadmask.js!
 * Prevents impatient users from clicking around an app that isn't ready to receive instructions!
 * Genius, right?  BUT WAIT, THERE'S MORE!
 * Call in the next 10 minutes to receive this free set of wonderful JSON Steak knives* :D
 * (*note: offer not available anywhere.)
 */
(function($,undefined) {	
	//if (!ND) var ND = window.ND = window.ND || {};
	
	ND.loadmask = function() {
		// This is the constructor method.
		// Not suitable for children under 5 years of age.
		// See your doctor if symptoms persist.
		var maskElem = $("<div class='loadmask' style='opacity: 1, display: none'></div>");
		var loadGif = $("<span class='loadgif'>&nbsp;</span>").appendTo(maskElem);
		// Dimensions of the loader gif, have to be pre-determined since we can't compute them when the element is hidden
		var loaderDimensions = {
			width: 220,
			height: 19
		};
		// Cachce the dimensions of the viewport for performance considerations
		var viewport = {
			height: $(window).height(),
			width: $(window).width()
		};
		
		loadGif.css("top", (viewport.height + loaderDimensions.height) / 2)
			.css("left", (viewport.width - loaderDimensions.width) / 2);
			
		maskElem.appendTo("body");
		
		return {
			show: function() {
				maskElem.stop().fadeIn();
			},
			hide: function() {
				maskElem.stop().fadeOut();
			}, 
			hideSlowly: function() {
				maskElem.fadeOut();
			}
		}
	};
})(jQuery);


$(function() {

    var cappedPriceCalc = function() {

    	//load configuration from template and get the urls ready
    	var urls = $('#capped-price-services').embeddedData();
    	var siteConfig = $('#common-config').embeddedData();
    	var selectTexts = $('#capped-price-text').embeddedData();
    	
    	var urlAllVehicles = urls['cps.allvehicles'],
    		urlModel = urls['cps.model'],
    		urlPdf = urls['cps.pdf'];
    		
    	var site = siteConfig.site;
    	urlAllVehicles = urlAllVehicles.replace('{site}', site);
    	urlModel = urlModel.replace('{site}', site);
    	urlPdf = urlPdf.replace('{site}', site);
    	
    	var selectStyle= selectTexts['select.style.text'] || "Select Style",
    	selectEngine = selectTexts['select.engine.text'] ||"Select Engine",
    	selectInterval = selectTexts['select.interval.text'] ||"Select Interval";
    	
    	// disable select boxes and labels
    	$('.capped-calculator select:not(select:first)').attr('disabled','disabled').css('opacity','.3');
    	$('.capped-calculator label:not(label:first)').css({opacity:'.3',cursor: 'default'});

        // hide brake fluid and coolant text
        $('#extra-costs').hide();

        var disableSelects = function(div) {
            // disable remaining select boxes and labels
            $(div).parent().nextAll().find('select').attr('disabled','disabled').css('opacity','.3');
            $(div).parent().nextAll().find('label').css({opacity:'.3',cursor: 'default'});
            if ($('#completed').is(':visible')) { 
                $('#completed').fadeOut(300);
                $('#extra-costs').fadeOut(300);
                $('#completed-buttons').fadeOut(300);
            }
        };

        // setup global ajax settings
        $.ajaxSetup({
            type: "GET",
            dataType: "json",
            cache: true,
            statusCode: {
                404: function() {
                    $('.capped-calculator').html('<p class="ajax-error">The capped price servicing calculator is currently offline.</p>');
                }
            }

        });

    	$.ajax({
            url: urlAllVehicles,
            success: function(data){
                
                $.each(data.vehicles, function(i,item){

                    var model = item.name;
                    $('select#model').append($('<option></option>').val(model).text(model));

                });

            }
           
        });

        $('select#model').bind('change',function() {

            disableSelects($(this));

            var model = $(this).val(),
                url = urlModel.replace('{model}', model);
            
            $('.capped-calculator select#style').attr('disabled',false).css('opacity','1');
            $('.capped-calculator select#style').prev('label').css({opacity:'1',cursor: 'pointer'});

            // reset 'Select your style' select box
            $('select#style option').remove();

            if (model != 'default') {
                $.ajax({
                    url: url,
                    success: function(data){

                        $('select#style').append($('<option value="default"></option>').text(selectStyle));
                        $('select#engine').val($('select#engine option:first').val());
                        $('select#interval').val($('select#interval option:first').val());

                        $.each(data.data.vehicle.style, function(i,value){
                           
                            var style = value['@id'];

                            // populate 'Select your style' select box
                            $('select#style').append($('<option></option>').val(i).text(style).attr('id',style));
                        });

                    }
                });
            } else {
                $('select#style').append($('<option value="default">'+selectStyle+'</option>'));
                $('select#engine option').remove();
                $('select#engine').append($('<option value="default">'+selectEngine+'</option>'));
                $('select#interval option').remove();
                $('select#interval').append($('<option value="default">'+selectInterval+'</option>'));
                disableSelects($(this));
            }

        });

        $('select#style').bind('change',function() {

            disableSelects($(this));
            
            var model = $('select#model option:selected').val(),
                url = urlModel.replace('{model}', model),
                currentStyle = $('select#style option:selected').val(),
                currentSelect = $(this).val();

            $('.capped-calculator select#engine').attr('disabled',false).css('opacity','1');
            $('.capped-calculator select#engine').prev('label').css({opacity:'1',cursor: 'pointer'});

            // reset 'Select your engine' select box
            $('select#engine option').remove();

            if (currentSelect != 'default') {
                $.ajax({
                    url: url,
                    success: function(data){    

                        $('select#engine').append($('<option value="default"></option>').text(selectEngine));
                        $('select#interval').val($('select#interval option:first').val());

                        var currentEngine = data.data.vehicle.style[currentStyle].engine;

                        $.each(currentEngine, function(i,value){

                            var engine = this['@id'];

                            // populate 'Select your engine' select box
                            $('select#engine').append($('<option></option>').val(i).text(engine).attr('id',engine));
                        });

                    }
                });
            } else {
                $('select#engine').append($('<option value="default">'+selectEngine+'</option>'));
                $('select#interval').append($('<option value="default">'+selectInterval+'</option>'));
                $('select#interval option').remove();
                $('select#interval').append($('<option value="default">'+selectInterval+'</option>'));
                disableSelects($(this));
            }

        });

        $('select#engine').bind('change',function() {

            disableSelects($(this));
            
            var model = $('select#model option:selected').val(),
                url = urlModel.replace('{model}', model),
                currentStyle = $('select#style option:selected').val(),
                currentEngine = $('select#engine option:selected').val(),
                currentSelect = $(this).val();

            $('.capped-calculator select#interval').attr('disabled',false).css('opacity','1');
            $('.capped-calculator select#interval').prev('label').css({opacity:'1',cursor: 'pointer'});

            // reset 'Select your interval' select box
            $('select#interval option').remove();

            if (currentSelect != 'default') {
                $.ajax({
                    url: url,
                    success: function(data){    

                        $('select#interval').append($('<option value="default" rel="default" id="default"></option>').text(selectInterval));

                        var engineObj =  data.data.vehicle.style[currentStyle].engine[currentEngine],
                            currentInterval = engineObj.summary_descriptions,
                            currentSummary = engineObj.summary,
                            currentBrake = engineObj.summary.brakefluid,
                            currentCoolant = engineObj.summary.coolant,
                            currentService = engineObj['@service_type'];
                            
                        (currentService === 'a') ? $('span.service-length').html('12') : $('span.service-length').html('6');

                        $('.brakefluid').html(currentBrake);
                        $('.coolant').html(currentCoolant);

                        $.each(currentInterval, function(i,value){

                            var interval = value;

                            if (value !== '') {
                                // populate 'Select your interval' select box
                                $('select#interval').append($('<option></option>').val(interval).text(interval).attr({'rel':currentSummary[i],'id':i}));
                            }


                        });


                        // sort Select Interval options numerically
                        var $dd = $('select#interval');
                        if ($dd.length > 0) { // make sure we found the select we were looking for

                            // save the selected value
                            var selectedVal = $dd.val();

                            // get the options and loop through them
                            var $options = $('option', $dd);
                            var arrVals = [];
                            $options.each(function(){

                                // push each option value and text into an array
                                arrVals.push({
                                    val: parseInt($(this).val(), 10),
                                    id: $(this).attr('id'),
                                    rel: $(this).attr('rel'),
                                    text: $(this).text()
                                });
                                    

                            });

                            // sort the array by the value (change val to text to sort by text instead)
                            arrVals.sort(function(a, b){
                                return a.val - b.val;
                            });

                            // loop through the sorted array and set the text/values to the options
                            for (var i = 0, l = arrVals.length; i < l; i++) {
                                $($options[i]).val(arrVals[i].val).text(arrVals[i].text).attr('id', arrVals[i].id).attr('rel', arrVals[i].rel);
                            }

                            // set the selected value back
                            $dd.val(selectedVal);
                        }


                    }
                });
            } else {
                $('select#interval').append($('<option value="default" rel="default" id="default">'+selectInterval+'</option>'));
                disableSelects($(this));
            }

        });

        $('select#interval').bind('change',function() {

            var model = $('select#model option:selected').val(), 
                encodedModel = encodeURIComponent(model),
                style = $('select#style option:selected').attr('id'),
                encodedStyle = encodeURIComponent(style),
                engine = $('select#engine option:selected').attr('id'),
                encodedEngine = encodeURIComponent(engine),
                interval = $('select#interval option:selected').text(),
                months = $('select#interval option:selected').attr('id'),
                
                
                url = urlPdf.replace('{model}', encodedModel);
            	url = url.replace('{style}', encodedStyle);
            	url = url.replace('{engine}', encodedEngine);
            	url = url.replace('{months}', months);
                
            	url = url.replace(/\s/g, "%20");

                if (months != 'default') {

                    // display quote valid date
                    $('span.valid-date').html(Date.today().addDays(30).toString('dd-MM-yyyy'));
                    // displayed capped price
                    $('span.capped-price').html($('select#interval option:selected').attr('rel'));
                    // add URL to PDF link
                    $('#print-pdf').attr('href', url);

                    // view extras - brake fluid and coolant charges
                    $('#extra-costs').fadeIn(300);

                    var intervalNoSpace = interval.replace(/\s/g, "");
                    //var intervalRemoveS = intervalNoSpace.replace(/[s]/g, "");
                    $('span.interval').html(intervalNoSpace);

                    $('#completed').fadeIn(300);
                    $('#completed-buttons').fadeIn(300);

                    // reload page when clicked
                    $('.btn-start').bind('click',function(e) {
                        e.preventDefault();

                        // disable select boxes and labels
                        $(this).parent().parent().find('.capped-calculator').children(':not(:first)').find('select').attr('disabled','disabled').css('opacity','.3');
                        $(this).parent().parent().find('.capped-calculator').children(':not(:first)').find('label').css({opacity:'.3',cursor: 'default'});
                        $('#completed').fadeOut(300);
                        $('#extra-costs').fadeOut(300);
                        $('#completed-buttons').fadeOut(300,function() {
                            $('html,body').animate({scrollTop:$('#content').offset().top}, 300);
                            $('select#model').val($('select#model option:first').val());
                            $('select#style').val($('select#style option:first').val());
                            $('select#engine').val($('select#engine option:first').val());
                            $('select#interval').val($('select#interval option:first').val());
                        });
                    });
                } else {
                    $('#completed').fadeOut(300);
                    $('#completed-buttons').fadeOut(300);
                }         
        });
    };

    if ($('.capped-calculator').length > 0) {
        cappedPriceCalc();
    }

});


(function($){

    var eCatalog = function(){

        // declare global variables for tool
        var ecatalog = this,
            toolContainer = $('.ecatalog-select'),
            urls = $('#product-search-data').embeddedData(),
            ajaxError = urls["xhr-product-search-feed-not-available"],
            resetTitle = urls["xhr-product-search-reset-title"],
            ctaTitle = urls["xhr-product-search-call-to-action-title"],
            ctaLink = urls["xhr-product-search-call-to-action-link"],
            selectDefault = urls["xhr-product-search-default-option"],
            dataAjax = function(){
                var dataJSON = urls["xhr-product-search-data"];

                return $.ajax({
                    url: dataJSON
                });
            };

        // setup global ajax settings
        $.ajaxSetup({
            type: "GET",
            cache: true,
            dataType: "json",
            statusCode: {
                404: function() {
                    $('.ajax-loader').remove();
                    $(toolContainer).html('<p class="ajax-error">' + ajaxError + '</p>');
                }
            }
        });

        // adds a new row with label and select elements
        ecatalog.addRow = function(id,value){
            $('.form-wrap', toolContainer).append('<div><label for="select' + id + '" id="label' + id + '">' + value + '</label><select id="select' + id + '"><option value="default">' + selectDefault + '</option></select></div>');
        };

        // reset options of all following select boxes
        ecatalog.resetOptions = function(selectBox){
            $(selectBox).parent().nextAll().find('select option:gt(0)').remove();
        };

        // populate the next select box
        ecatalog.addOptions = function(currentSelect){

            var selectedOptions = new Array(),
                rowCount = $('.form-wrap select', toolContainer).length,
                promise = dataAjax();

            // loop through select box values and create variables i.e. var = select1Val
            for(var i = 0; i < (rowCount); i++) {     
                selectedOptions.push($('select#select' + i + ' option:selected').val());
            }

            promise.success(function (data) {
                var pattern = /[0-9]+/g,
                    currentSelInt = currentSelect.match(pattern),
                    // takes current select id and returns only the integer + 1. i.e. id="select0" = 1, id="select1" = 2
                    currentSelIntPlusOne = parseInt(currentSelInt, 10) + 1;
                    
                $('.ajax-loader').remove();
                
                if (isNaN(currentSelIntPlusOne)) {
                    $.each(data, function(i,item){
                            $('select#select0').append($('<option></option>').val(i).text(i));
                    });
                } else {
                	
                	//find the nested data to show 
                	dataObj = data;
                	for(var i = 0; i < currentSelIntPlusOne; i++) {
                		dataObj = dataObj[selectedOptions[i]];
                	}

                    // if the last row is reached then the copy/text is displayed for that product
                    if (currentSelIntPlusOne === (rowCount)) {
                       
                        if ($('#completed').length === 0) {
                            $('.buttons', toolContainer).before('<div id="completed"></div>');
                        }                            

                        $.each(dataObj, function(i,item) {
                            $('#completed').append('<p>' + item + '</p>');
                        });
                        $('#completed').fadeIn(300);
                    } else {
                        
                        $.each(dataObj, function(i,item){
                            $('select#select' + currentSelIntPlusOne).append($('<option></option>').val(i).text(i));
                        });
                    }
                }
            });
        };

        // enable the next select and assosciated label
        ecatalog.enableNextSelect = function(dropdown) {
            $(dropdown).parent().next().find('select').attr('disabled',false).css('opacity','1');
            $(dropdown).parent().next().find('label').css({opacity:'1',cursor: 'pointer'});
        };

        // disable remaining selects and associated labels when selecting another option
        ecatalog.disableSelects = function(el){
            $(el).parent().next().nextAll().find('select').attr('disabled','disabled').css('opacity','.3');
            $(el).parent().next().nextAll().find('select option[value="default"]').attr('selected','selected');
            $(el).parent().next().nextAll().find('label').css({opacity:'.3',cursor: 'default'});
            if ($('#completed').is(':visible')) { 
                $('#completed').hide().html('');
            }
        };

        // disable remaining selects and associated labels when selecting the default option 'selecciona'
        ecatalog.disableSelects2 = function(el){
            $(el).parent().nextAll().find('select').attr('disabled','disabled').css('opacity','.3');
            $(el).parent().nextAll().find('select option[value="default"]').attr('selected','selected');
            $(el).parent().nextAll().find('label').css({opacity:'.3',cursor: 'default'});
            if ($('#completed').is(':visible')) { 
                $('#completed').hide().html('');
            }
        };

        // reset button function that disables all selects and associated labels (except the first select/label which is just reset)
        ecatalog.resetBtn = function(){
            toolContainer.on('click','.reset-btn',function() {
                var contentDiv = document.getElementById("content");
                function elementInViewport(el) {
                    var rect = el.getBoundingClientRect();
                    return (
                        rect.top >= 0 &&
                        rect.left >= 0 &&
                        rect.bottom <= window.innerHeight &&
                        rect.right <= window.innerWidth 
                        )
                }

                ecatalog.disableSelects2($('select#select0'));
                $('#select0 option[value="default"]').attr('selected','selected');
                if (!elementInViewport(contentDiv)) {
                    $('html,body').animate({scrollTop:$('#content').offset().top}, 300);
                }
            });
        };

        ecatalog.run = function(){

            ecatalog.disableSelects2('select#select0');

            var formWrap = '';
                formWrap += '<div class="form-wrap"></div>';
                productArray = [];
                buttonsDiv = '';
                buttonsDiv += '<div class="group buttons">';
                buttonsDiv += '<a href="' + ctaLink + '" class="buttonright" title="' + ctaTitle + '">' + ctaTitle + '</a>';
                buttonsDiv += '<input class="buttonleft reset-btn" type="reset" title="' + resetTitle + '" value="' + resetTitle + '" />';
                buttonsDiv += '</div>';

            // inject HTML from above declared formWrap variable to create the tool wrapper
            toolContainer.html(formWrap);

            var headersJSON = urls["xhr-product-search-config"],
                currentEl = $(this),
                currentOption = $('option:selected', this).val();
            
            // populate tool with labels and select boxes
            $.ajax({
                url: headersJSON,
                beforeSend: function(){
                    $('body').append('<div class="ajax-loader"></div>');
                },
                success: function(data){
                    $('.ajax-loader').remove();

                    $.each(data.names, function(index,value){
                        if (value != 'content') {
                            ecatalog.addRow(index,value);
                        }
                    });
                }
            });

            var promise = dataAjax();
        
            // populate the first select box with data
            promise.success(function (data) {
                ecatalog.resetOptions('select#select0');
                $.each(data, function(i,item){
                    $('select#select0').append($('<option></option>').val(i).text(i));
                });
                ecatalog.disableSelects2('select#select0');
            });

            // change event handler for all the select boxes
            toolContainer.on('change','select',function() {

                var currentEl = $(this),
                    currentOption = $('option:selected', this).val(),
                    currentSelect = currentEl.attr('id');
                
                    ecatalog.enableNextSelect($(this));

                    // add buttons to bottom of tool after first selection
                    if ($('.group.buttons').length === 0) {
                        toolContainer.append(buttonsDiv);
                        $('.buttons',toolContainer).fadeIn(300);
                    }

                    if (currentOption != 'default') {
                        productArray.push(currentOption);
                        ecatalog.resetOptions(currentEl);
                        ecatalog.disableSelects(currentEl);
                        ecatalog.addOptions(currentSelect);
                    } else {
                        ecatalog.disableSelects2(currentEl);
                    }
               
                ecatalog.resetBtn();
            });
        };

        // run the eCatalog tool
        ecatalog.init = function(){
            ecatalog.run();
        };

    };


    $(document).ready(function(){
        // initialise the eCatalog tool
        if ($('#product-search-data').length > 0) {
            var ecatalog = new eCatalog();
            ecatalog.init();
        }
    });

})(jQuery);


/*
 * Heavily Modified Basic jQuery Slider plug-in v.1.3
 *
 * http://www.basic-slider.com
 *
 * Original authored by John Cobb
 * http://www.johncobb.name
 * @john0514
 *
 * Copyright 2011, John Cobb
 * License: GNU General Public License, version 3 (GPL-3.0)
 * http://www.opensource.org/licenses/gpl-3.0.html
 *
 */

;(function($) {

    "use strict";

    $.fn.jslider = function(o) {
        
        // slider default settings
        var defaults        = {

            // w + h to enforce consistency
            width           : 480,
            height          : 579,

            // transition valuess
            animtype        : 'reveal',
            animduration    : 600,      // length of transition
            animspeed       : 4000,     // delay between transitions
            automatic       : true,     // enable/disable automatic slide rotation

            // control and marker configuration
            showcontrols    : true,     // enable/disable next + previous UI elements
            defaultcontrols : true,     // enable/disable next + previous to default position
            nexttext        : 'Next',   // text/html inside next UI element
            prevtext        : 'Prev',   // text/html inside previous UI element
            showmarkers     : false,    // enable/disable individual slide UI markers

            // interaction values
            keyboardnav     : true,     // enable/disable keyboard navigation
            hoverpause      : false,    // enable/disable pause slides on hover

            // presentational options
            responsive      : false,    // enable responsive behaviour
            intro           : false

        };

        // create settings from defauls and user options
        var settings        = $.extend({}, defaults, o);

        return this.each(function(){

            // slider elements
            var $wrapper        = $(this),
                $slider         = $wrapper.find('ul.jslider'),
                $slides         = $slider.children('li'),

                // control elements
                $c_wrapper      = null,
                $c_fwd          = null,
                $c_prev         = null,

                // marker elements
                $m_wrapper      = null,
                $m_markers      = null,

                // elements for slide animation
                $canvas         = null,
                $clone_first    = null,
                $clone_second   = null,
                $clone_last     = null;

            // state management object
            var state           = {
                slidecount      : $slides.length,   // total number of slides
                animating       : false,            // bool: is transition is progress
                paused          : false,            // bool: is the slider paused
                currentslide    : 0,                // current slide being viewed (not 0 based)
                nextslide       : 0,                // slide to view next (not 0 based)
                currentindex    : 0,                // current slide being viewed (0 based) - left slide
                nextindex       : 0,                // slide to view next (0 based)
                interval        : null              // interval for automatic rotation
            };

            var responsive      = {
                width           : null,
                height          : null,
                ratio           : null
            };

            // helpful variables
            var vars            = {
                fwd             : 'forward',
                prev            : 'previous'
            };

            // initialise intro slide counter
            var introcount = 2;
                
            // run through options and initialise settings
            var init = function() {

                // differentiate slider li from content li
                $slides.addClass('jslider-slide');

                // conf dimensions, responsive or static
                if( settings.responsive ){
                    conf_responsive();
                }
                else{
                    conf_static();
                }

                // configurations only available if more than 1 slide
                if( state.slidecount > 1 ){

                    // create and show controls
                    if( settings.showcontrols ){
                        conf_controls();
                    }

                    // create and show controls
                    if( settings.defaultcontrols ){
                        conf_defaultcontrols();
                    }

                    // create and show markers
                    if( settings.showmarkers ){
                        conf_markers();
                    }

                    // enable slidenumboard navigation
                    if( settings.keyboardnav ){
                        conf_keynav();
                    }

                    // enable pause on hover
                    if ( settings.hoverpause && settings.automatic ){
                        conf_hoverpause();
                    }

                    // conf slide animation
                    if ( settings.animtype === 'slide' ){
                        conf_slide();
                    }

                    // conf reveal animation
                    if ( settings.animtype === 'reveal' ){
                        conf_reveal();
                    }

                    // enable intro click
                    if ( settings.intro ){
                        conf_intro();
                    }

                    $slider.children().each(function( index ){
                        var index = index + 1,
                            slideNum = index.toString();
                        $(this).addClass('slide' + slideNum);              
                    });

                    // enable swipe
                    if( !settings.automatic ) {
                        conf_swipe();
                    }

                }

                if(settings.animtype === 'slide' || settings.animtype === 'reveal'){
                    state.currentindex = 1;
                    state.currentslide = 2;
                }

                // slide components are hidden by default, show them now
                $slider.show();
                $slides.eq(state.currentindex).show();

                // Finally, if automatic is set to true, kick off the interval
                if(settings.automatic){
                    state.interval = setInterval(function () {
                        go(vars.fwd, false);
                    }, settings.animspeed);
                }

                // disable prev button at start of slideshow
                disablePrevBtn(2);

                // anchor link to experience layer
                $('.experience-anchor').on('click',function(e){
                    e.preventDefault();
                    $('html,body').animate({scrollTop: $('#experience').offset().top}, 400);
                });
 
            };

            var conf_intro = function() {
                
                $('.start-experience').on('click',function() { 

                	//set required v13/c13 value - only here as we only want to track the first "page" view
                	//it assumes nameplate is required
					
                	if( window._da && window._da.om && ND && ND.omniture ) {
						
					s.eVar13 = s.prop13 = 'exp-intro' + (state.currentslide/2) + '-' + _da.nameplate.name;
                	trackEvent($('#experience-slider ul.jslider .slide1 .content'));
					
					}

                    // clear the interval set above for the intro slides
                    clearInterval(state.interval);

                    // reveal experience slider
                    reveal_experience();

                });

            };

            // function that calls omniture for click/keyboard and swipe events
            var trackEvent = function(slide) {
                if (window._da && window._da.om && ND && ND.omniture) {
					ND.analyticsTag.trackOmniturePage({
						pname: slide.data('pname'),
						hier: slide.data('hier'),
						tool: slide.data('tool'),
						tooldesc: slide.data('tooldesc')
					});
				}
            };

            var disablePrevBtn = function(currentSlide) {
                if(state.currentslide === currentSlide){
                    $('li.jslider-prev a').addClass('disabled').on('click.prevbtn', function() {
                        return false;
                    });
                } else {
                    $('li.jslider-prev a').off('click.prevbtn');
                }
            };

            var disableNextBtn = function(currentSlide) {
                if(state.currentslide === state.slidecount){
                    $('li.jslider-next a').addClass('disabled').on('click.nextbtn', function() {
                        return false;
                    });
                } else {
                    $('li.jslider-next a').off('click.nextbtn');
                }
            };

            // attach intro slide number to URL hash
            /*var insertParam = function(key, value) {
                    
                var encodedKey = encodeURIComponent(key), encodedValue = encodeURIComponent(value);
                document.location.hash = encodedKey + '=' + encodedValue;
                
            };*/

            var conf_responsive = function() {

                responsive.width    = $wrapper.outerWidth();
                responsive.ratio    = responsive.width/settings.width;
                responsive.height   = settings.height * responsive.ratio;

                if(settings.animtype === 'fade'){

                    // initial setup
                    $slides.css({
                        'height'        : settings.height,
                        'width'         : '100%'
                    });
                    $slides.children('img').css({
                        'height'        : settings.height,
                        'width'         : '100%'
                    });
                    $slider.css({
                        'height'        : settings.height,
                        'width'         : '100%'
                    });
                    $wrapper.css({
                        'height'        : settings.height,
                        'max-width'     : settings.width,
                        'position'      : 'relative'
                    });

                    if(responsive.width < settings.width){

                        $slides.css({
                            'height'        : responsive.height
                        });
                        $slides.children('img').css({
                            'height'        : responsive.height
                        });
                        $slider.css({
                            'height'        : responsive.height
                        });
                        $wrapper.css({
                            'height'        : responsive.height
                        });

                    }

                    $(window).resize(function() {

                        // calculate and update dimensions
                        responsive.width    = $wrapper.outerWidth();
                        responsive.ratio    = responsive.width/settings.width;
                        responsive.height   = settings.height * responsive.ratio;

                        $slides.css({
                            'height'        : responsive.height
                        });
                        $slides.children('img').css({
                            'height'        : responsive.height
                        });
                        $slider.css({
                            'height'        : responsive.height
                        });
                        $wrapper.css({
                            'height'        : responsive.height
                        });

                    });

                }

                if(settings.animtype === 'slide'){

                    // initial setup
                    $slides.css({
                        'height'        : settings.height,
                        'width'         : settings.width
                    });
                    $slides.children('img').css({
                        'height'        : settings.height,
                        'width'         : settings.width
                    });
                    $slider.css({
                        'height'        : settings.height,
                        'width'         : settings.width * settings.slidecount
                    });
                    $wrapper.css({
                        'height'        : settings.height,
                        'max-width'     : settings.width,
                        'position'      : 'relative'
                    });

                    if(responsive.width < settings.width){

                        $slides.css({
                            'height'        : responsive.height
                        });
                        $slides.children('img').css({
                            'height'        : responsive.height
                        });
                        $slider.css({
                            'height'        : responsive.height
                        });
                        $wrapper.css({
                            'height'        : responsive.height
                        });

                    }

                    $(window).resize(function() {

                        // calculate and update dimensions
                        responsive.width    = $wrapper.outerWidth();
                        responsive.ratio    = responsive.width/settings.width;
                        responsive.height   = settings.height * responsive.ratio;

                        $slides.css({
                            'height'        : responsive.height,
                            'width'         : responsive.width
                        });
                        $slides.children('img').css({
                            'height'        : responsive.height,
                            'width'         : responsive.width
                        });
                        $slider.css({
                            'height'        : responsive.height,
                            'width'         : responsive.width * settings.slidecount
                        });
                        $wrapper.css({
                            'height'        : responsive.height
                        });
                        $canvas.css({
                            'height'        : responsive.height,
                            'width'         : responsive.width
                        });

                        resize_complete(function(){
                            go(false,state.currentslide);
                        }, 200, "some unique string");

                    });

                }

            };

            var resize_complete = (function () {
                
                var timers = {};
                
                return function (callback, ms, uniqueId) {
                    if (!uniqueId) {
                        uniqueId = "Don't call this twice without a uniqueId";
                    }
                    if (timers[uniqueId]) {
                        clearTimeout (timers[uniqueId]);
                    }
                    timers[uniqueId] = setTimeout(callback, ms);
                };

            })();

            // enforce fixed sizing on slides, slider and wrapper
            var conf_static = function() {

                $slides.css({
                    'height'    : settings.height,
                    'width'     : settings.width
                });
                $slider.css({
                    'height'    : settings.height,
                    'width'     : settings.width
                });
                $wrapper.css({
                    'height'    : settings.height,
                    'width'     : settings.width,
                    'position'  : 'relative'
                });

            };

            var conf_reveal = function() {

                // update the elements object
                $slides             = $slider.children('li');
                state.slidecount    = $slides.length;

                // create a 'canvas' element which is neccessary for the slide animation to work
                $canvas = $('<div class="jslider-wrapper"></div>');

                // if the slider is responsive && the calculated width is less than the max width
                if(settings.responsive && (responsive.width < settings.width)){

                    $canvas.css({
                        'width'     : responsive.width,
                        'height'    : responsive.height,
                        'overflow'  : 'hidden',
                        'position'  : 'relative'
                    });

                    // update the dimensions to the slider to accomodate all the slides side by side
                    $slider.css({
                        'width'     : responsive.width * (state.slidecount + 2),
                        'left'      : -responsive.width * state.currentslide
                    });

                }
                else {

                    $canvas.css({
                        'width'     : settings.width * 2,
                        'height'    : settings.height,
                        'overflow'  : 'hidden',
                        'position'  : 'relative'
                    });

                    // update the dimensions to the slider to accomodate all the slides side by side
                    $slider.css({
                        'width'     : settings.width * (state.slidecount + 2),
                        'left'      : -settings.width * state.currentslide
                    });

                }

                // add some inline styles which will align our slides for left-right sliding
                $slides.css({
                    'float'         : 'left',
                    'position'      : 'relative',
                    'display'       : 'list-item'
                });

                // 'everything.. in it's right place'
                $canvas.prependTo($wrapper);
                $slider.appendTo($canvas);

                //insertParam('intcmp','exp-intro1');

            };

            var conf_slide = function() {

                // create three extra elements which are clones of the first, second and last slides
                $clone_first    = $slides.eq(0).clone();
                $clone_second   = $slides.eq(1).clone();
                $clone_last     = $slides.eq(state.slidecount-1).clone();

                // add them to the DOM where we need them
                $clone_first.attr({'data-clone' : 'last', 'data-slide' : 0}).appendTo($slider).show();
                $clone_second.appendTo($slider).show();
                $clone_last.attr({'data-clone' : 'first', 'data-slide' : 0}).prependTo($slider).show();

                // update the elements object
                $slides             = $slider.children('li');
                state.slidecount    = $slides.length;

                // create a 'canvas' element which is neccessary for the slide animation to work
                $canvas = $('<div class="jslider-wrapper"></div>');

                $canvas.css({
                    'width'     : settings.width * 2,
                    'height'    : settings.height,
                    'overflow'  : 'hidden',
                    'position'  : 'relative'
                });

                // update the dimensions to the slider to accomodate all the slides side by side
                $slider.css({
                    'width'     : settings.width * (state.slidecount + 2),
                    'left'      : -settings.width * state.currentslide
                });

                // add some inline styles which will align our slides for left-right sliding
                $slides.css({
                    'float'         : 'left',
                    'position'      : 'relative',
                    'display'       : 'list-item'
                });

                // 'everything.. in it's right place'
                $canvas.prependTo($wrapper);
                $slider.appendTo($canvas);

            };

            var conf_controls = function() {

                // create the elements for the controls
                $c_wrapper  = $('<ul class="jslider-controls"></ul>');
                $c_fwd      = $('<li class="jslider-next"><a href="#" data-direction="'+ vars.fwd +'">' + settings.nexttext + '</a></li>');
                $c_prev     = $('<li class="jslider-prev"><a href="#" data-direction="'+ vars.prev +'">' + settings.prevtext + '</a></li>');

                    // bind click events
                    //$c_wrapper.on('click','ul.jslider-controls a',function(e){
                	$c_wrapper.on('click','a',function(e){

                        e.preventDefault();
                        var direction = $(this).attr('data-direction');

                        if(!state.animating){

                            if(direction === vars.fwd){
                                go(vars.fwd,false);
                                disableNextBtn(state.currentslide);
                                if(state.currentslide != 2){
                                    $('li.jslider-prev a').removeClass('disabled');
                                }
                            }

                            if(direction === vars.prev){
                                go(vars.prev,false);
                                disableNextBtn(state.currentslide);
                                if(state.currentslide === 2){
                                    $('li.jslider-prev a').addClass('disabled');
                                }
                                if(state.currentslide < state.slidecount){
                                    $('li.jslider-next a').removeClass('disabled');
                                }
                            }

                            trackEvent($('.slide' + state.currentindex).children('.content'));

                        }

                    });

                // put 'em all together
                $c_prev.appendTo($c_wrapper);
                $c_fwd.appendTo($c_wrapper);
                $c_wrapper.appendTo($wrapper);

            };

            var conf_defaultcontrols = function() {
                $('ul.jslider-controls li a').addClass('default');
            };

            var conf_markers = function() {

                // create a wrapper for our markers
                $m_wrapper = $('<ol class="jslider-markers"></ol>');

                // for every slide, create a marker
                $.each($slides, function(key, slide){

                    var slidenum    = key + 1,
                        gotoslide   = key + 1;
                    
                    if(settings.animtype === 'slide'){
                        // + 2 to account for clones
                        gotoslide = key + 2;
                    }

                    var marker = $('<li><a href="#">'+ slidenum +'</a></li>');

                    // set the first marker to be active
                    if(slidenum === state.currentslide){ marker.addClass('active-marker'); }

                    // bind the click event
                    marker.on('click','a',function(e){
                        e.preventDefault();
                        if(!state.animating && state.currentslide !== gotoslide){
                            go(false,gotoslide);
                        }
                    });

                    // add the marker to the wrapper
                    marker.appendTo($m_wrapper);

                });

                $m_wrapper.appendTo($wrapper);
                $m_markers = $m_wrapper.find('li');

            };

            var nextSlide = function() {

                if(state.currentslide != state.slidecount && settings.animtype === 'reveal') {
                    go(vars.fwd, false);
                } else if(settings.animtype != 'reveal'){
                    go(vars.fwd, false);
                }

                disableNextBtn(state.currentslide);

                if(state.currentslide != 2){
                    $('li.jslider-prev a').removeClass('disabled');
                }

                trackEvent($('.slide' + (state.currentindex)).children('.content'));

            };

            var prevSlide = function() {

                if(state.currentslide >= 4 && settings.animtype === 'reveal') {
                    go(vars.prev, false);
                } else if(settings.animtype != 'reveal'){
                    go(vars.prev, false);
                }

                disableNextBtn(state.currentslide);
                
                if(state.currentslide === 2){
                    $('li.jslider-prev a').addClass('disabled');
                }
                if(state.currentslide < state.slidecount){
                    $('li.jslider-next a').removeClass('disabled');
                }

                trackEvent($('.slide' + state.currentindex).children('.content'));

            };

            var conf_keynav = function() {

                $(document).keyup(function (event) {

                    // run code only if the intro is complete
                    if ($('#intro-slider').length === 0){

                        if (!state.paused) {
                            clearInterval(state.interval);
                            state.paused = true;
                        }

                        if (!state.animating) {
                            if (event.keyCode === 39) {
                                
                                event.preventDefault();
                                nextSlide();

                            } else if (event.keyCode === 37) {
                                
                                event.preventDefault();
                                prevSlide();

                            }
                        }

                        if (state.paused && settings.automatic) {
                            state.interval = setInterval(function () {
                                go(vars.fwd);
                            }, settings.animspeed);
                            state.paused = false;
                        }

                    }

                });

            };

            var conf_swipe = function() {

                if (Modernizr.touch) {
                    // bind swipe events
                    if(!state.animating){
            
                        $slider.touchwipe({
                            wipeLeft: function() {
                                nextSlide();
                            },
                            wipeRight: function() {
                                prevSlide();
                            },
                            min_move_x: 20,
                            preventDefaultEvents: true
                        });

                    }
                }   

            };

            var conf_hoverpause = function() {

                $wrapper.hover(function () {
                    if (!state.paused) {
                        clearInterval(state.interval);
                        state.paused = true;
                    }
                }, function () {
                    if (state.paused) {
                        state.interval = setInterval(function () {
                            go(vars.fwd, false);
                        }, settings.animspeed);
                        state.paused = false;
                    }
                });

            };

            var set_next = function(direction) {

                if(direction === vars.fwd){
                    
                    if($slides.eq(state.currentindex).next().length){
                        state.nextindex = state.currentindex + 1;
                        state.nextslide = state.currentslide + 1;
                    }
                    else{
                        state.nextindex = 0;
                        state.nextslide = 1;
                    }

                }
                else{

                    if($slides.eq(state.currentindex).prev().length){
                        state.nextindex = state.currentindex - 3;
                        state.nextslide = state.currentslide - 3;
                        state.currentslide = state.currentslide - 4;
                    }
                    else{
                        state.nextindex = state.slidecount - 1;
                        state.nextslide = state.slidecount;
                    }

                }

            };

            var reveal_experience = function() {

                // clone the first and second slide of the experience layer for masking
                var $clone_firstSlide = $('#experience-slider .jslider li').eq(0).children().clone(),
                    $clone_secondSlide = $('#experience-slider .jslider li').eq(1).children().clone();

                if (Modernizr.csstransitions) {

                    // CSS3 transition version
                    // create masks of current and next slider and then animate
                    $clone_secondSlide.prependTo($canvas).addClass('reveal-right-mask');

                    // timeout required for transition to work
                    setTimeout(function(){
                        $('.reveal-right-mask').css({
                            'height'    : settings.height,
                            'width'     : settings.width,
                            'z-index'   : 12
                        });
                    },50);

                    // second reveal/slide activated just before first reveal/slide is complete
                    setTimeout(function(){

                        $clone_firstSlide.prependTo($canvas).addClass('reveal-left-mask').find("a.overlay").hide();//hide clone a.overlay because it doesnt have click event. this will broken overlay functionality
                        
                        setTimeout(function(){
                            $('.reveal-left-mask').css({
                                'height'    : settings.height,
                                'width'     : settings.width,
                                'z-index'   : 12
                            });

                            setTimeout(function(){
                                // once transitions are complete fade out masks and then remove intro slider from DOM
                                $('#intro-slider').fadeOut(700, function() {
                                    $('#intro-slider').remove(); 
                                });
                            },settings.animduration+50);
                        },50);
                    },200);

                } else {

                    // jQuery fallback animate version
                    // create masks of current and next slider and then animate
                    $clone_secondSlide.prependTo($canvas).addClass('reveal-right-mask').css({
                        'right'     : 0,
                        'height'    : settings.height,
                        'width'     : 0,
                        'z-index'   : 12
                    }).animate({'width': settings.width}, settings.animduration, 'easeOutCubic');

                    // second reveal/slide activated just before first reveal/slide is complete
                    setTimeout(function(){

                        $clone_firstSlide.prependTo($canvas).addClass('reveal-left-mask').css({
                            'right': state.slidewidth,
                            'height': settings.height,
                            'width': 0,
                            'z-index': 12
                        }).animate({'width': settings.width}, settings.animduration, 'easeOutCubic', function() {
                            $('#intro-slider').fadeOut(700, function() {
                                $('#intro-slider').remove(); 
                            });
                        });

                    },250);
                
                }        

            };

            var go = function(direction, position) {

                // only if we're not already doing things
                if(!state.animating){

                    // doing things
                    state.animating = true;

                    $('.btn_build-quote').hide();

                    if(position){
                        state.nextslide = position;
                        state.nextindex = position-1;
                    }
                    else{
                        set_next(direction);
                    }

                    // fade animation
                    if(settings.animtype === 'fade'){

                        if(settings.showmarkers){
                            $m_markers.removeClass('active-marker');
                            $m_markers.eq(state.nextindex).addClass('active-marker');
                        }

                        // fade out current
                        $slides.eq(state.currentindex).fadeOut(settings.animduration);
                        // fade in next
                        $slides.eq(state.nextindex).fadeIn(settings.animduration, function(){

                            // update state variables
                            state.animating = false;
                            state.currentslide = state.nextslide;
                            state.currentindex = state.nextindex;

                        });

                    }

                    // disable prev button at start of slideshow
                    disablePrevBtn(0);

                    // reveal animation
                    if(settings.animtype === 'reveal'){

                        state.slidewidth = settings.width;
                
                        // add intro slide number to URL hash
                        /*if ($('#intro-slider').length > 0) {
                            insertParam('intcmp','exp-intro' + introcount);
                            introcount++;
                            if (introcount > (state.slidecount / 2)) {
                                introcount = 1;
                            }
                        }*/

                        // clone the first, current and next slide for masking
                        var $clone_firstSlide = $slides.eq(state.currentslide-1).children().clone(),
                            $clone_currentSlide = $slides.eq(state.currentslide).children().clone(),
                            $clone_nextSlide = $slides.eq(state.nextslide).children().clone();

                            // CSS3 transitions for modern browsers and fallback to jQuery for IE9 and below
                            if (Modernizr.csstransitions) {

                                // CSS3 transition version
                                // create masks of current and next slider and then animate
                                if (direction === 'previous') {
                                    $clone_currentSlide.prependTo($canvas).addClass('left-mask').addClass('previous-mask');
                                } else {
                                    $clone_nextSlide.prependTo($canvas).addClass('right-mask');
                                }

                                // timeout required for transition to work
                                setTimeout(function(){
                                    $(direction === 'previous' ? '.left-mask' : '.right-mask').css({
                                        'height': settings.height,
                                        'width' : settings.width
                                    });
                                },50);

                                // second reveal/slide activated just before first reveal/slide is complete
                                setTimeout(function(){

                                    if (state.currentslide === 2 && settings.automatic) {
                                        $clone_currentSlide = $slides.eq(state.currentslide-2).children().clone();
                                    }
                                    if (direction === 'previous') {
                                        $clone_nextSlide.prependTo($canvas).addClass('right-mask').addClass('previous-mask');
                                    } else {
                                        $clone_currentSlide.prependTo($canvas).addClass('left-mask');
                                    }

                                    setTimeout(function(){
                                        $(direction === 'previous' ? '.right-mask' : '.left-mask').css({
                                            'height': settings.height,
                                            'width' : settings.width,
                                            'z-index': 3
                                        });

                                        setTimeout(function(){
                                            $('.left-mask').remove();
                                            $('.right-mask').remove();
                                            $slider.css({'left': -state.nextindex * state.slidewidth }); 
                                            $('.jslider-next').css('visibility','visible');
                                            state.animating = false;
                                            if (state.currentslide > 17){
                                                $('.btn_build-quote').delay(300).stop().fadeIn(750);
                                            }
                                        },settings.animduration+50);
                                    },50);
                                },200);

                            } else {

                                // jQuery fallback animate version
                                // create masks of current and next slider and then animate
                                if (direction === 'previous') {
                                    $clone_currentSlide.prependTo($canvas).addClass('left-mask').addClass('previous-mask').css({

                                        'left': 0,
                                        'height': settings.height,
                                        'width': 0

                                    }).animate({'width': settings.width}, settings.animduration, 'easeOutCubic');
                                } else {
                                    $clone_nextSlide.prependTo($canvas).addClass('right-mask').css({

                                        'right': 0,
                                        'height': settings.height,
                                        'width': 0

                                    }).animate({'width': settings.width}, settings.animduration, 'easeOutCubic');
                                }

                                // second reveal/slide activated just before first reveal/slide is complete
                                setTimeout(function(){
                                    
                                    if (state.currentslide === 2 && settings.automatic) {
                                        $clone_currentSlide = $slides.eq(state.currentslide-2).children().clone();
                                    }

                                    if (direction === 'previous') {
                                        $clone_nextSlide.prependTo($canvas).addClass('right-mask').addClass('previous-mask').css({
                                            'left': state.slidewidth,
                                            'height': settings.height,
                                            'width': 0,
                                            'z-index': 3
                                        }).animate({'width': settings.width}, settings.animduration, 'easeOutCubic', function() {
                                            $('.left-mask').remove();
                                            $('.right-mask').remove();
                                            $slider.css({'left': -state.nextindex * state.slidewidth });        
                                            $('.jslider-next').css('visibility','visible');

                                            state.animating = false;
                                            if (state.currentslide > 17){
                                                $('.btn_build-quote').delay(300).stop().fadeIn(750);
                                            }
                                        });
                                    } else {
                                        $clone_currentSlide.prependTo($canvas).addClass('left-mask').css({
                                        'right': state.slidewidth,
                                        'height': settings.height,
                                        'width': 0,
                                        'z-index': 3
                                        }).animate({'width': settings.width}, settings.animduration, 'easeOutCubic', function() {
                                            $('.left-mask').remove();
                                            $('.right-mask').remove();
                                            $slider.css({'left': -state.nextindex * state.slidewidth });        
                                            $('.jslider-next').css('visibility','visible');

                                            state.animating = false;
                                            if (state.currentslide > 17){
                                                $('.btn_build-quote').delay(300).stop().fadeIn(750);
                                            }
                                        });

                                    }

                                },250);

                            }                      
                        
                        state.currentslide = state.nextslide + 1;
                        state.currentindex = state.nextindex + 1;
                        
                    }

                    // slide animation
                    if(settings.animtype === 'slide'){

                        if(settings.showmarkers){
                            
                            var markerindex = state.nextindex-1;

                            if(markerindex === state.slidecount-2){
                                markerindex = 0;
                            }
                            else if(markerindex === -1){
                                markerindex = state.slidecount-3;
                            }

                            $m_markers.removeClass('active-marker');
                            $m_markers.eq(markerindex).addClass('active-marker');
                        }

                        // if the slider is responsive && the calculated width is less than the max width
                        if(settings.responsive && ( responsive.width < settings.width ) ){
                            state.slidewidth = responsive.width;
                        }
                        else{
                            state.slidewidth = settings.width;
                        }
                        
                        state.slidewidth = settings.width;

                        $slider.animate({'left': -state.nextindex * state.slidewidth }, settings.animduration, function(){

                            state.currentslide = state.nextslide;
                            state.currentindex = state.nextindex;
                            
                            // is the current slide a clone?
                            if($slides.eq(state.currentindex).attr('data-clone') === 'last'){
                                
                                // affirmative, at the last slide (clone of first)
                                $slider.css({'left': -state.slidewidth });
                                state.currentslide = 2;
                                state.currentindex = 1;

                            }
                            else if($slides.eq(state.currentindex).attr('data-clone') === 'first'){

                                // affirmative, at the fist slide (clone of last)
                                $slider.css({'left': -state.slidewidth *(state.slidecount - 3)});
                                state.currentslide = state.slidecount - 2;
                                state.currentindex = state.slidecount - 3;

                            }

                            state.animating = false;

                        });

                    }

                }

            };

            // start the slideshow
            init();

        });

    };

})(jQuery);


/*
* Project: B515
* Description: B515 Experience layer
* Reading: http://www.adequatelygood.com/2010/3/JavaScript-Module-Pattern-In-Depth
* Author: York Zhang
*/

/*globals jQuery, ND, window */
var ND = (function(ND, $) {
	
	//The create function creates the module object; It does no initialise the object
	ND.tileTransform = function () {
	
		/*
		 * Write private variables and functions here in this closure.
		 * They don't need to be just utility functions, they can refer to the private instance variables 
		 */
		var element,
			hasA;
		
		/*
		 * returns a new object that is the functionality of the module
		 * It has access to the private variables and functions declared in this closure.
		 */
		return {

			/*
			 * init Function. Needs to be called to initialise the new module object
			 * 
			 * eg. var myModule = ND.myModuleName()
			 *     myModule.init(); 
			 */
			init: function( elem ) { 
				
				/* Cache the jQuery instance of the element(s) this belongs too.
				 * Bake in default selectors. 
				 */
				element = $(elem || ".staging-wrap");
					
				/* Check this module needs to be initalised for this page */
				if( !element || !element.size() ) { return this; }

				var stagingHidden = $("div.staging-hidden", element);

				var hiddenContent = $("div.current.staging",element).find("div.center div.hidden-content").html();
				var textStaging = element.find("div.displayed-content");
				var isIE8 = $.browser.msie && $.browser.version < 9;
				var is_iPad = function(){
					var ua = navigator.userAgent.toLowerCase();
					if(ua.match(/iPad/i)=="ipad") {
						return true;
				 	} else {
						return false;
					}
				}();
				var is_webkit = $.browser.webkit;
				if(is_webkit){
					$("body").addClass("is-webkit");
				}

				if(is_iPad){
					$("body").addClass("is-ipad");
				}else{
					$("body").addClass("not-ipad");
				}

				var mapData = $.parseJSON($("#content-map").html());
				var contentMap = mapData.map;
				var defaultTileIndex = mapData.defaultTileIndex;
				var imageSlider = {};
				/* get content map's row sum and column sum, start from 0 */
				var rowMax = 0;
				var colMax = 0;
				$.each(contentMap,function(i,value){
					var rowValue = parseInt(value.row); 
					var colValue = parseInt(value.col);
					rowMax = (rowValue > rowMax) ? rowValue : rowMax;
					colMax = (colValue > colMax) ? colValue : colMax;
				});

				var easingEffect = "easeInOutQuart";
				var tileMovingDuration = 1500;
				// var easingEffect = "linear";
				// var tileMovingDuration = 800;

				//console.log(rowMax, colMax);
				//$("#slider").slider();
				
				textStaging.html(hiddenContent);
				if($("div.current.staging",element).find("div.center div.hidden-content").size()<1){
					textStaging.hide();
				}

	            var trackTile = function(tile) {
	            	//console.log("click tracking");
	                ND.analyticsTag.trackOmniturePage({
	                	pname: tile.attr('data-pname'),
	                	hier: tile.attr('data-hier')
	                });
	            };

	            var trackInitialTile = function(tile) {
	            	//console.log("init tracking");
	            	var tile_pname = tile.attr('data-pname'),
	            		tile_pnameArr,
	            		tile_pnameArrLength,
	            		intcmpValue;
	            	if(tile_pname != undefined){
		            	tile_pnameArr = tile_pname.split(":");
		            	tile_pnameArrLength = tile_pnameArr.length;
		            	s.eVar13 = s.prop13 = "exp-" + tile_pnameArr[tile_pnameArrLength - 1] + "-" + _da.nameplate.name;
		            }


	                ND.analyticsTag.trackOmniturePage({
	                	pname: tile.attr('data-pname'),
	                	hier: tile.attr('data-hier'),
	                	tool: tile.attr('data-tool'),
	                	tooldesc: tile.attr('data-tooldesc')
	                });
	            };

				var tilesRotate = function(option){
					//var clickedTile = is_webkit ? option.selector.find("div.border-hack") : option.selector;
					var clickedTile =  option.selector;
					clickedTile.live("click",function(){
						//var $thisTile = is_webkit ? $(this).parents("div.item-wrap") : $(this);
						var $thisTile = $(this);
						//trackTile($thisTile);
						$thisTile.trigger("mouseleave");
						//console.log($("div.current.staging",element).find("div.center div.item ul.image-slider").size());
						//imageSlider.destroySlider();
						if($("div.current.staging",element).find("div.center div.item ul.image-slider").size()>0){
							//console.log("destroy");
							imageSlider.stopAuto();
							$("div.current.staging",element).find("div.center div.item div.image-slider-wrap").hide();
							imageSlider.destroySlider();
							imageSlider = {};
						}
						textStaging.fadeOut();

						$("div.staging-wrap div.loading-cover").addClass("trans").show();

						/* make the tile in the center tile dark slowly */
						$("div.current.staging",element).find("div.center div.item").css({"background-color":"#000"});
						$("div.current.staging",element).find("div.center div.item > img").animate({"opacity":0.3},500,function(){
							$("div.staging-wrap div.loading-cover").removeClass("trans");
						});
						
						/* change the hash according to the tile's name */
						var hashString = "tile=" + $thisTile.attr("tilename"); 
						var hashStringPlus = "#" + hashString;
						location.hash = hashString;

						$("div.map-nav").find("div.link > a.active").addClass("visited").removeClass("active");
						$("div.map-nav div.link > a").each(function(){
							var $this = $(this);
							if($this.attr("href") == hashStringPlus){
								$this.addClass("active");
							}
						});

						var rowa = parseInt($thisTile.attr("tilerow_a")),
							rowb = parseInt($thisTile.attr("tilerow_b")),
							col = parseInt($thisTile.attr("tilecol")),
							tileIndex = parseInt($thisTile.attr("tileindex"));

						getTileData(option,rowa,rowb,col,tileIndex);

					});
				};

				var getTileData = function(option,rowa,rowb,col,tileIndex){
					var stagingNewest = stagingHidden.clone();
					var prevRow = (rowa-1 >= 0) ? rowa-1 : rowMax,
						nextRow = (rowb+1 <= rowMax) ? rowb+1 : 0,
						prevCol = (col-1 >= 0) ? col-1 : colMax,
						nextCol = (col+1 <= colMax) ? col+1 : 0;

					var tilesIndex = {};

					$.each(contentMap,function(i,tile){
						
						if(parseInt(tile.row) == rowa && parseInt(tile.col) == prevCol){ //try to get the left-top tile's index
							if(tile.tileIndex != "-1"){

								tilesIndex.leftTop = tile.tileIndex;
							}else{
								$.each(contentMap,function(i,tile){
									
									if(parseInt(tile.row) == rowMax && parseInt(tile.col) == prevCol ){
										tilesIndex.leftTop = tile.tileIndex;
									}
								});
							}
						}else if(parseInt(tile.row) == rowb && parseInt(tile.col) == prevCol){ //try to get the left-bottom tile's index
							
							if(tile.tileIndex != "-1"){
								
								tilesIndex.leftBottom = tile.tileIndex;
							}else{
								$.each(contentMap,function(i,tile){
									
									if(parseInt(tile.row) == 0 && parseInt(tile.col) == prevCol ){
										tilesIndex.leftBottom = tile.tileIndex;
									}
								});
							}
						}else if(parseInt(tile.row) == rowa && parseInt(tile.col) == nextCol){ //try to get the right-top tile's index
							
							if(tile.tileIndex != "-1"){
								
								tilesIndex.rightTop = tile.tileIndex;
							}else{
								$.each(contentMap,function(i,tile){
									
									if(parseInt(tile.row) == rowMax && parseInt(tile.col) == nextCol ){
										tilesIndex.rightTop = tile.tileIndex;
									}
								});
							}
						}else if(parseInt(tile.row) == rowb && parseInt(tile.col) == nextCol){ //try to get the right-bottom tile's index
							
							if(tile.tileIndex != "-1"){
								
								tilesIndex.rightBottom = tile.tileIndex;
							}else{
								$.each(contentMap,function(i,tile){
									
									if(parseInt(tile.row) == 0 && parseInt(tile.col) == nextCol ){
										tilesIndex.rightBottom = tile.tileIndex;
									}
								});
							}
						}else if(parseInt(tile.row) == prevRow && parseInt(tile.col) == col){ //try to get the Top tile's index
							
							if(tile.tileIndex != "-1"){
								
								tilesIndex.top = tile.tileIndex;
							}else{
								$.each(contentMap,function(i,tile){
									
									if(parseInt(tile.row) == rowMax-1 && parseInt(tile.col) == col ){
										tilesIndex.top = tile.tileIndex;
									}
								});
							}
						}else if(parseInt(tile.row) == nextRow && parseInt(tile.col) == col){ //try to get the bottom tile's index
							
							if(tile.tileIndex != "-1"){
								
								tilesIndex.bottom = tile.tileIndex;
							}else{
								$.each(contentMap,function(i,tile){
									
									if(parseInt(tile.row) == 1 && parseInt(tile.col) == col ){
										tilesIndex.bottom = tile.tileIndex;
									}
								});
							}
						}
					});

					var leftTopData = $.grep(contentMap,function(value,i){
						return(parseInt(value.tileIndex) == tilesIndex.leftTop);
					});
					
					var leftBottomData = $.grep(contentMap,function(value,i){
						return(parseInt(value.tileIndex) == tilesIndex.leftBottom);
					});

					var rightTopData = $.grep(contentMap,function(value,i){
						return(parseInt(value.tileIndex) == tilesIndex.rightTop);
					});
					
					var rightBottomData = $.grep(contentMap,function(value,i){
						return(parseInt(value.tileIndex) == tilesIndex.rightBottom);
					});

					var topData = $.grep(contentMap,function(value,i){
						return(parseInt(value.tileIndex) == tilesIndex.top);
					});
					
					var bottomData = $.grep(contentMap,function(value,i){
						return(parseInt(value.tileIndex) == tilesIndex.bottom);
					});

					var centerData = $.grep(contentMap,function(value,i){
						return(parseInt(value.tileIndex) == tileIndex);
					});

					$.when(
						/* get center tile's content */
						$.ajax({
							type:"GET",
							url:centerData[0].url,
							success:function(data){
								var newContent = $(data).addClass("center active").attr("tilerow_a",centerData[0].row).attr("tilerow_b",centerData[1].row).attr("tilecol",centerData[0].col).attr("tileindex",centerData[0].tileIndex).attr("tilename",centerData[0].tileName);
								stagingNewest.append(newContent);

/*								stagingNewest.find("div.center.active div.item > img").load(function(){
									$(this).parent("div.item").css({"background-color":"#fff"});
								});*/
							}
						}),

						/* get left-top tile's content */
						$.ajax({
							type:"GET",
							url:leftTopData[0].minorUrl,
							success:function(data){
								var newContent = $(data).addClass("left-top").attr("tilerow_a",leftTopData[0].row).attr("tilerow_b",leftTopData[1].row).attr("tilecol",leftTopData[0].col).attr("tileindex",leftTopData[0].tileIndex).attr("tilename",leftTopData[0].tileName);
								stagingNewest.append(newContent);
							}
						}),

						/* get left-bottom tile's content */
						$.ajax({
							type:"GET",
							url:leftBottomData[0].minorUrl,
							success:function(data){
								var newContent = $(data).addClass("left-bottom").attr("tilerow_a",leftBottomData[0].row).attr("tilerow_b",leftBottomData[1].row).attr("tilecol",leftBottomData[0].col).attr("tileindex",leftBottomData[0].tileIndex).attr("tilename",leftBottomData[0].tileName);
								stagingNewest.append(newContent);
							}
						}),

						/* get right-top tile's content */
						$.ajax({
							type:"GET",
							url:rightTopData[0].minorUrl,
							success:function(data){
								var newContent = $(data).addClass("right-top").attr("tilerow_a",rightTopData[0].row).attr("tilerow_b",rightTopData[1].row).attr("tilecol",rightTopData[0].col).attr("tileindex",rightTopData[0].tileIndex).attr("tilename",rightTopData[0].tileName);
								stagingNewest.append(newContent);
							}
						}),

						/* get right-bottom tile's content */
						$.ajax({
							type:"GET",
							url:rightBottomData[0].minorUrl,
							success:function(data){
								var newContent = $(data).addClass("right-bottom").attr("tilerow_a",rightBottomData[0].row).attr("tilerow_b",rightBottomData[1].row).attr("tilecol",rightBottomData[0].col).attr("tileindex",rightBottomData[0].tileIndex).attr("tilename",rightBottomData[0].tileName);
								stagingNewest.append(newContent);
							}
						}),

						/* get top tile's content */
						$.ajax({
							type:"GET",
							url:topData[0].minorUrl,
							success:function(data){
								var newContent = $(data).addClass("top").attr("tilerow_a",topData[0].row).attr("tilerow_b",topData[1].row).attr("tilecol",topData[0].col).attr("tileindex",topData[0].tileIndex).attr("tilename",topData[0].tileName);
								stagingNewest.append(newContent);
							}
						}),

						/* get bottom tile's content */
						$.ajax({
							type:"GET",
							url:bottomData[0].minorUrl,
							success:function(data){
								var newContent = $(data).addClass("bottom").attr("tilerow_a",bottomData[0].row).attr("tilerow_b",bottomData[1].row).attr("tilecol",bottomData[0].col).attr("tileindex",bottomData[0].tileIndex).attr("tilename",bottomData[0].tileName);
								stagingNewest.append(newContent);
							}
						})

					).then(function(){
						
						stagingNewest.find("div.item").each(function(){
							//$(this).append("<div class='border-hack'></div>");
							$(this).append("<div class='top-cover'></div><div class='bottom-cover'></div><div class='left-cover'></div><div class='right-cover'></div>");
						});
						
						if(is_iPad){
							var i = 0;
							
							stagingNewest.find("div.item > img").each(function(index,element){
								if(element.complete){
									i++;
									
									if(i == 7){//image already complete
										
										if(!option.initialLoading){
											setTimeout(function(){
												rotateCallback(option,stagingNewest);
											},500);
										}else{
											
											rotateCallback(option,stagingNewest);
										}
									}
								}else{
									element.onload = function(){
										i++;
										
										if(i == 7){//when image complete
											
											if(!option.initialLoading){
												setTimeout(function(){
													rotateCallback(option,stagingNewest);
												},500);
											}else{
												
												rotateCallback(option,stagingNewest);
											}
										}
									}
								}

							});
						}else{
							if(!option.initialLoading){
								setTimeout(function(){
									rotateCallback(option,stagingNewest);
								},500);
							}else{
								
								rotateCallback(option,stagingNewest);
								// var $centerTile = stagingNewest.find("div.center.item-wrap");
								// trackTile($centerTile);
							}
						}
						
					});
				}

				var rotateCallback = function(option,stagingNewest){
					$("div.staging-wrap div.loading-cover").hide();

					if(option.initialLoading){
						var $centerTile = stagingNewest.find("div.center.item-wrap");
						trackInitialTile($centerTile);
					}else{
						var $centerTile = stagingNewest.find("div.center.item-wrap");
						trackTile($centerTile);
					}
					
					if(isIE8){
						stagingNewest.css({
							"-webkit-transform":"rotate(5deg)",
							"-moz-transform":"rotate(5deg)",
							"-ms-transform":"rotate(5deg)",
							zIndex:9,
							"top":option.stagingTopPositionIE8,
							"left":option.stagingLeftPositionIE8
						});
					}else{
						stagingNewest.css({
							"-webkit-transform":"rotate(5deg)",
							"-moz-transform":"rotate(5deg)",
							"-ms-transform":"rotate(5deg)",
							zIndex:9,
							"top":option.stagingTopPosition,
							"left":option.stagingLeftPosition
						});
					}


					/* make the tile in the center tile dark slowly */

					//easingEffect = $(".easing-option").val();
					stagingNewest.appendTo(element).show();

					if(option.tileShiftingA){
						stagingNewest.find("div.left-bottom").css({"top":300-490}).animate({"top":300},tileMovingDuration,easingEffect);
						stagingNewest.find("div.left-top").css({"top":-190-490}).animate({"top":-190},tileMovingDuration,easingEffect);
						stagingNewest.find("div.right-bottom").css({"top":300+490}).animate({"top":300},tileMovingDuration,easingEffect);
						stagingNewest.find("div.right-top").css({"top":-190+490}).animate({"top":-190},tileMovingDuration,easingEffect);
						if(option.tileShiftingAleft){
							$("div.current.staging",element).find("div.center").animate({"top":55-490},tileMovingDuration,easingEffect);
							$("div.current.staging",element).find("div.top").animate({"top":-535-490},tileMovingDuration,easingEffect);

							var tempImg = $("div.current.staging",element).find("div.bottom > div.item > img").clone();
							var realImg = stagingNewest.find("div.right-top > div.item > img");
							realImg.css({"opacity":0});
							stagingNewest.find("div.right-top > div.item").append(tempImg);
							realImg.animate({"opacity":0.3},tileMovingDuration,easingEffect);
							tempImg.animate({"opacity":0},tileMovingDuration,easingEffect,function(){
								tempImg.remove();
							});
						}else if(option.tileShiftingAright){
							$("div.current.staging",element).find("div.center").animate({"top":55+490},tileMovingDuration,easingEffect);
							$("div.current.staging",element).find("div.bottom").animate({"top":545+490},tileMovingDuration,easingEffect);

							var tempImg = $("div.current.staging",element).find("div.top > div.item > img").clone();
							var realImg = stagingNewest.find("div.left-bottom > div.item > img");
							realImg.css({"opacity":0});
							stagingNewest.find("div.left-bottom > div.item").append(tempImg);
							realImg.animate({"opacity":0.3},tileMovingDuration,easingEffect);
							tempImg.animate({"opacity":0},tileMovingDuration,easingEffect,function(){
								tempImg.remove();
							});
						}
					}else if(option.tileShiftingB){
						stagingNewest.find("div.left-bottom").css({"top":300+490}).animate({"top":300},tileMovingDuration,easingEffect);
						stagingNewest.find("div.left-top").css({"top":-190+490}).animate({"top":-190},tileMovingDuration,easingEffect);
						stagingNewest.find("div.right-bottom").css({"top":300-490}).animate({"top":300},tileMovingDuration,easingEffect);
						stagingNewest.find("div.right-top").css({"top":-190-490}).animate({"top":-190},tileMovingDuration,easingEffect);
						if(option.tileShiftingBleft){
							$("div.current.staging",element).find("div.center").animate({"top":55+490},tileMovingDuration,easingEffect);
							$("div.current.staging",element).find("div.bottom").animate({"top":545+490},tileMovingDuration,easingEffect);
							
							var tempImg = $("div.current.staging",element).find("div.top > div.item > img").clone();
							var realImg = stagingNewest.find("div.right-bottom > div.item > img");
							realImg.css({"opacity":0});
							stagingNewest.find("div.right-bottom > div.item").append(tempImg);
							realImg.animate({"opacity":0.3},tileMovingDuration,easingEffect);
							tempImg.animate({"opacity":0},tileMovingDuration,easingEffect,function(){
								tempImg.remove();
							});
						}else if(option.tileShiftingBright){
							$("div.current.staging",element).find("div.center").animate({"top":55-490},tileMovingDuration,easingEffect);
							$("div.current.staging",element).find("div.top").animate({"top":-435-490},tileMovingDuration,easingEffect);

							var tempImg = $("div.current.staging",element).find("div.bottom > div.item > img").clone();
							var realImg = stagingNewest.find("div.left-top > div.item > img");
							realImg.css({"opacity":0});
							stagingNewest.find("div.left-top > div.item").append(tempImg);
							realImg.animate({"opacity":0.3},tileMovingDuration,easingEffect);
							tempImg.animate({"opacity":0},tileMovingDuration,easingEffect,function(){
								tempImg.remove();
							});
						}
					}else if(option.tileShiftingC){
						stagingNewest.find("div.left-bottom").css({"top":300-490}).animate({"top":300},tileMovingDuration,easingEffect);
						stagingNewest.find("div.left-top").css({"top":-190-490}).animate({"top":-190},tileMovingDuration,easingEffect);
						stagingNewest.find("div.right-bottom").css({"top":300-490}).animate({"top":300},tileMovingDuration,easingEffect);
						stagingNewest.find("div.right-top").css({"top":-190-490}).animate({"top":-190},tileMovingDuration,easingEffect);

						$("div.current.staging",element).find("div.left-bottom").animate({"top":300+490},tileMovingDuration,easingEffect);
						$("div.current.staging",element).find("div.left-top").animate({"top":-190+490},tileMovingDuration,easingEffect);
						$("div.current.staging",element).find("div.right-bottom").animate({"top":300+490},tileMovingDuration,easingEffect);
						$("div.current.staging",element).find("div.right-top").animate({"top":-190+490},tileMovingDuration,easingEffect);

					}else if(option.tileShiftingD){
						stagingNewest.find("div.left-bottom").css({"top":300+490}).animate({"top":300},tileMovingDuration,easingEffect);
						stagingNewest.find("div.left-top").css({"top":-190+490}).animate({"top":-190},tileMovingDuration,easingEffect);
						stagingNewest.find("div.right-bottom").css({"top":300+490}).animate({"top":300},tileMovingDuration,easingEffect);
						stagingNewest.find("div.right-top").css({"top":-190+490}).animate({"top":-190},tileMovingDuration,easingEffect);

						$("div.current.staging",element).find("div.left-bottom").animate({"top":300-490},tileMovingDuration,easingEffect);
						$("div.current.staging",element).find("div.left-top").animate({"top":-190-490},tileMovingDuration,easingEffect);
						$("div.current.staging",element).find("div.right-bottom").animate({"top":300-490},tileMovingDuration,easingEffect);
						$("div.current.staging",element).find("div.right-top").animate({"top":-190-490},tileMovingDuration,easingEffect);

					}

					/* make the tile in the center tile dark immediately */
					
					if(option.initialLoading){
						if(option.navClicked){
							$("div.global-nav",element).animate({"top":-600},500);
							$("div.current.staging",element).remove();
						}

						stagingNewest.addClass("current");

						if($("div.current.staging",element).find("div.center div.hidden-content").size()>0){
							var hiddenContent = $("div.current.staging",element).find("div.center div.hidden-content").html();

							textStaging.html(hiddenContent);
							stagingNewest.find("div.center.active div.item > img").css({"opacity":1});
							if(textStaging.find("a.auto-run").size()>0){
								//console.log("auto");
								var isManual = textStaging.find("a.auto-run").hasClass("manual") ? true : false;
								var required_url = textStaging.find("a.auto-run").attr("href");
								$("div.loading-cover",element).addClass("darker").show();

								autoImageCarousel(required_url,isManual);
							}else{
								textStaging.fadeIn();
							}
						}
					}else{

						if(isIE8 && option.middleColumn){
							$("div.current.staging",element).animate({
								"left":-option.stagingLeftPositionIE8,
								"top":-option.stagingTopPositionIE8
							},tileMovingDuration,easingEffect);
						}else{
							$("div.current.staging",element).animate({
								"left":-option.stagingLeftPosition,
								"top":-option.stagingTopPosition
							},tileMovingDuration,easingEffect);
						}

						stagingNewest.find("div.center.active div.item > img").animate({"opacity":1},1200);

						stagingNewest.animate({"left":"0px","top":"0px"},tileMovingDuration,easingEffect,function(){

							$("div.current.staging",element).remove();
							stagingNewest.addClass("current");

							if($("div.current.staging",element).find("div.center div.hidden-content").size()>0){
								var hiddenContent = $("div.current.staging",element).find("div.center div.hidden-content").html();

								textStaging.html(hiddenContent);
								if(textStaging.find("a.auto-run").size()>0){
									var isManual = textStaging.find("a.auto-run").hasClass("manual") ? true : false;
									var required_url = textStaging.find("a.auto-run").attr("href");
									$("div.loading-cover",element).addClass("darker").show();

									autoImageCarousel(required_url,isManual);
								}else{
									textStaging.fadeIn();
								}
								
							}

						});
					}
				}

				/* click and drag (view 360) */
				var pad = function(num, size) {
				    var s = num+"";
				    while (s.length < size) s = "0" + s;
				    return s;
				}

				var clickAndDrag = function(required_url){
					$.ajax({
						type:"GET",
						url:required_url,
						success:function(data){
							$("div.current.staging",element).find("div.center.active > div.item").append(data);
						},
						complete:function(){
							var centerTileItem = $("div.current.staging div.center.active > div.item");
							// centerTileItem.find("div.border-hack").remove();
							// centerTileItem.append("<div class='top-cover'></div><div class='bottom-cover'></div><div class='left-cover'></div><div class='right-cover'></div>");
							var sliderData = centerTileItem.find(".view360-data").embeddedData();
							//$("div.loading-cover",element).fadeOut().removeClass("darker");//
							var imagesArr = [];
							
							var imgCount = 0;

							for (var i = sliderData.start; i <= sliderData.end; i++) {
								imagesArr.push(sliderData.imagesLocation + sliderData.imageName + pad(i, sliderData.counterFormat.length) + "." + sliderData.extension);
								var imageObj = new Image();
								imageObj.src = sliderData.imagesLocation + sliderData.imageName + pad(i, sliderData.counterFormat.length) + "." + sliderData.extension;
								if(imageObj.complete){
									imgCount++;
									if(imgCount == (sliderData.end - sliderData.start +1)){
										
										$("div.loading-cover",element).fadeOut().removeClass("darker");
										var imgStaging = centerTileItem.find("div.view360-wrap img.view360-staging");
										var dragSlider = $("div.current.staging",element).find("div.center.active > div.item div.view360-wrap");
										dragSlider.find("div.view360-slider").slider({
											min:0,
											max:imagesArr.length - 1,
											create:function(){
												imgStaging.attr("src",imagesArr[0]);
												centerTileItem.find("div.view360-wrap").show();
												centerTileItem.children("img").hide();
												var sliderHandle = dragSlider.find("a.ui-slider-handle");
												sliderHandle.append("<span class='left-arrow'></span><span class='right-arrow'></span>");
												if(!!sliderData.showText){
													var showText = $("<img class='show-text'>");
													showText.attr("src",sliderData.showText).appendTo(dragSlider.find("div.view360-slider-wrap"));
													showText.load(function(){
														var imgWidth = $(this).width();
														var leftPosition = 26 - Math.floor(imgWidth/2);
														$(this).css({"left":leftPosition});
													});
												}

											},
											slide:function(event,ui){
												imgStaging.attr("src",imagesArr[ui.value]);
											},
											start:function(){
												dragSlider.find("div.view360-slider").addClass("move-active");
												dragSlider.find("img.show-text").hide();
												dragSlider.find("span.left-arrow, span.right-arrow").hide();
											},
											stop:function(){
												dragSlider.find("div.view360-slider").removeClass("move-active");
											}
										});
									}
								}else{
									$(imageObj).load(function(){
										imgCount++;
										
										if(imgCount == (sliderData.end - sliderData.start +1)){
											
											$("div.loading-cover",element).fadeOut().removeClass("darker");
											var imgStaging = centerTileItem.find("div.view360-wrap img.view360-staging");
											var dragSlider = $("div.current.staging",element).find("div.center.active > div.item div.view360-wrap");
											dragSlider.find("div.view360-slider").slider({
												min:0,
												max:imagesArr.length - 1,
												create:function(){
													imgStaging.attr("src",imagesArr[0]);
													centerTileItem.find("div.view360-wrap").show();
													centerTileItem.children("img").hide();
													var sliderHandle = dragSlider.find("a.ui-slider-handle");
													sliderHandle.append("<span class='left-arrow'></span><span class='right-arrow'></span>");
													if(!!sliderData.showText){
														var showText = $("<img class='show-text'>");
														showText.attr("src",sliderData.showText).appendTo(dragSlider.find("div.view360-slider-wrap"));
														showText.load(function(){
															var imgWidth = $(this).width();
															var leftPosition = 26 - Math.floor(imgWidth/2);
															$(this).css({"left":leftPosition});
														});
													}
												},
												slide:function(event,ui){
													imgStaging.attr("src",imagesArr[ui.value]);
												},
												start:function(){
													dragSlider.find("div.view360-slider").addClass("move-active");
													dragSlider.find("img.show-text").hide();
													dragSlider.find("span.left-arrow, span.right-arrow").hide();
												},
												stop:function(){
													dragSlider.find("div.view360-slider").removeClass("move-active");
												}

											});
										}
									});
								}

							};

							var imgStore = centerTileItem.find("div.image-store");
							$.each(imagesArr,function(index,value){
								$("<img>").attr("src",value).appendTo(imgStore);
							});

						}
					});
				}

				/* image carousel including auto and manual */
				var autoImageCarousel = function(required_url,isManual){
					//var overlayContent = $("div.lightbox-content",element);

					$.ajax({
						type:"GET",
						url:required_url,
						success:function(data){
							$("div.current.staging",element).find("div.center.active > div.item").append(data);
							//console.log(data);
						},
						complete:function(){
							if(isManual){
								/* special code for idad begin */
								var centerTileItem = $("div.current.staging div.center.active > div.item");
								// centerTileItem.find("div.border-hack").remove();
								// centerTileItem.append("<div class='top-cover'></div><div class='bottom-cover'></div><div class='left-cover'></div><div class='right-cover'></div>");
								/* special code for idad end */
								imageSlider = $("div.current.staging div.center.active > div.item ul.image-slider").bxSlider({
									mode:"fade",
									controls:true,
									onSliderLoad:function(){
										//$("div.current.staging",element).find("div.center.active > div.item > img").hide();
										$("div.current.staging",element).find("div.center.active div.image-slider-wrap").css({"visibility":"visible"});
										$("div.loading-cover",element).fadeOut(350,function(){
											textStaging.fadeIn();
											$("div.loading-cover",element).removeClass("darker");
										});
	/*									var currentSliderIndex = imageSlider.getCurrentSlide();
										var currentSlider = $("div.current.staging",element).find("div.center.active div.image-slider-wrap ul.image-slider > li > div.image").eq(currentSliderIndex);
										trackTile(currentSlider);*/
									},
									onSlideAfter:function(){
										var currentSliderIndex = imageSlider.getCurrentSlide();
										var currentSlider = $("div.current.staging",element).find("div.center.active div.image-slider-wrap ul.image-slider > li > div.image").eq(currentSliderIndex);
										trackTile(currentSlider);
									}
								});
							}else{
								imageSlider = $("div.current.staging div.center.active > div.item ul.image-slider").bxSlider({
									mode:"fade",
									controls:false,
									auto:true,
									autoStart:true,
									pause:4000,
									autoDelay:1500,
									pager:false,
									speed:1000,
									easing:"easeInOutBounce",
									onSliderLoad:function(){
										//$("div.current.staging",element).find("div.center.active > div.item > img").hide();
										$("div.current.staging",element).find("div.center.active div.image-slider-wrap").css({"visibility":"visible"});
										$("div.loading-cover",element).fadeOut(350,function(){
											textStaging.fadeIn();
											$("div.loading-cover",element).removeClass("darker");
										});
										setTimeout(function(){
											imageSlider.goToSlide(1);	
										},1500);
									}
								});
							}
						}
					});
				}
				
				/* initial loading option */
				var initialOption = {
					initialLoading:true,
					navClicked:false,
					hasHash:false
				};

				/* left-top area clicked */
				var leftTopOption = {
					leftTopLoading:true,
					selector:$("div.left-top"),
					stagingTopPosition:-313,
					stagingLeftPosition:-764,
					stagingTopPositionIE8:-245,
					stagingLeftPositionIE8:-788,
					tileShiftingB:true,
					tileShiftingBleft:true
				};

				tilesRotate(leftTopOption);

				/* left bottom area clicked */
				var leftBottomOption = {
					leftBottomLoading:true,
					selector:$("div.left-bottom"),
					stagingTopPosition:175,
					stagingLeftPosition:-806,
					stagingTopPositionIE8:245,
					stagingLeftPositionIE8:-788,
					tileShiftingA:true,
					tileShiftingAleft:true
				};

				tilesRotate(leftBottomOption);

				/* right bottom area clicked */
				var rightBottomOption = {
					rightBottomLoading:true,
					selector:$("div.right-bottom"),
					stagingTopPosition:313,
					stagingLeftPosition:764,
					stagingTopPositionIE8:245,
					stagingLeftPositionIE8:788,
					tileShiftingB:true,
					tileShiftingBright:true
				};

				tilesRotate(rightBottomOption);

				/* right top area clicked */
				var rightTopOption = {
					rightTopLoading:true,
					selector:$("div.right-top"),
					stagingTopPosition:-175,
					stagingLeftPosition:806,
					stagingTopPositionIE8:-245,
					stagingLeftPositionIE8:788,
					tileShiftingA:true,
					tileShiftingAright:true
				};

				tilesRotate(rightTopOption);

				/* top area clicked */
				var topOption = {
					topLoading:true,
					selector:$("div.top"),
					stagingTopPosition:-488,
					stagingLeftPosition:43,
					stagingTopPositionIE8:-490,
					stagingLeftPositionIE8:0,
					middleColumn:true,
					tileShiftingC:true
				};

				tilesRotate(topOption);
				
				/* bottom area clicked */
				var bottomOption = {
					bottomLoading:true,
					selector:$("div.bottom"),
					stagingTopPosition:488,
					stagingLeftPosition:-43,
					stagingTopPositionIE8:490,
					stagingLeftPositionIE8:0,
					middleColumn:true,
					tileShiftingD:true
				};

				tilesRotate(bottomOption);

				/* hover state setting */
				var hoverDistance = 15,
					tileHoverDuration = 270;
				var leftTopTile = {
						topValue:-190
					},
					leftBottomTile = {
						topValue:300
					},
					rightTopTile = {
						topValue:-190
					},
					rightBottomTile = {
						topValue:300
					},
					topTile = {
						topValue:-435
					},
					centerTile = {
						topValue:55
					},
					bottomTile = {
						topValue:545
					};

				/* left-top area hover */
				if(!is_iPad){
					$("div.left-top").live("mouseover",function(){
						var $this = $(this);
						$this.stop().animate({
							"top":leftTopTile.topValue + hoverDistance
						},tileHoverDuration);

						if(isIE8){
							$this.parent("div.staging").find("div.left-bottom.item-wrap").stop().animate({
								"top":leftBottomTile.topValue + hoverDistance
							},tileHoverDuration);
						}else{
							$this.siblings("div.left-bottom").stop().animate({
								"top":leftBottomTile.topValue + hoverDistance
							},tileHoverDuration);
						}
					});

					$("div.left-top").live("mouseleave",function(){
						var $this = $(this);
						$this.stop().animate({
							"top":leftTopTile.topValue
						},tileHoverDuration);

						if(isIE8){
							$this.parent("div.staging").find("div.left-bottom.item-wrap").stop().animate({
								"top":leftBottomTile.topValue
							},tileHoverDuration);
						}else{
							$this.siblings("div.left-bottom").stop().animate({
								"top":leftBottomTile.topValue
							},tileHoverDuration);
						}

					});

					/* left-bottom area hover */
					$("div.left-bottom").live("mouseover",function(){
						var $this = $(this);
						$this.stop().animate({
							"top":leftBottomTile.topValue - hoverDistance
						},tileHoverDuration);

						if(isIE8){
// console.log($this.parent("div.staging").find("div.left-top.item-wrap").size());
							$this.parent("div.staging").find("div.left-top.item-wrap").stop().animate({
								"top":leftTopTile.topValue - hoverDistance
							},tileHoverDuration);
						}else{
							$this.siblings("div.left-top").stop().animate({
								"top":leftTopTile.topValue - hoverDistance
							},tileHoverDuration);
						}
					});

					$("div.left-bottom").live("mouseleave",function(){
						var $this = $(this);
						$this.stop().animate({
							"top":leftBottomTile.topValue
						},tileHoverDuration);

						if(isIE8){
							$this.parent("div.staging").find("div.left-top.item-wrap").stop().animate({
								"top":leftTopTile.topValue
							},tileHoverDuration);
						}else{
							$this.siblings("div.left-top").stop().animate({
								"top":leftTopTile.topValue
							},tileHoverDuration);
						}
					});

					/* right-bottom area hover */
					$("div.right-bottom").live("mouseover",function(){
						var $this = $(this);
						$this.stop().animate({
							"top":rightBottomTile.topValue - hoverDistance
						},tileHoverDuration);

						if(isIE8){
							$this.parent("div.staging").find("div.right-top.item-wrap").stop().animate({
								"top":rightTopTile.topValue - hoverDistance
							},tileHoverDuration);
						}else{
							$this.siblings("div.right-top").stop().animate({
								"top":rightTopTile.topValue - hoverDistance
							},tileHoverDuration);
						}

					});

					$("div.right-bottom").live("mouseleave",function(){
						var $this = $(this);
						$this.stop().animate({
							"top":rightBottomTile.topValue
						},tileHoverDuration);

						if(isIE8){
							$this.parent("div.staging").find("div.right-top.item-wrap").stop().animate({
								"top":rightTopTile.topValue
							},tileHoverDuration);
						}else{
							$this.siblings("div.right-top").stop().animate({
								"top":rightTopTile.topValue
							},tileHoverDuration);
						}
					});

					/* right-top area hover */
					$("div.right-top").live("mouseover",function(){
						var $this = $(this);
						$this.stop().animate({
							"top":rightTopTile.topValue + hoverDistance
						},tileHoverDuration);

						if(isIE8){
							$this.parent("div.staging").find("div.right-bottom.item-wrap").stop().animate({
								"top":rightBottomTile.topValue + hoverDistance
							},tileHoverDuration);
						}else{
							$this.siblings("div.right-bottom").stop().animate({
								"top":rightBottomTile.topValue + hoverDistance
							},tileHoverDuration);
						}

					});

					$("div.right-top").live("mouseleave",function(){
						var $this = $(this);
						$this.stop().animate({
							"top":rightTopTile.topValue
						},tileHoverDuration);

						if(isIE8){
							$this.parent("div.staging").find("div.right-bottom.item-wrap").stop().animate({
								"top":rightBottomTile.topValue
							},tileHoverDuration);
						}else{
							$this.siblings("div.right-bottom").stop().animate({
								"top":rightBottomTile.topValue
							},tileHoverDuration);
						}

					});

					/* top area hover */
					$("div.top").live("mouseover",function(){
						var $this = $(this);
						$this.stop().animate({
							"top":topTile.topValue + hoverDistance
						},tileHoverDuration);

						if(isIE8){
							$this.parent("div.staging").find("div.center.item-wrap").stop().animate({
								"top":centerTile.topValue + hoverDistance
							},tileHoverDuration);
							
							$this.parent("div.staging").find("div.bottom.item-wrap").stop().animate({
								"top":bottomTile.topValue + hoverDistance
							},tileHoverDuration);
						}else{
							$this.siblings("div.center").stop().animate({
								"top":centerTile.topValue + hoverDistance
							},tileHoverDuration);
							
							$this.siblings("div.bottom").stop().animate({
								"top":bottomTile.topValue + hoverDistance
							},tileHoverDuration);
						}

					});

					$("div.top").live("mouseleave",function(){
						var $this = $(this);
						$this.stop().animate({
							"top":topTile.topValue
						},tileHoverDuration);

						if(isIE8){
							$this.parent("div.staging").find("div.center.item-wrap").stop().animate({
								"top":centerTile.topValue
							},tileHoverDuration);

							$this.parent("div.staging").find("div.bottom.item-wrap").stop().animate({
								"top":bottomTile.topValue
							},tileHoverDuration);
						}else{
							$this.siblings("div.center").stop().animate({
								"top":centerTile.topValue
							},tileHoverDuration);

							$this.siblings("div.bottom").stop().animate({
								"top":bottomTile.topValue
							},tileHoverDuration);
						}
					});

					/* bottom area hover */
					$("div.bottom").live("mouseover",function(){
						var $this = $(this);
						$this.stop().animate({
							"top":bottomTile.topValue - hoverDistance
						},tileHoverDuration);

						if(isIE8){
							$this.parent("div.staging").find("div.center.item-wrap").stop().animate({
								"top":centerTile.topValue - hoverDistance
							},tileHoverDuration);

							$this.parent("div.staging").find("div.top.item-wrap").stop().animate({
								"top":topTile.topValue - hoverDistance
							},tileHoverDuration);
						}else{
							$this.siblings("div.center").stop().animate({
								"top":centerTile.topValue - hoverDistance
							},tileHoverDuration);

							$this.siblings("div.top").stop().animate({
								"top":topTile.topValue - hoverDistance
							},tileHoverDuration);
						}
					});

					$("div.bottom").live("mouseleave",function(){
						var $this = $(this);
						$this.stop().animate({
							"top":bottomTile.topValue
						},tileHoverDuration);

						if(isIE8){
							$this.parent("div.staging").find("div.center.item-wrap").stop().animate({
								"top":centerTile.topValue
							},tileHoverDuration);

							$this.parent("div.staging").find("div.top.item-wrap").stop().animate({
								"top":topTile.topValue
							},tileHoverDuration);
						}else{
							$this.siblings("div.center").stop().animate({
								"top":centerTile.topValue
							},tileHoverDuration);

							$this.siblings("div.top").stop().animate({
								"top":topTile.topValue
							},tileHoverDuration);
						}
					});
				}

				/* tile's image get dark */
				if(!is_iPad){
/*					if(is_webkit){
						$("div.staging-wrap div.item div.border-hack").live("mouseover",function(){
							var $this = $(this);
							if(!$this.parents("div.item-wrap").hasClass("center")){
								$this.siblings("img").css({"opacity":0.3}).stop().animate({"opacity":1},500);
							}
						});
						$("div.staging-wrap div.item div.border-hack").live("mouseleave",function(){
							var $this = $(this);
							if(!$this.parents("div.item-wrap").hasClass("center")){
								$this.siblings("img").stop().animate({"opacity":0.3},500);
							}
						});
					}else{*/
						$("div.staging-wrap div.item > img").live("mouseover",function(){
							var $this = $(this);
							if(!$this.parents("div.item-wrap").hasClass("center")){
								$this.css({"opacity":0.3}).stop().animate({"opacity":1},500,function(){
									$this.parent("div.item").css({"background-color":"#ffffff"});
								});
							}
						});
						$("div.staging-wrap div.item > img").live("mouseleave",function(){
							var $this = $(this);
							if(!$this.parents("div.item-wrap").hasClass("center")){
								$this.parent("div.item").css({"background-color":"#000000"});
								$this.stop().animate({"opacity":0.3},500);
							}
						});
					// }
				}

				/* show prompt */
				var showPrompt = function(){
					
					$("div.staging-wrap div.prompt-cover").show();
					
					$.cookie("b515guide",1,{expires:10});
					setTimeout(function(){
						
						$("div.staging-wrap div.welcome-text").animate({top:0},500,function(){
							setTimeout(function(){
								$("div.staging-wrap div.prompt-cover").hide();
								$("div.staging-wrap div.welcome-text").animate({top:-150},500);
								
							},13000);
						});
						
					},1500);
					

					$("div.staging-wrap div.prompt-cover, div.staging-wrap div.welcome-text span.close-btn").click(function(){
						$("div.staging-wrap div.prompt-cover").hide();
						$("div.staging-wrap div.welcome-text").animate({top:-150},500);
						
					});
					
				}
				//when page loading check cookie then decide whether show the prompt;
				if(!$.cookie("b515guide")){
					
					showPrompt();

				}
				/* when page loading check hash and get the relative tile */
				var pageHash = location.hash;
				var tileName = pageHash.split("=")[1];
				var tileData ={};
				
				if(typeof(tileName) != "undefined"){
					


					var rowa = 2,
						rowb = 3,
						col = 1,
						tileIndex = defaultTileIndex;

					var hashStringPlus = "#tile=" + tileName;
					
					$("div.map-nav div.link > a").each(function(){
						var $this = $(this);
						if($this.attr("href") == hashStringPlus){
							$this.addClass("active");
						}
					});
					
					tileData = $.grep(contentMap,function(value,i){
						return(value.tileName == tileName);
					});

					//console.log(tileData);
					if(tileData.length != 0){
						rowa = parseInt(tileData[0].row);
						rowb = parseInt(tileData[1].row);
						col = parseInt(tileData[1].col);
						tileIndex = parseInt(tileData[0].tileIndex);
					}

					var hasHash = {hasHash:true};
					var initialWithHashOption =	$.extend({},initialOption,hasHash);

					getTileData(initialWithHashOption,rowa,rowb,col,tileIndex);
					//alert("has hash");
				}else{
					$.cookie("b515guide",1,{expires:10});
					//console.log("cookie");

					var rowa = 2,
						rowb = 3,
						col = 1,
						tileIndex = defaultTileIndex;
					var defaultHash = "#tile=";

					tileData = $.grep(contentMap,function(value,i){
						return(value.tileIndex == defaultTileIndex);
					});

					if(tileData.length != 0){
						rowa = parseInt(tileData[0].row);
						rowb = parseInt(tileData[1].row);
						col = parseInt(tileData[1].col);
						defaultHash = defaultHash + tileData[0].tileName;
					}

					$("div.map-nav div.link a").each(function(){
						var $this = $(this);
						if($this.attr("href") == defaultHash){
							$this.addClass("active");
						}
					});
					getTileData(initialOption,rowa,rowb,col,tileIndex);
				}

				/* global nav control */
				$("DIV.staging-wrap SPAN.expand-btn").click(function(){
					$("DIV.staging-wrap DIV.global-nav").animate({"top":0},1000,"easeOutQuart");
					return false;
				});

				$("DIV.staging-wrap SPAN.collapse-btn").click(function(){
					$("DIV.staging-wrap DIV.global-nav").animate({"top":-600},1000,"easeOutQuart");
					return false;
				});

				/* map nav style setting */

				var columnCount = $("div.map-nav > div.row:first-child").find("div.link").size();
				var rowCount = $("div.map-nav > div.row").size();
				var columnWidth = Math.floor(840/columnCount);
				var rowHeight = Math.floor(420/rowCount);
				var bottomSep = $("div.map-nav-wrap div.last img");
				var topSep = $("div.map-nav-wrap div.first img");
				var leftSep = $("div.map-nav-wrap div.middle div.left img");
				var rightSep = $("div.map-nav-wrap div.middle div.right img");
				$("div.map-nav > div.row > div.link").width(columnWidth-1);
				$("div.map-nav > div.row > div.link").height(rowHeight-1);
				$("div.map-nav > div.row > div.link a").width(columnWidth-1-16);
				$("div.map-nav > div.row > div.link a").height(rowHeight-1-16);

				for(i=1;i<=columnCount;i++){
					var sepPosition = columnWidth * i + 59;
					bottomSep.clone().css({"left":sepPosition}).appendTo("div.map-nav-wrap div.last");
					topSep.clone().css({"left":sepPosition}).appendTo("div.map-nav-wrap div.first");
				}

				for(i=1;i<=rowCount;i++){
					var sepPosition = rowHeight * i;
					leftSep.clone().css({"top":sepPosition}).appendTo("div.map-nav-wrap div.middle div.left");
					rightSep.clone().css({"top":sepPosition}).appendTo("div.map-nav-wrap div.middle div.right");
				}

				/* content map switch */
				$("div.map-nav div.link > a").click(function(){
					var $this = $(this);

					if(!$this.hasClass("active")){
						$("div.map-nav").find("div.link > a.active").addClass("visited").removeClass("active");
						$this.addClass("active");

						if($("div.current.staging",element).find("div.center div.item ul.image-slider").size()>0){
							//console.log("destroy2");
							imageSlider.stopAuto();
							$("div.current.staging",element).find("div.center div.item div.image-slider-wrap").hide();
							imageSlider.destroySlider();
							imageSlider = {};
						}

						textStaging.hide();
						$("div.staging-wrap div.loading-cover").show();

						var pageHash = $this.attr("href");
						var tileName = pageHash.split("=")[1];
						var tileData ={};

						tileData = $.grep(contentMap,function(value,i){
							return(value.tileName == tileName);
						});

						if(tileData.length != 0){
							rowa = parseInt(tileData[0].row);
							rowb = parseInt(tileData[1].row);
							col = parseInt(tileData[1].col);
							tileIndex = parseInt(tileData[0].tileIndex);
						}

						var fromNavOption = {navClicked:true};
						initialOption =	$.extend({},initialOption,fromNavOption);

						getTileData(initialOption,rowa,rowb,col,tileIndex);

					}else{
						return false;
					}

				});

				/* load video overlay */
				$("div.staging-wrap .overlay-link").live("click",function(){
					
					var $this = $(this);
					var required_url = $(this).attr("href");

					if($this.hasClass("in-tile")){
						textStaging.hide();
						$("div.loading-cover",element).addClass("darker").show();
						clickAndDrag(required_url);
					}else{

					
						element.append("<div class='lightbox-overlay'></div>");
						element.append("<div class='lightbox-content'><span class='close-btn'></span></div>");
						$("div.lightbox-overlay",element).css({opacity:0.8}).fadeIn();


						var overlayContent = $("div.lightbox-content",element);

						$.ajax({
							type:"GET",
							url:required_url,
							success:function(data){
								overlayContent.append(data);
							},
							complete:function(a,b,c){

								if(overlayContent.find(".multiple-video-wrap").size()>0){
									/* load click and switch (video player in overlay) */
									
									//$("div.lightbox-loading").hide();
									overlayContent.width(720).height(405).css({"top":-700}).show().animate({"top":60},1000,"easeOutQuart",function(){

										var firstVideoSetting = overlayContent.find("ul.clip-list li:first-child .video-config").embeddedData();
										//console.log(defaultVideoSetting);
										var defaultVideoOps = {
											width:720,
											height:405,
											controlbar: "none"
										};

										var initVideoSetting = $.extend({},defaultVideoOps,firstVideoSetting);
										initVideoSetting.play = true;
										//console.log(initVideoSetting);
										ND.video.init(initVideoSetting);
										//jwplayer("video-staging").setup(defaultOps);
										
										overlayContent.find("ul.clip-list > li > a").click(function(){
											var $this = $(this);
											overlayContent.find("ul.clip-list > li").removeClass("active");
											$this.parent("li").addClass("active");
											jwplayer("video-inner").remove();
											var videoSetting = $this.next(".video-config").embeddedData();
											// var videoSetting = $.parseJSON($(this).next(".video-config").html());
											var videoOps = $.extend({},defaultVideoOps,videoSetting);
											videoOps.play = true;
											//console.log(videoOps);
											ND.video.init(videoOps);
											// jwplayer("video-staging").play();
											return false;
										});
									});

								}else if(overlayContent.find(".single-video-wrap").size()>0){
									//$("div.lightbox-loading").hide();
									overlayContent.width(720).height(405).css({"top":-500}).show().animate({"top":90},1000,"easeOutQuart",function(){
										var videoConfig = overlayContent.find("#video-config").embeddedData();
										var defaultVideoOps = {
											width:720,
											height:405
										};
										videoConfig = $.extend({},defaultVideoOps,videoConfig);
										//console.log(videoConfig);
										ND.video.init(videoConfig);
									});
								}


							}
						});
					}

					return false;
				});

				
				
				//var popFlag = false;
				var popHide = function(){
					if($("div.lightbox-content").size() < 1){ return; }
					
					var overlayContent = $("div.lightbox-content");
					// var box_height = overlayContent.outerHeight();

					overlayContent.animate({"top":-600},400,"easeOutQuart",function(){
						$("div.lightbox-loading").remove();
						$("div.lightbox-overlay").fadeOut(250,function(){
							$(this).remove();
						});
						$("div.lightbox-content").fadeOut(250,function(){
							$(this).remove();
							
						});
					});
				}

/*				$("div.lightbox-content").live("mouseover",function(){
					popFlag = true;
					
				});
				$("div.lightbox-content").live("mouseleave",function(){
					popFlag = false;
				});*/

				$("div.lightbox-content span.close-btn",element).live("click",function(){
					popHide();
				})

				

/*				$("body").live("click",function(){
					if(!popFlag){
						popHide();
					}
				})*/

				/* Return this so it can be chained / assigned
				 * eg. var myModule = ND.myModuleName().init();
				 */
				return this;
			
			},
			
			/* Write Public Methods
			 * These will exist as methods on the new module object
			 * 
			 */
			setHasA: function( obj ) {
				hasA = obj;
			},
			
			getHasA: function( ) {
				return hasA;
			}
		
		
		};	
	};
	
	/* Return ND after it's been augmented */ 
	return ND;	

}(window.ND || {}, jQuery));
/* End File */


/*globals jQuery, ND, window */
(function(ND, $){
	$(function($){

		//EXAMPLE: Initialise a module needed for the page.
		var tilesTransformModule = ND.tileTransform().init();		
		//var tilesTestModule = ND.tileTesting().init();	

	});
}(window.ND || {}, jQuery));


(function($) {
	
	var ND = window.ND = window.ND || {};
	
	var personaliser = ND.personaliser = {

		userId: undefined,
		
		getUserId: function() {
			
			if (typeof this.userId !== 'undefined') {
				//do nothing return cached user id (this.userId) 
			} else {
				//check if user id cookie exist
				var store = Object.create(ND.cacheStore);
				store.key = "dfy.uuid";
				if (store.is()) {
					this.userId = store.get();
				} else {
					//user id cookie is not there - create
					this.userId = uuid.v1();
					store.expires = 365;
					store.set(this.userId);
				} 
			}
			
			return this.userId;
		}

	};	

	
})(jQuery);


(function($){
	
	//menu
	var Survey = function() {
		var survey = this;
		
		survey.intercept = function() {
			$(document).ready(function() {
				
				var config = $("#page-config").embeddedData();//get config
				
				if (typeof config !== 'undefined' && typeof config.survey !== 'undefined' && config.survey === 'true') {

					//check if have Omniture page name set
					if (typeof s !== 'undefined' && typeof s.pageName !== 'undefined') {
						
						//get current user id
						var sessionId = ND.personaliser.getUserId();
						
						$wait(function(){
							runInterceptRules(sessionId, s.pageName, window.location.hostname)
						});
					} else {
						//console.log("NO omniture NO survey.");
					}
				}
			});
		};
	};
	
	
	$(function() {
		var survey = new Survey();
		survey.intercept();
	});
	
})(jQuery);


/**
 * @author Sohrab Zabetian
 * @project formbuilder. To be used on Smob and Web
 * 
 * @description manages close button on pages/forms. Requires ND.cacheStore to manage cookie, Object.create and jQuery
 * 
 * 
 */
(function($) {
	
	BB = {
	
		config : {
			bkBtnCookieName : 'dfy.pg.bkbtn',
			bkBtnId : '#page-back-btn',
			bkBtnClass: '.formbuilder-close'
		},	
		
		store: null,
		$bkBtn: null,
		
		prepareBBCookie : function() {
			var store = BB.store = Object.create(ND.cacheStore),
				cookie = ''; //an array of uri for current domain
			
			store.key = BB.config.bkBtnCookieName;
			
			if (store.is()) {
				cookie = store.get();
			} else {
				store.expires = 365;
			} 
			return cookie;
		},
		
		init: function() {
			
			
			var $formConfig = $('#form-config');
    		if ($formConfig.length > 0) {
	    		
				var formConfig = $.extend(BB.config,JSON.parse($formConfig.html()));
				
				if (typeof formConfig.isform !== 'undefined' && (formConfig.isform === 'false' || formConfig.isform === false)) {
					BB.addPageToCookie(BB.prepareBBCookie());
				}
				
				BB.$bkBtn = $(BB.config.bkBtnClass);

				if (BB.$bkBtn.length > 0) {
					BB.addListeners();
				}
    		}
		},
		
		addPageToCookie: function(cookie) {
			// var pageURI = encodeURI('/' + window.location.href.replace(window.location.protocol + '//', '').replace(window.location.host + '/', ''));
			var pageURI = encodeURI(window.location.href);
			if (cookie !== pageURI) {
				BB.store.set(pageURI);
			}
		},
		
		handleBkBtnEvent: function(e) {
			e.stopPropagation();
			
			//user clicked form back button
			//check cookie, if we have a cookie and history has been recorded
			//go back to that page, otherwise use data-homepage to go back home
			
			var cookie = BB.prepareBBCookie(),
				lastURI = null;
			
			//remove the page we are just on now (Except if this page is a form page since it wasn't in the cookie), as we are navigating away from it
			if (cookie != null && cookie.length > 0) {
				lastURI = cookie;
				BB.store.set(null);
			} else if (typeof BB.config.homepage !== 'undefined' && BB.config.homepage !== '' && !$("body").hasClass("apaform") ) {
				lastURI = BB.config.homepage; 
			}else if($("body").hasClass("apaform") && BB.config.dashboardpage !==''){
				lastURI=BB.config.dashboardpage;
				
			} else {
				console.error("homepage data attribute is missing, can't go back");
			}
			
			if (lastURI != null) {
				
				var decodedLink = decodeURI(lastURI);
				BB.$bkBtn.each(function() {
					$(this).attr('href', decodedLink);
				});
			}
		},
		
		addListeners : function() {

			if($("body").hasClass("confirm-alert")){

				$(document).on('click', "#confirmPopup .formbuilder-close", BB.handleBkBtnEvent);//for APA owner confirm popup before close the page

			}else{

				$(document).on('click', BB.config.bkBtnClass, BB.handleBkBtnEvent);
			}
			
		},
		
		destroy: function() {
			if (BB.$bkBtn == null) {
				BB.$bkBtn = $(BB.config.bkBtnClass);
			}
			if (BB.$bkBtn.length > 0) {
				$(document).off('click', BB.config.bkBtnClass);
			}
		}
	};
	
	$(document).ready(BB.init);
	$(document).on('pagechange', function() {
		BB.destroy();
		BB.init();
	});
	
})(jQuery);


ND.fleetApA = ( function($, undefined) {
	
	fleetApA = {
    
        init: function(){
        	
        },
        initItems:function(){
        	if($("#benefits-data").size()>0){
	        	var data = $("#benefits-data").embeddedData(),
	        		benefits=$("#benefits");
	        	$("#benefits-template").tmpl(data).appendTo(benefits);
	        	this.rowsameHeight();
	        	this.initservice();
	        	this.initexpand();
        	}
        },
        rowsameHeight:function(){
        	var rowItem=$("#group #item");
        	$.each(rowItem,function(i){
        		var itemDiv=$(">div",rowItem.eq(i));
        		$.each(itemDiv,function(i){
        			var rheight=itemDiv.eq(0).height()+6;
        			if(i>0){
        			itemDiv.eq(i).height(rheight);
        			}
        		})
        	})
        },
        initservice:function(){
        	var serviceDiv=$("#service");
        	var rheight=$("#disclaimer",serviceDiv).height();
        	$("#phoneinfo",serviceDiv).css({"line-height":rheight+"px"});
	        $("#phoneinfo",serviceDiv).height(rheight);
        	
        },initexpand:function(){
        	var slef=this,
        		elmoreitem=$("#benefits #item");
        	
        	$.each(elmoreitem,function(i){
        		
        		$(".fleetexpand",elmoreitem.eq(i)).click(function(){
        			$this=$(this);
            		$("p.moreinfo",$this.parent()).toggle(1,function(){
            		slef.rowsameHeight();
            		$("span.more",$this).toggle();
            		$("span.less",$this).toggle();
            		});
            	})
        	})
        	
        },
        /*
         * @param, rowtag, identify each row in the page
         * @param, elmtag, columns under each row needs to be resized
         * @param, imgtag, img in each col if exist
         * @param, coltag, columns without imgtag
         * @param, htag
         * @param, emswidth, element width
         */
        resizeColunm:function(rowtag,elmtag,imgtag,coltag,htag,emswidth){
        	var row = $(rowtag);
        	if(row.length>0){//row exist
        		$(row).each(function(index){
        			var	imgmaxHeight=0,//initialize
		        		pmaxHeight=0,
		        		hmaxHeight=0,
		        		imgitem,
		        		pitem,
		        		hitem,
		        		totalwid=0;
        			var col = $(this).find(elmtag);
        			if(col.size()>0){
			        	$.each(col,function(i){
			        		imgitem=$(imgtag,col.eq(i));
			        		pitem=$(coltag,col.eq(i));
			        		hitem=$(htag,col.eq(i));
			        		
			        		if(imgitem.height()>imgmaxHeight){
			        			imgmaxHeight=imgitem.height();
			        		}
			        		if(pitem.height()>pmaxHeight){
			        			pmaxHeight=pitem.height();
			        		}
			        		if(hitem.height()>hmaxHeight){
			        			hmaxHeight=hitem.height();
			        		}
			        		totalwid+=col.eq(i).outerWidth(true);
			        	})
			        	
			        	$(imgtag,col).height(imgmaxHeight);
			        	$(coltag,col).height(pmaxHeight);
			        	$(htag,col).height(hmaxHeight);
			        	
			        	//to resize each width of col
			        	if(rowtag=="#columns"&&elmtag=="#column"){//only apply to columns tag
			        		var _noCol = 0;
							var _totalWidth = $(rowtag).width();
							
							_ColArr=$(rowtag).find(elmtag);
							_noCol=_ColArr.length;
							
							if(_noCol>0){
								_ColArr.each(function(index){
									var oldColWidth = $(this).width();
									var newColWidth = _totalWidth/_noCol-($(this).outerWidth()-oldColWidth)-12;// minus padding+border and 16px of marginLeft
									
									$(this).css({
										"width":newColWidth
									})
								})
							}
			        	}else{
			        		col.eq(0).css({"margin-left":(emswidth-totalwid)/2+"px"});
			        	}
		        	}
        		});
        	}
        },
        //dynamically change col size of each table row base on contents
        resizeBenefitsTable:function(){
        	var _benefitsGroup = $("#benefits");
        	var _groupWidth = _benefitsGroup.width();
        	var _row = _benefitsGroup.find("#group").children("#item")
        	var _header = _benefitsGroup.find("#head");
        	var _service = _benefitsGroup.find("#service");
        	var _availableHeaderWidth = _groupWidth-_header.width();
        	var _availableServiceWidth = _groupWidth-_service.width();
        	var _increaseHeaderWidth = _availableHeaderWidth/_header.children("div").length;//current items in header
        	var _increaseRowWidth = _availableHeaderWidth/_row.eq(0).children("div").length;//current items in row
        	
        	var _firstHeaderCol = _header.children("div:eq(0)");
        	var _firstHeaderColOuterWidth = _firstHeaderCol.outerWidth()-_firstHeaderCol.width();//cal padding border etc
        	var _firstRowCol = _row.eq(0).children("div:eq(0)");
        	var _firstRowOuterWidth = _firstRowCol.outerWidth()-_firstRowCol.width();//cal padding border etc
        	
        	if(_benefitsGroup){
        		if(_header.length>0){//if exist ,set width of header
        			_header.children("div").each(function(index){
        				if(_row.eq(0).children("div").length<=2){
    						if(index==0){
    							$(this).css({
			        				width:420-_firstHeaderColOuterWidth
			        			})
    						}else{
    							$(this).css({
			        				width:_groupWidth-420-($(this).outerWidth()-$(this).width())
			        			})
    						}
    					}else{
    						$(this).css({
		        				width:$(this).width()+_increaseHeaderWidth
		        			})
    					}
	        		});
        		}
        		if(_row.length>0){//if exist ,set width of row
        			_row.each(function(){//each row
        				$(this).children("div").each(function(index){//each col
        					if(_row.eq(0).children("div").length<=2){
        						if(index==0){
        							$(this).css({
				        				width:420-_firstRowOuterWidth
				        			})
        						}else{
        							$(this).css({
				        				width:_groupWidth-420
				        			})
        						}
        					}else{
        						$(this).css({
			        				width:$(this).width()+_increaseRowWidth
			        			})
        					}
        				})
        			});
        		}
        		if(_service.length>0){//if exist , set width of service
        			var _firstColWidth = _row.eq(0).children("div:eq(0)").outerWidth();//include padding
        			var _restAvailableColWidth = _groupWidth-_firstColWidth;
        			var _noPhoneItem = _service.children("#phoneinfo").length;
        			var _increaseServiceWidth = _restAvailableColWidth/_noPhoneItem;//current phone items in service
        			_service.children("#disclaimer").each(function(){
	        			$(this).css({
	        				width:_firstColWidth
	        			})
	        		});
	        		if(_noPhoneItem==1){//if only 1 phone item, remove border right which set from css
	        			_service.children("#phoneinfo").eq(0).css({
	        				"border-right":0
	        			})
	        		}
        			_service.children("#phoneinfo").each(function(){
	        			$(this).css({
	        				width:_increaseServiceWidth-($(this).outerWidth()-$(this).width())//for those item has border ,padding and margin
	        			})
	        		});
        		}
        	}
        },
        resizeServiceWid:function(){
        	var sitem=$("#servicedetail #colservice");
        	if(sitem.size()>1){
        		sitem.css({"width":"50%"})
        	}else{
        		sitem.css({"width":"100%"})
        	}
        },
        expandvechilelist:function(){
        	var $carinfo = $("#availablelist #caritem #carinfo"),
        		$carinfoHeader = $carinfo.siblings("a");
        	if($carinfo.length>0){
        		$carinfo.hide();
        		$carinfoHeader.hover(function(){
        			var $header = $(this);
        			if($header.siblings("#carinfo").is(":hidden")){//if collapsed, add/remove active on hover
						$header.addClass("active");
					}else{
						$header.removeClass("active");
					}
        		},function(){
        			var $header = $(this);
        			if($header.siblings("#carinfo").is(":hidden")){//if collapsed, add/remove active on hover
						$header.removeClass("active");
					}else{
						$header.addClass("active");
					}
        		});
    		}
        	$("#availablelist #caritem>a").click(function(e){
        		var curelmt=$(this);
        		var curCarinfo=curelmt.parent("#caritem").children("#carinfo:eq(0)");
        		if(curCarinfo.length!=0){//if has details
        			e.preventDefault();	
			    	e.stopPropagation();
        		}
        		if(curCarinfo.is(":hidden")){
        			$("#availablelist #caritem>a").removeClass("active");//reset all cols
        			$("#availablelist #carinfo").hide();
        			curelmt.addClass("active");
        			$("#carinfo",curelmt.parent()).show();
        		}else{
        			$("#availablelist #caritem>a").removeClass("active");//reset all cols
        			$("#availablelist #carinfo").hide();
        		}
        	})
        }
		
		
    };
    
	$(function(){
		fleetApA.resizeColunm("#availableitem #carinfo","#carinfoitem","#img","#detail","h5",870);
		fleetApA.initItems();
		fleetApA.resizeBenefitsTable();
		fleetApA.resizeServiceWid();
		fleetApA.expandvechilelist();
	});
}(jQuery)); 


/**
 * rotating banner
 * use bxslider to implement slideShow functionality
 * implementation will be added by adding "rotating-banner" class in body tag
 * default behavior is automatically jump to the next page every 6 seconds
 * @author Ray Huang
 */

//globals jQuery, ND, window
var ND = ( function(ND, $) {
	/**
	 * @param el, String, element that you wish bind image carousel to
	 * @param opts, Object, an options object to initialize the carousel
	 */
	ND.rotatingBanner = function(el,opts) {
		var element = el||".rotating-banner .slideritemwrap";
		if($(element+">div").length < 2 && $(element+">li").length < 2) { return; }//no rotate if there is only one slide
		var options = opts||{
			slideWidth : 1200,
			slideMargin : 0,
			auto : true,
			pause : 6000,
			autoHover : true
		}
		//fixed bxslider bug : auto slide will stop after click/swipe to the next slide manually
		//can use call() method to inherit onSlideAfter from opts in order to prevent onSlideAfter method been overrided
		if(!options.onSlideAfter&&options.auto){
			options.onSlideAfter = function() {
				slider.startAuto();
			}
		}
		
		var slider = $(element).bxSlider(options);
		
		/*
		* if ipad and bannerWidth greater than bodyWidth(entire page),
		* override the body width and footer width.
		* this fixed incorrected page display under ipad when banner width is greater than page width
		*/
		var ua = navigator.userAgent.toLowerCase(),
			bannerWidth = $(element).closest(".bx-wrapper").width(),
			bodyWidth = $("body").width();
		if (ua.match(/iPad/i)=="ipad"&&bannerWidth>bodyWidth){
			$("body,#footer-wrapper").css("min-width",bannerWidth);
		}
	}
	
	return ND;
}(window.ND || {}, jQuery));

(function($){
	/**
	 * load image carousel here, you can have as many way as you like
	 * Alternatively, you can load your image carousel in other files for specific purpose (eg, you want to bind the image carousel after some events triggered)
	 */
	$(function(){
		//keep "if" statement for this carousel load only , to remain previous projects load image carousel safely
		var bannerWidth = $(".rotating-banner .slideritemwrap").width();
		if($(".rotating-banner").length>0&&bannerWidth==1200){
			ND.rotatingBanner();
		}
		
		/**
		 * custom an image carousel: for example
		 * 
		 *  ND.rotatingBanner(".careers .slideritemwrap",{
		 *	    controls: false,
		 *	    pause : 6000,
		 *	    autoHover : true
		 *  });
		 */
		
	});
}(jQuery));


/***************************************
add the redirection disable flag to all the urls under the page
****************************************/
$( document ).ready(function(){
	var current = window.location.href;
	var str = "uar=false"
	
	if(current.indexOf("?" + str) > 0 || current.indexOf("&" + str) > 0){
		$("a").each(function (){
			if($( this ).hasClass('external-disclaimer') == false){
				var url = $( this ).attr("href")
				if(url.indexOf("http") == 0){
					if(url.indexOf("?") > 0){
						url += "&" + str;
					}else{
						url += "?" + str;
					}
					$(this).attr("href",url);
				}
			}
		});
	}
});


/**
 * all js related careers page goes here
 * require, rotating-banner.js
 * @author Ray Huang
 */

(function($){
	$(function(){
		if($("body").hasClass("careers")){
			/**
			 * custom image carousal
			 */
			ND.rotatingBanner(".careers .slideritemwrap",{
				mode: "fade",
				auto: true,
				controls: false,
				pause : 6000,
				autoHover : true
			});
			
			ND.rotatingBanner("#body .bxslider",{
				infiniteLoop: false,
				pager: false,
				slideWidth: 153,
			    minSlides: 2,
			    maxSlides: 3,
			    slideMargin: 1,
				hideControlOnEnd : true,
				onSlideBefore : function(slideElement,oldIdx,newIdx) {
					var clonedElement = slideElement.closest(".img-carousal").find(".thumbnail.clone");
					if(clonedElement.length>0){
						clonedElement.remove();//remove cloned element before each slide start
					}
				}
			});
			
			/**
			 * sticky the secondary navgation
			 * scroll to the specific content after click
			 */
			var nav = $("#secondary-nav");
			
			if(nav.length>0){//if navigation exist
				var topHeight = nav.offset().top;
				if ($(window).scrollTop() > topHeight){//for page load
					nav.addClass("sticky");
				}
				
				$(window).scroll(function(){//trigger when scroll event occurs
					if ($(window).scrollTop() > topHeight){
						nav.addClass("sticky");
					}
					else {
						nav.removeClass("sticky");
					}
				});
				
				var navItem = $("#secondary-nav li > a");
				navItem.on("click",function(e){
					e.preventDefault();
					var scope = $(this);
					var anchor = scope.attr("href");
					if(anchor=="#top"){//if anchor sets "#top", scroll to the top
						$("html, body").stop().animate({
							scrollTop: 0
						}, 500); 
					}else{
						if(!$(anchor).offset()){ return; }//if anchor is not exist, do nothing
						var position = $(anchor).offset().top-nav.outerHeight()-30;
						$("html, body").stop().animate({
							scrollTop: position
						}, 500); 
					}
				})
			}
			
			/**
			 * add "current" class for clicked element as activated element
			 * copy original element
			 * position copied element above the orirginal element as activation status
			 * 
			 * the reason for not doing this in css is because the parent has "overflow:hidden" and "position:relative"
			 * this will banned any child overflow element flyout to their parent box
			 */
			var stopExcution = true;// a flag to stop excute functionalities behand it
			$(".careers .img-carousal .bx-wrapper li").click(function(e){
				e.preventDefault();
				var scope = $(this);
				var idx = scope.index();
				var wrapper = scope.closest("#work-ford");
				
				//add "current" class to activated element
				wrapper.find("ul.bxslider > li").removeClass("current");
				scope.addClass("current");
				
				//copy original element, ready for cover above the original element
				var element = scope.children(".thumbnail");
				wrapper.find(".clone").remove();
				var cloneElement = element.clone().addClass("clone").insertAfter($(".careers .img-carousal .bx-controls"));
				cloneElement.click(function(e){e.preventDefault()});//prevent click tag "a" jump back to the top of browser
				var coordinates = {
					top: element.offset().top-12,
					left: element.offset().left-12
				}
				cloneElement.offset(coordinates);
				
				//to prevent first time click first element issue which will casue the first element disapper and fade in again.
				if(scope.index()==0&&stopExcution){ return; }
				//add "current" class to related element as activation status
				wrapper.find("ul.detail > li").fadeOut("slow").removeClass("current");
				wrapper.find("ul.detail > li:eq("+idx+")").fadeIn("slow").addClass("current");//show the related image
				stopExcution = false;
			})
		}
	});
}(jQuery));


/*
 * Author: Doris
 *
 <a class="loan-calculator-overlay" href="/servlet/Satellite/doris/loan-calc">Loan Calculator</a>
 $('.loan-calculator-overlay').on('click',function(){
    $(this).loanCalculatorOverlay({...});
 });
 *
 */

(function($) {
	
	$.fn.loanCalculatorOverlay = function(options){
	    var defaults = {
	        price: 0,
	        symbol: '',
	        url: '',
	        priceformatter: null,
	        customClass: 'loan-calc',
	        location: '',
			complete: null //callback function
	    };

	    
		var options = $.extend(defaults, options);
		
		var loanOverlay = function(element){
		    var loanOverlay = this,
				url,
                total_price = 0,
				interest_rate = 0,
                loan_duration = 0,
                down_payment=0,
                results = 0;

			loanOverlay.init = function () {
			    total_price = Math.round(options.price);
			    results = total_price;
			    url = options.url.length > 0 ? options.url : element.attr("href");
			    $.publish('overlay.launch', {
			        url: url,
			        positionType: 'window',
			        customClass: options.customClass,
			        name: "Loan Calculator",
			        success: function () {
			            loanOverlay.calculate();
			            loanOverlay.updateContent();
			            loanOverlay.registerEvent();
			        },
			        error: function (e) {
			            console.log(e);
			        }
			    });
			};
			
			loanOverlay.calculate = function (isInvalid) {
			    if (!isInvalid && total_price > 0 && interest_rate > 0 && loan_duration > 0 && down_payment > 0 && down_payment < total_price) {
			        var total_rate_payable = (total_price - down_payment) * (interest_rate/100) * loan_duration;
			        results = (total_rate_payable + (total_price - down_payment)) / (loan_duration * 12);
			    }
			    else {
			        results = 0;
			    }
			};

			loanOverlay.updateContent = function () {
			    if (options.priceformatter) {
			        $('.loan-calc-overlay .title span.price').html(options.priceformatter.format(total_price));
			        $('.loan-calc-overlay .result span.price').html(options.priceformatter.format(results));
			    }
			    else {
			        $('.loan-calc-overlay .title span.price').html(total_price);
			        $('.loan-calc-overlay .result span.price').html(results);
			    }
			    $('.loan-calc-overlay span.symbol').html(options.symbol);
			    if (options.location.length) {
			        $('.loan-calc-overlay span.location').html(options.location);
			    }
			    else {
			        $('.loan-calc-overlay p.loc').hide();
			    }
			};

			loanOverlay.registerEvent = function () {
			    $('#duration').on('change propertychange input', function () {
			        loan_duration = parseFloat($(this).val());
			        doCalculate($(this));
			    });
			    $('#rate').on('change propertychange input', function () {
			        interest_rate = parseFloat($(this).val());
			        doCalculate($(this));
			    });
			    $('#payment').on('change propertychange input', function () {
			        down_payment = parseFloat($(this).val());
			        doCalculate($(this));
			    });

			    function doCalculate($ele) {
			        if (isNaN($ele.val())) {
			            $ele.parent().addClass('invalid');
			            loanOverlay.calculate(true);
			        }
			        else {
			            $ele.parent().removeClass('invalid');
			            loanOverlay.calculate(false);
			        }
			        loanOverlay.updateContent();
			    }

			    $('#overlay .close-button a').on('click', function (e) {
			        $('#overlay').removeClass(options.customClass);
			    })

			    // callback 
			    if ($.isFunction(options.complete)) {
			        options.complete.call(this);
			    }
			};
						
		};
		
		var appendOverlay = function(element){
		    var overlay = new loanOverlay(element);
		    overlay.init();
		};
		
		appendOverlay($(this));
		

	};
	

}(jQuery));


/* formbuilder-dealer-postcode.js */
/**
 * @author Sohrab Zabetian
 * @project formbuilder
 * @description
 * If #dealer-by-postcode-postcode exists, attach to on blur.
		The on blur handler should populate the  #dealer-by-postcode-dealer select based on the REST call (see Dealers (location)). The postcode is passed as a location param.
		The REST service result handling should be:
			Case										Displayed																Value
		No results returned 			?no dealer for postcode? message displayed (from DFYTranslation)			Empty string  to prevent submission (when field is required)
		Single dealer returned			Single option preselected displayed.
		Multiple results returned		?please select a dealer? message displayed (from DFYTranslation)		Empty string  for ?please select a dealer? to prevent submission (when field is required).
																											dealerInfo returned in the REST response for each dealer

 */
(function($){
	var widget = {
		//default translations
		translations: {
		  selectDealer: 'Please select a dealer',
		  selectCity: 'Please select a city',
		  selectState: 'Please select a state',
		  selectStateOrCity: 'Please select a city or state',
		  pleaseWait: 'Please wait for dealers to load',
		  noDealersFound: 'No dealers found'
		},

		restServices : {

		},

		$dealerSelect : null,
		$stateSelect : null,
		$citySelect : null,
        $formSalesStateSelect : null,
        $formSalesCitySelect : null,
        $formSalesDealerSelect : null,

		stateCityMap : {},

		types : {
			address : 'ad',
			city : 'ct',
			region : 'rgn',
			regionCity : 'rgnCt'
		},

		constructDealerUrl : function(type, data) {
			switch (type) {
				case widget.types.city:
					return widget.restServices['dealer.byCityUrl'].replace('{city}', encodeURIComponent(data.city));

				case widget.types.region:
					return widget.restServices['dealer.byRegionUrl'].replace('{region}', encodeURIComponent(data.region));
                    //return '../../../../latest-offers-2014-client/carve/RAD2013/rest/dealer-region.js';

				case widget.types.regionCity:
					return widget.restServices['dealer.byRegionCityUrl'].replace('{region}', encodeURIComponent(data.region)).replace('{city}', encodeURIComponent(data.city));
                    //return '../../../../latest-offers-2014-client/carve/RAD2013/rest/dealer-city.js';

				case widget.types.address:
					return widget.restServices['dealer.byAddressUrl'].replace('{location}', encodeURIComponent(data.address));
			}
			return null;
		},

		createOption: function(text, value) {
			return '<option value="' + (value || '') + '">' + text + '</option>';
		},

		populateStateDropDown : function(stateSelect, citySelect, hasFirstOption) {
			var cityStateData = $('#cityDropdownData');
			if (cityStateData.length > 0) {
				cityStateData = JSON.parse(cityStateData.html());
				var i,
					j,
					state,
					cityLength = 0,
					statesLength = 0;

				for(i = 0 ; i < cityStateData.list.length; i++){
	                states = cityStateData.list[i].states;
	                statesLength = states.length;
	                cityLength = states.length;
	                for(j=0; j < cityLength; j++){
	                    if (states[j][1] != null) {
                            widget.stateCityMap[states[j][0]] = states[j][1];
                        }
	                }
	            }

                var firstOptionMsg = hasFirstOption?widget.translations.selectState: undefined;
				widget.populateDropDown(statesLength, stateSelect, firstOptionMsg, function(options) {

					for (state in widget.stateCityMap) {
						var stateText = widget.stateCityMap[state].name,
							city = widget.stateCityMap[state].cities[0][0];
						//only "ford Korean" and state name not equal city name
						if($("body").hasClass("koreanstate")&&stateText!=city){
							stateText = stateText + " - " + city;
						}
                        var stateCode = (window.ND.FORMBUILDER && window.ND.FORMBUILDER.LOCATIONMAP[state])?window.ND.FORMBUILDER.LOCATIONMAP[state].code : undefined;
                        if(stateCode){
                            options.push(widget.createOption(stateText, stateCode));
                        }else{
                            options.push(widget.createOption(stateText, (!!widget.stateCityMap[state].code)? (widget.stateCityMap[state].code.length>0?widget.stateCityMap[state].code:widget.stateCityMap[state].name):widget.stateCityMap[state].name));
                        }
					}
				});
				//we want the city field to hint to the user that state need to be selected first.
				widget.populateDropDown(2, citySelect, firstOptionMsg);

			}
		},

		populateDropDown: function(dataLength, $select, firstOptionMsg,  dataIteratorCallback) {

			var i, options = [], isRequired = $select.is("[required]");

            var firstOptionValue = firstOptionMsg? firstOptionMsg : $select.find(':first').html();
	        options.push(widget.createOption(firstOptionValue));

			if (typeof dataIteratorCallback !== 'undefined') {
				dataIteratorCallback(options);
			}

			$select.html(options.join(''));

			if (dataLength === 1 && isRequired) {
				$select.val($select.val());
			}

			if (ND.FormBuilder && ND.FormBuilder.styleSelectOptions) {
				ND.FormBuilder.styleSelectOptions($select);
			}
		},

		handleAjaxResponse : function(jqXHR, isDropDown) {
			if (typeof jqXHR !== 'undefined'  && jqXHR != null && jqXHR.length > 0) {

				widget.clearAjaxError();

				if(isDropDown){
                    widget.populateDropDown(jqXHR.length, widget.$dealerSelect, widget.translations.selectDealer, function(options) {

                        for (i = 0; i < jqXHR.length; i++) {
                        	if($("body").hasClass("dealerNameOnly")){
								 var specialities = jqXHR[i].specialities;
								// var withService = "Service";
								// specialities = jQuery.grep(specialities, function (dealrLst) {
								// 	return dealrLst != withService;
								// });
								
								
								 // $.each(specialities, function (value) {
								 //    console.log(value);
								 //    if (specialities.indexOf("Service") !== -1) {
									//     if (value.length > 1){
									//  		options.push(widget.createOption(jqXHR[i].dealershipName, jqXHR[i].dealerInfo));	
									//  	 }
								 // 	}
								 // });
								
								 if (specialities.indexOf("Sales") !== -1) {
								 //	if (Object.keys(specialities).length > 1){ 
										options.push(widget.createOption(jqXHR[i].dealershipName, jqXHR[i].dealerInfo));	
								 //}
								 }								 
                        	}else{
                            	options.push(widget.createOption(jqXHR[i].dealershipName + '(' + jqXHR[i].addressLine1 + ')', jqXHR[i].dealerInfo));
                        	}
                        }
                    });
                }else{
                    var locationStr = '';
                    if(widget.$formSalesStateSelect.get(0).selectedIndex !== 0){
                        locationStr = widget.$formSalesStateSelect.find(':selected').text();
                    }
                    if(widget.$formSalesCitySelect.get(0).selectedIndex !== 0){
                        var cityStr = widget.$formSalesCitySelect.find(':selected').text() + ' - ';
                        locationStr = cityStr + locationStr;
                    }

                    widget.$formSalesDealerSelect.find('.dealer-container').empty();

                    for(var idx = 0; idx < jqXHR.length; idx++){
                        var html = '<div style="margin-bottom: 1em;"><input name="distrib-radio" type="radio" value="'+jqXHR[idx].dealerInfo+'">' +
                            '<div class="dealer-item">' +
                            '<p style="font-weight: bold; margin-bottom:0;">'+jqXHR[idx].dealershipName+'</p>' +
                            '<p style="margin-bottom: 0;">' +
                            '<span class="dealer-place-font">'+locationStr+'</span>' +
                            '</p>' +
                            '</div>' +
                            '</div>';
                        widget.$formSalesDealerSelect.find('.dealer-container').append(html);
                    }
                    widget.attachFormSalesDealerListener();
                }

			} else {
				widget.handleAjaxError();

			}
		},

		clearAjaxError : function() {
			widget.$dealerSelect.removeClass('user-error');

			var $errorSibling = widget.$dealerSelect.next('span.error-box');
			if ($errorSibling.length > 0) {
				$errorSibling.remove();
			}
		},

		handleAjaxError : function() {

			widget.$dealerSelect.removeClass('user-success').addClass('user-error');
			//display error message
			if (widget.$dealerSelect.next('span.error-box').length === 0) {
				$('<span class="error-box"><span>' + widget.translations.noDealersFound + '</span></span>').insertAfter(widget.$dealerSelect);
			}
			widget.populateDropDown(2, widget.$dealerSelect, widget.translations.noDealersFound);

		},

		attachPostcodeListener : function($dealerByPostcode) {
			$dealerByPostcode.on('blur', function(e) {
				var val = $dealerByPostcode.val();
				if (val != null && $.trim(val).length > 0) {
					widget.fetchData(widget.types.address,{address : $.trim(val) }, true, widget.handleAjaxResponse);
				}
			});
			//first time page loads check to see if the value has already been set or not
			//if set, load values in dealer postcode
			$dealerByPostcode.trigger('blur');
		},

		attachStateCityListeners : function(stateSelect, citySelect, isDropDown) {

			stateSelect.on('change', function(e) {
                widget.$formSalesDealerSelect.parent().css('display', 'none');
                var dealerHiddenInput = widget.$formSalesDealerSelect.next();
                dealerHiddenInput.val('');

                var stateCode = stateSelect.val(),
				state = stateSelect.find('[value="'+stateCode+'"]').text(),
					i,
					cities = widget.stateCityMap[state]?widget.stateCityMap[state].cities || []:[],
					citiesLength = cities.length;
                var firstOptionMsg = isDropDown? widget.translations.selectCity: undefined;
				widget.populateDropDown(citiesLength, citySelect,firstOptionMsg, function(options) {

					for (i = 0;  i < citiesLength; i++) {
                        var cityName = cities[i][1].name;
                        var cityCode = (window.ND.FORMBUILDER && window.ND.FORMBUILDER.LOCATIONMAP[state])?window.ND.FORMBUILDER.LOCATIONMAP[state].cities[cityName] : undefined;
                        if(cityCode){
                            options.push(widget.createOption(cities[i][1].name, cityCode));
                        }else{
                            options.push(widget.createOption(cities[i][1].name, cityName));
                        }
					}
				});
                if(stateSelect.get(0).selectedIndex === 0){
                    citySelect.html(citySelect.find(':first'));
                }

				var city = citySelect.val();
				//debugger
				widget.retrieveDealersForCityState(state, city, isDropDown);

			});

            citySelect.on('change', function(e) {
                var dealerHiddenInput = widget.$formSalesDealerSelect.next();
                dealerHiddenInput.val('');
                if(citySelect.get(0).selectedIndex !== 0){
                    widget.$formSalesDealerSelect.parent().css('display', 'block');
                }else{
                    widget.$formSalesDealerSelect.parent().css('display', 'none');
                }
                var stateCode = stateSelect.val(),
                    cityCode = citySelect.val(),
                    state = stateSelect.find('[value="'+stateCode+'"]').text(),
                    city = citySelect.find('[value="'+cityCode+'"]').text();

				widget.retrieveDealersForCityState(state, city, isDropDown);

			});

		},

		attachDealerListener : function() {
			var $dealerInfoHiddenInput = $('#dealer-by-postcode-dealerinfo');
			if ($dealerInfoHiddenInput.length > 0) {
				widget.$dealerSelect.on('change', function(e) {
					$dealerInfoHiddenInput.val(widget.$dealerSelect.val());
				});
			}
		},

        attachFormSalesDealerListener : function(){
            var $formSalesDealerHiddenInput = widget.$formSalesDealerSelect.next();
            var $formSalesRadioGrp = widget.$formSalesDealerSelect.find('.dealer-container input[type="radio"]');
            $formSalesRadioGrp.click(function(){
                $formSalesDealerHiddenInput.val($(this).val());
            });
        },
		//ie8 doesn't have a trim function, use jQuery's instead
		retrieveDealersForCityState : function(state, city, isDropDown) {
			var hasState = state != null && $.trim(state).length > 0,
				hasCity = city != null && $.trim(city).length > 0;

			if (hasState && hasCity) {
				widget.fetchData(widget.types.regionCity,{region : $.trim(state), city : $.trim(city) }, isDropDown, widget.handleAjaxResponse);
			} else if (hasState) {
				widget.fetchData(widget.types.region, {region : $.trim(state)}, isDropDown, widget.handleAjaxResponse);
			} else if (hasCity) {
				widget.fetchData(widget.types.city,{city : $.trim(city) }, isDropDown, widget.handleAjaxResponse);
			} else if(isDropDown) {
				widget.populateDropDown(2, widget.$dealerSelect, widget.translations.selectStateOrCity);
			}
		},

		fetchData : function(type, data, isDropDown, callback) {
			var url = widget.constructDealerUrl(type, data);
			if (url != null) {
				widget.addLoader();
				$.ajax({
					url: url,
					dataType: 'json',
					success: function(jqXHR, textStatus, textResponse) {
						widget.removeLoader();
						callback(jqXHR, isDropDown);
					},
					error : function(jqXHR, textStatus, textResponse) {
						widget.removeLoader();
						widget.handleAjaxError();
					}
				});
			}
		},

		addLoader: function() {
			widget.$dealerSelect.attr('readonly', true)
								.html(widget.createOption(widget.translations.pleaseWait));
		},

		removeLoader: function() {
			widget.$dealerSelect.removeAttr('readonly').empty();
		},

//        addFormSalesValidation: function(){
//            var formSalesValidationElem = $('#formsales-validation-json');
//            if(formSalesValidationElem.length > 0){
//                var formSalesValidationConf = JSON.parse(formSalesValidationElem.html());
//                for(fieldName in formSalesValidationConf){
//                    var fieldConf = formSalesValidationConf[fieldName];
//                    var regexStr = fieldConf['CustomRegex'];
//                    var msg = fieldConf['CustomMsg'];
//                    var fieldElem = $('div.group input[name="'+fieldName+'"]');
//                    fieldElem.data('pattern',regexStr);
//                    fieldElem.data('errormsg', msg);
//                    fieldElem.on('blur', function(){
//                        var fieldValue = $(this).val();
//                        var fieldPattern = $(this).data('pattern');
//                        var fieldErrorMsg = $(this).data('pattern');
//                        var patternObj = new RegExp(fieldPattern);
//                        if(!patternObj.test(fieldValue)){
//                            alert(fieldErrorMsg);
//                        }
//                    });
//                }
//            }
//        },

		init : function() {
		    var $dealerByPostcode = $('#dealer-by-postcode-postcode'),
				$dealerTranslations = $('#dealer-translations'),
				$restServicesConfig = $('#rest-services'),
				$commonConfig = $('#common-config'),
                $dealerLabel = $('#dealer-label-json'),
                dealerLabelValue = {};

				widget.$dealerSelect = $('#dealer-by-postcode-dealer');
				widget.$stateSelect = $('#dealer-by-statecity-state');
				widget.$citySelect = $('#dealer-by-statecity-city');

                widget.$formSalesStateSelect = $('#FormSales_State');
                widget.$formSalesCitySelect = $('#FormSales_City');
			    widget.$formSalesDealerSelect = $('#FormSales_Dealer');

			    if ($dealerLabel.length) {
			        dealerLabelValue = JSON.parse($dealerLabel.html());

			        widget.$formSalesDealerSelect.append('<div class="ax-paragraph"><p style="font-weight: bold;margin-left:.5em;width:auto;">' + dealerLabelValue.dealerTitle + '</p></div><div class="dealer-container"></div>');

			    }
			    else {
			        widget.$formSalesDealerSelect.append('<div class="ax-paragraph"><p style="font-weight: bold;margin-left:.5em;width:auto;">Select a distributor</p></div><div class="dealer-container"></div>');
			    }

            //widget.addFormSalesValidation()
            widget.$formSalesDealerSelect.parent().css('display', 'none');

			if ($restServicesConfig.length > 0) {
				widget.restServices = JSON.parse($restServicesConfig.html());
				var commonConfig = JSON.parse($commonConfig.html());
				for (key in widget.restServices) {
					widget.restServices[key] = widget.restServices[key].replace('{site}',commonConfig.site);
				}

				if ($dealerTranslations.length > 0) {
					$.extend(widget.translations, JSON.parse($dealerTranslations.html()));
				}
				if (widget.$dealerSelect.length > 0) {

					widget.attachDealerListener();

					if ($dealerByPostcode.length > 0) {
						widget.attachPostcodeListener($dealerByPostcode);

					}

					if (widget.$stateSelect.length > 0 && widget.$citySelect.length > 0) {
						widget.populateStateDropDown(widget.$stateSelect, widget.$citySelect, true);
						widget.attachStateCityListeners(widget.$stateSelect, widget.$citySelect, true);

						widget.$stateSelect.trigger('change');
					}
                    if (widget.$formSalesStateSelect.length > 0 && widget.$formSalesCitySelect.length > 0) {
                        widget.populateStateDropDown(widget.$formSalesStateSelect, widget.$formSalesCitySelect, false);
                        widget.attachStateCityListeners(widget.$formSalesStateSelect, widget.$formSalesCitySelect, false);
                    }
				}else{
					//add only city and state logic
					if (widget.$stateSelect.length > 0 && widget.$citySelect.length > 0) {
                        widget.populateStateDropDown(widget.$stateSelect, widget.$citySelect, true);
                        widget.attachStateCityListeners(widget.$stateSelect, widget.$citySelect, true);

						widget.$stateSelect.trigger('change');
					}
                    if (widget.$formSalesStateSelect.length > 0 && widget.$formSalesCitySelect.length > 0) {
                        widget.populateStateDropDown(widget.$formSalesStateSelect, widget.$formSalesCitySelect, false);
                        widget.attachStateCityListeners(widget.$formSalesStateSelect, widget.$formSalesCitySelect, false);

                        widget.$formSalesStateSelect.trigger('change');
                    }

				}

		   }
		}
	};


	$(document).ready(function(){
		widget.init();
	});
})(jQuery);

;


/**
 * Created by bjie on 11/17/2014.
 */
(function($){
    var formSalesController = {
        init: function(){
            this.type = $('#FormSales_Selected_Type');
            this.typeName = this.type.attr('name');
            this.companyName = $('#FormSales_Company_Name');
            this.type.parent().css('display','none');
            this.companyName.parent().css('display','none');
            this.selectionElem = $('#FormSales_Selection');
            this.modelElem = $('#FormSales_Model');
            this.stateElem = $('#FormSales_State');
            var compNameElem = $('#FormSales_Company_Name');
            this.compName = compNameElem.attr('name');
            this.observeElem = $('#FormSales_Observation');
			this.telElem = $('#FormSales_Tel');
			this.singleInputWithCheck = $('.fbform input[type=text][data-check]');
			this._switchable = false;
			this.ctrlCode = [108,112,113,114,115,116,117,118,119,120,121,122,123,8,9,12,13,16,17,18,20,27,32,33,34,35,36,37,38,39,40,45,46,144,175,174,179,173,172,180,170,171];
			this._formatConfig = {
				"CNPJ": {
					"pattern": new RegExp(/^[0-9]{2}\.[0-9]{3}\.[0-9]{3}\/[0-9]{4}\-[0-9]{2}$/),
					"formatMap": {
						"2": ".",
						"6": ".",
						"10": "/",
						"15": "-",
						"last": "18"
					}
				},
				"CPF": {
					"pattern": new RegExp(/^[0-9]{3}\.[0-9]{3}\.[0-9]{3}\-[0-9]{2}$/),
					"formatMap": {
						"3": ".",
						"7": ".",
						"11": "-",
						"last": "14"
					}
				}
			};
            this.addEventListener();
        },
		
		dynmCheck: function($elem, fieldType, msg){
			var self = this;
			this._fieldType = fieldType;
			var maxlength = parseInt(this._formatConfig[this._fieldType].formatMap.last, 10);
			$elem.on('blur', function(){
				var inputValue = $(this).val();
				var isMatch = self._formatConfig[self._fieldType].pattern.test(inputValue);
				if(!isMatch){
					if (msg) {
				        msg.length && alert(msg);
				    } else {
				        alert(a_messages[self.typeName]['r']);
				    }
				}
			});
			$elem.on('keydown', function(event){
				var keyCode = event.keyCode;
				if(keyCode === 8){
					var inputValue = $(this).val();
					var inputLen = inputValue.length;
					if(self._switchable && self._fieldType === 'CNPJ' && inputLen === 15){
						inputValue = self.switchPattern(inputValue, 'CPF');
						inputLen = inputValue.length;
						$(this).val(inputValue);
					}
				}
							
				if($.inArray(keyCode, self.ctrlCode) === -1){
					var inputValue = $(this).val();
					var inputLen = inputValue.length;
					
					if(self._switchable && self._fieldType === 'CPF' && inputLen === 14){
						inputValue = self.switchPattern(inputValue, 'CNPJ');
						inputLen = inputValue.length;
						maxlength = parseInt(self._formatConfig[self._fieldType].formatMap.last, 10);
						$(this).val(inputValue);
					}
					
					if(inputLen >= maxlength){
						inputValue = inputValue.slice(0, maxlength-1);
						$(this).val(inputValue);
						return true;
					}
					
					var splitSymbol = self._formatConfig[self._fieldType].formatMap[''+inputLen];
					
					if(splitSymbol){
						inputValue = inputValue + splitSymbol;
						$(this).val(inputValue);
					}
				}
			});
		},
		switchPattern: function(inputValue, type){
			inputValue = inputValue.replace(/(\.)|(\-)|(\/)/g,'');
			this._fieldType = type;
			if(type === 'CNPJ'){
				inputValue = inputValue.replace(/^(.{2})(.{3})(.{3})(.{3})$/,'$1.$2.$3/$4');
			}else if(type === 'CPF'){
				inputValue = inputValue.replace(/^(.{3})(.{3})(.{3})(.{2})/,'$1.$2.$3-$4');
			}
			return inputValue;
		},
        addEventListener: function(){
            var self = this;
            this.selectionElem.change(function(){
                var selectedValue = $(this).val();
                self.type.val('');
				self.type.off();
                self.companyName.val('');
                var typeLabelElem = self.type.prev();
                switch(selectedValue){
                    case 'CNPJ':
                        self.type.attr({'placeholder':'__.___.___/____-__'}).removeAttr('maxlength');
                        typeLabelElem.html(selectedValue);
                        self.companyName.parent().css('display', 'none');
                        self.type.parent().css('display','block');
                        a_fields[self.compName]['r'] = false;
                        a_messages[self.typeName]['r'] = a_messages[self.typeName]['message_a'];
						self._switchable = false;
						self.dynmCheck(self.type, selectedValue);
                        break;
                    case 'CPF':
                        self.type.attr({'placeholder':'___.___.___-__'}).removeAttr('maxlength');
                        typeLabelElem.html(selectedValue);
                        self.companyName.parent().css('display', 'none');
                        self.type.parent().css('display','block');
                        a_fields[self.compName]['r'] = false;
                        a_messages[self.typeName]['r'] = a_messages[self.typeName]['message_b'];
						self._switchable = false;
						self.dynmCheck(self.type, selectedValue);
                        break;
                    case 'CPF/CNPJ':
						self.type.removeAttr('maxlength placeholder');
                        typeLabelElem.html(selectedValue);
                        self.companyName.parent().css('display', 'none');
                        self.type.parent().css('display','block');
                        a_fields[self.compName]['r'] = false;
                        a_messages[self.typeName]['r'] = a_messages[self.typeName]['message_c'];
						self._switchable = true;
						self.dynmCheck(self.type, 'CPF');
                        break;
                    case 'CPFB':
                        self.type.attr({'placeholder':'___.___.___-__'}).removeAttr('maxlength');
                        typeLabelElem.html('CPF');
                        self.type.parent().css('display', 'block');
                        self.companyName.parent().css('display', 'block');
                        a_fields[self.compName]['r'] = true;
                        a_messages[self.typeName]['r'] = a_messages[self.typeName]['message_d'];
						self._switchable = false;
						self.dynmCheck(self.type, 'CPF');
                        break;
                    default:
                        self.type.parent().css('display', 'none');
                        self.companyName.parent().css('display', 'none');
                        a_fields[self.compName]['r'] = false;
                        break;
                }
            });
            $('#FormSales_Observation').keydown(function(e){
                var keyCode = e.keyCode;
                
                if($.inArray(keyCode, self.ctrlCode) === -1){
                    var maxlength = self.observeElem.attr('maxlength');
                    if(self.observeElem.val().length >= maxlength){
                        var name = self.observeElem.attr('name');
                        alert(a_messages[name]['r']);
                    }
                }
            });
            $('.fbform input[type="reset"]').click(function(){
                self.selectionElem.find('option[value=""]').prop('selected', true);
                self.selectionElem.trigger("change");
                self.modelElem.find('option[value=""]').prop('selected', true);
                self.modelElem.trigger('change');
                self.stateElem.find('option[value=""]').prop('selected', true);
                self.stateElem.trigger('change');
            });
			if (self.singleInputWithCheck && self.singleInputWithCheck.length > 0) {
                self.singleInputWithCheck.each(function () {
                    var ftype = $(this).attr('data-check');
                    ftype = ftype ? ftype.toUpperCase() : '';
                    var msg = (a_messages[$(this).attr('name')] && a_messages[$(this).attr('name')]['r']) ? a_messages[$(this).attr('name')]['r'] : '';
                    switch (ftype) {
                        case 'CNPJ':
                            $(this).attr({ 'placeholder': '__.___.___/____-__' }).removeAttr('maxlength');
                            self.dynmCheck($(this), ftype, msg);
                            break;
                        case 'CPF':
                            $(this).attr({ 'placeholder': '___.___.___-__' }).removeAttr('maxlength');
                            self.dynmCheck($(this), ftype, msg);
                            break;
                    }
                });
            }
			
			this.telElem.on('keydown', function(event){
				var keyCode = event.keyCode;
				var inputVal = $(this).val();
				var inputLen = inputVal.length;
				if(keyCode === 8){
					if(inputLen === 5){
						inputVal = inputVal.replace(/\(([0-9]{2})\)/, '$1');
						$(this).val(inputVal);
					}else if(inputLen === 10){
						inputVal = inputVal.slice(0, 9);
						$(this).val(inputVal);
					}
				}
				if($.inArray(keyCode, self.ctrlCode) === -1){
					if(inputLen === 2){
						inputVal = '('+inputVal+')';
						$(this).val(inputVal);
					}else if(inputLen === 8){
						inputVal = inputVal + '-';
						$(this).val(inputVal);
					}
				}
			});
        }
    };
    $(function(){
        formSalesController.init();
    });
})(jQuery);

