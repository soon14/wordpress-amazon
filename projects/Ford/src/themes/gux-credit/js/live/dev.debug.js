
/* Modernizr 2.5.3 (Custom Build) | MIT & BSD
 * Build: http://modernizr.com/download/#-fontface-backgroundsize-borderimage-borderradius-boxshadow-flexbox-flexbox_legacy-hsla-multiplebgs-opacity-rgba-textshadow-cssanimations-csscolumns-generatedcontent-cssgradients-cssreflections-csstransforms-csstransforms3d-csstransitions-applicationcache-canvas-canvastext-draganddrop-hashchange-history-audio-video-indexeddb-input-inputtypes-localstorage-postmessage-sessionstorage-geolocation-touch-cssclasses-prefixed-teststyles-testprop-testallprops-hasevent-prefixes-domprefixes
 */
;window.Modernizr=function(a,b,c){function B(a){j.cssText=a}function C(a,b){return B(n.join(a+";")+(b||""))}function D(a,b){return typeof a===b}function E(a,b){return!!~(""+a).indexOf(b)}function F(a,b){for(var d in a)if(j[a[d]]!==c)return b=="pfx"?a[d]:!0;return!1}function G(a,b,d){for(var e in a){var f=b[a[e]];if(f!==c)return d===!1?a[e]:D(f,"function")?f.bind(d||b):f}return!1}function H(a,b,c){var d=a.charAt(0).toUpperCase()+a.substr(1),e=(a+" "+p.join(d+" ")+d).split(" ");return D(b,"string")||D(b,"undefined")?F(e,b):(e=(a+" "+q.join(d+" ")+d).split(" "),G(e,b,c))}function J(){e.input=function(c){for(var d=0,e=c.length;d<e;d++)t[c[d]]=c[d]in k;return t.list&&(t.list=!!b.createElement("datalist")&&!!a.HTMLDataListElement),t}("autocomplete autofocus list placeholder max min multiple pattern required step".split(" ")),e.inputtypes=function(a){for(var d=0,e,f,h,i=a.length;d<i;d++)k.setAttribute("type",f=a[d]),e=k.type!=="text",e&&(k.value=l,k.style.cssText="position:absolute;visibility:hidden;",/^range$/.test(f)&&k.style.WebkitAppearance!==c?(g.appendChild(k),h=b.defaultView,e=h.getComputedStyle&&h.getComputedStyle(k,null).WebkitAppearance!=="textfield"&&k.offsetHeight!==0,g.removeChild(k)):/^(search|tel)$/.test(f)||(/^(url|email)$/.test(f)?e=k.checkValidity&&k.checkValidity()===!1:/^color$/.test(f)?(g.appendChild(k),g.offsetWidth,e=k.value!=l,g.removeChild(k)):e=k.value!=l)),s[a[d]]=!!e;return s}("search tel url email datetime date month week time datetime-local number range color".split(" "))}var d="2.5.3",e={},f=!0,g=b.documentElement,h="modernizr",i=b.createElement(h),j=i.style,k=b.createElement("input"),l=":)",m={}.toString,n=" -webkit- -moz- -o- -ms- ".split(" "),o="Webkit Moz O ms",p=o.split(" "),q=o.toLowerCase().split(" "),r={},s={},t={},u=[],v=u.slice,w,x=function(a,c,d,e){var f,i,j,k=b.createElement("div"),l=b.body,m=l?l:b.createElement("body");if(parseInt(d,10))while(d--)j=b.createElement("div"),j.id=e?e[d]:h+(d+1),k.appendChild(j);return f=["&#173;","<style>",a,"</style>"].join(""),k.id=h,(l?k:m).innerHTML+=f,m.appendChild(k),l||(m.style.background="",g.appendChild(m)),i=c(k,a),l?k.parentNode.removeChild(k):m.parentNode.removeChild(m),!!i},y=function(){function d(d,e){e=e||b.createElement(a[d]||"div"),d="on"+d;var f=d in e;return f||(e.setAttribute||(e=b.createElement("div")),e.setAttribute&&e.removeAttribute&&(e.setAttribute(d,""),f=D(e[d],"function"),D(e[d],"undefined")||(e[d]=c),e.removeAttribute(d))),e=null,f}var a={select:"input",change:"input",submit:"form",reset:"form",error:"img",load:"img",abort:"img"};return d}(),z={}.hasOwnProperty,A;!D(z,"undefined")&&!D(z.call,"undefined")?A=function(a,b){return z.call(a,b)}:A=function(a,b){return b in a&&D(a.constructor.prototype[b],"undefined")},Function.prototype.bind||(Function.prototype.bind=function(b){var c=this;if(typeof c!="function")throw new TypeError;var d=v.call(arguments,1),e=function(){if(this instanceof e){var a=function(){};a.prototype=c.prototype;var f=new a,g=c.apply(f,d.concat(v.call(arguments)));return Object(g)===g?g:f}return c.apply(b,d.concat(v.call(arguments)))};return e});var I=function(c,d){var f=c.join(""),g=d.length;x(f,function(c,d){var f=b.styleSheets[b.styleSheets.length-1],h=f?f.cssRules&&f.cssRules[0]?f.cssRules[0].cssText:f.cssText||"":"",i=c.childNodes,j={};while(g--)j[i[g].id]=i[g];e.touch="ontouchstart"in a||a.DocumentTouch&&b instanceof DocumentTouch||(j.touch&&j.touch.offsetTop)===9,e.csstransforms3d=(j.csstransforms3d&&j.csstransforms3d.offsetLeft)===9&&j.csstransforms3d.offsetHeight===3,e.generatedcontent=(j.generatedcontent&&j.generatedcontent.offsetHeight)>=1,e.fontface=/src/i.test(h)&&h.indexOf(d.split(" ")[0])===0},g,d)}(['@font-face {font-family:"font";src:url("https://")}',["@media (",n.join("touch-enabled),("),h,")","{#touch{top:9px;position:absolute}}"].join(""),["@media (",n.join("transform-3d),("),h,")","{#csstransforms3d{left:9px;position:absolute;height:3px;}}"].join(""),['#generatedcontent:after{content:"',l,'";visibility:hidden}'].join("")],["fontface","touch","csstransforms3d","generatedcontent"]);r.flexbox=function(){return H("flexOrder")},r["flexbox-legacy"]=function(){return H("boxDirection")},r.canvas=function(){var a=b.createElement("canvas");return!!a.getContext&&!!a.getContext("2d")},r.canvastext=function(){return!!e.canvas&&!!D(b.createElement("canvas").getContext("2d").fillText,"function")},r.touch=function(){return e.touch},r.geolocation=function(){return!!navigator.geolocation},r.postmessage=function(){return!!a.postMessage},r.indexedDB=function(){return!!H("indexedDB",a)},r.hashchange=function(){return y("hashchange",a)&&(b.documentMode===c||b.documentMode>7)},r.history=function(){return!!a.history&&!!history.pushState},r.draganddrop=function(){var a=b.createElement("div");return"draggable"in a||"ondragstart"in a&&"ondrop"in a},r.rgba=function(){return B("background-color:rgba(150,255,150,.5)"),E(j.backgroundColor,"rgba")},r.hsla=function(){return B("background-color:hsla(120,40%,100%,.5)"),E(j.backgroundColor,"rgba")||E(j.backgroundColor,"hsla")},r.multiplebgs=function(){return B("background:url(https://),url(https://),red url(https://)"),/(url\s*\(.*?){3}/.test(j.background)},r.backgroundsize=function(){return H("backgroundSize")},r.borderimage=function(){return H("borderImage")},r.borderradius=function(){return H("borderRadius")},r.boxshadow=function(){return H("boxShadow")},r.textshadow=function(){return b.createElement("div").style.textShadow===""},r.opacity=function(){return C("opacity:.55"),/^0.55$/.test(j.opacity)},r.cssanimations=function(){return H("animationName")},r.csscolumns=function(){return H("columnCount")},r.cssgradients=function(){var a="background-image:",b="gradient(linear,left top,right bottom,from(#9f9),to(white));",c="linear-gradient(left top,#9f9, white);";return B((a+"-webkit- ".split(" ").join(b+a)+n.join(c+a)).slice(0,-a.length)),E(j.backgroundImage,"gradient")},r.cssreflections=function(){return H("boxReflect")},r.csstransforms=function(){return!!H("transform")},r.csstransforms3d=function(){var a=!!H("perspective");return a&&"webkitPerspective"in g.style&&(a=e.csstransforms3d),a},r.csstransitions=function(){return H("transition")},r.fontface=function(){return e.fontface},r.generatedcontent=function(){return e.generatedcontent},r.video=function(){var a=b.createElement("video"),c=!1;try{if(c=!!a.canPlayType)c=new Boolean(c),c.ogg=a.canPlayType('video/ogg; codecs="theora"').replace(/^no$/,""),c.h264=a.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/,""),c.webm=a.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/,"")}catch(d){}return c},r.audio=function(){var a=b.createElement("audio"),c=!1;try{if(c=!!a.canPlayType)c=new Boolean(c),c.ogg=a.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/,""),c.mp3=a.canPlayType("audio/mpeg;").replace(/^no$/,""),c.wav=a.canPlayType('audio/wav; codecs="1"').replace(/^no$/,""),c.m4a=(a.canPlayType("audio/x-m4a;")||a.canPlayType("audio/aac;")).replace(/^no$/,"")}catch(d){}return c},r.localstorage=function(){try{return localStorage.setItem(h,h),localStorage.removeItem(h),!0}catch(a){return!1}},r.sessionstorage=function(){try{return sessionStorage.setItem(h,h),sessionStorage.removeItem(h),!0}catch(a){return!1}},r.applicationcache=function(){return!!a.applicationCache};for(var K in r)A(r,K)&&(w=K.toLowerCase(),e[w]=r[K](),u.push((e[w]?"":"no-")+w));return e.input||J(),B(""),i=k=null,e._version=d,e._prefixes=n,e._domPrefixes=q,e._cssomPrefixes=p,e.hasEvent=y,e.testProp=function(a){return F([a])},e.testAllProps=H,e.testStyles=x,e.prefixed=function(a,b,c){return b?H(a,b,c):H(a,"pfx")},g.className=g.className.replace(/(^|\s)no-js(\s|$)/,"$1$2")+(f?" js "+u.join(" "):""),e}(this,this.document);


/*!
 * jQuery Migrate - v1.2.1 - 2013-05-08
 * https://github.com/jquery/jquery-migrate
 * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors; Licensed MIT
 */
(function( jQuery, window, undefined ) {
// See http://bugs.jquery.com/ticket/13335
// "use strict";


var warnedAbout = {};

// List of warnings already given; public read only
jQuery.migrateWarnings = [];

// Set to true to prevent console output; migrateWarnings still maintained
jQuery.migrateMute = true;

// Show a message on the console so devs know we're active
if ( !jQuery.migrateMute && window.console && window.console.log ) {
	window.console.log("JQMIGRATE: Logging is active");
}

// Set to false to disable traces that appear with warnings
if ( jQuery.migrateTrace === undefined ) {
	jQuery.migrateTrace = true;
}

// Forget any warnings we've already given; public
jQuery.migrateReset = function() {
	warnedAbout = {};
	jQuery.migrateWarnings.length = 0;
};

function migrateWarn( msg) {
	var console = window.console;
	if ( !warnedAbout[ msg ] ) {
		warnedAbout[ msg ] = true;
		jQuery.migrateWarnings.push( msg );
		if ( console && console.warn && !jQuery.migrateMute ) {
			console.warn( "JQMIGRATE: " + msg );
			if ( jQuery.migrateTrace && console.trace ) {
				console.trace();
			}
		}
	}
}

function migrateWarnProp( obj, prop, value, msg ) {
	if ( Object.defineProperty ) {
		// On ES5 browsers (non-oldIE), warn if the code tries to get prop;
		// allow property to be overwritten in case some other plugin wants it
		try {
			Object.defineProperty( obj, prop, {
				configurable: true,
				enumerable: true,
				get: function() {
					migrateWarn( msg );
					return value;
				},
				set: function( newValue ) {
					migrateWarn( msg );
					value = newValue;
				}
			});
			return;
		} catch( err ) {
			// IE8 is a dope about Object.defineProperty, can't warn there
		}
	}

	// Non-ES5 (or broken) browser; just set the property
	jQuery._definePropertyBroken = true;
	obj[ prop ] = value;
}

if ( document.compatMode === "BackCompat" ) {
	// jQuery has never supported or tested Quirks Mode
	migrateWarn( "jQuery is not compatible with Quirks Mode" );
}


var attrFn = jQuery( "<input/>", { size: 1 } ).attr("size") && jQuery.attrFn,
	oldAttr = jQuery.attr,
	valueAttrGet = jQuery.attrHooks.value && jQuery.attrHooks.value.get ||
		function() { return null; },
	valueAttrSet = jQuery.attrHooks.value && jQuery.attrHooks.value.set ||
		function() { return undefined; },
	rnoType = /^(?:input|button)$/i,
	rnoAttrNodeType = /^[238]$/,
	rboolean = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
	ruseDefault = /^(?:checked|selected)$/i;

// jQuery.attrFn
migrateWarnProp( jQuery, "attrFn", attrFn || {}, "jQuery.attrFn is deprecated" );

jQuery.attr = function( elem, name, value, pass ) {
	var lowerName = name.toLowerCase(),
		nType = elem && elem.nodeType;

	if ( pass ) {
		// Since pass is used internally, we only warn for new jQuery
		// versions where there isn't a pass arg in the formal params
		if ( oldAttr.length < 4 ) {
			migrateWarn("jQuery.fn.attr( props, pass ) is deprecated");
		}
		if ( elem && !rnoAttrNodeType.test( nType ) &&
			(attrFn ? name in attrFn : jQuery.isFunction(jQuery.fn[name])) ) {
			return jQuery( elem )[ name ]( value );
		}
	}

	// Warn if user tries to set `type`, since it breaks on IE 6/7/8; by checking
	// for disconnected elements we don't warn on $( "<button>", { type: "button" } ).
	if ( name === "type" && value !== undefined && rnoType.test( elem.nodeName ) && elem.parentNode ) {
		migrateWarn("Can't change the 'type' of an input or button in IE 6/7/8");
	}

	// Restore boolHook for boolean property/attribute synchronization
	if ( !jQuery.attrHooks[ lowerName ] && rboolean.test( lowerName ) ) {
		jQuery.attrHooks[ lowerName ] = {
			get: function( elem, name ) {
				// Align boolean attributes with corresponding properties
				// Fall back to attribute presence where some booleans are not supported
				var attrNode,
					property = jQuery.prop( elem, name );
				return property === true || typeof property !== "boolean" &&
					( attrNode = elem.getAttributeNode(name) ) && attrNode.nodeValue !== false ?

					name.toLowerCase() :
					undefined;
			},
			set: function( elem, value, name ) {
				var propName;
				if ( value === false ) {
					// Remove boolean attributes when set to false
					jQuery.removeAttr( elem, name );
				} else {
					// value is true since we know at this point it's type boolean and not false
					// Set boolean attributes to the same name and set the DOM property
					propName = jQuery.propFix[ name ] || name;
					if ( propName in elem ) {
						// Only set the IDL specifically if it already exists on the element
						elem[ propName ] = true;
					}

					elem.setAttribute( name, name.toLowerCase() );
				}
				return name;
			}
		};

		// Warn only for attributes that can remain distinct from their properties post-1.9
		if ( ruseDefault.test( lowerName ) ) {
			migrateWarn( "jQuery.fn.attr('" + lowerName + "') may use property instead of attribute" );
		}
	}

	return oldAttr.call( jQuery, elem, name, value );
};

// attrHooks: value
jQuery.attrHooks.value = {
	get: function( elem, name ) {
		var nodeName = ( elem.nodeName || "" ).toLowerCase();
		if ( nodeName === "button" ) {
			return valueAttrGet.apply( this, arguments );
		}
		if ( nodeName !== "input" && nodeName !== "option" ) {
			migrateWarn("jQuery.fn.attr('value') no longer gets properties");
		}
		return name in elem ?
			elem.value :
			null;
	},
	set: function( elem, value ) {
		var nodeName = ( elem.nodeName || "" ).toLowerCase();
		if ( nodeName === "button" ) {
			return valueAttrSet.apply( this, arguments );
		}
		if ( nodeName !== "input" && nodeName !== "option" ) {
			migrateWarn("jQuery.fn.attr('value', val) no longer sets properties");
		}
		// Does not return so that setAttribute is also used
		elem.value = value;
	}
};


var matched, browser,
	oldInit = jQuery.fn.init,
	oldParseJSON = jQuery.parseJSON,
	// Note: XSS check is done below after string is trimmed
	rquickExpr = /^([^<]*)(<[\w\W]+>)([^>]*)$/;

// $(html) "looks like html" rule change
jQuery.fn.init = function( selector, context, rootjQuery ) {
	var match;

	if ( selector && typeof selector === "string" && !jQuery.isPlainObject( context ) &&
			(match = rquickExpr.exec( jQuery.trim( selector ) )) && match[ 0 ] ) {
		// This is an HTML string according to the "old" rules; is it still?
		if ( selector.charAt( 0 ) !== "<" ) {
			migrateWarn("$(html) HTML strings must start with '<' character");
		}
		if ( match[ 3 ] ) {
			migrateWarn("$(html) HTML text after last tag is ignored");
		}
		// Consistently reject any HTML-like string starting with a hash (#9521)
		// Note that this may break jQuery 1.6.x code that otherwise would work.
		if ( match[ 0 ].charAt( 0 ) === "#" ) {
			migrateWarn("HTML string cannot start with a '#' character");
			jQuery.error("JQMIGRATE: Invalid selector string (XSS)");
		}
		// Now process using loose rules; let pre-1.8 play too
		if ( context && context.context ) {
			// jQuery object as context; parseHTML expects a DOM object
			context = context.context;
		}
		if ( jQuery.parseHTML ) {
			return oldInit.call( this, jQuery.parseHTML( match[ 2 ], context, true ),
					context, rootjQuery );
		}
	}
	return oldInit.apply( this, arguments );
};
jQuery.fn.init.prototype = jQuery.fn;

// Let $.parseJSON(falsy_value) return null
jQuery.parseJSON = function( json ) {
	if ( !json && json !== null ) {
		migrateWarn("jQuery.parseJSON requires a valid JSON string");
		return null;
	}
	return oldParseJSON.apply( this, arguments );
};

jQuery.uaMatch = function( ua ) {
	ua = ua.toLowerCase();

	var match = /(chrome)[ \/]([\w.]+)/.exec( ua ) ||
		/(webkit)[ \/]([\w.]+)/.exec( ua ) ||
		/(opera)(?:.*version|)[ \/]([\w.]+)/.exec( ua ) ||
		/(msie) ([\w.]+)/.exec( ua ) ||
		ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec( ua ) ||
		[];

	return {
		browser: match[ 1 ] || "",
		version: match[ 2 ] || "0"
	};
};

// Don't clobber any existing jQuery.browser in case it's different
if ( !jQuery.browser ) {
	matched = jQuery.uaMatch( navigator.userAgent );
	browser = {};

	if ( matched.browser ) {
		browser[ matched.browser ] = true;
		browser.version = matched.version;
	}

	// Chrome is Webkit, but Webkit is also Safari.
	if ( browser.chrome ) {
		browser.webkit = true;
	} else if ( browser.webkit ) {
		browser.safari = true;
	}

	jQuery.browser = browser;
}

// Warn if the code tries to get jQuery.browser
migrateWarnProp( jQuery, "browser", jQuery.browser, "jQuery.browser is deprecated" );

jQuery.sub = function() {
	function jQuerySub( selector, context ) {
		return new jQuerySub.fn.init( selector, context );
	}
	jQuery.extend( true, jQuerySub, this );
	jQuerySub.superclass = this;
	jQuerySub.fn = jQuerySub.prototype = this();
	jQuerySub.fn.constructor = jQuerySub;
	jQuerySub.sub = this.sub;
	jQuerySub.fn.init = function init( selector, context ) {
		if ( context && context instanceof jQuery && !(context instanceof jQuerySub) ) {
			context = jQuerySub( context );
		}

		return jQuery.fn.init.call( this, selector, context, rootjQuerySub );
	};
	jQuerySub.fn.init.prototype = jQuerySub.fn;
	var rootjQuerySub = jQuerySub(document);
	migrateWarn( "jQuery.sub() is deprecated" );
	return jQuerySub;
};


// Ensure that $.ajax gets the new parseJSON defined in core.js
jQuery.ajaxSetup({
	converters: {
		"text json": jQuery.parseJSON
	}
});


var oldFnData = jQuery.fn.data;

jQuery.fn.data = function( name ) {
	var ret, evt,
		elem = this[0];

	// Handles 1.7 which has this behavior and 1.8 which doesn't
	if ( elem && name === "events" && arguments.length === 1 ) {
		ret = jQuery.data( elem, name );
		evt = jQuery._data( elem, name );
		if ( ( ret === undefined || ret === evt ) && evt !== undefined ) {
			migrateWarn("Use of jQuery.fn.data('events') is deprecated");
			return evt;
		}
	}
	return oldFnData.apply( this, arguments );
};


var rscriptType = /\/(java|ecma)script/i,
	oldSelf = jQuery.fn.andSelf || jQuery.fn.addBack;

jQuery.fn.andSelf = function() {
	migrateWarn("jQuery.fn.andSelf() replaced by jQuery.fn.addBack()");
	return oldSelf.apply( this, arguments );
};

// Since jQuery.clean is used internally on older versions, we only shim if it's missing
if ( !jQuery.clean ) {
	jQuery.clean = function( elems, context, fragment, scripts ) {
		// Set context per 1.8 logic
		context = context || document;
		context = !context.nodeType && context[0] || context;
		context = context.ownerDocument || context;

		migrateWarn("jQuery.clean() is deprecated");

		var i, elem, handleScript, jsTags,
			ret = [];

		jQuery.merge( ret, jQuery.buildFragment( elems, context ).childNodes );

		// Complex logic lifted directly from jQuery 1.8
		if ( fragment ) {
			// Special handling of each script element
			handleScript = function( elem ) {
				// Check if we consider it executable
				if ( !elem.type || rscriptType.test( elem.type ) ) {
					// Detach the script and store it in the scripts array (if provided) or the fragment
					// Return truthy to indicate that it has been handled
					return scripts ?
						scripts.push( elem.parentNode ? elem.parentNode.removeChild( elem ) : elem ) :
						fragment.appendChild( elem );
				}
			};

			for ( i = 0; (elem = ret[i]) != null; i++ ) {
				// Check if we're done after handling an executable script
				if ( !( jQuery.nodeName( elem, "script" ) && handleScript( elem ) ) ) {
					// Append to fragment and handle embedded scripts
					fragment.appendChild( elem );
					if ( typeof elem.getElementsByTagName !== "undefined" ) {
						// handleScript alters the DOM, so use jQuery.merge to ensure snapshot iteration
						jsTags = jQuery.grep( jQuery.merge( [], elem.getElementsByTagName("script") ), handleScript );

						// Splice the scripts into ret after their former ancestor and advance our index beyond them
						ret.splice.apply( ret, [i + 1, 0].concat( jsTags ) );
						i += jsTags.length;
					}
				}
			}
		}

		return ret;
	};
}

var eventAdd = jQuery.event.add,
	eventRemove = jQuery.event.remove,
	eventTrigger = jQuery.event.trigger,
	oldToggle = jQuery.fn.toggle,
	oldLive = jQuery.fn.live,
	oldDie = jQuery.fn.die,
	ajaxEvents = "ajaxStart|ajaxStop|ajaxSend|ajaxComplete|ajaxError|ajaxSuccess",
	rajaxEvent = new RegExp( "\\b(?:" + ajaxEvents + ")\\b" ),
	rhoverHack = /(?:^|\s)hover(\.\S+|)\b/,
	hoverHack = function( events ) {
		if ( typeof( events ) !== "string" || jQuery.event.special.hover ) {
			return events;
		}
		if ( rhoverHack.test( events ) ) {
			migrateWarn("'hover' pseudo-event is deprecated, use 'mouseenter mouseleave'");
		}
		return events && events.replace( rhoverHack, "mouseenter$1 mouseleave$1" );
	};

// Event props removed in 1.9, put them back if needed; no practical way to warn them
if ( jQuery.event.props && jQuery.event.props[ 0 ] !== "attrChange" ) {
	jQuery.event.props.unshift( "attrChange", "attrName", "relatedNode", "srcElement" );
}

// Undocumented jQuery.event.handle was "deprecated" in jQuery 1.7
if ( jQuery.event.dispatch ) {
	migrateWarnProp( jQuery.event, "handle", jQuery.event.dispatch, "jQuery.event.handle is undocumented and deprecated" );
}

// Support for 'hover' pseudo-event and ajax event warnings
jQuery.event.add = function( elem, types, handler, data, selector ){
	if ( elem !== document && rajaxEvent.test( types ) ) {
		migrateWarn( "AJAX events should be attached to document: " + types );
	}
	eventAdd.call( this, elem, hoverHack( types || "" ), handler, data, selector );
};
jQuery.event.remove = function( elem, types, handler, selector, mappedTypes ){
	eventRemove.call( this, elem, hoverHack( types ) || "", handler, selector, mappedTypes );
};

jQuery.fn.error = function() {
	var args = Array.prototype.slice.call( arguments, 0);
	migrateWarn("jQuery.fn.error() is deprecated");
	args.splice( 0, 0, "error" );
	if ( arguments.length ) {
		return this.bind.apply( this, args );
	}
	// error event should not bubble to window, although it does pre-1.7
	this.triggerHandler.apply( this, args );
	return this;
};

jQuery.fn.toggle = function( fn, fn2 ) {

	// Don't mess with animation or css toggles
	if ( !jQuery.isFunction( fn ) || !jQuery.isFunction( fn2 ) ) {
		return oldToggle.apply( this, arguments );
	}
	migrateWarn("jQuery.fn.toggle(handler, handler...) is deprecated");

	// Save reference to arguments for access in closure
	var args = arguments,
		guid = fn.guid || jQuery.guid++,
		i = 0,
		toggler = function( event ) {
			// Figure out which function to execute
			var lastToggle = ( jQuery._data( this, "lastToggle" + fn.guid ) || 0 ) % i;
			jQuery._data( this, "lastToggle" + fn.guid, lastToggle + 1 );

			// Make sure that clicks stop
			event.preventDefault();

			// and execute the function
			return args[ lastToggle ].apply( this, arguments ) || false;
		};

	// link all the functions, so any of them can unbind this click handler
	toggler.guid = guid;
	while ( i < args.length ) {
		args[ i++ ].guid = guid;
	}

	return this.click( toggler );
};

jQuery.fn.live = function( types, data, fn ) {
	migrateWarn("jQuery.fn.live() is deprecated");
	if ( oldLive ) {
		return oldLive.apply( this, arguments );
	}
	jQuery( this.context ).on( types, this.selector, data, fn );
	return this;
};

jQuery.fn.die = function( types, fn ) {
	migrateWarn("jQuery.fn.die() is deprecated");
	if ( oldDie ) {
		return oldDie.apply( this, arguments );
	}
	jQuery( this.context ).off( types, this.selector || "**", fn );
	return this;
};

// Turn global events into document-triggered events
jQuery.event.trigger = function( event, data, elem, onlyHandlers  ){
	if ( !elem && !rajaxEvent.test( event ) ) {
		migrateWarn( "Global events are undocumented and deprecated" );
	}
	return eventTrigger.call( this,  event, data, elem || document, onlyHandlers  );
};
jQuery.each( ajaxEvents.split("|"),
	function( _, name ) {
		jQuery.event.special[ name ] = {
			setup: function() {
				var elem = this;

				// The document needs no shimming; must be !== for oldIE
				if ( elem !== document ) {
					jQuery.event.add( document, name + "." + jQuery.guid, function() {
						jQuery.event.trigger( name, null, elem, true );
					});
					jQuery._data( this, name, jQuery.guid++ );
				}
				return false;
			},
			teardown: function() {
				if ( this !== document ) {
					jQuery.event.remove( document, name + "." + jQuery._data( this, name ) );
				}
				return false;
			}
		};
	}
);


})( jQuery, window );


/*
    http://www.JSON.org/json2.js
    2010-08-25

    Public Domain.

    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.

    See http://www.JSON.org/js.html


    This code should be minified before deployment.
    See http://javascript.crockford.com/jsmin.html

    USE YOUR OWN COPY. IT IS EXTREMELY UNWISE TO LOAD CODE FROM SERVERS YOU DO
    NOT CONTROL.


    This file creates a global JSON object containing two methods: stringify
    and parse.

        JSON.stringify(value, replacer, space)
            value       any JavaScript value, usually an object or array.

            replacer    an optional parameter that determines how object
                        values are stringified for objects. It can be a
                        function or an array of strings.

            space       an optional parameter that specifies the indentation
                        of nested structures. If it is omitted, the text will
                        be packed without extra whitespace. If it is a number,
                        it will specify the number of spaces to indent at each
                        level. If it is a string (such as '\t' or '&nbsp;'),
                        it contains the characters used to indent at each level.

            This method produces a JSON text from a JavaScript value.

            When an object value is found, if the object contains a toJSON
            method, its toJSON method will be called and the result will be
            stringified. A toJSON method does not serialize: it returns the
            value represented by the name/value pair that should be serialized,
            or undefined if nothing should be serialized. The toJSON method
            will be passed the key associated with the value, and this will be
            bound to the value

            For example, this would serialize Dates as ISO strings.

                Date.prototype.toJSON = function (key) {
                    function f(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n;
                    }

                    return this.getUTCFullYear()   + '-' +
                         f(this.getUTCMonth() + 1) + '-' +
                         f(this.getUTCDate())      + 'T' +
                         f(this.getUTCHours())     + ':' +
                         f(this.getUTCMinutes())   + ':' +
                         f(this.getUTCSeconds())   + 'Z';
                };

            You can provide an optional replacer method. It will be passed the
            key and value of each member, with this bound to the containing
            object. The value that is returned from your method will be
            serialized. If your method returns undefined, then the member will
            be excluded from the serialization.

            If the replacer parameter is an array of strings, then it will be
            used to select the members to be serialized. It filters the results
            such that only members with keys listed in the replacer array are
            stringified.

            Values that do not have JSON representations, such as undefined or
            functions, will not be serialized. Such values in objects will be
            dropped; in arrays they will be replaced with null. You can use
            a replacer function to replace those with JSON values.
            JSON.stringify(undefined) returns undefined.

            The optional space parameter produces a stringification of the
            value that is filled with line breaks and indentation to make it
            easier to read.

            If the space parameter is a non-empty string, then that string will
            be used for indentation. If the space parameter is a number, then
            the indentation will be that many spaces.

            Example:

            text = JSON.stringify(['e', {pluribus: 'unum'}]);
            // text is '["e",{"pluribus":"unum"}]'


            text = JSON.stringify(['e', {pluribus: 'unum'}], null, '\t');
            // text is '[\n\t"e",\n\t{\n\t\t"pluribus": "unum"\n\t}\n]'

            text = JSON.stringify([new Date()], function (key, value) {
                return this[key] instanceof Date ?
                    'Date(' + this[key] + ')' : value;
            });
            // text is '["Date(---current time---)"]'


        JSON.parse(text, reviver)
            This method parses a JSON text to produce an object or array.
            It can throw a SyntaxError exception.

            The optional reviver parameter is a function that can filter and
            transform the results. It receives each of the keys and values,
            and its return value is used instead of the original value.
            If it returns what it received, then the structure is not modified.
            If it returns undefined then the member is deleted.

            Example:

            // Parse the text. Values that look like ISO date strings will
            // be converted to Date objects.

            myData = JSON.parse(text, function (key, value) {
                var a;
                if (typeof value === 'string') {
                    a =
/^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2}(?:\.\d*)?)Z$/.exec(value);
                    if (a) {
                        return new Date(Date.UTC(+a[1], +a[2] - 1, +a[3], +a[4],
                            +a[5], +a[6]));
                    }
                }
                return value;
            });

            myData = JSON.parse('["Date(09/09/2001)"]', function (key, value) {
                var d;
                if (typeof value === 'string' &&
                        value.slice(0, 5) === 'Date(' &&
                        value.slice(-1) === ')') {
                    d = new Date(value.slice(5, -1));
                    if (d) {
                        return d;
                    }
                }
                return value;
            });


    This is a reference implementation. You are free to copy, modify, or
    redistribute.
*/

/*jslint evil: true, strict: false */

/*members "", "\b", "\t", "\n", "\f", "\r", "\"", JSON, "\\", apply,
    call, charCodeAt, getUTCDate, getUTCFullYear, getUTCHours,
    getUTCMinutes, getUTCMonth, getUTCSeconds, hasOwnProperty, join,
    lastIndex, length, parse, prototype, push, replace, slice, stringify,
    test, toJSON, toString, valueOf
*/


// Create a JSON object only if one does not already exist. We create the
// methods in a closure to avoid creating global variables.

if (!this.JSON) {
    this.JSON = {};
}

(function () {

    function f(n) {
        // Format integers to have at least two digits.
        return n < 10 ? '0' + n : n;
    }

    if (typeof Date.prototype.toJSON !== 'function') {

        Date.prototype.toJSON = function (key) {

            return isFinite(this.valueOf()) ?
                   this.getUTCFullYear()   + '-' +
                 f(this.getUTCMonth() + 1) + '-' +
                 f(this.getUTCDate())      + 'T' +
                 f(this.getUTCHours())     + ':' +
                 f(this.getUTCMinutes())   + ':' +
                 f(this.getUTCSeconds())   + 'Z' : null;
        };

        String.prototype.toJSON =
        Number.prototype.toJSON =
        Boolean.prototype.toJSON = function (key) {
            return this.valueOf();
        };
    }

    var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
        gap,
        indent,
        meta = {    // table of character substitutions
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"' : '\\"',
            '\\': '\\\\'
        },
        rep;


    function quote(string) {

// If the string contains no control characters, no quote characters, and no
// backslash characters, then we can safely slap some quotes around it.
// Otherwise we must also replace the offending characters with safe escape
// sequences.

        escapable.lastIndex = 0;
        return escapable.test(string) ?
            '"' + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === 'string' ? c :
                    '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"' :
            '"' + string + '"';
    }


    function str(key, holder) {

// Produce a string from holder[key].

        var i,          // The loop counter.
            k,          // The member key.
            v,          // The member value.
            length,
            mind = gap,
            partial,
            value = holder[key];

// If the value has a toJSON method, call it to obtain a replacement value.

        if (value && typeof value === 'object' &&
                typeof value.toJSON === 'function') {
            value = value.toJSON(key);
        }

// If we were called with a replacer function, then call the replacer to
// obtain a replacement value.

        if (typeof rep === 'function') {
            value = rep.call(holder, key, value);
        }

// What happens next depends on the value's type.

        switch (typeof value) {
        case 'string':
            return quote(value);

        case 'number':

// JSON numbers must be finite. Encode non-finite numbers as null.

            return isFinite(value) ? String(value) : 'null';

        case 'boolean':
        case 'null':

// If the value is a boolean or null, convert it to a string. Note:
// typeof null does not produce 'null'. The case is included here in
// the remote chance that this gets fixed someday.

            return String(value);

// If the type is 'object', we might be dealing with an object or an array or
// null.

        case 'object':

// Due to a specification blunder in ECMAScript, typeof null is 'object',
// so watch out for that case.

            if (!value) {
                return 'null';
            }

// Make an array to hold the partial results of stringifying this object value.

            gap += indent;
            partial = [];

// Is the value an array?

            if (Object.prototype.toString.apply(value) === '[object Array]') {

// The value is an array. Stringify every element. Use null as a placeholder
// for non-JSON values.

                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }

// Join all of the elements together, separated with commas, and wrap them in
// brackets.

                v = partial.length === 0 ? '[]' :
                    gap ? '[\n' + gap +
                            partial.join(',\n' + gap) + '\n' +
                                mind + ']' :
                          '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }

// If the replacer is an array, use it to select the members to be stringified.

            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            } else {

// Otherwise, iterate through all of the keys in the object.

                for (k in value) {
                    if (Object.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }

// Join all of the member texts together, separated with commas,
// and wrap them in braces.

            v = partial.length === 0 ? '{}' :
                gap ? '{\n' + gap + partial.join(',\n' + gap) + '\n' +
                        mind + '}' : '{' + partial.join(',') + '}';
            gap = mind;
            return v;
        }
    }

// If the JSON object does not yet have a stringify method, give it one.

    if (typeof JSON.stringify !== 'function') {
        JSON.stringify = function (value, replacer, space) {

// The stringify method takes a value and an optional replacer, and an optional
// space parameter, and returns a JSON text. The replacer can be a function
// that can replace values, or an array of strings that will select the keys.
// A default replacer method can be provided. Use of the space parameter can
// produce text that is more easily readable.

            var i;
            gap = '';
            indent = '';

// If the space parameter is a number, make an indent string containing that
// many spaces.

            if (typeof space === 'number') {
                for (i = 0; i < space; i += 1) {
                    indent += ' ';
                }

// If the space parameter is a string, it will be used as the indent string.

            } else if (typeof space === 'string') {
                indent = space;
            }

// If there is a replacer, it must be a function or an array.
// Otherwise, throw an error.

            rep = replacer;
            if (replacer && typeof replacer !== 'function' &&
                    (typeof replacer !== 'object' ||
                     typeof replacer.length !== 'number')) {
                throw new Error('JSON.stringify');
            }

// Make a fake root object containing our value under the key of ''.
// Return the result of stringifying the value.

            return str('', {'': value});
        };
    }


// If the JSON object does not yet have a parse method, give it one.

    if (typeof JSON.parse !== 'function') {
        JSON.parse = function (text, reviver) {

// The parse method takes a text and an optional reviver function, and returns
// a JavaScript value if the text is a valid JSON text.

            var j;

            function walk(holder, key) {

// The walk method is used to recursively walk the resulting structure so
// that modifications can be made.

                var k, v, value = holder[key];
                if (value && typeof value === 'object') {
                    for (k in value) {
                        if (Object.hasOwnProperty.call(value, k)) {
                            v = walk(value, k);
                            if (v !== undefined) {
                                value[k] = v;
                            } else {
                                delete value[k];
                            }
                        }
                    }
                }
                return reviver.call(holder, key, value);
            }


// Parsing happens in four stages. In the first stage, we replace certain
// Unicode characters with escape sequences. JavaScript handles many characters
// incorrectly, either silently deleting them, or treating them as line endings.

            text = String(text);
            cx.lastIndex = 0;
            if (cx.test(text)) {
                text = text.replace(cx, function (a) {
                    return '\\u' +
                        ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
                });
            }

// In the second stage, we run the text against regular expressions that look
// for non-JSON patterns. We are especially concerned with '()' and 'new'
// because they can cause invocation, and '=' because it can cause mutation.
// But just to be safe, we want to reject all unexpected forms.

// We split the second stage into 4 regexp operations in order to work around
// crippling inefficiencies in IE's and Safari's regexp engines. First we
// replace the JSON backslash pairs with '@' (a non-JSON character). Second, we
// replace all simple value tokens with ']' characters. Third, we delete all
// open brackets that follow a colon or comma or that begin the text. Finally,
// we look to see that the remaining characters are only whitespace or ']' or
// ',' or ':' or '{' or '}'. If that is so, then the text is safe for eval.

            if (/^[\],:{}\s]*$/
.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g, '@')
.replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, ']')
.replace(/(?:^|:|,)(?:\s*\[)+/g, ''))) {

// In the third stage we use the eval function to compile the text into a
// JavaScript structure. The '{' operator is subject to a syntactic ambiguity
// in JavaScript: it can begin a block or an object literal. We wrap the text
// in parens to eliminate the ambiguity.

                j = eval('(' + text + ')');

// In the optional fourth stage, we recursively walk the new structure, passing
// each name/value pair to a reviver function for possible transformation.

                return typeof reviver === 'function' ?
                    walk({'': j}, '') : j;
            }

// If the text is not JSON parseable, then a SyntaxError is thrown.

            throw new SyntaxError('JSON.parse');
        };
    }
}());


/*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas. Dual MIT/BSD license */

window.matchMedia = window.matchMedia || (function(doc, undefined){

  var docElem  = doc.documentElement,
      refNode  = docElem.firstElementChild || docElem.firstChild,
      // fakeBody required for <FF4 when executed in <head>
      fakeBody = doc.createElement('body'),
      div      = doc.createElement('div');

  div.id = 'mq-test-1';
  div.style.cssText = "position:absolute;top:-100em";
  fakeBody.style.background = "none";
  fakeBody.appendChild(div);

  var mqRun = function ( mq ) {
    div.innerHTML = '&shy;<style media="' + mq + '"> #mq-test-1 { width: 42px; }</style>';
    docElem.insertBefore( fakeBody, refNode );
    bool = div.offsetWidth === 42;
    docElem.removeChild( fakeBody );
    
    return { matches: bool, media: mq };
  },
  
  getEmValue = function () {
    var ret,
        body = docElem.body,
        fakeUsed = false;

    div.style.cssText = "position:absolute;font-size:1em;width:1em";

    if( !body ) {
      body = fakeUsed = doc.createElement( "body" );
      body.style.background = "none";
    }

    body.appendChild( div );

    docElem.insertBefore( body, docElem.firstChild );

    if( fakeUsed ) {
      docElem.removeChild( body );
    } else {
      body.removeChild( div );
    }
    
    //also update eminpx before returning
    ret = eminpx = parseFloat( div.offsetWidth );

    return ret;
  },
  
  //cached container for 1em value, populated the first time it's needed 
  eminpx,
  
  // verify that we have support for a simple media query
  mqSupport = mqRun( '(min-width: 0px)' ).matches;

  return function ( mq ) {
    if( mqSupport ) {
      return mqRun( mq );
    } else {
      var min = mq.match( /\(min\-width[\s]*:[\s]*([\s]*[0-9\.]+)(px|em)[\s]*\)/ ) && parseFloat( RegExp.$1 ) + ( RegExp.$2 || "" ),
          max = mq.match( /\(max\-width[\s]*:[\s]*([\s]*[0-9\.]+)(px|em)[\s]*\)/ ) && parseFloat( RegExp.$1 ) + ( RegExp.$2 || "" ),
          minnull = min === null,
          maxnull = max === null,
          currWidth = doc.body.offsetWidth,
          em = 'em';
      
      if( !!min ) { min = parseFloat( min ) * ( min.indexOf( em ) > -1 ? ( eminpx || getEmValue() ) : 1 ); }
      if( !!max ) { max = parseFloat( max ) * ( max.indexOf( em ) > -1 ? ( eminpx || getEmValue() ) : 1 ); }
      
      bool = ( !minnull || !maxnull ) && ( minnull || currWidth >= min ) && ( maxnull || currWidth <= max );

      return { matches: bool, media: mq };
    }
  };

}( document ));


/*! Picturefill - v2.0.0-beta - 2014-05-02
* http://scottjehl.github.io/picturefill
* Copyright (c) 2014 https://github.com/scottjehl/picturefill/blob/master/Authors.txt; Licensed MIT */
window.matchMedia||(window.matchMedia=function(){"use strict";var a=window.styleMedia||window.media;if(!a){var b=document.createElement("style"),c=document.getElementsByTagName("script")[0],d=null;b.type="text/css",b.id="matchmediajs-test",c.parentNode.insertBefore(b,c),d="getComputedStyle"in window&&window.getComputedStyle(b,null)||b.currentStyle,a={matchMedium:function(a){var c="@media "+a+"{ #matchmediajs-test { width: 1px; } }";return b.styleSheet?b.styleSheet.cssText=c:b.textContent=c,"1px"===d.width}}}return function(b){return{matches:a.matchMedium(b||"all"),media:b||"all"}}}()),function(a,b){"use strict";function c(a){var b,c,d,f,g,h;a=a||{},b=a.elements||e.getAllElements();for(var i=0,j=b.length;j>i;i++)if(c=b[i],d=c.nodeName.toUpperCase(),f=void 0,g=void 0,h=void 0,c[e.ns]||(c[e.ns]={}),a.reevaluate||!c[e.ns].evaluated){if("PICTURE"===d){if(e.removeVideoShim(c),f=e.getMatch(c),f===!1)continue;h=c.getElementsByTagName("img")[0]}else f=void 0,h=c;h&&(h[e.ns]||(h[e.ns]={}),h.srcset&&("PICTURE"===d||h.getAttribute("sizes"))&&e.dodgeSrcset(h),f?(g=e.processSourceSet(f),e.applyBestCandidate(g,h)):(g=e.processSourceSet(h),(void 0===h.srcset||h.getAttribute("sizes"))&&e.applyBestCandidate(g,h)),c[e.ns].evaluated=!0)}}function d(){c();var d=setInterval(function(){return a.picturefill(),/^loaded|^i|^c/.test(b.readyState)?void clearInterval(d):void 0},250);if(a.addEventListener){var e;a.addEventListener("resize",function(){a.clearTimeout(e),e=a.setTimeout(function(){c({reevaluate:!0})},60)},!1)}}if(!a.HTMLPictureElement){b.createElement("picture");var e={};e.ns="picturefill",e.srcsetSupported=void 0!==(new a.Image).srcset,e.trim=function(a){return a.trim?a.trim():a.replace(/^\s+|\s+$/g,"")},e.endsWith=function(a,b){return a.endsWith?a.endsWith(b):-1!==a.indexOf(b,a.length-b.length)},e.matchesMedia=function(b){return a.matchMedia&&a.matchMedia(b).matches},e.getDpr=function(){return a.devicePixelRatio||1},e.getWidthFromLength=function(a){return a=a&&parseFloat(a)>0?a:"100vw",a=a.replace("vw","%"),e.lengthEl||(e.lengthEl=b.createElement("div"),b.documentElement.insertBefore(e.lengthEl,b.documentElement.firstChild)),e.lengthEl.style.cssText="position: absolute; left: 0; width: "+a+";",e.lengthEl.offsetWidth},e.types={},e.types["image/svg+xml"]=b.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#Image","1.1"),e.types["image/webp"]=function(){var b=new a.Image,d="image/webp";b.onerror=function(){e.types[d]=!1,c()},b.onload=function(){e.types[d]=1===b.width,c()},b.src="data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="},e.verifyTypeSupport=function(a){var b=a.getAttribute("type");return null===b||""===b?!0:"function"==typeof e.types[b]?(e.types[b](),"pending"):e.types[b]},e.parseSize=function(a){var b=/(\([^)]+\))?\s*(.+)/g.exec(a);return{media:b&&b[1],length:b&&b[2]}},e.findWidthFromSourceSize=function(a){for(var b,c=e.trim(a).split(/\s*,\s*/),d=0,f=c.length;f>d;d++){var g=c[d],h=e.parseSize(g),i=h.length,j=h.media;if(i&&(!j||e.matchesMedia(j))){b=i;break}}return e.getWidthFromLength(b)},e.getCandidatesFromSourceSet=function(a,b){for(var c=e.trim(a).split(/,\s+/),d=b?e.findWidthFromSourceSize(b):"100%",f=[],g=0,h=c.length;h>g;g++){var i,j=c[g],k=j.split(/\s+/),l=k[1];!l||"w"!==l.slice(-1)&&"x"!==l.slice(-1)||(l=l.slice(0,-1)),i=b?parseFloat(parseInt(l,10)/d):l?parseFloat(l,10):1;var m={url:k[0],resolution:i};f.push(m)}return f},e.dodgeSrcset=function(a){a.srcset&&(a[e.ns].srcset=a.srcset,a.removeAttribute("srcset"))},e.processSourceSet=function(a){var b=a.getAttribute("srcset"),c=a.getAttribute("sizes"),d=[];return"IMG"===a.nodeName.toUpperCase()&&a[e.ns]&&a[e.ns].srcset&&(b=a[e.ns].srcset),b&&(d=e.getCandidatesFromSourceSet(b,c)),d},e.applyBestCandidate=function(a,b){var c,d,f;a.sort(e.ascendingSort),d=a.length,f=a[d-1];for(var g=0;d>g;g++)if(c=a[g],c.resolution>=e.getDpr()){f=c;break}e.endsWith(b.src,f.url)||(b.src=f.url,b.currentSrc=b.src)},e.ascendingSort=function(a,b){return a.resolution-b.resolution},e.removeVideoShim=function(a){var b=a.getElementsByTagName("video");if(b.length){for(var c=b[0],d=c.getElementsByTagName("source");d.length;)a.insertBefore(d[0],c);c.parentNode.removeChild(c)}},e.getAllElements=function(){for(var a=b.getElementsByTagName("picture"),c=[],d=b.getElementsByTagName("img"),f=0,g=a.length+d.length;g>f;f++)if(f<a.length)c[f]=a[f];else{var h=d[f-a.length];"PICTURE"!==h.parentNode.nodeName.toUpperCase()&&(e.srcsetSupported&&h.getAttribute("sizes")||null!==h.getAttribute("srcset"))&&c.push(h)}return c},e.getMatch=function(a){for(var b,c=a.childNodes,d=0,f=c.length;f>d;d++){var g=c[d];if(1===g.nodeType){if("IMG"===g.nodeName.toUpperCase())return b;if("SOURCE"===g.nodeName.toUpperCase()){var h=g.getAttribute("media");if(g.getAttribute("srcset")&&(!h||e.matchesMedia(h))){var i=e.verifyTypeSupport(g);if(i===!0){b=g;break}if("pending"===i)return!1}}}}return b},d(),c._=e,"object"==typeof module&&"object"==typeof module.exports?module.exports=c:"object"==typeof define&&define.amd?define(function(){return c}):"object"==typeof a&&(a.picturefill=c)}}(this,this.document);


/**
 * @preserve FastClick: polyfill to remove click delays on browsers with touch UIs.
 *
 * @version 1.0.2
 * @codingstandard ftlabs-jsv2
 * @copyright The Financial Times Limited [All Rights Reserved]
 * @license MIT License (see LICENSE.txt)
 */
function FastClick(a,b){"use strict";function c(a,b){return function(){return a.apply(b,arguments)}}var d;if(b=b||{},this.trackingClick=!1,this.trackingClickStart=0,this.targetElement=null,this.touchStartX=0,this.touchStartY=0,this.lastTouchIdentifier=0,this.touchBoundary=b.touchBoundary||10,this.layer=a,this.tapDelay=b.tapDelay||200,!FastClick.notNeeded(a)){for(var e=["onMouse","onClick","onTouchStart","onTouchMove","onTouchEnd","onTouchCancel"],f=this,g=0,h=e.length;h>g;g++)f[e[g]]=c(f[e[g]],f);deviceIsAndroid&&(a.addEventListener("mouseover",this.onMouse,!0),a.addEventListener("mousedown",this.onMouse,!0),a.addEventListener("mouseup",this.onMouse,!0)),a.addEventListener("click",this.onClick,!0),a.addEventListener("touchstart",this.onTouchStart,!1),a.addEventListener("touchmove",this.onTouchMove,!1),a.addEventListener("touchend",this.onTouchEnd,!1),a.addEventListener("touchcancel",this.onTouchCancel,!1),Event.prototype.stopImmediatePropagation||(a.removeEventListener=function(b,c,d){var e=Node.prototype.removeEventListener;"click"===b?e.call(a,b,c.hijacked||c,d):e.call(a,b,c,d)},a.addEventListener=function(b,c,d){var e=Node.prototype.addEventListener;"click"===b?e.call(a,b,c.hijacked||(c.hijacked=function(a){a.propagationStopped||c(a)}),d):e.call(a,b,c,d)}),"function"==typeof a.onclick&&(d=a.onclick,a.addEventListener("click",function(a){d(a)},!1),a.onclick=null)}}var deviceIsAndroid=navigator.userAgent.indexOf("Android")>0,deviceIsIOS=/iP(ad|hone|od)/.test(navigator.userAgent),deviceIsIOS4=deviceIsIOS&&/OS 4_\d(_\d)?/.test(navigator.userAgent),deviceIsIOSWithBadTarget=deviceIsIOS&&/OS ([6-9]|\d{2})_\d/.test(navigator.userAgent);FastClick.prototype.needsClick=function(a){"use strict";switch(a.nodeName.toLowerCase()){case"button":case"select":case"textarea":if(a.disabled)return!0;break;case"input":if(deviceIsIOS&&"file"===a.type||a.disabled)return!0;break;case"label":case"video":return!0}return/\bneedsclick\b/.test(a.className)},FastClick.prototype.needsFocus=function(a){"use strict";switch(a.nodeName.toLowerCase()){case"textarea":return!0;case"select":return!deviceIsAndroid;case"input":switch(a.type){case"button":case"checkbox":case"file":case"image":case"radio":case"submit":return!1}return!a.disabled&&!a.readOnly;default:return/\bneedsfocus\b/.test(a.className)}},FastClick.prototype.sendClick=function(a,b){"use strict";var c,d;document.activeElement&&document.activeElement!==a&&document.activeElement.blur(),d=b.changedTouches[0],c=document.createEvent("MouseEvents"),c.initMouseEvent(this.determineEventType(a),!0,!0,window,1,d.screenX,d.screenY,d.clientX,d.clientY,!1,!1,!1,!1,0,null),c.forwardedTouchEvent=!0,a.dispatchEvent(c)},FastClick.prototype.determineEventType=function(a){"use strict";return deviceIsAndroid&&"select"===a.tagName.toLowerCase()?"mousedown":"click"},FastClick.prototype.focus=function(a){"use strict";var b;deviceIsIOS&&a.setSelectionRange&&0!==a.type.indexOf("date")&&"time"!==a.type?(b=a.value.length,a.setSelectionRange(b,b)):a.focus()},FastClick.prototype.updateScrollParent=function(a){"use strict";var b,c;if(b=a.fastClickScrollParent,!b||!b.contains(a)){c=a;do{if(c.scrollHeight>c.offsetHeight){b=c,a.fastClickScrollParent=c;break}c=c.parentElement}while(c)}b&&(b.fastClickLastScrollTop=b.scrollTop)},FastClick.prototype.getTargetElementFromEventTarget=function(a){"use strict";return a.nodeType===Node.TEXT_NODE?a.parentNode:a},FastClick.prototype.onTouchStart=function(a){"use strict";var b,c,d;if(a.targetTouches.length>1)return!0;if(b=this.getTargetElementFromEventTarget(a.target),c=a.targetTouches[0],deviceIsIOS){if(d=window.getSelection(),d.rangeCount&&!d.isCollapsed)return!0;if(!deviceIsIOS4){if(c.identifier===this.lastTouchIdentifier)return a.preventDefault(),!1;this.lastTouchIdentifier=c.identifier,this.updateScrollParent(b)}}return this.trackingClick=!0,this.trackingClickStart=a.timeStamp,this.targetElement=b,this.touchStartX=c.pageX,this.touchStartY=c.pageY,a.timeStamp-this.lastClickTime<this.tapDelay&&a.preventDefault(),!0},FastClick.prototype.touchHasMoved=function(a){"use strict";var b=a.changedTouches[0],c=this.touchBoundary;return Math.abs(b.pageX-this.touchStartX)>c||Math.abs(b.pageY-this.touchStartY)>c?!0:!1},FastClick.prototype.onTouchMove=function(a){"use strict";return this.trackingClick?((this.targetElement!==this.getTargetElementFromEventTarget(a.target)||this.touchHasMoved(a))&&(this.trackingClick=!1,this.targetElement=null),!0):!0},FastClick.prototype.findControl=function(a){"use strict";return void 0!==a.control?a.control:a.htmlFor?document.getElementById(a.htmlFor):a.querySelector("button, input:not([type=hidden]), keygen, meter, output, progress, select, textarea")},FastClick.prototype.onTouchEnd=function(a){"use strict";var b,c,d,e,f,g=this.targetElement;if(!this.trackingClick)return!0;if(a.timeStamp-this.lastClickTime<this.tapDelay)return this.cancelNextClick=!0,!0;if(this.cancelNextClick=!1,this.lastClickTime=a.timeStamp,c=this.trackingClickStart,this.trackingClick=!1,this.trackingClickStart=0,deviceIsIOSWithBadTarget&&(f=a.changedTouches[0],g=document.elementFromPoint(f.pageX-window.pageXOffset,f.pageY-window.pageYOffset)||g,g.fastClickScrollParent=this.targetElement.fastClickScrollParent),d=g.tagName.toLowerCase(),"label"===d){if(b=this.findControl(g)){if(this.focus(g),deviceIsAndroid)return!1;g=b}}else if(this.needsFocus(g))return a.timeStamp-c>100||deviceIsIOS&&window.top!==window&&"input"===d?(this.targetElement=null,!1):(this.focus(g),this.sendClick(g,a),deviceIsIOS&&"select"===d||(this.targetElement=null,a.preventDefault()),!1);return deviceIsIOS&&!deviceIsIOS4&&(e=g.fastClickScrollParent,e&&e.fastClickLastScrollTop!==e.scrollTop)?!0:(this.needsClick(g)||(a.preventDefault(),this.sendClick(g,a)),!1)},FastClick.prototype.onTouchCancel=function(){"use strict";this.trackingClick=!1,this.targetElement=null},FastClick.prototype.onMouse=function(a){"use strict";return this.targetElement?a.forwardedTouchEvent?!0:a.cancelable&&(!this.needsClick(this.targetElement)||this.cancelNextClick)?(a.stopImmediatePropagation?a.stopImmediatePropagation():a.propagationStopped=!0,a.stopPropagation(),a.preventDefault(),!1):!0:!0},FastClick.prototype.onClick=function(a){"use strict";var b;return this.trackingClick?(this.targetElement=null,this.trackingClick=!1,!0):"submit"===a.target.type&&0===a.detail?!0:(b=this.onMouse(a),b||(this.targetElement=null),b)},FastClick.prototype.destroy=function(){"use strict";var a=this.layer;deviceIsAndroid&&(a.removeEventListener("mouseover",this.onMouse,!0),a.removeEventListener("mousedown",this.onMouse,!0),a.removeEventListener("mouseup",this.onMouse,!0)),a.removeEventListener("click",this.onClick,!0),a.removeEventListener("touchstart",this.onTouchStart,!1),a.removeEventListener("touchmove",this.onTouchMove,!1),a.removeEventListener("touchend",this.onTouchEnd,!1),a.removeEventListener("touchcancel",this.onTouchCancel,!1)},FastClick.notNeeded=function(a){"use strict";var b,c;if("undefined"==typeof window.ontouchstart)return!0;if(c=+(/Chrome\/([0-9]+)/.exec(navigator.userAgent)||[,0])[1]){if(!deviceIsAndroid)return!0;if(b=document.querySelector("meta[name=viewport]")){if(-1!==b.content.indexOf("user-scalable=no"))return!0;if(c>31&&document.documentElement.scrollWidth<=window.outerWidth)return!0}}return"none"===a.style.msTouchAction?!0:!1},FastClick.attach=function(a,b){"use strict";return new FastClick(a,b)},"function"==typeof define&&"object"==typeof define.amd&&define.amd?define(function(){"use strict";return FastClick}):"undefined"!=typeof module&&module.exports?(module.exports=FastClick.attach,module.exports.FastClick=FastClick):window.FastClick=FastClick;


/*
 * jQuery FlexSlider v2.5.0
 * Copyright 2012 WooThemes
 * Contributing Author: Tyler Smith
 */
;
(function ($) {

  //FlexSlider: Object Instance
  $.flexslider = function(el, options) {
    var slider = $(el);

    // making variables public
    slider.vars = $.extend({}, $.flexslider.defaults, options);

    var namespace = slider.vars.namespace,
        msGesture = window.navigator && window.navigator.msPointerEnabled && window.MSGesture,
        touch = (( "ontouchstart" in window ) || msGesture || window.DocumentTouch && document instanceof DocumentTouch) && slider.vars.touch,
        // depricating this idea, as devices are being released with both of these events
        //eventType = (touch) ? "touchend" : "click",
        eventType = "click touchend MSPointerUp keyup",
        watchedEvent = "",
        watchedEventClearTimer,
        vertical = slider.vars.direction === "vertical",
        reverse = slider.vars.reverse,
        carousel = (slider.vars.itemWidth > 0),
        fade = slider.vars.animation === "fade",
        asNav = slider.vars.asNavFor !== "",
        methods = {},
        focused = true;

    // Store a reference to the slider object
    $.data(el, "flexslider", slider);

    // Private slider methods
    methods = {
      init: function() {
        slider.animating = false;
        // Get current slide and make sure it is a number
        slider.currentSlide = parseInt( ( slider.vars.startAt ? slider.vars.startAt : 0), 10 );
        if ( isNaN( slider.currentSlide ) ) { slider.currentSlide = 0; }
        slider.animatingTo = slider.currentSlide;
        slider.atEnd = (slider.currentSlide === 0 || slider.currentSlide === slider.last);
        slider.containerSelector = slider.vars.selector.substr(0,slider.vars.selector.search(' '));
        slider.slides = $(slider.vars.selector, slider);
        slider.container = $(slider.containerSelector, slider);
        slider.count = slider.slides.length;
        // SYNC:
        slider.syncExists = $(slider.vars.sync).length > 0;
        // SLIDE:
        if (slider.vars.animation === "slide") { slider.vars.animation = "swing"; }
        slider.prop = (vertical) ? "top" : "marginLeft";
        slider.args = {};
        // SLIDESHOW:
        slider.manualPause = false;
        slider.stopped = false;
        //PAUSE WHEN INVISIBLE
        slider.started = false;
        slider.startTimeout = null;
        // TOUCH/USECSS:
        slider.transitions = !slider.vars.video && !fade && slider.vars.useCSS && (function() {
          var obj = document.createElement('div'),
              props = ['perspectiveProperty', 'WebkitPerspective', 'MozPerspective', 'OPerspective', 'msPerspective'];
          for (var i in props) {
            if ( obj.style[ props[i] ] !== undefined ) {
              slider.pfx = props[i].replace('Perspective','').toLowerCase();
              slider.prop = "-" + slider.pfx + "-transform";
              return true;
            }
          }
          return false;
        }());
        slider.ensureAnimationEnd = '';
        // CONTROLSCONTAINER:
        if (slider.vars.controlsContainer !== "") slider.controlsContainer = $(slider.vars.controlsContainer).length > 0 && $(slider.vars.controlsContainer);
        // MANUAL:
        if (slider.vars.manualControls !== "") slider.manualControls = $(slider.vars.manualControls).length > 0 && $(slider.vars.manualControls);

        // CUSTOM DIRECTION NAV:
        if (slider.vars.customDirectionNav !== "") slider.customDirectionNav = $(slider.vars.customDirectionNav).length === 2 && $(slider.vars.customDirectionNav);

        // RANDOMIZE:
        if (slider.vars.randomize) {
          slider.slides.sort(function() { return (Math.round(Math.random())-0.5); });
          slider.container.empty().append(slider.slides);
        }

        slider.doMath();

        // INIT
        slider.setup("init");

        // CONTROLNAV:
        if (slider.vars.controlNav) { methods.controlNav.setup(); }

        // DIRECTIONNAV:
        if (slider.vars.directionNav) { methods.directionNav.setup(); }

        // KEYBOARD:
        if (slider.vars.keyboard && ($(slider.containerSelector).length === 1 || slider.vars.multipleKeyboard)) {
          $(document).bind('keyup', function(event) {
            var keycode = event.keyCode;
            if (!slider.animating && (keycode === 39 || keycode === 37)) {
              var target = (keycode === 39) ? slider.getTarget('next') :
                           (keycode === 37) ? slider.getTarget('prev') : false;
              slider.flexAnimate(target, slider.vars.pauseOnAction);
            }
          });
        }
        // MOUSEWHEEL:
        if (slider.vars.mousewheel) {
          slider.bind('mousewheel', function(event, delta, deltaX, deltaY) {
            event.preventDefault();
            var target = (delta < 0) ? slider.getTarget('next') : slider.getTarget('prev');
            slider.flexAnimate(target, slider.vars.pauseOnAction);
          });
        }

        // PAUSEPLAY
        if (slider.vars.pausePlay) { methods.pausePlay.setup(); }

        //PAUSE WHEN INVISIBLE
        if (slider.vars.slideshow && slider.vars.pauseInvisible) { methods.pauseInvisible.init(); }

        // SLIDSESHOW
        if (slider.vars.slideshow) {
          if (slider.vars.pauseOnHover) {
            slider.hover(function() {
              if (!slider.manualPlay && !slider.manualPause) { slider.pause(); }
            }, function() {
              if (!slider.manualPause && !slider.manualPlay && !slider.stopped) { slider.play(); }
            });
          }
          // initialize animation
          //If we're visible, or we don't use PageVisibility API
          if(!slider.vars.pauseInvisible || !methods.pauseInvisible.isHidden()) {
            (slider.vars.initDelay > 0) ? slider.startTimeout = setTimeout(slider.play, slider.vars.initDelay) : slider.play();
          }
        }

        // ASNAV:
        if (asNav) { methods.asNav.setup(); }

        // TOUCH
        if (touch && slider.vars.touch) { methods.touch(); }

        // FADE&&SMOOTHHEIGHT || SLIDE:
        if (!fade || (fade && slider.vars.smoothHeight)) { $(window).bind("resize orientationchange focus", methods.resize); }

        slider.find("img").attr("draggable", "false");

        // API: start() Callback
        setTimeout(function(){
          slider.vars.start(slider);
        }, 200);
      },
      asNav: {
        setup: function() {
          slider.asNav = true;
          slider.animatingTo = Math.floor(slider.currentSlide/slider.move);
          slider.currentItem = slider.currentSlide;
          slider.slides.removeClass(namespace + "active-slide").eq(slider.currentItem).addClass(namespace + "active-slide");
          if(!msGesture){
              slider.slides.on(eventType, function(e){
                e.preventDefault();
                var $slide = $(this),
                    target = $slide.index();
                var posFromLeft = $slide.offset().left - $(slider).scrollLeft(); // Find position of slide relative to left of slider container
                if( posFromLeft <= 0 && $slide.hasClass( namespace + 'active-slide' ) ) {
                  slider.flexAnimate(slider.getTarget("prev"), true);
                } else if (!$(slider.vars.asNavFor).data('flexslider').animating && !$slide.hasClass(namespace + "active-slide")) {
                  slider.direction = (slider.currentItem < target) ? "next" : "prev";
                  slider.flexAnimate(target, slider.vars.pauseOnAction, false, true, true);
                }
              });
          }else{
              el._slider = slider;
              slider.slides.each(function (){
                  var that = this;
                  that._gesture = new MSGesture();
                  that._gesture.target = that;
                  that.addEventListener("MSPointerDown", function (e){
                      e.preventDefault();
                      if(e.currentTarget._gesture) {
                        e.currentTarget._gesture.addPointer(e.pointerId);
                      }
                  }, false);
                  that.addEventListener("MSGestureTap", function (e){
                      e.preventDefault();
                      var $slide = $(this),
                          target = $slide.index();
                      if (!$(slider.vars.asNavFor).data('flexslider').animating && !$slide.hasClass('active')) {
                          slider.direction = (slider.currentItem < target) ? "next" : "prev";
                          slider.flexAnimate(target, slider.vars.pauseOnAction, false, true, true);
                      }
                  });
              });
          }
        }
      },
      controlNav: {
        setup: function() {
          if (!slider.manualControls) {
            methods.controlNav.setupPaging();
          } else { // MANUALCONTROLS:
            methods.controlNav.setupManual();
          }
        },
        setupPaging: function() {
          var type = (slider.vars.controlNav === "thumbnails") ? 'control-thumbs' : 'control-paging',
              j = 1,
              item,
              slide;

          slider.controlNavScaffold = $('<ol class="'+ namespace + 'control-nav ' + namespace + type + '"></ol>');

          if (slider.pagingCount > 1) {
            for (var i = 0; i < slider.pagingCount; i++) {
              slide = slider.slides.eq(i);
              item = (slider.vars.controlNav === "thumbnails") ? '<img src="' + slide.attr( 'data-thumb' ) + '"/>' : '<a>' + j + '</a>';
              if ( 'thumbnails' === slider.vars.controlNav && true === slider.vars.thumbCaptions ) {
                var captn = slide.attr( 'data-thumbcaption' );
                if ( '' !== captn && undefined !== captn ) { item += '<span class="' + namespace + 'caption">' + captn + '</span>'; }
              }
              slider.controlNavScaffold.append('<li>' + item + '</li>');
              j++;
            }
          }

          // CONTROLSCONTAINER:
          (slider.controlsContainer) ? $(slider.controlsContainer).append(slider.controlNavScaffold) : slider.append(slider.controlNavScaffold);
          methods.controlNav.set();

          methods.controlNav.active();

          slider.controlNavScaffold.delegate('a, img', eventType, function(event) {
            event.preventDefault();

            if (watchedEvent === "" || watchedEvent === event.type) {
              var $this = $(this),
                  target = slider.controlNav.index($this);

              if (!$this.hasClass(namespace + 'active')) {
                slider.direction = (target > slider.currentSlide) ? "next" : "prev";
                slider.flexAnimate(target, slider.vars.pauseOnAction);
              }
            }

            // setup flags to prevent event duplication
            if (watchedEvent === "") {
              watchedEvent = event.type;
            }
            methods.setToClearWatchedEvent();

          });
        },
        setupManual: function() {
          slider.controlNav = slider.manualControls;
          methods.controlNav.active();

          slider.controlNav.bind(eventType, function(event) {
            event.preventDefault();

            if (watchedEvent === "" || watchedEvent === event.type) {
              var $this = $(this),
                  target = slider.controlNav.index($this);

              if (!$this.hasClass(namespace + 'active')) {
                (target > slider.currentSlide) ? slider.direction = "next" : slider.direction = "prev";
                slider.flexAnimate(target, slider.vars.pauseOnAction);
              }
            }

            // setup flags to prevent event duplication
            if (watchedEvent === "") {
              watchedEvent = event.type;
            }
            methods.setToClearWatchedEvent();
          });
        },
        set: function() {
          var selector = (slider.vars.controlNav === "thumbnails") ? 'img' : 'a';
          slider.controlNav = $('.' + namespace + 'control-nav li ' + selector, (slider.controlsContainer) ? slider.controlsContainer : slider);
        },
        active: function() {
          slider.controlNav.removeClass(namespace + "active").eq(slider.animatingTo).addClass(namespace + "active");
        },
        update: function(action, pos) {
          if (slider.pagingCount > 1 && action === "add") {
            slider.controlNavScaffold.append($('<li><a>' + slider.count + '</a></li>'));
          } else if (slider.pagingCount === 1) {
            slider.controlNavScaffold.find('li').remove();
          } else {
            slider.controlNav.eq(pos).closest('li').remove();
          }
          methods.controlNav.set();
          (slider.pagingCount > 1 && slider.pagingCount !== slider.controlNav.length) ? slider.update(pos, action) : methods.controlNav.active();
        }
      },
      directionNav: {
        setup: function() {
          var directionNavScaffold = $('<ul class="' + namespace + 'direction-nav"><li class="' + namespace + 'nav-prev"><a class="' + namespace + 'prev" href="#">' + slider.vars.prevText + '</a></li><li class="' + namespace + 'nav-next"><a class="' + namespace + 'next" href="#">' + slider.vars.nextText + '</a></li></ul>');

          // CUSTOM DIRECTION NAV:
          if (slider.customDirectionNav) {
            slider.directionNav = slider.customDirectionNav;
          // CONTROLSCONTAINER:
          } else if (slider.controlsContainer) {
            $(slider.controlsContainer).append(directionNavScaffold);
            slider.directionNav = $('.' + namespace + 'direction-nav li a', slider.controlsContainer);
          } else {
            slider.append(directionNavScaffold);
            slider.directionNav = $('.' + namespace + 'direction-nav li a', slider);
          }

          methods.directionNav.update();

          slider.directionNav.bind(eventType, function(event) {
            event.preventDefault();
            var target;

            if (watchedEvent === "" || watchedEvent === event.type) {
              target = ($(this).hasClass(namespace + 'next')) ? slider.getTarget('next') : slider.getTarget('prev');
              slider.flexAnimate(target, slider.vars.pauseOnAction);
            }

            // setup flags to prevent event duplication
            if (watchedEvent === "") {
              watchedEvent = event.type;
            }
            methods.setToClearWatchedEvent();
          });
        },
        update: function() {
          var disabledClass = namespace + 'disabled';
          if (slider.pagingCount === 1) {
            slider.directionNav.addClass(disabledClass).attr('tabindex', '-1');
          } else if (!slider.vars.animationLoop) {
            if (slider.animatingTo === 0) {
              slider.directionNav.removeClass(disabledClass).filter('.' + namespace + "prev").addClass(disabledClass).attr('tabindex', '-1');
            } else if (slider.animatingTo === slider.last) {
              slider.directionNav.removeClass(disabledClass).filter('.' + namespace + "next").addClass(disabledClass).attr('tabindex', '-1');
            } else {
              slider.directionNav.removeClass(disabledClass).removeAttr('tabindex');
            }
          } else {
            slider.directionNav.removeClass(disabledClass).removeAttr('tabindex');
          }
        }
      },
      pausePlay: {
        setup: function() {
          var pausePlayScaffold = $('<div class="' + namespace + 'pauseplay"><a></a></div>');

          // CONTROLSCONTAINER:
          if (slider.controlsContainer) {
            slider.controlsContainer.append(pausePlayScaffold);
            slider.pausePlay = $('.' + namespace + 'pauseplay a', slider.controlsContainer);
          } else {
            slider.append(pausePlayScaffold);
            slider.pausePlay = $('.' + namespace + 'pauseplay a', slider);
          }

          methods.pausePlay.update((slider.vars.slideshow) ? namespace + 'pause' : namespace + 'play');

          slider.pausePlay.bind(eventType, function(event) {
            event.preventDefault();

            if (watchedEvent === "" || watchedEvent === event.type) {
              if ($(this).hasClass(namespace + 'pause')) {
                slider.manualPause = true;
                slider.manualPlay = false;
                slider.pause();
              } else {
                slider.manualPause = false;
                slider.manualPlay = true;
                slider.play();
              }
            }

            // setup flags to prevent event duplication
            if (watchedEvent === "") {
              watchedEvent = event.type;
            }
            methods.setToClearWatchedEvent();
          });
        },
        update: function(state) {
          (state === "play") ? slider.pausePlay.removeClass(namespace + 'pause').addClass(namespace + 'play').html(slider.vars.playText) : slider.pausePlay.removeClass(namespace + 'play').addClass(namespace + 'pause').html(slider.vars.pauseText);
        }
      },
      touch: function() {
        var startX,
          startY,
          offset,
          cwidth,
          dx,
          startT,
          onTouchStart,
          onTouchMove,
          onTouchEnd,
          scrolling = false,
          localX = 0,
          localY = 0,
          accDx = 0;

        if(!msGesture){
            onTouchStart = function(e) {
              if (slider.animating) {
                e.preventDefault();
              } else if ( ( window.navigator.msPointerEnabled ) || e.touches.length === 1 ) {
                slider.pause();
                // CAROUSEL:
                cwidth = (vertical) ? slider.h : slider. w;
                startT = Number(new Date());
                // CAROUSEL:

                // Local vars for X and Y points.
                localX = e.touches[0].pageX;
                localY = e.touches[0].pageY;

                offset = (carousel && reverse && slider.animatingTo === slider.last) ? 0 :
                         (carousel && reverse) ? slider.limit - (((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.animatingTo) :
                         (carousel && slider.currentSlide === slider.last) ? slider.limit :
                         (carousel) ? ((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.currentSlide :
                         (reverse) ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth;
                startX = (vertical) ? localY : localX;
                startY = (vertical) ? localX : localY;

                el.addEventListener('touchmove', onTouchMove, false);
                el.addEventListener('touchend', onTouchEnd, false);
              }
            };

            onTouchMove = function(e) {
              // Local vars for X and Y points.

              localX = e.touches[0].pageX;
              localY = e.touches[0].pageY;

              dx = (vertical) ? startX - localY : startX - localX;
              scrolling = (vertical) ? (Math.abs(dx) < Math.abs(localX - startY)) : (Math.abs(dx) < Math.abs(localY - startY));

              var fxms = 500;

              if ( ! scrolling || Number( new Date() ) - startT > fxms ) {
                e.preventDefault();
                if (!fade && slider.transitions) {
                  if (!slider.vars.animationLoop) {
                    dx = dx/((slider.currentSlide === 0 && dx < 0 || slider.currentSlide === slider.last && dx > 0) ? (Math.abs(dx)/cwidth+2) : 1);
                  }
                  slider.setProps(offset + dx, "setTouch");
                }
              }
            };

            onTouchEnd = function(e) {
              // finish the touch by undoing the touch session
              el.removeEventListener('touchmove', onTouchMove, false);

              if (slider.animatingTo === slider.currentSlide && !scrolling && !(dx === null)) {
                var updateDx = (reverse) ? -dx : dx,
                    target = (updateDx > 0) ? slider.getTarget('next') : slider.getTarget('prev');

                if (slider.canAdvance(target) && (Number(new Date()) - startT < 550 && Math.abs(updateDx) > 50 || Math.abs(updateDx) > cwidth/2)) {
                  slider.flexAnimate(target, slider.vars.pauseOnAction);
                } else {
                  if (!fade) { slider.flexAnimate(slider.currentSlide, slider.vars.pauseOnAction, true); }
                }
              }
              el.removeEventListener('touchend', onTouchEnd, false);

              startX = null;
              startY = null;
              dx = null;
              offset = null;
            };

            el.addEventListener('touchstart', onTouchStart, false);
        }else{
            el.style.msTouchAction = "none";
            el._gesture = new MSGesture();
            el._gesture.target = el;
            el.addEventListener("MSPointerDown", onMSPointerDown, false);
            el._slider = slider;
            el.addEventListener("MSGestureChange", onMSGestureChange, false);
            el.addEventListener("MSGestureEnd", onMSGestureEnd, false);

            function onMSPointerDown(e){
                e.stopPropagation();
                if (slider.animating) {
                    e.preventDefault();
                }else{
                    slider.pause();
                    el._gesture.addPointer(e.pointerId);
                    accDx = 0;
                    cwidth = (vertical) ? slider.h : slider. w;
                    startT = Number(new Date());
                    // CAROUSEL:

                    offset = (carousel && reverse && slider.animatingTo === slider.last) ? 0 :
                        (carousel && reverse) ? slider.limit - (((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.animatingTo) :
                            (carousel && slider.currentSlide === slider.last) ? slider.limit :
                                (carousel) ? ((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.currentSlide :
                                    (reverse) ? (slider.last - slider.currentSlide + slider.cloneOffset) * cwidth : (slider.currentSlide + slider.cloneOffset) * cwidth;
                }
            }

            function onMSGestureChange(e) {
                e.stopPropagation();
                var slider = e.target._slider;
                if(!slider){
                    return;
                }
                var transX = -e.translationX,
                    transY = -e.translationY;

                //Accumulate translations.
                accDx = accDx + ((vertical) ? transY : transX);
                dx = accDx;
                scrolling = (vertical) ? (Math.abs(accDx) < Math.abs(-transX)) : (Math.abs(accDx) < Math.abs(-transY));

                if(e.detail === e.MSGESTURE_FLAG_INERTIA){
                    setImmediate(function (){
                        el._gesture.stop();
                    });

                    return;
                }

                if (!scrolling || Number(new Date()) - startT > 500) {
                    e.preventDefault();
                    if (!fade && slider.transitions) {
                        if (!slider.vars.animationLoop) {
                            dx = accDx / ((slider.currentSlide === 0 && accDx < 0 || slider.currentSlide === slider.last && accDx > 0) ? (Math.abs(accDx) / cwidth + 2) : 1);
                        }
                        slider.setProps(offset + dx, "setTouch");
                    }
                }
            }

            function onMSGestureEnd(e) {
                e.stopPropagation();
                var slider = e.target._slider;
                if(!slider){
                    return;
                }
                if (slider.animatingTo === slider.currentSlide && !scrolling && !(dx === null)) {
                    var updateDx = (reverse) ? -dx : dx,
                        target = (updateDx > 0) ? slider.getTarget('next') : slider.getTarget('prev');

                    if (slider.canAdvance(target) && (Number(new Date()) - startT < 550 && Math.abs(updateDx) > 50 || Math.abs(updateDx) > cwidth/2)) {
                        slider.flexAnimate(target, slider.vars.pauseOnAction);
                    } else {
                        if (!fade) { slider.flexAnimate(slider.currentSlide, slider.vars.pauseOnAction, true); }
                    }
                }

                startX = null;
                startY = null;
                dx = null;
                offset = null;
                accDx = 0;
            }
        }
      },
      resize: function() {
        if (!slider.animating && slider.is(':visible')) {
          if (!carousel) { slider.doMath(); }

          if (fade) {
            // SMOOTH HEIGHT:
            methods.smoothHeight();
          } else if (carousel) { //CAROUSEL:
            slider.slides.width(slider.computedW);
            slider.update(slider.pagingCount);
            slider.setProps();
          }
          else if (vertical) { //VERTICAL:
            slider.viewport.height(slider.h);
            slider.setProps(slider.h, "setTotal");
          } else {
            // SMOOTH HEIGHT:
            if (slider.vars.smoothHeight) { methods.smoothHeight(); }
            slider.newSlides.width(slider.computedW);
            slider.setProps(slider.computedW, "setTotal");
          }
        }
      },
      smoothHeight: function(dur) {
        if (!vertical || fade) {
          var $obj = (fade) ? slider : slider.viewport;
          (dur) ? $obj.animate({"height": slider.slides.eq(slider.animatingTo).height()}, dur) : $obj.height(slider.slides.eq(slider.animatingTo).height());
        }
      },
      sync: function(action) {
        var $obj = $(slider.vars.sync).data("flexslider"),
            target = slider.animatingTo;

        switch (action) {
          case "animate": $obj.flexAnimate(target, slider.vars.pauseOnAction, false, true); break;
          case "play": if (!$obj.playing && !$obj.asNav) { $obj.play(); } break;
          case "pause": $obj.pause(); break;
        }
      },
      uniqueID: function($clone) {
        // Append _clone to current level and children elements with id attributes
        $clone.filter( '[id]' ).add($clone.find( '[id]' )).each(function() {
          var $this = $(this);
          $this.attr( 'id', $this.attr( 'id' ) + '_clone' );
        });
        return $clone;
      },
      pauseInvisible: {
        visProp: null,
        init: function() {
          var visProp = methods.pauseInvisible.getHiddenProp();
          if (visProp) {
            var evtname = visProp.replace(/[H|h]idden/,'') + 'visibilitychange';
            document.addEventListener(evtname, function() {
              if (methods.pauseInvisible.isHidden()) {
                if(slider.startTimeout) {
                  clearTimeout(slider.startTimeout); //If clock is ticking, stop timer and prevent from starting while invisible
                } else { 
                  slider.pause(); //Or just pause
                }
              }
              else {
                if(slider.started) {
                  slider.play(); //Initiated before, just play
                } else { 
                  if (slider.vars.initDelay > 0) { 
                    setTimeout(slider.play, slider.vars.initDelay);
                  } else {
                    slider.play(); //Didn't init before: simply init or wait for it
                  } 
                }
              }
            });
          }
        },
        isHidden: function() {
          var prop = methods.pauseInvisible.getHiddenProp();
          if (!prop) {
            return false;
          }
          return document[prop];
        },
        getHiddenProp: function() {
          var prefixes = ['webkit','moz','ms','o'];
          // if 'hidden' is natively supported just return it
          if ('hidden' in document) {
            return 'hidden';
          }
          // otherwise loop over all the known prefixes until we find one
          for ( var i = 0; i < prefixes.length; i++ ) {
              if ((prefixes[i] + 'Hidden') in document) {
                return prefixes[i] + 'Hidden';
              }
          }
          // otherwise it's not supported
          return null;
        }
      },
      setToClearWatchedEvent: function() {
        clearTimeout(watchedEventClearTimer);
        watchedEventClearTimer = setTimeout(function() {
          watchedEvent = "";
        }, 3000);
      }
    };

    // public methods
    slider.flexAnimate = function(target, pause, override, withSync, fromNav) {
      if (!slider.vars.animationLoop && target !== slider.currentSlide) {
        slider.direction = (target > slider.currentSlide) ? "next" : "prev";
      }

      if (asNav && slider.pagingCount === 1) slider.direction = (slider.currentItem < target) ? "next" : "prev";

      if (!slider.animating && (slider.canAdvance(target, fromNav) || override) && slider.is(":visible")) {
        if (asNav && withSync) {
          var master = $(slider.vars.asNavFor).data('flexslider');
          slider.atEnd = target === 0 || target === slider.count - 1;
          master.flexAnimate(target, true, false, true, fromNav);
          slider.direction = (slider.currentItem < target) ? "next" : "prev";
          master.direction = slider.direction;

          if (Math.ceil((target + 1)/slider.visible) - 1 !== slider.currentSlide && target !== 0) {
            slider.currentItem = target;
            slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
            target = Math.floor(target/slider.visible);
          } else {
            slider.currentItem = target;
            slider.slides.removeClass(namespace + "active-slide").eq(target).addClass(namespace + "active-slide");
            return false;
          }
        }

        slider.animating = true;
        slider.animatingTo = target;

        // SLIDESHOW:
        if (pause) { slider.pause(); }

        // API: before() animation Callback
        slider.vars.before(slider);

        // SYNC:
        if (slider.syncExists && !fromNav) { methods.sync("animate"); }

        // CONTROLNAV
        if (slider.vars.controlNav) { methods.controlNav.active(); }

        // !CAROUSEL:
        // CANDIDATE: slide active class (for add/remove slide)
        if (!carousel) { slider.slides.removeClass(namespace + 'active-slide').eq(target).addClass(namespace + 'active-slide'); }

        // INFINITE LOOP:
        // CANDIDATE: atEnd
        slider.atEnd = target === 0 || target === slider.last;

        // DIRECTIONNAV:
        if (slider.vars.directionNav) { methods.directionNav.update(); }

        if (target === slider.last) {
          // API: end() of cycle Callback
          slider.vars.end(slider);
          // SLIDESHOW && !INFINITE LOOP:
          if (!slider.vars.animationLoop) { slider.pause(); }
        }

        // SLIDE:
        if (!fade) {
          var dimension = (vertical) ? slider.slides.filter(':first').height() : slider.computedW,
              margin, slideString, calcNext;

          // INFINITE LOOP / REVERSE:
          if (carousel) {
            //margin = (slider.vars.itemWidth > slider.w) ? slider.vars.itemMargin * 2 : slider.vars.itemMargin;
            margin = slider.vars.itemMargin;
            calcNext = ((slider.itemW + margin) * slider.move) * slider.animatingTo;
            slideString = (calcNext > slider.limit && slider.visible !== 1) ? slider.limit : calcNext;
          } else if (slider.currentSlide === 0 && target === slider.count - 1 && slider.vars.animationLoop && slider.direction !== "next") {
            slideString = (reverse) ? (slider.count + slider.cloneOffset) * dimension : 0;
          } else if (slider.currentSlide === slider.last && target === 0 && slider.vars.animationLoop && slider.direction !== "prev") {
            slideString = (reverse) ? 0 : (slider.count + 1) * dimension;
          } else {
            slideString = (reverse) ? ((slider.count - 1) - target + slider.cloneOffset) * dimension : (target + slider.cloneOffset) * dimension;
          }
          slider.setProps(slideString, "", slider.vars.animationSpeed);
          if (slider.transitions) {
            if (!slider.vars.animationLoop || !slider.atEnd) {
              slider.animating = false;
              slider.currentSlide = slider.animatingTo;
            }
            
            // Unbind previous transitionEnd events and re-bind new transitionEnd event
            slider.container.unbind("webkitTransitionEnd transitionend");
            slider.container.bind("webkitTransitionEnd transitionend", function() {
              clearTimeout(slider.ensureAnimationEnd);
              slider.wrapup(dimension);
            });

            // Insurance for the ever-so-fickle transitionEnd event
            clearTimeout(slider.ensureAnimationEnd);
            slider.ensureAnimationEnd = setTimeout(function() {
              slider.wrapup(dimension);
            }, slider.vars.animationSpeed + 100);

          } else {
            slider.container.animate(slider.args, slider.vars.animationSpeed, slider.vars.easing, function(){
              slider.wrapup(dimension);
            });
          }
        } else { // FADE:
          if (!touch) {
            //slider.slides.eq(slider.currentSlide).fadeOut(slider.vars.animationSpeed, slider.vars.easing);
            //slider.slides.eq(target).fadeIn(slider.vars.animationSpeed, slider.vars.easing, slider.wrapup);

            slider.slides.eq(slider.currentSlide).css({"zIndex": 1}).animate({"opacity": 0}, slider.vars.animationSpeed, slider.vars.easing);
            slider.slides.eq(target).css({"zIndex": 2}).animate({"opacity": 1}, slider.vars.animationSpeed, slider.vars.easing, slider.wrapup);

          } else {
            slider.slides.eq(slider.currentSlide).css({ "opacity": 0, "zIndex": 1 });
            slider.slides.eq(target).css({ "opacity": 1, "zIndex": 2 });
            slider.wrapup(dimension);
          }
        }
        // SMOOTH HEIGHT:
        if (slider.vars.smoothHeight) { methods.smoothHeight(slider.vars.animationSpeed); }
      }
    };
    slider.wrapup = function(dimension) {
      // SLIDE:
      if (!fade && !carousel) {
        if (slider.currentSlide === 0 && slider.animatingTo === slider.last && slider.vars.animationLoop) {
          slider.setProps(dimension, "jumpEnd");
        } else if (slider.currentSlide === slider.last && slider.animatingTo === 0 && slider.vars.animationLoop) {
          slider.setProps(dimension, "jumpStart");
        }
      }
      slider.animating = false;
      slider.currentSlide = slider.animatingTo;
      // API: after() animation Callback
      slider.vars.after(slider);
    };

    // SLIDESHOW:
    slider.animateSlides = function() {
      if (!slider.animating && focused ) { slider.flexAnimate(slider.getTarget("next")); }
    };
    // SLIDESHOW:
    slider.pause = function() {
      clearInterval(slider.animatedSlides);
      slider.animatedSlides = null;
      slider.playing = false;
      // PAUSEPLAY:
      if (slider.vars.pausePlay) { methods.pausePlay.update("play"); }
      // SYNC:
      if (slider.syncExists) { methods.sync("pause"); }
    };
    // SLIDESHOW:
    slider.play = function() {
      if (slider.playing) { clearInterval(slider.animatedSlides); }
      slider.animatedSlides = slider.animatedSlides || setInterval(slider.animateSlides, slider.vars.slideshowSpeed);
      slider.started = slider.playing = true;
      // PAUSEPLAY:
      if (slider.vars.pausePlay) { methods.pausePlay.update("pause"); }
      // SYNC:
      if (slider.syncExists) { methods.sync("play"); }
    };
    // STOP:
    slider.stop = function () {
      slider.pause();
      slider.stopped = true;
    };
    slider.canAdvance = function(target, fromNav) {
      // ASNAV:
      var last = (asNav) ? slider.pagingCount - 1 : slider.last;
      return (fromNav) ? true :
             (asNav && slider.currentItem === slider.count - 1 && target === 0 && slider.direction === "prev") ? true :
             (asNav && slider.currentItem === 0 && target === slider.pagingCount - 1 && slider.direction !== "next") ? false :
             (target === slider.currentSlide && !asNav) ? false :
             (slider.vars.animationLoop) ? true :
             (slider.atEnd && slider.currentSlide === 0 && target === last && slider.direction !== "next") ? false :
             (slider.atEnd && slider.currentSlide === last && target === 0 && slider.direction === "next") ? false :
             true;
    };
    slider.getTarget = function(dir) {
      slider.direction = dir;
      if (dir === "next") {
        return (slider.currentSlide === slider.last) ? 0 : slider.currentSlide + 1;
      } else {
        return (slider.currentSlide === 0) ? slider.last : slider.currentSlide - 1;
      }
    };

    // SLIDE:
    slider.setProps = function(pos, special, dur) {
      var target = (function() {
        var posCheck = (pos) ? pos : ((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.animatingTo,
            posCalc = (function() {
              if (carousel) {
                return (special === "setTouch") ? pos :
                       (reverse && slider.animatingTo === slider.last) ? 0 :
                       (reverse) ? slider.limit - (((slider.itemW + slider.vars.itemMargin) * slider.move) * slider.animatingTo) :
                       (slider.animatingTo === slider.last) ? slider.limit : posCheck;
              } else {
                switch (special) {
                  case "setTotal": return (reverse) ? ((slider.count - 1) - slider.currentSlide + slider.cloneOffset) * pos : (slider.currentSlide + slider.cloneOffset) * pos;
                  case "setTouch": return (reverse) ? pos : pos;
                  case "jumpEnd": return (reverse) ? pos : slider.count * pos;
                  case "jumpStart": return (reverse) ? slider.count * pos : pos;
                  default: return pos;
                }
              }
            }());

            return (posCalc * -1) + "px";
          }());

      if (slider.transitions) {
        target = (vertical) ? "translate3d(0," + target + ",0)" : "translate3d(" + target + ",0,0)";
        dur = (dur !== undefined) ? (dur/1000) + "s" : "0s";
        slider.container.css("-" + slider.pfx + "-transition-duration", dur);
         slider.container.css("transition-duration", dur);
      }

      slider.args[slider.prop] = target;
      if (slider.transitions || dur === undefined) { slider.container.css(slider.args); }

      slider.container.css('transform',target);
    };

    slider.setup = function(type) {
      // SLIDE:
      if (!fade) {
        var sliderOffset, arr;

        if (type === "init") {
          slider.viewport = $('<div class="' + namespace + 'viewport"></div>').css({"overflow": "hidden", "position": "relative"}).appendTo(slider).append(slider.container);
          // INFINITE LOOP:
          slider.cloneCount = 0;
          slider.cloneOffset = 0;
          // REVERSE:
          if (reverse) {
            arr = $.makeArray(slider.slides).reverse();
            slider.slides = $(arr);
            slider.container.empty().append(slider.slides);
          }
        }
        // INFINITE LOOP && !CAROUSEL:
        if (slider.vars.animationLoop && !carousel) {
          slider.cloneCount = 2;
          slider.cloneOffset = 1;
          // clear out old clones
          if (type !== "init") { slider.container.find('.clone').remove(); }
          slider.container.append(methods.uniqueID(slider.slides.first().clone().addClass('clone')).attr('aria-hidden', 'true'))
                          .prepend(methods.uniqueID(slider.slides.last().clone().addClass('clone')).attr('aria-hidden', 'true'));
        }
        slider.newSlides = $(slider.vars.selector, slider);

        sliderOffset = (reverse) ? slider.count - 1 - slider.currentSlide + slider.cloneOffset : slider.currentSlide + slider.cloneOffset;
        // VERTICAL:
        if (vertical && !carousel) {
          slider.container.height((slider.count + slider.cloneCount) * 200 + "%").css("position", "absolute").width("100%");
          setTimeout(function(){
            slider.newSlides.css({"display": "block"});
            slider.doMath();
            slider.viewport.height(slider.h);
            slider.setProps(sliderOffset * slider.h, "init");
          }, (type === "init") ? 100 : 0);
        } else {
          slider.container.width((slider.count + slider.cloneCount) * 200 + "%");
          slider.setProps(sliderOffset * slider.computedW, "init");
          setTimeout(function(){
            slider.doMath();
            slider.newSlides.css({"width": slider.computedW, "float": "left", "display": "block"});
            // SMOOTH HEIGHT:
            if (slider.vars.smoothHeight) { methods.smoothHeight(); }
          }, (type === "init") ? 100 : 0);
        }
      } else { // FADE:
        slider.slides.css({"width": "100%", "float": "left", "marginRight": "-100%", "position": "relative"});
        if (type === "init") {
          if (!touch) {
            //slider.slides.eq(slider.currentSlide).fadeIn(slider.vars.animationSpeed, slider.vars.easing);
            if (slider.vars.fadeFirstSlide == false) {
              slider.slides.css({ "opacity": 0, "display": "block", "zIndex": 1 }).eq(slider.currentSlide).css({"zIndex": 2}).css({"opacity": 1});
            } else {
              slider.slides.css({ "opacity": 0, "display": "block", "zIndex": 1 }).eq(slider.currentSlide).css({"zIndex": 2}).animate({"opacity": 1},slider.vars.animationSpeed,slider.vars.easing);
            }
          } else {
            slider.slides.css({ "opacity": 0, "display": "block", "webkitTransition": "opacity " + slider.vars.animationSpeed / 1000 + "s ease", "zIndex": 1 }).eq(slider.currentSlide).css({ "opacity": 1, "zIndex": 2});
          }
        }
        // SMOOTH HEIGHT:
        if (slider.vars.smoothHeight) { methods.smoothHeight(); }
      }
      // !CAROUSEL:
      // CANDIDATE: active slide
      if (!carousel) { slider.slides.removeClass(namespace + "active-slide").eq(slider.currentSlide).addClass(namespace + "active-slide"); }

      //FlexSlider: init() Callback
      slider.vars.init(slider);
    };

    slider.doMath = function() {
      var slide = slider.slides.first(),
          slideMargin = slider.vars.itemMargin,
          minItems = slider.vars.minItems,
          maxItems = slider.vars.maxItems;

      slider.w = (slider.viewport===undefined) ? slider.width() : slider.viewport.width();
      slider.h = slide.height();
      slider.boxPadding = slide.outerWidth() - slide.width();

      // CAROUSEL:
      if (carousel) {
        slider.itemT = slider.vars.itemWidth + slideMargin;
        slider.minW = (minItems) ? minItems * slider.itemT : slider.w;
        slider.maxW = (maxItems) ? (maxItems * slider.itemT) - slideMargin : slider.w;
        slider.itemW = (slider.minW > slider.w) ? (slider.w - (slideMargin * (minItems - 1)))/minItems :
                       (slider.maxW < slider.w) ? (slider.w - (slideMargin * (maxItems - 1)))/maxItems :
                       (slider.vars.itemWidth > slider.w) ? slider.w : slider.vars.itemWidth;

        slider.visible = Math.floor(slider.w/(slider.itemW));
        slider.move = (slider.vars.move > 0 && slider.vars.move < slider.visible ) ? slider.vars.move : slider.visible;
        slider.pagingCount = Math.ceil(((slider.count - slider.visible)/slider.move) + 1);
        slider.last =  slider.pagingCount - 1;
        slider.limit = (slider.pagingCount === 1) ? 0 :
                       (slider.vars.itemWidth > slider.w) ? (slider.itemW * (slider.count - 1)) + (slideMargin * (slider.count - 1)) : ((slider.itemW + slideMargin) * slider.count) - slider.w - slideMargin;
      } else {
        slider.itemW = slider.w;
        slider.pagingCount = slider.count;
        slider.last = slider.count - 1;
      }
      slider.computedW = slider.itemW - slider.boxPadding;
    };

    slider.update = function(pos, action) {
      slider.doMath();

      // update currentSlide and slider.animatingTo if necessary
      if (!carousel) {
        if (pos < slider.currentSlide) {
          slider.currentSlide += 1;
        } else if (pos <= slider.currentSlide && pos !== 0) {
          slider.currentSlide -= 1;
        }
        slider.animatingTo = slider.currentSlide;
      }

      // update controlNav
      if (slider.vars.controlNav && !slider.manualControls) {
        if ((action === "add" && !carousel) || slider.pagingCount > slider.controlNav.length) {
          methods.controlNav.update("add");
        } else if ((action === "remove" && !carousel) || slider.pagingCount < slider.controlNav.length) {
          if (carousel && slider.currentSlide > slider.last) {
            slider.currentSlide -= 1;
            slider.animatingTo -= 1;
          }
          methods.controlNav.update("remove", slider.last);
        }
      }
      // update directionNav
      if (slider.vars.directionNav) { methods.directionNav.update(); }

    };

    slider.addSlide = function(obj, pos) {
      var $obj = $(obj);

      slider.count += 1;
      slider.last = slider.count - 1;

      // append new slide
      if (vertical && reverse) {
        (pos !== undefined) ? slider.slides.eq(slider.count - pos).after($obj) : slider.container.prepend($obj);
      } else {
        (pos !== undefined) ? slider.slides.eq(pos).before($obj) : slider.container.append($obj);
      }

      // update currentSlide, animatingTo, controlNav, and directionNav
      slider.update(pos, "add");

      // update slider.slides
      slider.slides = $(slider.vars.selector + ':not(.clone)', slider);
      // re-setup the slider to accomdate new slide
      slider.setup();

      //FlexSlider: added() Callback
      slider.vars.added(slider);
    };
    slider.removeSlide = function(obj) {
      var pos = (isNaN(obj)) ? slider.slides.index($(obj)) : obj;

      // update count
      slider.count -= 1;
      slider.last = slider.count - 1;

      // remove slide
      if (isNaN(obj)) {
        $(obj, slider.slides).remove();
      } else {
        (vertical && reverse) ? slider.slides.eq(slider.last).remove() : slider.slides.eq(obj).remove();
      }

      // update currentSlide, animatingTo, controlNav, and directionNav
      slider.doMath();
      slider.update(pos, "remove");

      // update slider.slides
      slider.slides = $(slider.vars.selector + ':not(.clone)', slider);
      // re-setup the slider to accomdate new slide
      slider.setup();

      // FlexSlider: removed() Callback
      slider.vars.removed(slider);
    };

    //FlexSlider: Initialize
    methods.init();
  };

  // Ensure the slider isn't focussed if the window loses focus.
  $( window ).blur( function ( e ) {
    focused = false;
  }).focus( function ( e ) {
    focused = true;
  });

  //FlexSlider: Default Settings
  $.flexslider.defaults = {
    namespace: "flex-",             //{NEW} String: Prefix string attached to the class of every element generated by the plugin
    selector: ".slides > li",       //{NEW} Selector: Must match a simple pattern. '{container} > {slide}' -- Ignore pattern at your own peril
    animation: "fade",              //String: Select your animation type, "fade" or "slide"
    easing: "swing",                //{NEW} String: Determines the easing method used in jQuery transitions. jQuery easing plugin is supported!
    direction: "horizontal",        //String: Select the sliding direction, "horizontal" or "vertical"
    reverse: false,                 //{NEW} Boolean: Reverse the animation direction
    animationLoop: true,            //Boolean: Should the animation loop? If false, directionNav will received "disable" classes at either end
    smoothHeight: false,            //{NEW} Boolean: Allow height of the slider to animate smoothly in horizontal mode
    startAt: 0,                     //Integer: The slide that the slider should start on. Array notation (0 = first slide)
    slideshow: true,                //Boolean: Animate slider automatically
    slideshowSpeed: 7000,           //Integer: Set the speed of the slideshow cycling, in milliseconds
    animationSpeed: 600,            //Integer: Set the speed of animations, in milliseconds
    initDelay: 0,                   //{NEW} Integer: Set an initialization delay, in milliseconds
    randomize: false,               //Boolean: Randomize slide order
    fadeFirstSlide: true,           //Boolean: Fade in the first slide when animation type is "fade"
    thumbCaptions: false,           //Boolean: Whether or not to put captions on thumbnails when using the "thumbnails" controlNav.

    // Usability features
    pauseOnAction: true,            //Boolean: Pause the slideshow when interacting with control elements, highly recommended.
    pauseOnHover: false,            //Boolean: Pause the slideshow when hovering over slider, then resume when no longer hovering
    pauseInvisible: true,   		//{NEW} Boolean: Pause the slideshow when tab is invisible, resume when visible. Provides better UX, lower CPU usage.
    useCSS: true,                   //{NEW} Boolean: Slider will use CSS3 transitions if available
    touch: true,                    //{NEW} Boolean: Allow touch swipe navigation of the slider on touch-enabled devices
    video: false,                   //{NEW} Boolean: If using video in the slider, will prevent CSS3 3D Transforms to avoid graphical glitches

    // Primary Controls
    controlNav: true,               //Boolean: Create navigation for paging control of each slide? Note: Leave true for manualControls usage
    directionNav: true,             //Boolean: Create navigation for previous/next navigation? (true/false)
    prevText: "Previous",           //String: Set the text for the "previous" directionNav item
    nextText: "Next",               //String: Set the text for the "next" directionNav item

    // Secondary Navigation
    keyboard: true,                 //Boolean: Allow slider navigating via keyboard left/right keys
    multipleKeyboard: false,        //{NEW} Boolean: Allow keyboard navigation to affect multiple sliders. Default behavior cuts out keyboard navigation with more than one slider present.
    mousewheel: false,              //{UPDATED} Boolean: Requires jquery.mousewheel.js (https://github.com/brandonaaron/jquery-mousewheel) - Allows slider navigating via mousewheel
    pausePlay: false,               //Boolean: Create pause/play dynamic element
    pauseText: "Pause",             //String: Set the text for the "pause" pausePlay item
    playText: "Play",               //String: Set the text for the "play" pausePlay item

    // Special properties
    controlsContainer: "",          //{UPDATED} jQuery Object/Selector: Declare which container the navigation elements should be appended too. Default container is the FlexSlider element. Example use would be $(".flexslider-container"). Property is ignored if given element is not found.
    manualControls: "",             //{UPDATED} jQuery Object/Selector: Declare custom control navigation. Examples would be $(".flex-control-nav li") or "#tabs-nav li img", etc. The number of elements in your controlNav should match the number of slides/tabs.
    customDirectionNav: "",         //{NEW} jQuery Object/Selector: Custom prev / next button. Must be two jQuery elements. In order to make the events work they have to have the classes "prev" and "next" (plus namespace)
    sync: "",                       //{NEW} Selector: Mirror the actions performed on this slider with another slider. Use with care.
    asNavFor: "",                   //{NEW} Selector: Internal property exposed for turning the slider into a thumbnail navigation for another slider

    // Carousel Options
    itemWidth: 0,                   //{NEW} Integer: Box-model width of individual carousel items, including horizontal borders and padding.
    itemMargin: 0,                  //{NEW} Integer: Margin between carousel items.
    minItems: 1,                    //{NEW} Integer: Minimum number of carousel items that should be visible. Items will resize fluidly when below this.
    maxItems: 0,                    //{NEW} Integer: Maxmimum number of carousel items that should be visible. Items will resize fluidly when above this limit.
    move: 0,                        //{NEW} Integer: Number of carousel items that should move on animation. If 0, slider will move all visible items.
    allowOneSlide: true,           //{NEW} Boolean: Whether or not to allow a slider comprised of a single slide

    // Callback API
    start: function(){},            //Callback: function(slider) - Fires when the slider loads the first slide
    before: function(){},           //Callback: function(slider) - Fires asynchronously with each slider animation
    after: function(){},            //Callback: function(slider) - Fires after each slider animation completes
    end: function(){},              //Callback: function(slider) - Fires when the slider reaches the last slide (asynchronous)
    added: function(){},            //{NEW} Callback: function(slider) - Fires after a slide is added
    removed: function(){},           //{NEW} Callback: function(slider) - Fires after a slide is removed
    init: function() {}             //{NEW} Callback: function(slider) - Fires after the slider is initially setup
  };

  //FlexSlider: Plugin Function
  $.fn.flexslider = function(options) {
    if (options === undefined) { options = {}; }

    if (typeof options === "object") {
      return this.each(function() {
        var $this = $(this),
            selector = (options.selector) ? options.selector : ".slides > li",
            $slides = $this.find(selector);

      if ( ( $slides.length === 1 && options.allowOneSlide === true ) || $slides.length === 0 ) {
          $slides.fadeIn(400);
          if (options.start) { options.start($this); }
        } else if ($this.data('flexslider') === undefined) {
          new $.flexslider(this, options);
        }
      });
    } else {
      // Helper strings to quickly perform functions on the slider
      var $slider = $(this).data('flexslider');
      switch (options) {
        case "play": $slider.play(); break;
        case "pause": $slider.pause(); break;
        case "stop": $slider.stop(); break;
        case "next": $slider.flexAnimate($slider.getTarget("next"), true); break;
        case "prev":
        case "previous": $slider.flexAnimate($slider.getTarget("prev"), true); break;
        default: if (typeof options === "number") { $slider.flexAnimate(options, true); }
      }
    }
  };
})(jQuery);


/*!
* Parsleyjs
* Guillaume Potier - <guillaume@wisembly.com>
* Version 2.0.3 - built Mon Jul 21 2014 11:58:33
* MIT Licensed
*
*/
!(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module depending on jQuery.
    define(['jquery'], factory);
  } else {
    // No AMD. Register plugin with global jQuery object.
    factory(jQuery);
  }
}(function ($) {
  // small hack for requirejs if jquery is loaded through map and not path
  // see http://requirejs.org/docs/jquery.html
  if ('undefined' === typeof $ && 'undefined' !== typeof window.jQuery)
    $ = window.jQuery;
  var ParsleyUtils = {
    // Parsley DOM-API
    // returns object from dom attributes and values
    // if attr is given, returns bool if attr present in DOM or not
    attr: function ($element, namespace, checkAttr) {
      var
        attribute,
        obj = {},
        msie = this.msieversion(),
        regex = new RegExp('^' + namespace, 'i');
      if ('undefined' === typeof $element || 'undefined' === typeof $element[0])
        return {};
      for (var i in $element[0].attributes) {
        attribute = $element[0].attributes[i];
        if ('undefined' !== typeof attribute && null !== attribute && (!msie || msie >= 8 || attribute.specified) && regex.test(attribute.name)) {
          if ('undefined' !== typeof checkAttr && new RegExp(checkAttr + '$', 'i').test(attribute.name))
            return true;
          obj[this.camelize(attribute.name.replace(namespace, ''))] = this.deserializeValue(attribute.value);
        }
      }
      return 'undefined' === typeof checkAttr ? obj : false;
    },
    setAttr: function ($element, namespace, attr, value) {
      $element[0].setAttribute(this.dasherize(namespace + attr), String(value));
    },
    // Recursive object / array getter
    get: function (obj, path) {
      var
        i = 0,
        paths = (path || '').split('.');
      while (this.isObject(obj) || this.isArray(obj)) {
        obj = obj[paths[i++]];
        if (i === paths.length)
          return obj;
      }
      return undefined;
    },
    hash: function (length) {
      return String(Math.random()).substring(2, length ? length + 2 : 9);
    },
    /** Third party functions **/
    // Underscore isArray
    isArray: function (mixed) {
      return Object.prototype.toString.call(mixed) === '[object Array]';
    },
    // Underscore isObject
    isObject: function (mixed) {
      return mixed === Object(mixed);
    },
    // Zepto deserialize function
    deserializeValue: function (value) {
      var num;
      try {
        return value ?
          value == "true" ||
          (value == "false" ? false :
          value == "null" ? null :
          !isNaN(num = Number(value)) ? num :
          /^[\[\{]/.test(value) ? $.parseJSON(value) :
          value)
          : value;
      } catch (e) { return value; }
    },
    // Zepto camelize function
    camelize: function (str) {
      return str.replace(/-+(.)?/g, function(match, chr) {
        return chr ? chr.toUpperCase() : '';
      });
    },
    // Zepto dasherize function
    dasherize: function (str) {
      return str.replace(/::/g, '/')
        .replace(/([A-Z]+)([A-Z][a-z])/g, '$1_$2')
        .replace(/([a-z\d])([A-Z])/g, '$1_$2')
        .replace(/_/g, '-')
        .toLowerCase();
    },
    // http://support.microsoft.com/kb/167820
    // http://stackoverflow.com/questions/19999388/jquery-check-if-user-is-using-ie
    msieversion: function () {
      var
        ua = window.navigator.userAgent,
        msie = ua.indexOf('MSIE ');
      if (msie > 0 || !!navigator.userAgent.match(/Trident.*rv\:11\./))
        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
      return 0;
   }
  };
// All these options could be overriden and specified directly in DOM using
// `data-parsley-` default DOM-API
// eg: `inputs` can be set in DOM using `data-parsley-inputs="input, textarea"`
// eg: `data-parsley-stop-on-first-failing-constraint="false"`
  var ParsleyDefaults = {
    // ### General
    // Default data-namespace for DOM API
    namespace: 'data-parsley-',
    // Supported inputs by default
    inputs: 'input, textarea, select',
    // Excluded inputs by default
    excluded: 'input[type=button], input[type=submit], input[type=reset], input[type=hidden]',
    // Stop validating field on highest priority failing constraint
    priorityEnabled: true,
    // ### UI
    // Enable\Disable error messages
    uiEnabled: true,
    // Key events threshold before validation
    validationThreshold: 3,
    // Focused field on form validation error. 'fist'|'last'|'none'
    focus: 'first',
    // `$.Event()` that will trigger validation. eg: `keyup`, `change`..
    trigger: false,
    // Class that would be added on every failing validation Parsley field
    errorClass: 'parsley-error',
    // Same for success validation
    successClass: 'parsley-success',
    // Return the `$element` that will receive these above success or error classes
    // Could also be (and given directly from DOM) a valid selector like `'#div'`
    classHandler: function (ParsleyField) {},
    // Return the `$element` where errors will be appended
    // Could also be (and given directly from DOM) a valid selector like `'#div'`
    errorsContainer: function (ParsleyField) {},
    // ul elem that would receive errors' list
    errorsWrapper: '<ul class="parsley-errors-list"></ul>',
    // li elem that would receive error message
    errorTemplate: '<li></li>'
  };

  var ParsleyAbstract = function() {};
  ParsleyAbstract.prototype = {
    asyncSupport: false,
    actualizeOptions: function () {
      this.options = this.OptionsFactory.get(this);
      return this;
    },
    // ParsleyValidator validate proxy function . Could be replaced by third party scripts
    validateThroughValidator: function (value, constraints, priority) {
      return window.ParsleyValidator.validate.apply(window.ParsleyValidator, [value, constraints, priority]);
    },
    // Subscribe an event and a handler for a specific field or a specific form
    // If on a ParsleyForm instance, it will be attached to form instance and also
    // To every field instance for this form
    subscribe: function (name, fn) {
      $.listenTo(this, name.toLowerCase(), fn);
      return this;
    },
    // Same as subscribe above. Unsubscribe an event for field, or form + its fields
    unsubscribe: function (name) {
      $.unsubscribeTo(this, name.toLowerCase());
      return this;
    },
    // Reset UI
    reset: function () {
      // Field case: just emit a reset event for UI
      if ('ParsleyForm' !== this.__class__)
        return $.emit('parsley:field:reset', this);
      // Form case: emit a reset event for each field
      for (var i = 0; i < this.fields.length; i++)
        $.emit('parsley:field:reset', this.fields[i]);
      $.emit('parsley:form:reset', this);
    },
    // Destroy Parsley instance (+ UI)
    destroy: function () {
      // Field case: emit destroy event to clean UI and then destroy stored instance
      if ('ParsleyForm' !== this.__class__) {
        this.$element.removeData('Parsley');
        this.$element.removeData('ParsleyFieldMultiple');
        $.emit('parsley:field:destroy', this);
        return;
      }
      // Form case: destroy all its fields and then destroy stored instance
      for (var i = 0; i < this.fields.length; i++)
        this.fields[i].destroy();
      this.$element.removeData('Parsley');
      $.emit('parsley:form:destroy', this);
    }
  };
/*!
* validator.js
* Guillaume Potier - <guillaume@wisembly.com>
* Version 0.5.8 - built Sun Mar 16 2014 17:18:21
* MIT Licensed
*
*/
( function ( exports ) {
  /**
  * Validator
  */
  var Validator = function ( options ) {
    this.__class__ = 'Validator';
    this.__version__ = '0.5.8';
    this.options = options || {};
    this.bindingKey = this.options.bindingKey || '_validatorjsConstraint';
    return this;
  };
  Validator.prototype = {
    constructor: Validator,
    /*
    * Validate string: validate( string, Assert, string ) || validate( string, [ Assert, Assert ], [ string, string ] )
    * Validate object: validate( object, Constraint, string ) || validate( object, Constraint, [ string, string ] )
    * Validate binded object: validate( object, string ) || validate( object, [ string, string ] )
    */
    validate: function ( objectOrString, AssertsOrConstraintOrGroup, group ) {
      if ( 'string' !== typeof objectOrString && 'object' !== typeof objectOrString )
        throw new Error( 'You must validate an object or a string' );
      // string / array validation
      if ( 'string' === typeof objectOrString || _isArray(objectOrString) )
        return this._validateString( objectOrString, AssertsOrConstraintOrGroup, group );
      // binded object validation
      if ( this.isBinded( objectOrString ) )
        return this._validateBindedObject( objectOrString, AssertsOrConstraintOrGroup );
      // regular object validation
      return this._validateObject( objectOrString, AssertsOrConstraintOrGroup, group );
    },
    bind: function ( object, constraint ) {
      if ( 'object' !== typeof object )
        throw new Error( 'Must bind a Constraint to an object' );
      object[ this.bindingKey ] = new Constraint( constraint );
      return this;
    },
    unbind: function ( object ) {
      if ( 'undefined' === typeof object._validatorjsConstraint )
        return this;
      delete object[ this.bindingKey ];
      return this;
    },
    isBinded: function ( object ) {
      return 'undefined' !== typeof object[ this.bindingKey ];
    },
    getBinded: function ( object ) {
      return this.isBinded( object ) ? object[ this.bindingKey ] : null;
    },
    _validateString: function ( string, assert, group ) {
      var result, failures = [];
      if ( !_isArray( assert ) )
        assert = [ assert ];
      for ( var i = 0; i < assert.length; i++ ) {
        if ( ! ( assert[ i ] instanceof Assert) )
          throw new Error( 'You must give an Assert or an Asserts array to validate a string' );
        result = assert[ i ].check( string, group );
        if ( result instanceof Violation )
          failures.push( result );
      }
      return failures.length ? failures : true;
    },
    _validateObject: function ( object, constraint, group ) {
      if ( 'object' !== typeof constraint )
        throw new Error( 'You must give a constraint to validate an object' );
      if ( constraint instanceof Constraint )
        return constraint.check( object, group );
      return new Constraint( constraint ).check( object, group );
    },
    _validateBindedObject: function ( object, group ) {
      return object[ this.bindingKey ].check( object, group );
    }
  };
  Validator.errorCode = {
    must_be_a_string: 'must_be_a_string',
    must_be_an_array: 'must_be_an_array',
    must_be_a_number: 'must_be_a_number',
    must_be_a_string_or_array: 'must_be_a_string_or_array'
  };
  /**
  * Constraint
  */
  var Constraint = function ( data, options ) {
    this.__class__ = 'Constraint';
    this.options = options || {};
    this.nodes = {};
    if ( data ) {
      try {
        this._bootstrap( data );
      } catch ( err ) {
        throw new Error( 'Should give a valid mapping object to Constraint', err, data );
      }
    }
    return this;
  };
  Constraint.prototype = {
    constructor: Constraint,
    check: function ( object, group ) {
      var result, failures = {};
      // check all constraint nodes if strict validation enabled. Else, only object nodes that have a constraint
      for ( var property in this.options.strict ? this.nodes : object ) {
        if ( this.options.strict ? this.has( property, object ) : this.has( property ) ) {
          result = this._check( property, object[ property ], group );
          // check returned an array of Violations or an object mapping Violations
          if ( ( _isArray( result ) && result.length > 0 ) || ( !_isArray( result ) && !_isEmptyObject( result ) ) )
            failures[ property ] = result;
        // in strict mode, get a violation for each constraint node not in object
        } else if ( this.options.strict ) {
          try {
            // we trigger here a HaveProperty Assert violation to have uniform Violation object in the end
            new Assert().HaveProperty( property ).validate( object );
          } catch ( violation ) {
            failures[ property ] = violation;
          }
        }
      }
      return _isEmptyObject(failures) ? true : failures;
    },
    add: function ( node, object ) {
      if ( object instanceof Assert  || ( _isArray( object ) && object[ 0 ] instanceof Assert ) ) {
        this.nodes[ node ] = object;
        return this;
      }
      if ( 'object' === typeof object && !_isArray( object ) ) {
        this.nodes[ node ] = object instanceof Constraint ? object : new Constraint( object );
        return this;
      }
      throw new Error( 'Should give an Assert, an Asserts array, a Constraint', object );
    },
    has: function ( node, nodes ) {
      nodes = 'undefined' !== typeof nodes ? nodes : this.nodes;
      return 'undefined' !== typeof nodes[ node ];
    },
    get: function ( node, placeholder ) {
      return this.has( node ) ? this.nodes[ node ] : placeholder || null;
    },
    remove: function ( node ) {
      var _nodes = [];
      for ( var i in this.nodes )
        if ( i !== node )
          _nodes[ i ] = this.nodes[ i ];
      this.nodes = _nodes;
      return this;
    },
    _bootstrap: function ( data ) {
      if ( data instanceof Constraint )
        return this.nodes = data.nodes;
      for ( var node in data )
        this.add( node, data[ node ] );
    },
    _check: function ( node, value, group ) {
      // Assert
      if ( this.nodes[ node ] instanceof Assert )
        return this._checkAsserts( value, [ this.nodes[ node ] ], group );
      // Asserts
      if ( _isArray( this.nodes[ node ] ) )
        return this._checkAsserts( value, this.nodes[ node ], group );
      // Constraint -> check api
      if ( this.nodes[ node ] instanceof Constraint )
        return this.nodes[ node ].check( value, group );
      throw new Error( 'Invalid node', this.nodes[ node ] );
    },
    _checkAsserts: function ( value, asserts, group ) {
      var result, failures = [];
      for ( var i = 0; i < asserts.length; i++ ) {
        result = asserts[ i ].check( value, group );
        if ( 'undefined' !== typeof result && true !== result )
          failures.push( result );
        // Some asserts (Collection for example) could return an object
        // if ( result && ! ( result instanceof Violation ) )
        //   return result;
        //
        // // Vast assert majority return Violation
        // if ( result instanceof Violation )
        //   failures.push( result );
      }
      return failures;
    }
  };
  /**
  * Violation
  */
  var Violation = function ( assert, value, violation ) {
    this.__class__ = 'Violation';
    if ( ! ( assert instanceof Assert ) )
      throw new Error( 'Should give an assertion implementing the Assert interface' );
    this.assert = assert;
    this.value = value;
    if ( 'undefined' !== typeof violation )
      this.violation = violation;
  };
  Violation.prototype = {
    show: function () {
      var show =  {
        assert: this.assert.__class__,
        value: this.value
      };
      if ( this.violation )
        show.violation = this.violation;
      return show;
    },
    __toString: function () {
      if ( 'undefined' !== typeof this.violation )
        this.violation = '", ' + this.getViolation().constraint + ' expected was ' + this.getViolation().expected;
      return this.assert.__class__ + ' assert failed for "' + this.value + this.violation || '';
    },
    getViolation: function () {
      var constraint, expected;
      for ( constraint in this.violation )
        expected = this.violation[ constraint ];
      return { constraint: constraint, expected: expected };
    }
  };
  /**
  * Assert
  */
  var Assert = function ( group ) {
    this.__class__ = 'Assert';
    this.__parentClass__ = this.__class__;
    this.groups = [];
    if ( 'undefined' !== typeof group )
      this.addGroup( group );
    return this;
  };
  Assert.prototype = {
    construct: Assert,
    check: function ( value, group ) {
      if ( group && !this.hasGroup( group ) )
        return;
      if ( !group && this.hasGroups() )
        return;
      try {
        return this.validate( value, group );
      } catch ( violation ) {
        return violation;
      }
    },
    hasGroup: function ( group ) {
      if ( _isArray( group ) )
        return this.hasOneOf( group );
      // All Asserts respond to "Any" group
      if ( 'Any' === group )
        return true;
      // Asserts with no group also respond to "Default" group. Else return false
      if ( !this.hasGroups() )
        return 'Default' === group;
      return -1 !== this.groups.indexOf( group );
    },
    hasOneOf: function ( groups ) {
      for ( var i = 0; i < groups.length; i++ )
        if ( this.hasGroup( groups[ i ] ) )
          return true;
      return false;
    },
    hasGroups: function () {
      return this.groups.length > 0;
    },
    addGroup: function ( group ) {
      if ( _isArray( group ) )
        return this.addGroups( group );
      if ( !this.hasGroup( group ) )
        this.groups.push( group );
      return this;
    },
    removeGroup: function ( group ) {
      var _groups = [];
      for ( var i = 0; i < this.groups.length; i++ )
        if ( group !== this.groups[ i ] )
          _groups.push( this.groups[ i ] );
      this.groups = _groups;
      return this;
    },
    addGroups: function ( groups ) {
      for ( var i = 0; i < groups.length; i++ )
        this.addGroup( groups[ i ] );
      return this;
    },
    /**
    * Asserts definitions
    */
    HaveProperty: function ( node ) {
      this.__class__ = 'HaveProperty';
      this.node = node;
      this.validate = function ( object ) {
        if ( 'undefined' === typeof object[ this.node ] )
          throw new Violation( this, object, { value: this.node } );
        return true;
      };
      return this;
    },
    Blank: function () {
      this.__class__ = 'Blank';
      this.validate = function ( value ) {
        if ( 'string' !== typeof value )
          throw new Violation( this, value, { value: Validator.errorCode.must_be_a_string } );
        if ( '' !== value.replace( /^\s+/g, '' ).replace( /\s+$/g, '' ) )
          throw new Violation( this, value );
        return true;
      };
      return this;
    },
    Callback: function ( fn ) {
      this.__class__ = 'Callback';
      this.arguments = Array.prototype.slice.call( arguments );
      if ( 1 === this.arguments.length )
        this.arguments = [];
      else
        this.arguments.splice( 0, 1 );
      if ( 'function' !== typeof fn )
        throw new Error( 'Callback must be instanciated with a function' );
      this.fn = fn;
      this.validate = function ( value ) {
        var result = this.fn.apply( this, [ value ].concat( this.arguments ) );
        if ( true !== result )
          throw new Violation( this, value, { result: result } );
        return true;
      };
      return this;
    },
    Choice: function ( list ) {
      this.__class__ = 'Choice';
      if ( !_isArray( list ) && 'function' !== typeof list )
        throw new Error( 'Choice must be instanciated with an array or a function' );
      this.list = list;
      this.validate = function ( value ) {
        var list = 'function' === typeof this.list ? this.list() : this.list;
        for ( var i = 0; i < list.length; i++ )
          if ( value === list[ i ] )
            return true;
        throw new Violation( this, value, { choices: list } );
      };
      return this;
    },
    Collection: function ( constraint ) {
      this.__class__ = 'Collection';
      this.constraint = 'undefined' !== typeof constraint ? new Constraint( constraint ) : false;
      this.validate = function ( collection, group ) {
        var result, validator = new Validator(), count = 0, failures = {}, groups = this.groups.length ? this.groups : group;
        if ( !_isArray( collection ) )
          throw new Violation( this, array, { value: Validator.errorCode.must_be_an_array } );
        for ( var i = 0; i < collection.length; i++ ) {
          result = this.constraint ?
            validator.validate( collection[ i ], this.constraint, groups ) :
            validator.validate( collection[ i ], groups );
          if ( !_isEmptyObject( result ) )
            failures[ count ] = result;
          count++;
        }
        return !_isEmptyObject( failures ) ? failures : true;
      };
      return this;
    },
    Count: function ( count ) {
      this.__class__ = 'Count';
      this.count = count;
      this.validate = function ( array ) {
        if ( !_isArray( array ) )
          throw new Violation( this, array, { value: Validator.errorCode.must_be_an_array } );
        var count = 'function' === typeof this.count ? this.count( array ) : this.count;
        if ( isNaN( Number( count ) ) )
          throw new Error( 'Count must be a valid interger', count );
        if ( count !== array.length )
          throw new Violation( this, array, { count: count } );
        return true;
      };
      return this;
    },
    Email: function () {
      this.__class__ = 'Email';
      this.validate = function ( value ) {
        var regExp = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
        if ( 'string' !== typeof value )
          throw new Violation( this, value, { value: Validator.errorCode.must_be_a_string } );
        if ( !regExp.test( value ) )
          throw new Violation( this, value );
        return true;
      };
      return this;
    },
    Eql: function ( eql ) {
      this.__class__ = 'Eql';
      if ( 'undefined' === typeof eql )
        throw new Error( 'Equal must be instanciated with an Array or an Object' );
      this.eql = eql;
      this.validate = function ( value ) {
        var eql = 'function' === typeof this.eql ? this.eql( value ) : this.eql;
        if ( !expect.eql( eql, value ) )
          throw new Violation( this, value, { eql: eql } );
        return true;
      };
      return this;
    },
    EqualTo: function ( reference ) {
      this.__class__ = 'EqualTo';
      if ( 'undefined' === typeof reference )
        throw new Error( 'EqualTo must be instanciated with a value or a function' );
      this.reference = reference;
      this.validate = function ( value ) {
        var reference = 'function' === typeof this.reference ? this.reference( value ) : this.reference;
        if ( reference !== value )
          throw new Violation( this, value, { value: reference } );
        return true;
      };
      return this;
    },
    GreaterThan: function ( threshold ) {
      this.__class__ = 'GreaterThan';
      if ( 'undefined' === typeof threshold )
        throw new Error( 'Should give a threshold value' );
      this.threshold = threshold;
      this.validate = function ( value ) {
        if ( '' === value || isNaN( Number( value ) ) )
          throw new Violation( this, value, { value: Validator.errorCode.must_be_a_number } );
        if ( this.threshold >= value )
          throw new Violation( this, value, { threshold: this.threshold } );
        return true;
      };
      return this;
    },
    GreaterThanOrEqual: function ( threshold ) {
      this.__class__ = 'GreaterThanOrEqual';
      if ( 'undefined' === typeof threshold )
        throw new Error( 'Should give a threshold value' );
      this.threshold = threshold;
      this.validate = function ( value ) {
        if ( '' === value || isNaN( Number( value ) ) )
          throw new Violation( this, value, { value: Validator.errorCode.must_be_a_number } );
        if ( this.threshold > value )
          throw new Violation( this, value, { threshold: this.threshold } );
        return true;
      };
      return this;
    },
    InstanceOf: function ( classRef ) {
      this.__class__ = 'InstanceOf';
      if ( 'undefined' === typeof classRef )
        throw new Error( 'InstanceOf must be instanciated with a value' );
      this.classRef = classRef;
      this.validate = function ( value ) {
        if ( true !== (value instanceof this.classRef) )
          throw new Violation( this, value, { classRef: this.classRef } );
        return true;
      };
      return this;
    },
    IPv4: function () {
      this.__class__ = 'IPv4';
      this.validate = function ( value ) {
        var regExp = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
        if ( 'string' !== typeof value )
          throw new Violation( this, value, { value: Validator.errorCode.must_be_a_string } );
        if ( !regExp.test( value ) )
          throw new Violation( this, value );
        return true;
      };
      return this;
    },
    Length: function ( boundaries ) {
      this.__class__ = 'Length';
      if ( !boundaries.min && !boundaries.max )
        throw new Error( 'Lenth assert must be instanciated with a { min: x, max: y } object' );
      this.min = boundaries.min;
      this.max = boundaries.max;
      this.validate = function ( value ) {
        if ( 'string' !== typeof value && !_isArray( value ) )
          throw new Violation( this, value, { value: Validator.errorCode.must_be_a_string_or_array } );
        if ( 'undefined' !== typeof this.min && this.min === this.max && value.length !== this.min )
          throw new Violation( this, value, { min: this.min, max: this.max } );
        if ( 'undefined' !== typeof this.max && value.length > this.max )
          throw new Violation( this, value, { max: this.max } );
        if ( 'undefined' !== typeof this.min && value.length < this.min )
          throw new Violation( this, value, { min: this.min } );
        return true;
      };
      return this;
    },
    LessThan: function ( threshold ) {
      this.__class__ = 'LessThan';
      if ( 'undefined' === typeof threshold )
        throw new Error( 'Should give a threshold value' );
      this.threshold = threshold;
      this.validate = function ( value ) {
        if ( '' === value || isNaN( Number( value ) ) )
          throw new Violation( this, value, { value: Validator.errorCode.must_be_a_number } );
        if ( this.threshold <= value )
          throw new Violation( this, value, { threshold: this.threshold } );
        return true;
      };
      return this;
    },
    LessThanOrEqual: function ( threshold ) {
      this.__class__ = 'LessThanOrEqual';
      if ( 'undefined' === typeof threshold )
        throw new Error( 'Should give a threshold value' );
      this.threshold = threshold;
      this.validate = function ( value ) {
        if ( '' === value || isNaN( Number( value ) ) )
          throw new Violation( this, value, { value: Validator.errorCode.must_be_a_number } );
        if ( this.threshold < value )
          throw new Violation( this, value, { threshold: this.threshold } );
        return true;
      };
      return this;
    },
    Mac: function () {
      this.__class__ = 'Mac';
      this.validate = function ( value ) {
        var regExp = /^(?:[0-9A-F]{2}:){5}[0-9A-F]{2}$/i;
        if ( 'string' !== typeof value )
          throw new Violation( this, value, { value: Validator.errorCode.must_be_a_string } );
        if ( !regExp.test( value ) )
          throw new Violation( this, value );
        return true;
      };
      return this;
    },
    NotNull: function () {
      this.__class__ = 'NotNull';
      this.validate = function ( value ) {
        if ( null === value || 'undefined' === typeof value )
          throw new Violation( this, value );
        return true;
      };
      return this;
    },
    NotBlank: function () {
      this.__class__ = 'NotBlank';
      this.validate = function ( value ) {
        if ( 'string' !== typeof value )
          throw new Violation( this, value, { value: Validator.errorCode.must_be_a_string } );
        if ( '' === value.replace( /^\s+/g, '' ).replace( /\s+$/g, '' ) )
          throw new Violation( this, value );
        return true;
      };
      return this;
    },
    Null: function () {
      this.__class__ = 'Null';
      this.validate = function ( value ) {
        if ( null !== value )
          throw new Violation( this, value );
        return true;
      };
      return this;
    },
    Range: function ( min, max ) {
      this.__class__ = 'Range';
      if ( 'undefined' === typeof min || 'undefined' === typeof max )
        throw new Error( 'Range assert expects min and max values' );
      this.min = min;
      this.max = max;
      this.validate = function ( value ) {
          try {
            // validate strings and objects with their Length
            if ( ( 'string' === typeof value && isNaN( Number( value ) ) ) || _isArray( value ) )
              new Assert().Length( { min: this.min, max: this.max } ).validate( value );
            // validate numbers with their value
            else
              new Assert().GreaterThanOrEqual( this.min ).validate( value ) && new Assert().LessThanOrEqual( this.max ).validate( value );
            return true;
          } catch ( violation ) {
            throw new Violation( this, value, violation.violation );
          }
        return true;
      };
      return this;
    },
    Regexp: function ( regexp, flag ) {
      this.__class__ = 'Regexp';
      if ( 'undefined' === typeof regexp )
        throw new Error( 'You must give a regexp' );
      this.regexp = regexp;
      this.flag = flag || '';
      this.validate = function ( value ) {
        if ( 'string' !== typeof value )
          throw new Violation( this, value, { value: Validator.errorCode.must_be_a_string } );
        if ( !new RegExp( this.regexp, this.flag ).test( value ) )
          throw new Violation( this, value, { regexp: this.regexp, flag: this.flag } );
        return true;
      };
      return this;
    },
    Required: function () {
      this.__class__ = 'Required';
      this.validate = function ( value ) {
        if ( 'undefined' === typeof value )
          throw new Violation( this, value );
        try {
          if ( 'string' === typeof value )
            new Assert().NotNull().validate( value ) && new Assert().NotBlank().validate( value );
          else if ( true === _isArray( value ) )
            new Assert().Length( { min: 1 } ).validate( value );
        } catch ( violation ) {
          throw new Violation( this, value );
        }
        return true;
      };
      return this;
    },
    // Unique() or Unique ( { key: foo } )
    Unique: function ( object ) {
      this.__class__ = 'Unique';
      if ( 'object' === typeof object )
        this.key = object.key;
      this.validate = function ( array ) {
        var value, store = [];
        if ( !_isArray( array ) )
          throw new Violation( this, array, { value: Validator.errorCode.must_be_an_array } );
        for ( var i = 0; i < array.length; i++ ) {
          value = 'object' === typeof array[ i ] ? array[ i ][ this.key ] : array[ i ];
          if ( 'undefined' === typeof value )
            continue;
          if ( -1 !== store.indexOf( value ) )
            throw new Violation( this, array, { value: value } );
          store.push( value );
        }
        return true;
      };
      return this;
    }
  };
  // expose to the world these awesome classes
  exports.Assert = Assert;
  exports.Validator = Validator;
  exports.Violation = Violation;
  exports.Constraint = Constraint;
  /**
  * Some useful object prototypes / functions here
  */
  // IE8<= compatibility
  // https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Array/indexOf
  if (!Array.prototype.indexOf)
    Array.prototype.indexOf = function (searchElement /*, fromIndex */ ) {
        
        if (this === null) {
            throw new TypeError();
        }
        var t = Object(this);
        var len = t.length >>> 0;
        if (len === 0) {
            return -1;
        }
        var n = 0;
        if (arguments.length > 1) {
            n = Number(arguments[1]);
            if (n != n) { // shortcut for verifying if it's NaN
                n = 0;
            } else if (n !== 0 && n != Infinity && n != -Infinity) {
                n = (n > 0 || -1) * Math.floor(Math.abs(n));
            }
        }
        if (n >= len) {
            return -1;
        }
        var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
        for (; k < len; k++) {
            if (k in t && t[k] === searchElement) {
                return k;
            }
        }
        return -1;
    };
  // Test if object is empty, useful for Constraint violations check
  var _isEmptyObject = function ( obj ) {
    for ( var property in obj )
      return false;
    return true;
  };
  var _isArray = function ( obj ) {
    return Object.prototype.toString.call( obj ) === '[object Array]';
  };
  // https://github.com/LearnBoost/expect.js/blob/master/expect.js
  var expect = {
    eql: function ( actual, expected ) {
      if ( actual === expected ) {
        return true;
      } else if ( 'undefined' !== typeof Buffer && Buffer.isBuffer( actual ) && Buffer.isBuffer( expected ) ) {
        if ( actual.length !== expected.length ) return false;
        for ( var i = 0; i < actual.length; i++ )
          if ( actual[i] !== expected[i] ) return false;
        return true;
      } else if ( actual instanceof Date && expected instanceof Date ) {
        return actual.getTime() === expected.getTime();
      } else if ( typeof actual !== 'object' && typeof expected !== 'object' ) {
        // loosy ==
        return actual == expected;
      } else {
        return this.objEquiv(actual, expected);
      }
    },
    isUndefinedOrNull: function ( value ) {
      return value === null || typeof value === 'undefined';
    },
    isArguments: function ( object ) {
      return Object.prototype.toString.call(object) == '[object Arguments]';
    },
    keys: function ( obj ) {
      if ( Object.keys )
        return Object.keys( obj );
      var keys = [];
      for ( var i in obj )
        if ( Object.prototype.hasOwnProperty.call( obj, i ) )
          keys.push(i);
      return keys;
    },
    objEquiv: function ( a, b ) {
      if ( this.isUndefinedOrNull( a ) || this.isUndefinedOrNull( b ) )
        return false;
      if ( a.prototype !== b.prototype ) return false;
      if ( this.isArguments( a ) ) {
        if ( !this.isArguments( b ) )
          return false;
        return eql( pSlice.call( a ) , pSlice.call( b ) );
      }
      try {
        var ka = this.keys( a ), kb = this.keys( b ), key, i;
        if ( ka.length !== kb.length )
          return false;
        ka.sort();
        kb.sort();
        for ( i = ka.length - 1; i >= 0; i-- )
          if ( ka[ i ] != kb[ i ] )
            return false;
        for ( i = ka.length - 1; i >= 0; i-- ) {
          key = ka[i];
          if ( !this.eql( a[ key ], b[ key ] ) )
             return false;
        }
        return true;
      } catch ( e ) {
        return false;
      }
    }
  };
  // AMD Compliance
  if ( "function" === typeof define && define.amd ) {
    define( 'validator', [],function() { return exports; } );
  }
} )( 'undefined' === typeof exports ? this[ 'undefined' !== typeof validatorjs_ns ? validatorjs_ns : 'Validator' ] = {} : exports );


  var ParsleyValidator = function (validators, catalog) {
    this.__class__ = 'ParsleyValidator';
    this.Validator = Validator;
    // Default Parsley locale is en
    this.locale = 'en';
    this.init(validators || {}, catalog || {});
  };
  ParsleyValidator.prototype = {
    init: function (validators, catalog) {
      this.catalog = catalog;
      for (var name in validators)
        this.addValidator(name, validators[name].fn, validators[name].priority, validators[name].requirementsTransformer);
      $.emit('parsley:validator:init');
    },
    // Set new messages locale if we have dictionary loaded in ParsleyConfig.i18n
    setLocale: function (locale) {
      if ('undefined' === typeof this.catalog[locale])
        throw new Error(locale + ' is not available in the catalog');
      this.locale = locale;
      return this;
    },
    // Add a new messages catalog for a given locale. Set locale for this catalog if set === `true`
    addCatalog: function (locale, messages, set) {
      if ('object' === typeof messages)
        this.catalog[locale] = messages;
      if (true === set)
        return this.setLocale(locale);
      return this;
    },
    // Add a specific message for a given constraint in a given locale
    addMessage: function (locale, name, message) {
      if ('undefined' === typeof this.catalog[locale])
        this.catalog[locale] = {};
      this.catalog[locale][name.toLowerCase()] = message;
      return this;
    },
    validate: function (value, constraints, priority) {
      return new this.Validator.Validator().validate.apply(new Validator.Validator(), arguments);
    },
    // Add a new validator
    addValidator: function (name, fn, priority, requirementsTransformer) {
      this.validators[name.toLowerCase()] = function (requirements) {
        return $.extend(new Validator.Assert().Callback(fn, requirements), {
          priority: priority,
          requirementsTransformer: requirementsTransformer
        });
      };
      return this;
    },
    updateValidator: function (name, fn, priority, requirementsTransformer) {
      return this.addValidator(name, fn, priority, requirementsTransformer);
    },
    removeValidator: function (name) {
      delete this.validators[name];
      return this;
    },
    getErrorMessage: function (constraint) {
      var message;
      // Type constraints are a bit different, we have to match their requirements too to find right error message
      if ('type' === constraint.name)
        message = this.catalog[this.locale][constraint.name][constraint.requirements];
      else
        message = this.formatMessage(this.catalog[this.locale][constraint.name], constraint.requirements);
      return '' !== message ? message : this.catalog[this.locale].defaultMessage;
    },
    // Kind of light `sprintf()` implementation
    formatMessage: function (string, parameters) {
      if ('object' === typeof parameters) {
        for (var i in parameters)
          string = this.formatMessage(string, parameters[i]);
        return string;
      }
      return 'string' === typeof string ? string.replace(new RegExp('%s', 'i'), parameters) : '';
    },
    // Here is the Parsley default validators list.
    // This is basically Validatorjs validators, with different API for some of them
    // and a Parsley priority set
    validators: {
      notblank: function () {
        return $.extend(new Validator.Assert().NotBlank(), { priority: 2 });
      },
      required: function () {
        return $.extend(new Validator.Assert().Required(), { priority: 512 });
      },
      type: function (type) {
        var assert;
        switch (type) {
          case 'email':
            assert = new Validator.Assert().Email();
            break;
          // range type just ensure we have a number here
          case 'range':
          case 'number':
            assert = new Validator.Assert().Regexp('^-?(?:\\d+|\\d{1,3}(?:,\\d{3})+)?(?:\\.\\d+)?$');
            break;
          case 'integer':
            assert = new Validator.Assert().Regexp('^-?\\d+$');
            break;
          case 'digits':
            assert = new Validator.Assert().Regexp('^\\d+$');
            break;
          case 'alphanum':
            assert = new Validator.Assert().Regexp('^\\w+$', 'i');
            break;
          case 'url':
            assert = new Validator.Assert().Regexp('(https?:\\/\\/)?(www\\.)?[-a-zA-Z0-9@:%._\\+~#=]{2,256}\\.[a-z]{2,4}\\b([-a-zA-Z0-9@:%_\\+.~#?&//=]*)', 'i');
            break;
          default:
            throw new Error('validator type `' + type + '` is not supported');
        }
        return $.extend(assert, { priority: 256 });
      },
      pattern: function (regexp) {
        var flags = '';
        // Test if RegExp is literal, if not, nothing to be done, otherwise, we need to isolate flags and pattern
        if (!!(/^\/.*\/(?:[gimy]*)$/.test(regexp))) {
          // Replace the regexp literal string with the first match group: ([gimy]*)
          // If no flag is present, this will be a blank string
          flags = regexp.replace(/.*\/([gimy]*)$/, '$1');
          // Again, replace the regexp literal string with the first match group:
          // everything excluding the opening and closing slashes and the flags
          regexp = regexp.replace(new RegExp('^/(.*?)/' + flags + '$'), '$1');
        }
        return $.extend(new Validator.Assert().Regexp(regexp, flags), { priority: 64 });
      },
      minlength: function (value) {
        return $.extend(new Validator.Assert().Length({ min: value }), {
          priority: 30,
          requirementsTransformer: function () {
            return 'string' === typeof value && !isNaN(value) ? parseInt(value, 10) : value;
          }
        });
      },
      maxlength: function (value) {
        return $.extend(new Validator.Assert().Length({ max: value }), {
        priority: 30,
        requirementsTransformer: function () {
            return 'string' === typeof value && !isNaN(value) ? parseInt(value, 10) : value;
          }
      });
      },
      length: function (array) {
        return $.extend(new Validator.Assert().Length({ min: array[0], max: array[1] }), { priority: 32 });
      },
      mincheck: function (length) {
        return this.minlength(length);
      },
      maxcheck: function (length) {
        return this.maxlength(length);
      },
      check: function (array) {
        return this.length(array);
      },
      min: function (value) {
        return $.extend(new Validator.Assert().GreaterThanOrEqual(value), {
          priority: 30,
          requirementsTransformer: function () {
            return 'string' === typeof value && !isNaN(value) ? parseInt(value, 10) : value;
          }
        });
      },
      max: function (value) {
        return $.extend(new Validator.Assert().LessThanOrEqual(value), {
          priority: 30,
          requirementsTransformer: function () {
            return 'string' === typeof value && !isNaN(value) ? parseInt(value, 10) : value;
          }
        });
      },
      range: function (array) {
        return $.extend(new Validator.Assert().Range(array[0], array[1]), {
          priority: 32,
          requirementsTransformer: function () {
            for (var i = 0; i < array.length; i++)
              array[i] = 'string' === typeof array[i] && !isNaN(array[i]) ? parseInt(array[i], 10) : array[i];
            return array;
          }
        });
      },
      equalto: function (value) {
        return $.extend(new Validator.Assert().EqualTo(value), {
          priority: 256,
          requirementsTransformer: function () {
            return $(value).length ? $(value).val() : value;
          }
        });
      }
    }
  };

  var ParsleyUI = function (options) {
    this.__class__ = 'ParsleyUI';
  };
  ParsleyUI.prototype = {
    listen: function () {
      $.listen('parsley:form:init', this, this.setupForm);
      $.listen('parsley:field:init', this, this.setupField);
      $.listen('parsley:field:validated', this, this.reflow);
      $.listen('parsley:form:validated', this, this.focus);
      $.listen('parsley:field:reset', this, this.reset);
      $.listen('parsley:form:destroy', this, this.destroy);
      $.listen('parsley:field:destroy', this, this.destroy);
      return this;
    },
    reflow: function (fieldInstance) {
      // If this field has not an active UI (case for multiples) don't bother doing something
      if ('undefined' === typeof fieldInstance._ui || false === fieldInstance._ui.active)
        return;
      // Diff between two validation results
      var diff = this._diff(fieldInstance.validationResult, fieldInstance._ui.lastValidationResult);
      // Then store current validation result for next reflow
      fieldInstance._ui.lastValidationResult = fieldInstance.validationResult;
      // Field have been validated at least once if here. Useful for binded key events..
      fieldInstance._ui.validatedOnce = true;
      // Handle valid / invalid / none field class
      this.manageStatusClass(fieldInstance);
      // Add, remove, updated errors messages
      this.manageErrorsMessages(fieldInstance, diff);
      // Triggers impl
      this.actualizeTriggers(fieldInstance);
      // If field is not valid for the first time, bind keyup trigger to ease UX and quickly inform user
      if ((diff.kept.length || diff.added.length) && 'undefined' === typeof fieldInstance._ui.failedOnce)
        this.manageFailingFieldTrigger(fieldInstance);
    },
    // Returns an array of field's error message(s)
    getErrorsMessages: function (fieldInstance) {
      // No error message, field is valid
      if (true === fieldInstance.validationResult)
        return [];
      var messages = [];
      for (var i = 0; i < fieldInstance.validationResult.length; i++)
        messages.push(this._getErrorMessage(fieldInstance, fieldInstance.validationResult[i].assert));
      return messages;
    },
    manageStatusClass: function (fieldInstance) {
      if (true === fieldInstance.validationResult)
        this._successClass(fieldInstance);
      else if (fieldInstance.validationResult.length > 0)
        this._errorClass(fieldInstance);
      else
        this._resetClass(fieldInstance);
    },
    manageErrorsMessages: function (fieldInstance, diff) {
      if ('undefined' !== typeof fieldInstance.options.errorsMessagesDisabled)
        return;
      // Case where we have errorMessage option that configure an unique field error message, regardless failing validators
      if ('undefined' !== typeof fieldInstance.options.errorMessage) {
        if ((diff.added.length || diff.kept.length)) {
          if (0 === fieldInstance._ui.$errorsWrapper.find('.parsley-custom-error-message').length)
            fieldInstance._ui.$errorsWrapper
              .append($(fieldInstance.options.errorTemplate)
              .addClass('parsley-custom-error-message'));
          return fieldInstance._ui.$errorsWrapper
            .addClass('filled')
            .find('.parsley-custom-error-message')
            .html(fieldInstance.options.errorMessage);
        }
        return fieldInstance._ui.$errorsWrapper
          .removeClass('filled')
          .find('.parsley-custom-error-message')
          .remove();
      }
      // Show, hide, update failing constraints messages
      for (var i = 0; i < diff.removed.length; i++)
        this.removeError(fieldInstance, diff.removed[i].assert.name, true);
      for (i = 0; i < diff.added.length; i++)
        this.addError(fieldInstance, diff.added[i].assert.name, undefined, diff.added[i].assert, true);
      for (i = 0; i < diff.kept.length; i++)
        this.updateError(fieldInstance, diff.kept[i].assert.name, undefined, diff.kept[i].assert, true);
    },
    // TODO: strange API here, intuitive for manual usage with addError(pslyInstance, 'foo', 'bar')
    // but a little bit complex for above internal usage, with forced undefined parametter..
    addError: function (fieldInstance, name, message, assert, doNotUpdateClass) {
      fieldInstance._ui.$errorsWrapper
        .addClass('filled')
        .append($(fieldInstance.options.errorTemplate)
        .addClass('parsley-' + name)
        .html(message || this._getErrorMessage(fieldInstance, assert)));
      if (true !== doNotUpdateClass)
        this._errorClass(fieldInstance);
    },
    // Same as above
    updateError: function (fieldInstance, name, message, assert, doNotUpdateClass) {
      fieldInstance._ui.$errorsWrapper
        .addClass('filled')
        .find('.parsley-' + name)
        .html(message || this._getErrorMessage(fieldInstance, assert));
      if (true !== doNotUpdateClass)
        this._errorClass(fieldInstance);
    },
    // Same as above twice
    removeError: function (fieldInstance, name, doNotUpdateClass) {
      fieldInstance._ui.$errorsWrapper
        .removeClass('filled')
        .find('.parsley-' + name)
        .remove();
      // edge case possible here: remove a standard Parsley error that is still failing in fieldInstance.validationResult
      // but highly improbable cuz' manually removing a well Parsley handled error makes no sense.
      if (true !== doNotUpdateClass)
        this.manageStatusClass(fieldInstance);
    },
    focus: function (formInstance) {
      if (true === formInstance.validationResult || 'none' === formInstance.options.focus)
        return formInstance._focusedField = null;
      formInstance._focusedField = null;
      for (var i = 0; i < formInstance.fields.length; i++)
        if (true !== formInstance.fields[i].validationResult && formInstance.fields[i].validationResult.length > 0 && 'undefined' === typeof formInstance.fields[i].options.noFocus) {
          if ('first' === formInstance.options.focus) {
            formInstance._focusedField = formInstance.fields[i].$element;
            return formInstance._focusedField.focus();
          }
          formInstance._focusedField = formInstance.fields[i].$element;
        }
      if (null === formInstance._focusedField)
        return null;
      return formInstance._focusedField.focus();
    },
    _getErrorMessage: function (fieldInstance, constraint) {
      var customConstraintErrorMessage = constraint.name + 'Message';
      if ('undefined' !== typeof fieldInstance.options[customConstraintErrorMessage])
        return window.ParsleyValidator.formatMessage(fieldInstance.options[customConstraintErrorMessage], constraint.requirements);
      return window.ParsleyValidator.getErrorMessage(constraint);
    },
    _diff: function (newResult, oldResult, deep) {
      var
        added = [],
        kept = [];
      for (var i = 0; i < newResult.length; i++) {
        var found = false;
        for (var j = 0; j < oldResult.length; j++)
          if (newResult[i].assert.name === oldResult[j].assert.name) {
            found = true;
            break;
          }
        if (found)
          kept.push(newResult[i]);
        else
          added.push(newResult[i]);
      }
      return {
        kept: kept,
        added: added,
        removed: !deep ? this._diff(oldResult, newResult, true).added : []
      };
    },
    setupForm: function (formInstance) {
      formInstance.$element.on('submit.Parsley', false, $.proxy(formInstance.onSubmitValidate, formInstance));
      // UI could be disabled
      if (false === formInstance.options.uiEnabled)
        return;
      formInstance.$element.attr('novalidate', '');
    },
    setupField: function (fieldInstance) {
      var _ui = { active: false };
      // UI could be disabled
      if (false === fieldInstance.options.uiEnabled)
        return;
      _ui.active = true;
      // Give field its Parsley id in DOM
      fieldInstance.$element.attr(fieldInstance.options.namespace + 'id', fieldInstance.__id__);
      /** Generate important UI elements and store them in fieldInstance **/
      // $errorClassHandler is the $element that woul have parsley-error and parsley-success classes
      _ui.$errorClassHandler = this._manageClassHandler(fieldInstance);
      // $errorsWrapper is a div that would contain the various field errors, it will be appended into $errorsContainer
      _ui.errorsWrapperId = 'parsley-id-' + ('undefined' !== typeof fieldInstance.options.multiple ? 'multiple-' + fieldInstance.options.multiple : fieldInstance.__id__);
      _ui.$errorsWrapper = $(fieldInstance.options.errorsWrapper).attr('id', _ui.errorsWrapperId);
      // ValidationResult UI storage to detect what have changed bwt two validations, and update DOM accordingly
      _ui.lastValidationResult = [];
      _ui.validatedOnce = false;
      _ui.validationInformationVisible = false;
      // Store it in fieldInstance for later
      fieldInstance._ui = _ui;
      /** Mess with DOM now **/
      this._insertErrorWrapper(fieldInstance);
      // Bind triggers first time
      this.actualizeTriggers(fieldInstance);
    },
    // Determine which element will have `parsley-error` and `parsley-success` classes
    _manageClassHandler: function (fieldInstance) {
      // An element selector could be passed through DOM with `data-parsley-class-handler=#foo`
      if ('string' === typeof fieldInstance.options.classHandler && $(fieldInstance.options.classHandler).length)
        return $(fieldInstance.options.classHandler);
      // Class handled could also be determined by function given in Parsley options
      var $handler = fieldInstance.options.classHandler(fieldInstance);
      // If this function returned a valid existing DOM element, go for it
      if ('undefined' !== typeof $handler && $handler.length)
        return $handler;
      // Otherwise, if simple element (input, texatrea, select..) it will perfectly host the classes
      if ('undefined' === typeof fieldInstance.options.multiple || fieldInstance.$element.is('select'))
        return fieldInstance.$element;
      // But if multiple element (radio, checkbox), that would be their parent
      return fieldInstance.$element.parent();
    },
    _insertErrorWrapper: function (fieldInstance) {
      var $errorsContainer;
      if ('string' === typeof fieldInstance.options.errorsContainer) {
        if ($(fieldInstance.options.errorsContainer).length)
          return $(fieldInstance.options.errorsContainer).append(fieldInstance._ui.$errorsWrapper);
        else if (window.console && window.console.warn)
          window.console.warn('The errors container `' + fieldInstance.options.errorsContainer + '` does not exist in DOM');
      }
      else if ('function' === typeof fieldInstance.options.errorsContainer)
        $errorsContainer = fieldInstance.options.errorsContainer(fieldInstance);
      if ('undefined' !== typeof $errorsContainer && $errorsContainer.length)
        return $errorsContainer.append(fieldInstance._ui.$errorsWrapper);
      return 'undefined' === typeof fieldInstance.options.multiple ? fieldInstance.$element.after(fieldInstance._ui.$errorsWrapper) : fieldInstance.$element.parent().after(fieldInstance._ui.$errorsWrapper);
    },
    actualizeTriggers: function (fieldInstance) {
      var that = this;
      // Remove Parsley events already binded on this field
      if (fieldInstance.options.multiple)
        $('[' + fieldInstance.options.namespace + 'multiple="' + fieldInstance.options.multiple + '"]').each(function () {
          $(this).off('.Parsley');
        });
      else
        fieldInstance.$element.off('.Parsley');
      // If no trigger is set, all good
      if (false === fieldInstance.options.trigger)
        return;
      var triggers = fieldInstance.options.trigger.replace(/^\s+/g , '').replace(/\s+$/g , '');
      if ('' === triggers)
        return;
      // Bind fieldInstance.eventValidate if exists (for parsley.ajax for example), ParsleyUI.eventValidate otherwise
      if (fieldInstance.options.multiple)
        $('[' + fieldInstance.options.namespace + 'multiple="' + fieldInstance.options.multiple + '"]').each(function () {
          $(this).on(
            triggers.split(' ').join('.Parsley ') + '.Parsley',
            false,
            $.proxy('function' === typeof fieldInstance.eventValidate ? fieldInstance.eventValidate : that.eventValidate, fieldInstance));
        });
      else
        fieldInstance.$element
          .on(
            triggers.split(' ').join('.Parsley ') + '.Parsley',
            false,
            $.proxy('function' === typeof fieldInstance.eventValidate ? fieldInstance.eventValidate : this.eventValidate, fieldInstance));
    },
    // Called through $.proxy with fieldInstance. `this` context is ParsleyField
    eventValidate: function(event) {
      // For keyup, keypress, keydown.. events that could be a little bit obstrusive
      // do not validate if val length < min threshold on first validation. Once field have been validated once and info
      // about success or failure have been displayed, always validate with this trigger to reflect every yalidation change.
      if (new RegExp('key').test(event.type))
        if (!this._ui.validationInformationVisible && this.getValue().length <= this.options.validationThreshold)
          return;
      this._ui.validatedOnce = true;
      this.validate();
    },
    manageFailingFieldTrigger: function (fieldInstance) {
      fieldInstance._ui.failedOnce = true;
      // Radio and checkboxes fields must bind every field multiple
      if (fieldInstance.options.multiple)
        $('[' + fieldInstance.options.namespace + 'multiple="' + fieldInstance.options.multiple + '"]').each(function () {
          if (!new RegExp('change', 'i').test($(this).parsley().options.trigger || ''))
            return $(this).on('change.ParsleyFailedOnce', false, $.proxy(fieldInstance.validate, fieldInstance));
        });
      // Select case
      if (fieldInstance.$element.is('select'))
        if (!new RegExp('change', 'i').test(fieldInstance.options.trigger || ''))
          return fieldInstance.$element.on('change.ParsleyFailedOnce', false, $.proxy(fieldInstance.validate, fieldInstance));
      // All other inputs fields
      if (!new RegExp('keyup', 'i').test(fieldInstance.options.trigger || ''))
        return fieldInstance.$element.on('keyup.ParsleyFailedOnce', false, $.proxy(fieldInstance.validate, fieldInstance));
    },
    reset: function (parsleyInstance) {
      // Reset all event listeners
      parsleyInstance.$element.off('.Parsley');
      parsleyInstance.$element.off('.ParsleyFailedOnce');
      // Nothing to do if UI never initialized for this field
      if ('undefined' === typeof parsleyInstance._ui)
        return;
      if ('ParsleyForm' === parsleyInstance.__class__)
        return;
      // Reset all errors' li
      parsleyInstance._ui.$errorsWrapper.children().each(function () {
        $(this).remove();
      });
      // Reset validation class
      this._resetClass(parsleyInstance);
      // Reset validation flags and last validation result
      parsleyInstance._ui.validatedOnce = false;
      parsleyInstance._ui.lastValidationResult = [];
      parsleyInstance._ui.validationInformationVisible = false;
    },
    destroy: function (parsleyInstance) {
      this.reset(parsleyInstance);
      if ('ParsleyForm' === parsleyInstance.__class__)
        return;
      if ('undefined' !== typeof parsleyInstance._ui)
        parsleyInstance._ui.$errorsWrapper.remove();
      delete parsleyInstance._ui;
    },
    _successClass: function (fieldInstance) {
      fieldInstance._ui.validationInformationVisible = true;
      fieldInstance._ui.$errorClassHandler.removeClass(fieldInstance.options.errorClass).addClass(fieldInstance.options.successClass);
    },
    _errorClass: function (fieldInstance) {
      fieldInstance._ui.validationInformationVisible = true;
      fieldInstance._ui.$errorClassHandler.removeClass(fieldInstance.options.successClass).addClass(fieldInstance.options.errorClass);
    },
    _resetClass: function (fieldInstance) {
      fieldInstance._ui.$errorClassHandler.removeClass(fieldInstance.options.successClass).removeClass(fieldInstance.options.errorClass);
    }
  };

  var ParsleyOptionsFactory = function (defaultOptions, globalOptions, userOptions, namespace) {
    this.__class__ = 'OptionsFactory';
    this.__id__ = ParsleyUtils.hash(4);
    this.formOptions = null;
    this.fieldOptions = null;
    this.staticOptions = $.extend(true, {}, defaultOptions, globalOptions, userOptions, { namespace: namespace });
  };
  ParsleyOptionsFactory.prototype = {
    get: function (parsleyInstance) {
      if ('undefined' === typeof parsleyInstance.__class__)
        throw new Error('Parsley Instance expected');
      switch (parsleyInstance.__class__) {
        case 'Parsley':
          return this.staticOptions;
        case 'ParsleyForm':
          return this.getFormOptions(parsleyInstance);
        case 'ParsleyField':
        case 'ParsleyFieldMultiple':
          return this.getFieldOptions(parsleyInstance);
        default:
          throw new Error('Instance ' + parsleyInstance.__class__ + ' is not supported');
      }
    },
    getFormOptions: function (formInstance) {
      this.formOptions = ParsleyUtils.attr(formInstance.$element, this.staticOptions.namespace);
      // not deep extend, since formOptions is a 1 level deep object
      return $.extend({}, this.staticOptions, this.formOptions);
    },
    getFieldOptions: function (fieldInstance) {
      this.fieldOptions = ParsleyUtils.attr(fieldInstance.$element, this.staticOptions.namespace);
      if (null === this.formOptions && 'undefined' !== typeof fieldInstance.parent)
        this.formOptions = this.getFormOptions(fieldInstance.parent);
      // not deep extend, since formOptions and fieldOptions is a 1 level deep object
      return $.extend({}, this.staticOptions, this.formOptions, this.fieldOptions);
    }
  };

  var ParsleyForm = function (element, OptionsFactory) {
    this.__class__ = 'ParsleyForm';
    this.__id__ = ParsleyUtils.hash(4);
    if ('OptionsFactory' !== ParsleyUtils.get(OptionsFactory, '__class__'))
      throw new Error('You must give an OptionsFactory instance');
    this.OptionsFactory = OptionsFactory;
    this.$element = $(element);
    this.validationResult = null;
    this.options = this.OptionsFactory.get(this);
  };
  ParsleyForm.prototype = {
    onSubmitValidate: function (event) {
      this.validate(undefined, undefined, event);
      // prevent form submission if validation fails
      if (false === this.validationResult && event instanceof $.Event) {
        event.stopImmediatePropagation();
        event.preventDefault();
      }
      return this;
    },
    // @returns boolean
    validate: function (group, force, event) {
      this.submitEvent = event;
      this.validationResult = true;
      var fieldValidationResult = [];
      // Refresh form DOM options and form's fields that could have changed
      this._refreshFields();
      $.emit('parsley:form:validate', this);
      // loop through fields to validate them one by one
      for (var i = 0; i < this.fields.length; i++) {
        // do not validate a field if not the same as given validation group
        if (group && group !== this.fields[i].options.group)
          continue;
        fieldValidationResult = this.fields[i].validate(force);
        if (true !== fieldValidationResult && fieldValidationResult.length > 0 && this.validationResult)
          this.validationResult = false;
      }
      $.emit('parsley:form:validated', this);
      return this.validationResult;
    },
    // Iterate over refreshed fields, and stop on first failure
    isValid: function (group, force) {
      this._refreshFields();
      for (var i = 0; i < this.fields.length; i++) {
        // do not validate a field if not the same as given validation group
        if (group && group !== this.fields[i].options.group)
          continue;
        if (false === this.fields[i].isValid(force))
          return false;
      }
      return true;
    },
    _refreshFields: function () {
      return this.actualizeOptions()._bindFields();
    },
    _bindFields: function () {
      var self = this;
      this.fields = [];
      this.fieldsMappedById = {};
      this.$element.find(this.options.inputs).each(function () {
        var fieldInstance = new window.Parsley(this, {}, self);
        // Only add valid and not excluded `ParsleyField` and `ParsleyFieldMultiple` children
        if (('ParsleyField' === fieldInstance.__class__ || 'ParsleyFieldMultiple' === fieldInstance.__class__) && !fieldInstance.$element.is(fieldInstance.options.excluded))
          if ('undefined' === typeof self.fieldsMappedById[fieldInstance.__class__ + '-' + fieldInstance.__id__]) {
            self.fieldsMappedById[fieldInstance.__class__ + '-' + fieldInstance.__id__] = fieldInstance;
            self.fields.push(fieldInstance);
          }
      });
      return this;
    }
  };

  var ConstraintFactory = function (parsleyField, name, requirements, priority, isDomConstraint) {
    if (!new RegExp('ParsleyField').test(ParsleyUtils.get(parsleyField, '__class__')))
      throw new Error('ParsleyField or ParsleyFieldMultiple instance expected');
    if ('function' !== typeof window.ParsleyValidator.validators[name] &&
      'Assert' !== window.ParsleyValidator.validators[name](requirements).__parentClass__)
      throw new Error('Valid validator expected');
    var getPriority = function (parsleyField, name) {
      if ('undefined' !== typeof parsleyField.options[name + 'Priority'])
        return parsleyField.options[name + 'Priority'];
      return ParsleyUtils.get(window.ParsleyValidator.validators[name](requirements), 'priority') || 2;
    };
    priority = priority || getPriority(parsleyField, name);
    // If validator have a requirementsTransformer, execute it
    if ('function' === typeof window.ParsleyValidator.validators[name](requirements).requirementsTransformer)
      requirements = window.ParsleyValidator.validators[name](requirements).requirementsTransformer();
    return $.extend(window.ParsleyValidator.validators[name](requirements), {
      name: name,
      requirements: requirements,
      priority: priority,
      groups: [priority],
      isDomConstraint: isDomConstraint || ParsleyUtils.attr(parsleyField.$element, parsleyField.options.namespace, name)
    });
  };

  var ParsleyField = function (field, OptionsFactory, parsleyFormInstance) {
    this.__class__ = 'ParsleyField';
    this.__id__ = ParsleyUtils.hash(4);
    this.$element = $(field);
    // If we have a parent `ParsleyForm` instance given, use its `OptionsFactory`, and save parent
    if ('undefined' !== typeof parsleyFormInstance) {
      this.parent = parsleyFormInstance;
      this.OptionsFactory = this.parent.OptionsFactory;
      this.options = this.OptionsFactory.get(this);
    // Else, take the `Parsley` one
    } else {
      this.OptionsFactory = OptionsFactory;
      this.options = this.OptionsFactory.get(this);
    }
    // Initialize some properties
    this.constraints = [];
    this.constraintsByName = {};
    this.validationResult = [];
    // Bind constraints
    this._bindConstraints();
  };
  ParsleyField.prototype = {
    // # Public API
    // Validate field and $.emit some events for mainly `ParsleyUI`
    // @returns validationResult:
    //  - `true` if all constraint passes
    //  - `[]` if not required field and empty (not validated)
    //  - `[Violation, [Violation..]]` if there were validation errors
    validate: function (force) {
      this.value = this.getValue();
      // Field Validate event. `this.value` could be altered for custom needs
      $.emit('parsley:field:validate', this);
      $.emit('parsley:field:' + (this.isValid(force, this.value) ? 'success' : 'error'), this);
      // Field validated event. `this.validationResult` could be altered for custom needs too
      $.emit('parsley:field:validated', this);
      return this.validationResult;
    },
    // Just validate field. Do not trigger any event
    // Same @return as `validate()`
    isValid: function (force, value) {
      // Recompute options and rebind constraints to have latest changes
      this.refreshConstraints();
      // Sort priorities to validate more important first
      var priorities = this._getConstraintsSortedPriorities();
      // Value could be passed as argument, needed to add more power to 'parsley:field:validate'
      value = value || this.getValue();
      // If a field is empty and not required, leave it alone, it's just fine
      // Except if `data-parsley-validate-if-empty` explicitely added, useful for some custom validators
      if (0 === value.length && !this._isRequired() && 'undefined' === typeof this.options.validateIfEmpty && true !== force)
        return this.validationResult = [];
      // If we want to validate field against all constraints, just call Validator and let it do the job
      if (false === this.options.priorityEnabled)
        return true === (this.validationResult = this.validateThroughValidator(value, this.constraints, 'Any'));
      // Else, iterate over priorities one by one, and validate related asserts one by one
      for (var i = 0; i < priorities.length; i++)
        if (true !== (this.validationResult = this.validateThroughValidator(value, this.constraints, priorities[i])))
          return false;
      return true;
    },
    // @returns Parsley field computed value that could be overrided or configured in DOM
    getValue: function () {
      var value;
      // Value could be overriden in DOM
      if ('undefined' !== typeof this.options.value)
        value = this.options.value;
      else
        value = this.$element.val();
      // Handle wrong DOM or configurations
      if ('undefined' === typeof value || null === value)
        return '';
      // Use `data-parsley-trim-value="true"` to auto trim inputs entry
      if (true === this.options.trimValue)
        return value.replace(/^\s+|\s+$/g, '');
      return value;
    },
    // Actualize options that could have change since previous validation
    // Re-bind accordingly constraints (could be some new, removed or updated)
    refreshConstraints: function () {
      return this.actualizeOptions()._bindConstraints();
    },
    /**
    * Add a new constraint to a field
    *
    * @method addConstraint
    * @param {String}   name
    * @param {Mixed}    requirements      optional
    * @param {Number}   priority          optional
    * @param {Boolean}  isDomConstraint   optional
    */
    addConstraint: function (name, requirements, priority, isDomConstraint) {
      name = name.toLowerCase();
      if ('function' === typeof window.ParsleyValidator.validators[name]) {
        var constraint = new ConstraintFactory(this, name, requirements, priority, isDomConstraint);
        // if constraint already exist, delete it and push new version
        if ('undefined' !== this.constraintsByName[constraint.name])
          this.removeConstraint(constraint.name);
        this.constraints.push(constraint);
        this.constraintsByName[constraint.name] = constraint;
      }
      return this;
    },
    // Remove a constraint
    removeConstraint: function (name) {
      for (var i = 0; i < this.constraints.length; i++)
        if (name === this.constraints[i].name) {
          this.constraints.splice(i, 1);
          break;
        }
      return this;
    },
    // Update a constraint (Remove + re-add)
    updateConstraint: function (name, parameters, priority) {
      return this.removeConstraint(name)
        .addConstraint(name, parameters, priority);
    },
    // # Internals
    // Internal only.
    // Bind constraints from config + options + DOM
    _bindConstraints: function () {
      var constraints = [];
      // clean all existing DOM constraints to only keep javascript user constraints
      for (var i = 0; i < this.constraints.length; i++)
        if (false === this.constraints[i].isDomConstraint)
          constraints.push(this.constraints[i]);
      this.constraints = constraints;
      // then re-add Parsley DOM-API constraints
      for (var name in this.options)
        this.addConstraint(name, this.options[name]);
      // finally, bind special HTML5 constraints
      return this._bindHtml5Constraints();
    },
    // Internal only.
    // Bind specific HTML5 constraints to be HTML5 compliant
    _bindHtml5Constraints: function () {
      // html5 required
      if (this.$element.hasClass('required') || this.$element.attr('required'))
        this.addConstraint('required', true, undefined, true);
      // html5 pattern
      if ('string' === typeof this.$element.attr('pattern'))
        this.addConstraint('pattern', this.$element.attr('pattern'), undefined, true);
      // range
      if ('undefined' !== typeof this.$element.attr('min') && 'undefined' !== typeof this.$element.attr('max'))
        this.addConstraint('range', [this.$element.attr('min'), this.$element.attr('max')], undefined, true);
      // HTML5 min
      else if ('undefined' !== typeof this.$element.attr('min'))
        this.addConstraint('min', this.$element.attr('min'), undefined, true);
      // HTML5 max
      else if ('undefined' !== typeof this.$element.attr('max'))
        this.addConstraint('max', this.$element.attr('max'), undefined, true);
      // html5 types
      var type = this.$element.attr('type');
      if ('undefined' === typeof type)
        return this;
      // Small special case here for HTML5 number, that is in fact an integer validator
      if ('number' === type)
        return this.addConstraint('type', 'integer', undefined, true);
      // Regular other HTML5 supported types
      else if (new RegExp(type, 'i').test('email url range'))
        return this.addConstraint('type', type, undefined, true);
      return this;
    },
    // Internal only.
    // Field is required if have required constraint without `false` value
    _isRequired: function () {
      if ('undefined' === typeof this.constraintsByName.required)
        return false;
      return false !== this.constraintsByName.required.requirements;
    },
    // Internal only.
    // Sort constraints by priority DESC
    _getConstraintsSortedPriorities: function () {
      var priorities = [];
      // Create array unique of priorities
      for (var i = 0; i < this.constraints.length; i++)
        if (-1 === priorities.indexOf(this.constraints[i].priority))
          priorities.push(this.constraints[i].priority);
      // Sort them by priority DESC
      priorities.sort(function (a, b) { return b - a; });
      return priorities;
    }
  };

  var ParsleyMultiple = function () {
    this.__class__ = 'ParsleyFieldMultiple';
  };
  ParsleyMultiple.prototype = {
    // Add new `$element` sibling for multiple field
    addElement: function ($element) {
      this.$elements.push($element);
      return this;
    },
    // See `ParsleyField.refreshConstraints()`
    refreshConstraints: function () {
      var fieldConstraints;
      this.constraints = [];
      // Select multiple special treatment
      if (this.$element.is('select')) {
        this.actualizeOptions()._bindConstraints();
        return this;
      }
      // Gather all constraints for each input in the multiple group
      for (var i = 0; i < this.$elements.length; i++) {
        // Check if element have not been dynamically removed since last binding
        if (!$('html').has(this.$elements[i]).length) {
          this.$elements.splice(i, 1);
          continue;
        }
        fieldConstraints = this.$elements[i].data('ParsleyFieldMultiple').refreshConstraints().constraints;
        for (var j = 0; j < fieldConstraints.length; j++)
          this.addConstraint(fieldConstraints[j].name, fieldConstraints[j].requirements, fieldConstraints[j].priority, fieldConstraints[j].isDomConstraint);
      }
      return this;
    },
    // See `ParsleyField.getValue()`
    getValue: function () {
      // Value could be overriden in DOM
      if ('undefined' !== typeof this.options.value)
        return this.options.value;
      // Radio input case
      if (this.$element.is('input[type=radio]'))
        return $('[' + this.options.namespace + 'multiple="' + this.options.multiple + '"]:checked').val() || '';
      // checkbox input case
      if (this.$element.is('input[type=checkbox]')) {
        var values = [];
        $('[' + this.options.namespace + 'multiple="' + this.options.multiple + '"]:checked').each(function () {
          values.push($(this).val());
        });
        return values.length ? values : [];
      }
      // Select multiple case
      if (this.$element.is('select') && null === this.$element.val())
        return [];
      // Default case that should never happen
      return this.$element.val();
    },
    _init: function (multiple) {
      this.$elements = [this.$element];
      this.options.multiple = multiple;
      return this;
    }
  };

  var
    o = $({}),
    subscribed = {};
  // $.listen(name, callback);
  // $.listen(name, context, callback);
  $.listen = function (name) {
    if ('undefined' === typeof subscribed[name])
      subscribed[name] = [];
    if ('function' === typeof arguments[1])
      return subscribed[name].push({ fn: arguments[1] });
    if ('object' === typeof arguments[1] && 'function' === typeof arguments[2])
      return subscribed[name].push({ fn: arguments[2], ctxt: arguments[1] });
    throw new Error('Wrong parameters');
  };
  $.listenTo = function (instance, name, fn) {
    if ('undefined' === typeof subscribed[name])
      subscribed[name] = [];
    if (!(instance instanceof ParsleyField) && !(instance instanceof ParsleyForm))
      throw new Error('Must give Parsley instance');
    if ('string' !== typeof name || 'function' !== typeof fn)
      throw new Error('Wrong parameters');
    subscribed[name].push({ instance: instance, fn: fn });
  };
  $.unsubscribe = function (name, fn) {
    if ('undefined' === typeof subscribed[name])
      return;
    if ('string' !== typeof name || 'function' !== typeof fn)
      throw new Error('Wrong arguments');
    for (var i = 0; i < subscribed[name].length; i++)
      if (subscribed[name][i].fn === fn)
        return subscribed[name].splice(i, 1);
  };
  $.unsubscribeTo = function (instance, name) {
    if ('undefined' === typeof subscribed[name])
      return;
    if (!(instance instanceof ParsleyField) && !(instance instanceof ParsleyForm))
      throw new Error('Must give Parsley instance');
    for (var i = 0; i < subscribed[name].length; i++)
      if ('undefined' !== typeof subscribed[name][i].instance && subscribed[name][i].instance.__id__ === instance.__id__)
        return subscribed[name].splice(i, 1);
  };
  $.unsubscribeAll = function (name) {
    if ('undefined' === typeof subscribed[name])
      return;
    delete subscribed[name];
  };
  // $.emit(name [, arguments...]);
  // $.emit(name, instance [, arguments..]);
  $.emit = function (name, instance) {
    if ('undefined' === typeof subscribed[name])
      return;
    // loop through registered callbacks for this event
    for (var i = 0; i < subscribed[name].length; i++) {
      // if instance is not registered, simple emit
      if ('undefined' === typeof subscribed[name][i].instance) {
        subscribed[name][i].fn.apply('undefined' !== typeof subscribed[name][i].ctxt ? subscribed[name][i].ctxt : o, Array.prototype.slice.call(arguments, 1));
        continue;
      }
      // if instance registered but no instance given for the emit, continue
      if (!(instance instanceof ParsleyField) && !(instance instanceof ParsleyForm))
        continue;
      // if instance is registered and same id, emit
      if (subscribed[name][i].instance.__id__ === instance.__id__) {
        subscribed[name][i].fn.apply(o, Array.prototype.slice.call(arguments, 1));
        continue;
      }
      // if registered instance is a Form and fired one is a Field, loop over all its fields and emit if field found
      if (subscribed[name][i].instance instanceof ParsleyForm && instance instanceof ParsleyField)
        for (var j = 0; j < subscribed[name][i].instance.fields.length; j++)
          if (subscribed[name][i].instance.fields[j].__id__ === instance.__id__) {
            subscribed[name][i].fn.apply(o, Array.prototype.slice.call(arguments, 1));
            continue;
          }
    }
  };
  $.subscribed = function () { return subscribed; };

// ParsleyConfig definition if not already set
window.ParsleyConfig = window.ParsleyConfig || {};
window.ParsleyConfig.i18n = window.ParsleyConfig.i18n || {};
// Define then the messages
window.ParsleyConfig.i18n.en = $.extend(window.ParsleyConfig.i18n.en || {}, {
  defaultMessage: "This value seems to be invalid.",
  type: {
    email:        "This value should be a valid email.",
    url:          "This value should be a valid url.",
    number:       "This value should be a valid number.",
    integer:      "This value should be a valid integer.",
    digits:       "This value should be digits.",
    alphanum:     "This value should be alphanumeric."
  },
  notblank:       "This value should not be blank.",
  required:       "This value is required.",
  pattern:        "This value seems to be invalid.",
  min:            "This value should be greater than or equal to %s.",
  max:            "This value should be lower than or equal to %s.",
  range:          "This value should be between %s and %s.",
  minlength:      "This value is too short. It should have %s characters or more.",
  maxlength:      "This value is too long. It should have %s characters or fewer.",
  length:         "This value length is invalid. It should be between %s and %s characters long.",
  mincheck:       "You must select at least %s choices.",
  maxcheck:       "You must select %s choices or fewer.",
  check:          "You must select between %s and %s choices.",
  equalto:        "This value should be the same."
});
// If file is loaded after Parsley main file, auto-load locale
if ('undefined' !== typeof window.ParsleyValidator)
  window.ParsleyValidator.addCatalog('en', window.ParsleyConfig.i18n.en, true);

//     Parsley.js 2.0.3
//     http://parsleyjs.org
//     (c) 20012-2014 Guillaume Potier, Wisembly
//     Parsley may be freely distributed under the MIT license.

  // ### Parsley factory
  var Parsley = function (element, options, parsleyFormInstance) {
    this.__class__ = 'Parsley';
    this.__version__ = '2.0.3';
    this.__id__ = ParsleyUtils.hash(4);
    // Parsley must be instanciated with a DOM element or jQuery $element
    if ('undefined' === typeof element)
      throw new Error('You must give an element');
    if ('undefined' !== typeof parsleyFormInstance && 'ParsleyForm' !== parsleyFormInstance.__class__)
      throw new Error('Parent instance must be a ParsleyForm instance');
    return this.init($(element), options, parsleyFormInstance);
  };
  Parsley.prototype = {
    init: function ($element, options, parsleyFormInstance) {
      if (!$element.length)
        throw new Error('You must bind Parsley on an existing element.');
      this.$element = $element;
      // If element have already been binded, returns its saved Parsley instance
      if (this.$element.data('Parsley')) {
        var savedparsleyFormInstance = this.$element.data('Parsley');
        // If saved instance have been binded without a ParsleyForm parent and there is one given in this call, add it
        if ('undefined' !== typeof parsleyFormInstance)
          savedparsleyFormInstance.parent = parsleyFormInstance;
        return savedparsleyFormInstance;
      }
      // Handle 'static' options
      this.OptionsFactory = new ParsleyOptionsFactory(ParsleyDefaults, ParsleyUtils.get(window, 'ParsleyConfig') || {}, options, this.getNamespace(options));
      this.options = this.OptionsFactory.get(this);
      // A ParsleyForm instance is obviously a `<form>` elem but also every node that is not an input and have `data-parsley-validate` attribute
      if (this.$element.is('form') || (ParsleyUtils.attr(this.$element, this.options.namespace, 'validate') && !this.$element.is(this.options.inputs)))
        return this.bind('parsleyForm');
      // Every other supported element and not excluded element is binded as a `ParsleyField` or `ParsleyFieldMultiple`
      else if (this.$element.is(this.options.inputs) && !this.$element.is(this.options.excluded))
        return this.isMultiple() ? this.handleMultiple(parsleyFormInstance) : this.bind('parsleyField', parsleyFormInstance);
      return this;
    },
    isMultiple: function () {
      return (this.$element.is('input[type=radio], input[type=checkbox]') && 'undefined' === typeof this.options.multiple) || (this.$element.is('select') && 'undefined' !== typeof this.$element.attr('multiple'));
    },
    // Multiples fields are a real nightmare :(
    // Maybe some refacto would be appreciated here..
    handleMultiple: function (parsleyFormInstance) {
      var
        that = this,
        name,
        multiple,
        parsleyMultipleInstance;
      // Get parsleyFormInstance options if exist, mixed with element attributes
      this.options = $.extend(this.options, parsleyFormInstance ? parsleyFormInstance.OptionsFactory.get(parsleyFormInstance) : {}, ParsleyUtils.attr(this.$element, this.options.namespace));
      // Handle multiple name
      if (this.options.multiple)
        multiple = this.options.multiple;
      else if ('undefined' !== typeof this.$element.attr('name') && this.$element.attr('name').length)
        multiple = name = this.$element.attr('name');
      else if ('undefined' !== typeof this.$element.attr('id') && this.$element.attr('id').length)
        multiple = this.$element.attr('id');
      // Special select multiple input
      if (this.$element.is('select') && 'undefined' !== typeof this.$element.attr('multiple')) {
        return this.bind('parsleyFieldMultiple', parsleyFormInstance, multiple || this.__id__);
      // Else for radio / checkboxes, we need a `name` or `data-parsley-multiple` to properly bind it
      } else if ('undefined' === typeof multiple) {
        if (window.console && window.console.warn)
          window.console.warn('To be binded by Parsley, a radio, a checkbox and a multiple select input must have either a name or a multiple option.', this.$element);
        return this;
      }
      // Remove special chars
      multiple = multiple.replace(/(:|\.|\[|\]|\$)/g, '');
      // Add proper `data-parsley-multiple` to siblings if we have a valid multiple name
      if ('undefined' !== typeof name) {
        $('input[name="' + name + '"]').each(function () {
          if ($(this).is('input[type=radio], input[type=checkbox]'))
            $(this).attr(that.options.namespace + 'multiple', multiple);
        });
      }
      // Check here if we don't already have a related multiple instance saved
      if ($('[' + this.options.namespace + 'multiple=' + multiple +']').length) {
        for (var i = 0; i < $('[' + this.options.namespace + 'multiple=' + multiple +']').length; i++) {
          if ('undefined' !== typeof $($('[' + this.options.namespace + 'multiple=' + multiple +']').get(i)).data('Parsley')) {
            parsleyMultipleInstance = $($('[' + this.options.namespace + 'multiple=' + multiple +']').get(i)).data('Parsley');
            if (!this.$element.data('ParsleyFieldMultiple')) {
              parsleyMultipleInstance.addElement(this.$element);
              this.$element.attr(this.options.namespace + 'id', parsleyMultipleInstance.__id__);
            }
            break;
          }
        }
      }
      // Create a secret ParsleyField instance for every multiple field. It would be stored in `data('ParsleyFieldMultiple')`
      // And would be useful later to access classic `ParsleyField` stuff while being in a `ParsleyFieldMultiple` instance
      this.bind('parsleyField', parsleyFormInstance, multiple, true);
      return parsleyMultipleInstance || this.bind('parsleyFieldMultiple', parsleyFormInstance, multiple);
    },
    // Retrieve namespace used for DOM-API
    getNamespace: function (options) {
      // `data-parsley-namespace=<namespace>`
      if ('undefined' !== typeof this.$element.data('parsleyNamespace'))
        return this.$element.data('parsleyNamespace');
      if ('undefined' !== typeof ParsleyUtils.get(options, 'namespace'))
        return options.namespace;
      if ('undefined' !== typeof ParsleyUtils.get(window, 'ParsleyConfig.namespace'))
        return window.ParsleyConfig.namespace;
      return ParsleyDefaults.namespace;
    },
    // Return proper `ParsleyForm`, `ParsleyField` or `ParsleyFieldMultiple`
    bind: function (type, parentParsleyFormInstance, multiple, doNotStore) {
      var parsleyInstance;
      switch (type) {
        case 'parsleyForm':
          parsleyInstance = $.extend(
            new ParsleyForm(this.$element, this.OptionsFactory),
            new ParsleyAbstract(),
            window.ParsleyExtend
          )._bindFields();
          break;
        case 'parsleyField':
          parsleyInstance = $.extend(
            new ParsleyField(this.$element, this.OptionsFactory, parentParsleyFormInstance),
            new ParsleyAbstract(),
            window.ParsleyExtend
          );
          break;
        case 'parsleyFieldMultiple':
          parsleyInstance = $.extend(
            new ParsleyField(this.$element, this.OptionsFactory, parentParsleyFormInstance),
            new ParsleyAbstract(),
            new ParsleyMultiple(),
            window.ParsleyExtend
          )._init(multiple);
          break;
        default:
          throw new Error(type + 'is not a supported Parsley type');
      }
      if ('undefined' !== typeof multiple)
        ParsleyUtils.setAttr(this.$element, this.options.namespace, 'multiple', multiple);
      if ('undefined' !== typeof doNotStore) {
        this.$element.data('ParsleyFieldMultiple', parsleyInstance);
        return parsleyInstance;
      }
      // Store instance if `ParsleyForm`, `ParsleyField` or `ParsleyFieldMultiple`
      if (new RegExp('ParsleyF', 'i').test(parsleyInstance.__class__)) {
        // Store for later access the freshly binded instance in DOM element itself using jQuery `data()`
        this.$element.data('Parsley', parsleyInstance);
        // Tell the world we got a new ParsleyForm or ParsleyField instance!
        $.emit('parsley:' + ('parsleyForm' === type ? 'form' : 'field') + ':init', parsleyInstance);
      }
      return parsleyInstance;
    }
  };
  // ### jQuery API
  // `$('.elem').parsley(options)` or `$('.elem').psly(options)`
  $.fn.parsley = $.fn.psly = function (options) {
    if (this.length > 1) {
      var instances = [];
      this.each(function () {
        instances.push($(this).parsley(options));
      });
      return instances;
    }
    // Return undefined if applied to non existing DOM element
    if (!$(this).length) {
      if (window.console && window.console.warn)
        window.console.warn('You must bind Parsley on an existing element.');
      return;
    }
    return new Parsley(this, options);
  };
  // ### ParsleyUI
  // UI is a class apart that only listen to some events and them modify DOM accordingly
  // Could be overriden by defining a `window.ParsleyConfig.ParsleyUI` appropriate class (with `listen()` method basically)
  window.ParsleyUI = 'function' === typeof ParsleyUtils.get(window, 'ParsleyConfig.ParsleyUI') ?
    new window.ParsleyConfig.ParsleyUI().listen() : new ParsleyUI().listen();
  // ### ParsleyField and ParsleyForm extension
  // Ensure that defined if not already the case
  if ('undefined' === typeof window.ParsleyExtend)
    window.ParsleyExtend = {};
  // ### ParsleyConfig
  // Ensure that defined if not already the case
  if ('undefined' === typeof window.ParsleyConfig)
    window.ParsleyConfig = {};
  // ### Globals
  window.Parsley = window.psly = Parsley;
  window.ParsleyUtils = ParsleyUtils;
  window.ParsleyValidator = new ParsleyValidator(window.ParsleyConfig.validators, window.ParsleyConfig.i18n);
  // ### PARSLEY auto-binding
  // Prevent it by setting `ParsleyConfig.autoBind` to `false`
  if (false !== ParsleyUtils.get(window, 'ParsleyConfig.autoBind'))
    $(document).ready(function () {
      // Works only on `data-parsley-validate`.
      if ($('[data-parsley-validate]').length)
        $('[data-parsley-validate]').parsley();
    });
}));


(function(e,t){"use strict";function n(e){var t=Array.prototype.slice.call(arguments,1);return e.prop?e.prop.apply(e,t):e.attr.apply(e,t)}function s(e,t,n){var s,a;for(s in n)n.hasOwnProperty(s)&&(a=s.replace(/ |$/g,t.eventNamespace),e.bind(a,n[s]))}function a(e,t,n){s(e,n,{focus:function(){t.addClass(n.focusClass)},blur:function(){t.removeClass(n.focusClass),t.removeClass(n.activeClass)},mouseenter:function(){t.addClass(n.hoverClass)},mouseleave:function(){t.removeClass(n.hoverClass),t.removeClass(n.activeClass)},"mousedown touchbegin":function(){e.is(":disabled")||t.addClass(n.activeClass)},"mouseup touchend":function(){t.removeClass(n.activeClass)}})}function i(e,t){e.removeClass(t.hoverClass+" "+t.focusClass+" "+t.activeClass)}function r(e,t,n){n?e.addClass(t):e.removeClass(t)}function l(e,t,n){var s="checked",a=t.is(":"+s);t.prop?t.prop(s,a):a?t.attr(s,s):t.removeAttr(s),r(e,n.checkedClass,a)}function u(e,t,n){r(e,n.disabledClass,t.is(":disabled"))}function o(e,t,n){switch(n){case"after":return e.after(t),e.next();case"before":return e.before(t),e.prev();case"wrap":return e.wrap(t),e.parent()}return null}function c(t,s,a){var i,r,l;return a||(a={}),a=e.extend({bind:{},divClass:null,divWrap:"wrap",spanClass:null,spanHtml:null,spanWrap:"wrap"},a),i=e("<div />"),r=e("<span />"),s.autoHide&&t.is(":hidden")&&"none"===t.css("display")&&i.hide(),a.divClass&&i.addClass(a.divClass),s.wrapperClass&&i.addClass(s.wrapperClass),a.spanClass&&r.addClass(a.spanClass),l=n(t,"id"),s.useID&&l&&n(i,"id",s.idPrefix+"-"+l),a.spanHtml&&r.html(a.spanHtml),i=o(t,i,a.divWrap),r=o(t,r,a.spanWrap),u(i,t,s),{div:i,span:r}}function d(t,n){var s;return n.wrapperClass?(s=e("<span />").addClass(n.wrapperClass),s=o(t,s,"wrap")):null}function f(){var t,n,s,a;return a="rgb(120,2,153)",n=e('<div style="width:0;height:0;color:'+a+'">'),e("body").append(n),s=n.get(0),t=window.getComputedStyle?window.getComputedStyle(s,"").color:(s.currentStyle||s.style||{}).color,n.remove(),t.replace(/ /g,"")!==a}function p(t){return t?e("<span />").text(t).html():""}function m(){return navigator.cpuClass&&!navigator.product}function v(){return window.XMLHttpRequest!==void 0?!0:!1}function h(e){var t;return e[0].multiple?!0:(t=n(e,"size"),!t||1>=t?!1:!0)}function C(){return!1}function w(e,t){var n="none";s(e,t,{"selectstart dragstart mousedown":C}),e.css({MozUserSelect:n,msUserSelect:n,webkitUserSelect:n,userSelect:n})}function b(e,t,n){var s=e.val();""===s?s=n.fileDefaultHtml:(s=s.split(/[\/\\]+/),s=s[s.length-1]),t.text(s)}function y(e,t,n){var s,a;for(s=[],e.each(function(){var e;for(e in t)Object.prototype.hasOwnProperty.call(t,e)&&(s.push({el:this,name:e,old:this.style[e]}),this.style[e]=t[e])}),n();s.length;)a=s.pop(),a.el.style[a.name]=a.old}function g(e,t){var n;n=e.parents(),n.push(e[0]),n=n.not(":visible"),y(n,{visibility:"hidden",display:"block",position:"absolute"},t)}function k(e,t){return function(){e.unwrap().unwrap().unbind(t.eventNamespace)}}var H=!0,x=!1,A=[{match:function(e){return e.is("a, button, :submit, :reset, input[type='button']")},apply:function(e,t){var r,l,o,d,f;return l=t.submitDefaultHtml,e.is(":reset")&&(l=t.resetDefaultHtml),d=e.is("a, button")?function(){return e.html()||l}:function(){return p(n(e,"value"))||l},o=c(e,t,{divClass:t.buttonClass,spanHtml:d()}),r=o.div,a(e,r,t),f=!1,s(r,t,{"click touchend":function(){var t,s,a,i;f||e.is(":disabled")||(f=!0,e[0].dispatchEvent?(t=document.createEvent("MouseEvents"),t.initEvent("click",!0,!0),s=e[0].dispatchEvent(t),e.is("a")&&s&&(a=n(e,"target"),i=n(e,"href"),a&&"_self"!==a?window.open(i,a):document.location.href=i)):e.click(),f=!1)}}),w(r,t),{remove:function(){return r.after(e),r.remove(),e.unbind(t.eventNamespace),e},update:function(){i(r,t),u(r,e,t),e.detach(),o.span.html(d()).append(e)}}}},{match:function(e){return e.is(":checkbox")},apply:function(e,t){var n,r,o;return n=c(e,t,{divClass:t.checkboxClass}),r=n.div,o=n.span,a(e,r,t),s(e,t,{"click touchend":function(){l(o,e,t)}}),l(o,e,t),{remove:k(e,t),update:function(){i(r,t),o.removeClass(t.checkedClass),l(o,e,t),u(r,e,t)}}}},{match:function(e){return e.is(":file")},apply:function(t,r){function l(){b(t,p,r)}var d,f,p,v;return d=c(t,r,{divClass:r.fileClass,spanClass:r.fileButtonClass,spanHtml:r.fileButtonHtml,spanWrap:"after"}),f=d.div,v=d.span,p=e("<span />").html(r.fileDefaultHtml),p.addClass(r.filenameClass),p=o(t,p,"after"),n(t,"size")||n(t,"size",f.width()/10),a(t,f,r),l(),m()?s(t,r,{click:function(){t.trigger("change"),setTimeout(l,0)}}):s(t,r,{change:l}),w(p,r),w(v,r),{remove:function(){return p.remove(),v.remove(),t.unwrap().unbind(r.eventNamespace)},update:function(){i(f,r),b(t,p,r),u(f,t,r)}}}},{match:function(e){if(e.is("input")){var t=(" "+n(e,"type")+" ").toLowerCase(),s=" color date datetime datetime-local email month number password search tel text time url week ";return s.indexOf(t)>=0}return!1},apply:function(e,t){var s,i;return s=n(e,"type"),e.addClass(t.inputClass),i=d(e,t),a(e,e,t),t.inputAddTypeAsClass&&e.addClass(s),{remove:function(){e.removeClass(t.inputClass),t.inputAddTypeAsClass&&e.removeClass(s),i&&e.unwrap()},update:C}}},{match:function(e){return e.is(":radio")},apply:function(t,r){var o,d,f;return o=c(t,r,{divClass:r.radioClass}),d=o.div,f=o.span,a(t,d,r),s(t,r,{"click touchend":function(){e.uniform.update(e(':radio[name="'+n(t,"name")+'"]'))}}),l(f,t,r),{remove:k(t,r),update:function(){i(d,r),l(f,t,r),u(d,t,r)}}}},{match:function(e){return e.is("select")&&!h(e)?!0:!1},apply:function(t,n){var r,l,o,d;return n.selectAutoWidth&&g(t,function(){d=t.width()}),r=c(t,n,{divClass:n.selectClass,spanHtml:(t.find(":selected:first")||t.find("option:first")).html(),spanWrap:"before"}),l=r.div,o=r.span,n.selectAutoWidth?g(t,function(){y(e([o[0],l[0]]),{display:"block"},function(){var e;e=o.outerWidth()-o.width(),l.width(d+e),o.width(d)})}):l.addClass("fixedWidth"),a(t,l,n),s(t,n,{change:function(){o.html(t.find(":selected").html()),l.removeClass(n.activeClass)},"click touchend":function(){var e=t.find(":selected").html();o.html()!==e&&t.trigger("change")},keyup:function(){o.html(t.find(":selected").html())}}),w(o,n),{remove:function(){return o.remove(),t.unwrap().unbind(n.eventNamespace),t},update:function(){n.selectAutoWidth?(e.uniform.restore(t),t.uniform(n)):(i(l,n),o.html(t.find(":selected").html()),u(l,t,n))}}}},{match:function(e){return e.is("select")&&h(e)?!0:!1},apply:function(e,t){var n;return e.addClass(t.selectMultiClass),n=d(e,t),a(e,e,t),{remove:function(){e.removeClass(t.selectMultiClass),n&&e.unwrap()},update:C}}},{match:function(e){return e.is("textarea")},apply:function(e,t){var n;return e.addClass(t.textareaClass),n=d(e,t),a(e,e,t),{remove:function(){e.removeClass(t.textareaClass),n&&e.unwrap()},update:C}}}];m()&&!v()&&(H=!1),e.uniform={defaults:{activeClass:"active",autoHide:!0,buttonClass:"button",checkboxClass:"checker",checkedClass:"checked",disabledClass:"disabled",eventNamespace:".uniform",fileButtonClass:"action",fileButtonHtml:"Choose File",fileClass:"uploader",fileDefaultHtml:"No file selected",filenameClass:"filename",focusClass:"focus",hoverClass:"hover",idPrefix:"uniform",inputAddTypeAsClass:!0,inputClass:"uniform-input",radioClass:"radio",resetDefaultHtml:"Reset",resetSelector:!1,selectAutoWidth:!0,selectClass:"selector",selectMultiClass:"uniform-multiselect",submitDefaultHtml:"Submit",textareaClass:"uniform",useID:!0,wrapperClass:null},elements:[]},e.fn.uniform=function(t){var n=this;return t=e.extend({},e.uniform.defaults,t),x||(x=!0,f()&&(H=!1)),H?(t.resetSelector&&e(t.resetSelector).mouseup(function(){window.setTimeout(function(){e.uniform.update(n)},10)}),this.each(function(){var n,s,a,i=e(this);if(i.data("uniformed"))return e.uniform.update(i),void 0;for(n=0;A.length>n;n+=1)if(s=A[n],s.match(i,t))return a=s.apply(i,t),i.data("uniformed",a),e.uniform.elements.push(i.get(0)),void 0})):this},e.uniform.restore=e.fn.uniform.restore=function(n){n===t&&(n=e.uniform.elements),e(n).each(function(){var t,n,s=e(this);n=s.data("uniformed"),n&&(n.remove(),t=e.inArray(this,e.uniform.elements),t>=0&&e.uniform.elements.splice(t,1),s.removeData("uniformed"))})},e.uniform.update=e.fn.uniform.update=function(n){n===t&&(n=e.uniform.elements),e(n).each(function(){var t,n=e(this);t=n.data("uniformed"),t&&t.update(n,t.options)})}})(jQuery);


/*!
 * Bootstrap v3.2.0 (http://getbootstrap.com)
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */

/*!
 * Generated using the Bootstrap Customizer (http://getbootstrap.com/customize/?id=817aeb2704dbb5afdbec)
 * Config saved to config.json and https://gist.github.com/817aeb2704dbb5afdbec
 */
if (typeof jQuery === "undefined") { throw new Error("Bootstrap's JavaScript requires jQuery") }

/* ========================================================================
 * Bootstrap: modal.js v3.2.0
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options        = options
    this.$body          = $(document.body)
    this.$element       = $(element)
    this.$backdrop      =
    this.isShown        = null
    this.scrollbarWidth = 0

    if (this.options.remote) {
      this.$element
        .find('.modal-content')
        .load(this.options.remote, $.proxy(function () {
          this.$element.trigger('loaded.bs.modal')
        }, this))
    }
  }

  Modal.VERSION  = '3.2.0'

  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  }

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget)
  }

  Modal.prototype.show = function (_relatedTarget) {
    var that = this
    var e    = $.Event('show.bs.modal', { relatedTarget: _relatedTarget })

    this.$element.trigger(e)

    if (this.isShown || e.isDefaultPrevented()) return

    this.isShown = true

    this.checkScrollbar()
    this.$body.addClass('modal-open')

    this.setScrollbar()
    this.escape()

    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this))

    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade')

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body) // don't move modals dom position
      }

      that.$element
        .show()
        .scrollTop(0)

      if (transition) {
        that.$element[0].offsetWidth // force reflow
      }

      that.$element
        .addClass('in')
        .attr('aria-hidden', false)

      that.enforceFocus()

      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget })

      transition ?
        that.$element.find('.modal-dialog') // wait for modal to slide in
          .one('bsTransitionEnd', function () {
            that.$element.trigger('focus').trigger(e)
          })
          .emulateTransitionEnd(300) :
        that.$element.trigger('focus').trigger(e)
    })
  }

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault()

    e = $.Event('hide.bs.modal')

    this.$element.trigger(e)

    if (!this.isShown || e.isDefaultPrevented()) return

    this.isShown = false

    this.$body.removeClass('modal-open')

    this.resetScrollbar()
    this.escape()

    $(document).off('focusin.bs.modal')

    this.$element
      .removeClass('in')
      .attr('aria-hidden', true)
      .off('click.dismiss.bs.modal')

    $.support.transition && this.$element.hasClass('fade') ?
      this.$element
        .one('bsTransitionEnd', $.proxy(this.hideModal, this))
        .emulateTransitionEnd(300) :
      this.hideModal()
  }

  Modal.prototype.enforceFocus = function () {
    $(document)
      .off('focusin.bs.modal') // guard against infinite focus loop
      .on('focusin.bs.modal', $.proxy(function (e) {
        if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
          this.$element.trigger('focus')
        }
      }, this))
  }

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keyup.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide()
      }, this))
    } else if (!this.isShown) {
      this.$element.off('keyup.dismiss.bs.modal')
    }
  }

  Modal.prototype.hideModal = function () {
    var that = this
    this.$element.hide()
    this.backdrop(function () {
      that.$element.trigger('hidden.bs.modal')
    })
  }

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove()
    this.$backdrop = null
  }

  Modal.prototype.backdrop = function (callback) {
    var that = this
    var animate = this.$element.hasClass('fade') ? 'fade' : ''

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate

      this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />')
        .appendTo(this.$body)

      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (e.target !== e.currentTarget) return
        this.options.backdrop == 'static'
          ? this.$element[0].focus.call(this.$element[0])
          : this.hide.call(this)
      }, this))

      if (doAnimate) this.$backdrop[0].offsetWidth // force reflow

      this.$backdrop.addClass('in')

      if (!callback) return

      doAnimate ?
        this.$backdrop
          .one('bsTransitionEnd', callback)
          .emulateTransitionEnd(150) :
        callback()

    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in')

      var callbackRemove = function () {
        that.removeBackdrop()
        callback && callback()
      }
      $.support.transition && this.$element.hasClass('fade') ?
        this.$backdrop
          .one('bsTransitionEnd', callbackRemove)
          .emulateTransitionEnd(150) :
        callbackRemove()

    } else if (callback) {
      callback()
    }
  }

  Modal.prototype.checkScrollbar = function () {
    if (document.body.clientWidth >= window.innerWidth) return
    this.scrollbarWidth = this.scrollbarWidth || this.measureScrollbar()
  }

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10)
    if (this.scrollbarWidth) this.$body.css('padding-right', bodyPad + this.scrollbarWidth)
  }

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', '')
  }

  Modal.prototype.measureScrollbar = function () { // thx walsh
    var scrollDiv = document.createElement('div')
    scrollDiv.className = 'modal-scrollbar-measure'
    this.$body.append(scrollDiv)
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth
    this.$body[0].removeChild(scrollDiv)
    return scrollbarWidth
  }


  // MODAL PLUGIN DEFINITION
  // =======================

  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this   = $(this)
      var data    = $this.data('bs.modal')
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option)

      if (!data) $this.data('bs.modal', (data = new Modal(this, options)))
      if (typeof option == 'string') data[option](_relatedTarget)
      else if (options.show) data.show(_relatedTarget)
    })
  }

  var old = $.fn.modal

  $.fn.modal             = Plugin
  $.fn.modal.Constructor = Modal


  // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old
    return this
  }


  // MODAL DATA-API
  // ==============

  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this   = $(this)
    var href    = $this.attr('href')
    var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, ''))) // strip for ie7
    var option  = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data())

    if ($this.is('a')) e.preventDefault()

    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return // only register focus restorer if modal will actually get shown
      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus')
      })
    })
    Plugin.call($target, option, this)
  })

}(jQuery);

/* ========================================================================
 * Bootstrap: transition.js v3.2.0
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */


+function ($) {
  'use strict';

  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap')

    var transEndEventNames = {
      WebkitTransition : 'webkitTransitionEnd',
      MozTransition    : 'transitionend',
      OTransition      : 'oTransitionEnd otransitionend',
      transition       : 'transitionend'
    }

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] }
      }
    }

    return false // explicit for ie8 (  ._.)
  }

  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false
    var $el = this
    $(this).one('bsTransitionEnd', function () { called = true })
    var callback = function () { if (!called) $($el).trigger($.support.transition.end) }
    setTimeout(callback, duration)
    return this
  }

  $(function () {
    $.support.transition = transitionEnd()

    if (!$.support.transition) return

    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments)
      }
    }
  })

}(jQuery);


//     Underscore.js 1.6.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.6.0';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return obj;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
    return obj;
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var result;
    any(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);
    each(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, function(value, index, list) {
      return !predicate.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);
    each(obj, function(value, index, list) {
      if (!(result = result && predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);
    each(obj, function(value, index, list) {
      if (result || (result = predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    var result = -Infinity, lastComputed = -Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed > lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    var result = Infinity, lastComputed = Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed < lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Shuffle an array, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher???Yates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return value;
    return _.property(value);
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, iterator, context) {
    iterator = lookupIterator(iterator);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iterator, context) {
      var result = {};
      iterator = lookupIterator(iterator);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    _.has(result, key) ? result[key].push(value) : result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[0];
    if (n < 0) return [];
    return slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Split an array into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(array, predicate) {
    var pass = [], fail = [];
    each(array, function(elem) {
      (predicate(elem) ? pass : fail).push(elem);
    });
    return [pass, fail];
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.contains(other, item);
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, 'length').concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    return function() {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _) args[i] = arguments[position++];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error('bindAll must be passed function names');
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;
      if (last < wait) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))
                        && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (typeof (/./) !== 'function') {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  _.constant = function(value) {
    return function () {
      return value;
    };
  };

  _.property = function(key) {
    return function(obj) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
  _.matches = function(attrs) {
    return function(obj) {
      if (obj === attrs) return true; //avoid comparing an object to itself.
      for (var key in attrs) {
        if (attrs[key] !== obj[key])
          return false;
      }
      return true;
    }
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() { return new Date().getTime(); };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}).call(this);


/*!
 * jQuery Cookie Plugin v1.4.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2006, 2014 Klaus Hartl
 * Released under the MIT license
 */
(function (factory) {
	if (typeof define === 'function' && define.amd) {
		// AMD
		define(['jquery'], factory);
	} else if (typeof exports === 'object') {
		// CommonJS
		factory(require('jquery'));
	} else {
		// Browser globals
		factory(jQuery);
	}
}(function ($) {

	var pluses = /\+/g;

	function encode(s) {
		return config.raw ? s : encodeURIComponent(s);
	}

	function decode(s) {
		return config.raw ? s : decodeURIComponent(s);
	}

	function stringifyCookieValue(value) {
		return encode(config.json ? JSON.stringify(value) : String(value));
	}

	function parseCookieValue(s) {
		if (s.indexOf('"') === 0) {
			// This is a quoted cookie as according to RFC2068, unescape...
			s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
		}

		try {
			// Replace server-side written pluses with spaces.
			// If we can't decode the cookie, ignore it, it's unusable.
			// If we can't parse the cookie, ignore it, it's unusable.
			s = decodeURIComponent(s.replace(pluses, ' '));
			return config.json ? JSON.parse(s) : s;
		} catch(e) {}
	}

	function read(s, converter) {
		var value = config.raw ? s : parseCookieValue(s);
		return $.isFunction(converter) ? converter(value) : value;
	}

	var config = $.cookie = function (key, value, options) {

		// Write

		if (arguments.length > 1 && !$.isFunction(value)) {
			options = $.extend({}, config.defaults, options);

			if (typeof options.expires === 'number') {
				var days = options.expires, t = options.expires = new Date();
				t.setTime(+t + days * 864e+5);
			}

			return (document.cookie = [
				encode(key), '=', stringifyCookieValue(value),
				options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
				options.path    ? '; path=' + options.path : '',
				options.domain  ? '; domain=' + options.domain : '',
				options.secure  ? '; secure' : ''
			].join(''));
		}

		// Read

		var result = key ? undefined : {};

		// To prevent the for loop in the first place assign an empty array
		// in case there are no cookies at all. Also prevents odd result when
		// calling $.cookie().
		var cookies = document.cookie ? document.cookie.split('; ') : [];

		for (var i = 0, l = cookies.length; i < l; i++) {
			var parts = cookies[i].split('=');
			var name = decode(parts.shift());
			var cookie = parts.join('=');

			if (key && key === name) {
				// If second argument (value) is a function it's a converter...
				result = read(cookie, value);
				break;
			}

			// Prevent storing a cookie that we couldn't decode.
			if (!key && (cookie = read(cookie)) !== undefined) {
				result[name] = cookie;
			}
		}

		return result;
	};

	config.defaults = {};

	$.removeCookie = function (key, options) {
		if ($.cookie(key) === undefined) {
			return false;
		}

		// Must not alter options, thus extending a fresh object...
		$.cookie(key, '', $.extend({}, options, { expires: -1 }));
		return !$.cookie(key);
	};

}));



if(brightcove==undefined){var brightcove={};brightcove.getExperience=function(){alert("Please import APIModules_all.js in order to use the API.");};}
if(brightcove.experiences==undefined){brightcove.servicesURL='http://c.brightcove.com/services';brightcove.cdnURL='http://admin.brightcove.com';brightcove.secureCDNURL='https://sadmin.brightcove.com';brightcove.secureServicesURL='https://secure.brightcove.com/services';brightcove.pubHost='c.$pubcode$.$zoneprefix$$zone$';brightcove.pubSecureHost='secure.$pubcode$.$zoneprefix$$zone$';brightcove.pubSubdomain='ariessaucetown.local';brightcove.experiences={};brightcove.experienceObjects={};brightcove.timeouts={};brightcove.flashTimeoutInterval=10000;brightcove.htmlTimeoutInterval=10000;brightcove.experienceNum=0;brightcove.majorVersion=9;brightcove.majorRevision=0;brightcove.minorRevision=28;brightcove.servlet={AS3:"federated_f9",HTML:"htmlFederated"};brightcove.playerType={FLASH:"flash",HTML:"html",FLASH_IFRAME:"flashIFrame",INSTALLER:"installer",NO_SUPPORT:"nosupport"};brightcove.errorCodes={UNKNOWN:0,DOMAIN_RESTRICTED:1,GEO_RESTRICTED:2,INVALID_ID:3,NO_CONTENT:4,UNAVAILABLE_CONTENT:5,UPGRADE_REQUIRED_FOR_VIDEO:6,UPGRADE_REQUIRED_FOR_PLAYER:7,SERVICE_UNAVAILABLE:8};brightcove.defaultParam={};brightcove.defaultParam.width='100%';brightcove.defaultParam.height='100%';brightcove.defaultFlashParam={};brightcove.defaultFlashParam.allowScriptAccess='always';brightcove.defaultFlashParam.allowFullScreen='true';brightcove.defaultFlashParam.seamlessTabbing=false;brightcove.defaultFlashParam.swliveconnect=true;brightcove.defaultFlashParam.wmode='window';brightcove.defaultFlashParam.quality='high';brightcove.defaultFlashParam.bgcolor='#999999';brightcove.hasActiveX=brightcove.isIE=(window.ActiveXObject!=undefined);brightcove.userAgent=navigator.userAgent;brightcove._queuedAPICalls=[];var brightcoveJS=brightcove;brightcove.createExperiences=function(pEvent,pElementID){var experiences=[];var params;var experience;var flashSupport=brightcove.checkFlashSupport();var htmlSupport=brightcove.checkHtmlSupport();if(pElementID!=null){experiences.push(document.getElementById(pElementID));}else{experiences=brightcove.collectExperiences();}
if(brightcove.hasActiveX){params=document.getElementsByTagName('param');}
var urlParams=brightcove.cacheUrlParams();var numExperiences=experiences.length;for(var i=0;i<numExperiences;i++){experience=experiences[i];experience=brightcove.copyDefaultParams(experience);experience=brightcove.copySnippetParams(experience,params);experience=brightcove.copyUrlParams(experience,urlParams,numExperiences);var playerType=brightcove.determinePlayerType(experience,flashSupport,htmlSupport);var secureConnections=false;if(playerType==brightcove.playerType.HTML){secureConnections=experience.params.secureHTMLConnections=="true";}else{secureConnections=experience.params.secureConnections=="true";}
if(playerType==brightcove.playerType.NO_SUPPORT){brightcove.renderInstallGif(experience,secureConnections);brightcove.reportUpgradeRequired(experience);continue;}
if(playerType==brightcove.playerType.HTML){delete experience.params.linkBaseURL;}else{if(experience.params.includeAPI&&experience.params.templateReadyHandler!=null){experience.params.originalTemplateReadyHandler=experience.params.templateReadyHandler;var handlerName="templateReadyHandler"+experience.id;brightcove[handlerName]=(function(id){return function(event){if(brightcove.internal!=null&&brightcove.internal._instances[id]!=null){brightcove._addModuleToEvent(id,event);}
var player=brightcove.experienceObjects[id];brightcove.callHandlerForPlayer(player,"originalTemplateReadyHandler",event);};})(experience.id);experience.params.templateReadyHandler='brightcove["'+handlerName+'"]';}}
var file=brightcove.generateRequestUrl(experience,playerType,secureConnections);if(document.location.protocol=="http:"){var event='http://goku.brightcove.com/1pix.gif?';var gokuParams=["dcsuri=/viewer/player_load_req","playerType="+playerType,"playerURL="+encodeURIComponent(document.location||"")];var image=brightcove.createElement('image');for(var j in experience.params){gokuParams.push([encodeURIComponent(j)+"="+encodeURIComponent(experience.params[j])]);}
event+=gokuParams.join('&');image.src=event;}
brightcove.renderExperience(experience,file,playerType,secureConnections);}};brightcove.collectExperiences=function(){var experiences=[];var allObjects=document.getElementsByTagName('object');var numObjects=allObjects.length;for(var i=0;i<numObjects;i++){if(/\bBrightcoveExperience\b/.test(allObjects[i].className)){if(allObjects[i].type!='application/x-shockwave-flash'){experiences.push(allObjects[i]);}}}
return experiences;};brightcove.cacheUrlParams=function(){var urlParams={};urlParams.playerKey=decodeURIComponent(brightcove.getParameter("bckey"));urlParams.playerID=brightcove.getParameter("bcpid");urlParams.titleID=brightcove.getParameter("bctid");urlParams.lineupID=brightcove.getParameter("bclid");urlParams.autoStart=brightcove.getParameter("autoStart");urlParams.debuggerID=brightcove.getParameter("debuggerID");urlParams.forceHTML=brightcove.getParameter("forceHTML");urlParams.forceFlashIFrame=brightcove.getParameter("forceFlashIFrame");urlParams.debug=brightcove.getParameter("debug");urlParams.showNoContentMessage=brightcove.getParameter("showNoContentMessage");urlParams.htmlDefaultBitrate=brightcove.getParameter("htmlDefaultBitrate");urlParams.linkSrc=brightcove.getParameter("linkSrc");return urlParams;};brightcove.copyDefaultParams=function(experience){if(!experience.params)experience.params={};if(!experience.flashParams)experience.flashParams={};for(var i in brightcove.defaultParam){experience.params[i]=brightcove.defaultParam[i];}
for(var j in brightcove.defaultFlashParam){experience.flashParams[j]=brightcove.defaultFlashParam[j];}
if(experience.id.length>0){experience.params.flashID=experience.id;}else{experience.id=experience.params.flashID='bcExperienceObj'+(brightcove.experienceNum++);}
return experience;};brightcove.copySnippetParams=function(experience,params){if(!brightcove.hasActiveX){params=experience.getElementsByTagName('param');}
var numParams=params.length;var param;for(var j=0;j<numParams;j++){param=params[j];if(brightcove.hasActiveX&&param.parentNode.id!=experience.id){continue;}
experience.params[param.name]=param.value;}
if(experience.params.bgcolor!=undefined)experience.flashParams.bgcolor=experience.params.bgcolor;if(experience.params.wmode!=undefined)experience.flashParams.wmode=experience.params.wmode;if(experience.params.seamlessTabbing!=undefined)experience.flashParams.seamlessTabbing=experience.params.seamlessTabbing;return experience;};brightcove.copyUrlParams=function(experience,urlParams){if(experience.params.autoStart==undefined&&urlParams.autoStart!=undefined){experience.params.autoStart=urlParams.autoStart;}
if(urlParams.debuggerID!=undefined){experience.params.debuggerID=urlParams.debuggerID;}
if(urlParams.forceHTML!=undefined&&urlParams.forceHTML!==''){experience.params.forceHTML=urlParams.forceHTML;}
if(urlParams.forceFlashIFrame!=undefined&&urlParams.forceFlashIFrame!==''){experience.params.forceFlashIFrame=urlParams.forceFlashIFrame;}
if(urlParams.debug!=undefined&&urlParams.debug!==''){experience.params.debug=urlParams.debug;}
if(urlParams.showNoContentMessage!=undefined&&urlParams.showNoContentMessage!=''){experience.params.showNoContentMessage=urlParams.showNoContentMessage;}
if(urlParams.htmlDefaultBitrate!=undefined&&urlParams.htmlDefaultBitrate!==''){experience.params.htmlDefaultBitrate=urlParams.htmlDefaultBitrate;}
if(urlParams.linkSrc!=undefined&&urlParams.linkSrc!=''){experience.params.linkSrc=urlParams.linkSrc;}
var overrideContent=(urlParams.playerID.length<1&&urlParams.playerKey.length<1)||(urlParams.playerID==experience.params.playerID)||(urlParams.playerKey==experience.params.playerKey);if(overrideContent){if(urlParams.titleID.length>0){experience.params.videoID=urlParams.titleID;experience.params["@videoPlayer"]=urlParams.titleID;experience.params.autoStart=(experience.params.autoStart!="false"&&urlParams.autoStart!="false");}
if(urlParams.lineupID.length>0){experience.params.lineupID=urlParams.lineupID;}}
return experience;};brightcove.determinePlayerType=function(experience,flashSupport,htmlSupport){if(flashSupport==null&&htmlSupport==false){return brightcove.playerType.NO_SUPPORT;}
if(experience.params.forceHTML){if(window.console){var message="The forceHTML parameter was used for the Brightcove player. This value should ONLY be used for";message+=" development and testing purposes and is not supported in production environments.";console.log(message);}
return brightcove.playerType.HTML;}
if(experience.params.forceFlashIFrame||(brightcove.isMetroIE()&&flashSupport==null)){return brightcove.playerType.FLASH_IFRAME;}
if(flashSupport!=null){if(brightcove.isFlashVersionSufficient(experience,flashSupport)){return brightcove.playerType.FLASH;}else{return brightcove.playerType.INSTALLER;}}
if(htmlSupport){if(brightcove.isSupportedHTMLDevice()||experience.params.htmlFallback){return brightcove.playerType.HTML;}}
return brightcove.playerType.NO_SUPPORT;};brightcove.isFlashVersionSufficient=function(experience,flashSupport){if(flashSupport==null)return false;var setMajorVersion=false;var requestedMajorVersion;var requestedMajorRevision;var requestedMinorRevision;if(experience.params.majorVersion!=undefined){requestedMajorVersion=parseInt(experience.params.majorVersion,10);setMajorVersion=true;}else{requestedMajorVersion=brightcove.majorVersion;}
if(experience.params.majorRevision!=undefined){requestedMajorRevision=parseInt(experience.params.majorRevision,10);}else{if(setMajorVersion){requestedMajorRevision=0;}else{requestedMajorRevision=brightcove.majorRevision;}}
if(experience.params.minorRevision!=undefined){requestedMinorRevision=parseInt(experience.params.minorRevision,10);}else{if(setMajorVersion){requestedMinorRevision=0;}else{requestedMinorRevision=brightcove.minorRevision;}}
return(flashSupport.majorVersion>requestedMajorVersion||(flashSupport.majorVersion==requestedMajorVersion&&flashSupport.majorRevision>requestedMajorRevision)||(flashSupport.majorVersion==requestedMajorVersion&&flashSupport.majorRevision==requestedMajorRevision&&flashSupport.minorRevision>=requestedMinorRevision));};brightcove.generateRequestUrl=function(experience,playerType,secureConnections){var file;if(playerType==brightcove.playerType.INSTALLER){file=brightcove.cdnURL+"/viewer/playerProductInstall.swf";var MMPlayerType=brightcove.hasActiveX?"ActiveX":"PlugIn";document.title=document.title.slice(0,47)+" - Flash Player Installation";var MMdoctitle=document.title;file+="?&MMredirectURL="+window.location+'&MMplayerType='+MMPlayerType+'&MMdoctitle='+MMdoctitle;brightcove.reportUpgradeRequired(experience);}else{if(secureConnections){file=brightcove.getPubURL(brightcove.secureServicesURL,brightcove.pubSecureHost,experience.params.pubCode);}else{file=brightcove.getPubURL(brightcove.servicesURL,brightcove.pubHost,experience.params.pubCode);}
var servlet=(playerType==brightcove.playerType.HTML)?brightcove.servlet.HTML:brightcove.servlet.AS3;file+='/viewer/'+servlet+'?'+brightcove.getOverrides();for(var config in experience.params){file+='&'+encodeURIComponent(config)+'='+encodeURIComponent(experience.params[config]);}}
return file;};brightcove.renderInstallGif=function(experience,secureConnections){var containerID='_container'+experience.id;var container=brightcove.createElement('span');if(experience.params.height.charAt(experience.params.height.length-1)=="%"){container.style.display='block';}else{container.style.display='inline-block';}
container.id=containerID;var cdnURL=secureConnections?brightcove.secureCDNURL:brightcove.cdnURL;var upgradeFlashImage=cdnURL.indexOf('.co.jp')>0?"upgrade_flash_player_kk.gif":"upgrade_flash_player2.gif";var linkHTML="<a href='http://www.adobe.com/go/getflash/' target='_blank'><img src='"+cdnURL+"/viewer/"+upgradeFlashImage+"' alt='Get Flash Player' width='314' height='200' border='0'></a>";experience.parentNode.replaceChild(container,experience);document.getElementById(containerID).innerHTML=linkHTML;};brightcove.renderExperience=function(experience,file,playerType,secureConnections){var experienceElement;var experienceID=experience.id;var container;var timeout=brightcove.flashTimeoutInterval;if(!(experience.params.playerKey||experience.params.playerID||experience.params.playerId||experience.params.playerid)){if(window.console){console.log("No playerID or playerKey was found for the Brightcove player, so it can not be rendered.");}
return;}
brightcove.experienceObjects[experienceID]=experience;var unminified=(brightcove.getParameter("unminified")=="true")||(experience.params.unminified==="true");if(experience.params.includeAPI==="true"&&!(brightcove._apiRequested||brightcove.api)){var source="/js/api/";if(unminified){source+="unminified/";}
source+="SmartPlayerAPI.js";var apiInclude=brightcove.createElement('script');apiInclude.type="text/javascript";var cdnURL=secureConnections?brightcove.secureCDNURL:brightcove.cdnURL;apiInclude.src=cdnURL+source;experience.parentNode.appendChild(apiInclude);brightcove._apiRequested=true;}
file+="&startTime="+new Date().getTime();if(playerType===brightcove.playerType.HTML){timeout=brightcove.htmlTimeoutInterval;file+="&refURL="+(window.document.referrer?window.document.referrer:'not available');if(unminified){file+="&unminified=true";}
experienceElement=brightcove.createIFrame(experience);experience.parentNode.replaceChild(experienceElement,experience);brightcove.experiences[experienceID]=experienceElement;experience.element=experienceElement;if(experience.params.videoID||experience.params.videoId){file+="&"+encodeURIComponent("@videoPlayer")+"="+encodeURIComponent(experience.params.videoID||experience.params.videoId);}
experienceElement.src=file;}else if(playerType===brightcove.playerType.FLASH_IFRAME){var currentCDN=secureConnections?brightcove.secureCDNURL:brightcove.cdnURL;var iframeURL=currentCDN+"/js/flash_iframe.html?parentPage="+window.location.toString().split("?")[0];iframeURL+='&currentCDN='+currentCDN;if(unminified){iframeURL+='&unminified='+unminified;}
experienceElement=brightcove.createIFrame(experience);experience.parentNode.replaceChild(experienceElement,experience);brightcove.experiences[experienceID]=experienceElement;experience.element=experienceElement;experienceElement.src=iframeURL;window.addEventListener('message',function(event){if(event.origin.split("/")[2]!==currentCDN.split("/")[2])return;var data=JSON.parse(event.data);if(data!="bcIframeInitialized"){return;}
var playerConfig;if(brightcove.hasActiveX){experience.flashParams.movie=file;var flashEmbedStr=brightcove.getFlashEmbedString(experience,secureConnections);playerConfig={activeX:flashEmbedStr,height:experience.params.height,id:'_container'+experience.id,file:file};}else{playerConfig=brightcove.getFlashObjectParams(experience,file);}
var playerConfigStr=JSON.stringify(playerConfig);experienceElement.contentWindow.postMessage(playerConfigStr,currentCDN);},false);window.addEventListener('message',function(event){if(event.origin.split("/")[2]!==currentCDN.split("/")[2])return;var data=JSON.parse(event.data);if(data.api&&brightcove.internal&&brightcove.internal._setAPICallback){if(data.api=="apiCallback"){brightcove.internal._setAPICallback(data.pid,data.callback,iframeURL);}else if(data.api=="loadEvent"){window[data.callback](data.event);}else if(data.api=="onTemplateReadyEvent"){brightcove[data.callback](data.event);}}},false);}else{if(brightcove.hasActiveX){experience.flashParams.movie=file;var flashEmbedStr=brightcove.getFlashEmbedString(experience,secureConnections);var containerID='_container'+experience.id;container=brightcove.createFlashEmbed(containerID,experience.params.height);experience.parentNode.replaceChild(container,experience);document.getElementById(containerID).innerHTML=flashEmbedStr;brightcove.experiences[experienceID]=container;}else{var flashObjectParams=brightcove.getFlashObjectParams(experience,file);experienceElement=brightcove.createFlashObject(flashObjectParams);experience.parentNode.replaceChild(experienceElement,experience);brightcove.experiences[experienceID]=experienceElement;}}
brightcove.timeouts[experience.id]=setTimeout(function(){brightcove.handleExperienceTimeout(experienceID);},timeout);};brightcove.createIFrame=function(experience){var iframeElement=brightcove.createElement('iframe');iframeElement.id=experience.id;iframeElement.width=experience.params.width;iframeElement.height=experience.params.height;iframeElement.className=experience.className;iframeElement.frameborder=0;iframeElement.scrolling="no";iframeElement.style.borderStyle="none";return iframeElement;};brightcove.getFlashEmbedString=function(experience,secureConnections){var options='';var flashParams=experience.flashParams;for(var pOption in flashParams){options+='<param name="'+pOption+'" value="'+experience.flashParams[pOption]+'" />';}
var protocol=secureConnections?"https":"http";return'<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000"'
+' codebase="'+protocol+'://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version='+brightcove.majorVersion+','+brightcove.majorRevision+','+brightcove.minorRevision+',0"'
+' id="'+experience.id+'"'
+' width="'+experience.params.width+'"'
+' height="'+experience.params.height+'"'
+' type="application/x-shockwave-flash"'
+' class="BrightcoveExperience">'
+options
+'</object>';};brightcove.getFlashObjectParams=function(experience,file){var experienceObject={};experienceObject.type='application/x-shockwave-flash';experienceObject.data=file;experienceObject.id=experience.params.flashID;experienceObject.width=experience.params.width;experienceObject.height=experience.params.height;experienceObject.className=experience.className;experienceObject.seamlesstabbing=experience.flashParams.seamlessTabbing;for(var config in experience.flashParams){experienceObject["flashParam_"+config]=experience.flashParams[config];}
return experienceObject;};brightcove.createFlashEmbed=function(experienceId,height){var container=brightcove.createElement('span');if(height.charAt(height.length-1)=="%"){container.style.display='block';}else{container.style.display='inline-block';}
container.id=experienceId;return container;};brightcove.createFlashObject=function(playerConfig){var experienceElement=brightcove.createElement('object');experienceElement.type=playerConfig.type;experienceElement.data=playerConfig.data;experienceElement.id=playerConfig.id;experienceElement.width=playerConfig.width;experienceElement.height=playerConfig.height;experienceElement.className=playerConfig.className;experienceElement.setAttribute("seamlesstabbing",playerConfig.seamlessTabbing);var tempParam;var flashParamPrefix="flashParam_";for(var config in playerConfig){var flashParamInd=config.indexOf(flashParamPrefix);if(flashParamInd==0){tempParam=brightcove.createElement('param');tempParam.name=config.substring(flashParamPrefix.length);tempParam.value=playerConfig[config];experienceElement.appendChild(tempParam);}}
return experienceElement;};brightcove.handleExperienceTimeout=function(pID){brightcove.executeErrorHandlerForExperience(brightcove.experienceObjects[pID],{type:"templateError",errorType:"serviceUnavailable",code:brightcove.errorCodes.SERVICE_UNAVAILABLE,info:pID});};brightcove.reportPlayerLoad=function(pID){var timeout=brightcove.timeouts[pID];if(timeout){clearTimeout(timeout);}};brightcove.reportUpgradeRequired=function(pExperience){brightcove.executeErrorHandlerForExperience(pExperience,{type:"templateError",errorType:"upgradeRequiredForPlayer",code:brightcove.errorCodes.UPGRADE_REQUIRED_FOR_PLAYER,info:pExperience.id});};brightcove.checkFlashSupport=function(){var hasActiveX=(window.ActiveXObject!=undefined);return(hasActiveX)?brightcove.checkFlashSupportIE():brightcove.checkFlashSupportStandard();};brightcove.checkFlashSupportIE=function(){var versions;try{var flash=new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7");var version=flash.GetVariable('$version');versions=/ ([0-9]+),([0-9]+),([0-9]+),/.exec(version);}catch(exception){return null;}
return{majorVersion:versions[1],majorRevision:versions[2],minorRevision:versions[3]};};brightcove.isMetroIE=function(){var version=0;if(navigator.appVersion.indexOf("MSIE")!=-1){var appSplit=navigator.appVersion.split("MSIE");if(appSplit.length>1){version=parseFloat(appSplit[1]);}}
if(version<10||isNaN(version)){return false;}
var activeXSupport=false;try{activeXSupport=!!new ActiveXObject("htmlfile");}catch(e){activeXSupport=false;}
return!activeXSupport;};brightcove.checkFlashSupportStandard=function(){var versions;var majorVersion;var majorRevision;var minorRevision;try{if(typeof navigator.plugins!='undefined'&&navigator.plugins.length>0){if(navigator.plugins["Shockwave Flash 2.0"]||navigator.plugins["Shockwave Flash"]){var swfVersion=navigator.plugins["Shockwave Flash 2.0"]?" 2.0":"";var description=navigator.plugins["Shockwave Flash"+swfVersion].description;var filename=navigator.plugins["Shockwave Flash"+swfVersion].filename;if(filename.match){if(filename.toLowerCase().match(/lite/)){throw new Error();}}
versions=description.split(" ");majorVersion=versions[2].split(".")[0];majorRevision=versions[2].split(".")[1];minorRevision=versions[3];if(minorRevision==""){minorRevision=versions[4];}
if(minorRevision[0]=="d"){minorRevision=minorRevision.substring(1);}else if(minorRevision[0]=="r"){minorRevision=minorRevision.substring(1);if(minorRevision.indexOf("d")>0){minorRevision=minorRevision.substring(0,minorRevision.indexOf("d"));}}}else{throw new Error();}}else{return null;}}catch(exception){return null;}
return{majorVersion:majorVersion,majorRevision:majorRevision,minorRevision:minorRevision};};brightcove.checkHtmlSupport=function(){var v=brightcove.createElement('video');var videoSupport=true;if(!brightcove.userAgent.match(new RegExp("android","i"))){videoSupport=!!(v.canPlayType&&v.canPlayType('video/mp4; codecs="avc1.42E01E, mp4a.40.2"').replace(/no/,''));}
if(brightcove.userAgent.match(/BlackBerry.*Version\/6\.0/)){return false;}
var canvasSupport=!!brightcove.createElement('canvas').getContext;return videoSupport&&canvasSupport;};brightcove.isSupportedHTMLDevice=function(pUAString){var types=["iPad","iPhone","iPod","android","Silk"];var numTypes=types.length;var uaString=pUAString||brightcove.userAgent;for(var i=0;i<numTypes;i++){if(uaString.match(new RegExp(types[i],"i"))){return true;}}
return false;};brightcove.getTechnology=function(pExperienceId){for(var id in brightcove.experiences){if(pExperienceId==id){return(brightcove.experiences[id].tagName=="object")?brightcove.playerType.FLASH:brightcove.playerType.HTML;}}
return brightcove.playerType.NO_SUPPORT;};brightcove.respondToMessages=function(pMessage){if(brightcove.verifyMessage(pMessage)){var messageData=pMessage.data;if(messageData.charAt(0)=="\""){if(window.JSON){messageData=window.JSON.parse(messageData);}else{messageData=brightcove.json_parse(messageData);}}
var messageParts=messageData.split("::");var type=messageParts[1];var messageInfo="";for(var index=2;index<messageParts.length;index++){messageInfo+=messageParts[index];}
var messageJson=messageInfo.split("\n").join(" ");var messageDataObject;if(window.JSON){messageDataObject=window.JSON.parse(messageJson);}else{messageDataObject=brightcove.json_parse(messageJson);}
switch(type){case"error":brightcove.executeMessageCallback(messageDataObject,brightcove.executeErrorHandlerForExperience);break;case"api":brightcove.handleAPICallForHTML(messageDataObject);break;case"handler":var event=brightcove.internal._convertDates(messageDataObject.event);try{brightcove.internal._handlers[messageDataObject.handler](event);}catch(e){}
break;case"asyncGetter":var data=brightcove.internal._convertDates(messageDataObject.data);brightcove.internal._handlers[messageDataObject.handler](data);break;}}};brightcove.verifyMessage=function(pMessage){return(/^brightcove\.player/).test(pMessage.data);};brightcove.handleAPICallForHTML=function(pMessageObject){var experience=brightcove.experienceObjects[pMessageObject.id];if(experience==null){return;}
var id=experience.id;var method=pMessageObject.method;switch(method){case"initializeBridge":brightcove.reportPlayerLoad(id);if(pMessageObject.arguments[0]){if(brightcove.internal!=null){brightcove.internal._setAPICallback(id,null,pMessageObject.arguments[1]);brightcove.callHandlerForPlayer(experience,"templateLoadHandler",id);}else if(brightcove._apiRequested){brightcove._queuedAPICalls.push(pMessageObject);}}
break;case"callTemplateReady":if(brightcove._apiRequested&&!brightcove.internal){brightcove._queuedAPICalls.push(pMessageObject);}else{var event=pMessageObject.arguments;brightcove._addModuleToEvent(id,event);brightcove.callHandlerForPlayer(experience,"templateReadyHandler",event);}
break;}};brightcove._addModuleToEvent=function(pID,pEvent){if(pEvent.type!=null&&brightcove.api){var experience=brightcove.api.getExperience(pID);if(experience){pEvent.target=experience.getModule("experience");}}};brightcove.callHandlerForPlayer=function(pExperience,pHandler,pArgument){if(pExperience&&pExperience.params&&pExperience.params[pHandler]){var namespaceArray=pExperience.params[pHandler].split(".");var namespaces;if((namespaces=namespaceArray.length)>1){var trace=window;for(var i=0;i<namespaces;i++){trace=trace[namespaceArray[i]];}
if(typeof trace==="function"){trace(pArgument);}}else{window[pExperience.params[pHandler]](pArgument);}}};brightcove.executeErrorHandlerForExperience=function(pExperience,pErrorObject){brightcove.callHandlerForPlayer(pExperience,"templateErrorHandler",pErrorObject);};brightcove.executeMessageCallback=function(pMessageDataObject,pCallback){var experience;for(var experienceKey in brightcove.experienceObjects){experience=brightcove.experienceObjects[experienceKey];if(experience.element.src===pMessageDataObject.__srcUrl){delete pMessageDataObject.__srcUrl;pCallback(experience,pMessageDataObject);break;}}};brightcove.createExperience=function(pElement,pParentOrSibling,pAppend){if(!pElement.id||pElement.id.length<1){pElement.id='bcExperienceObj'+(brightcove.experienceNum++);}
if(pAppend){pParentOrSibling.appendChild(pElement);}else{pParentOrSibling.parentNode.insertBefore(pElement,pParentOrSibling);}
brightcove.createExperiences(null,pElement.id);};brightcove.removeExperience=function(pID){if(brightcove.experiences[pID]!=null){brightcove.experiences[pID].parentNode.removeChild(brightcove.experiences[pID]);}};brightcove.getURL=function(){var url;if(typeof window.location.search!='undefined'){url=window.location.search;}else{url=/(\?.*)$/.exec(document.location.href);}
return url;};brightcove.getOverrides=function(){var url=brightcove.getURL();var query=new RegExp('@[\\w\\.]+=[^&]+','g');var value=query.exec(url);var overrides="";while(value!=null){overrides+="&"+value;value=query.exec(url);}
return overrides;};brightcove.getParameter=function(pName,pDefaultValue){if(pDefaultValue==null)pDefaultValue="";var url=brightcove.getURL();var query=new RegExp(pName+'=([^&]*)');var value=query.exec(url);if(value!=null){return value[1];}else{return pDefaultValue;}};brightcove.createElement=function(el){if(document.createElementNS){return document.createElementNS('http://www.w3.org/1999/xhtml',el);}else{return document.createElement(el);}};brightcove.i18n={'BROWSER_TOO_OLD':'The browser you are using is too old. Please upgrade to the latest version of your browser.'};brightcove.removeListeners=function(){if(/KHTML/i.test(navigator.userAgent)){clearInterval(checkLoad);document.removeEventListener('load',brightcove.createExperiences,false);}
if(typeof document.addEventListener!='undefined'){document.removeEventListener('DOMContentLoaded',brightcove.createExperiences,false);document.removeEventListener('load',brightcove.createExperiences,false);}else if(typeof window.attachEvent!='undefined'){window.detachEvent('onload',brightcove.createExperiences);}};brightcove.getPubURL=function(source,host,pubCode){if(!pubCode||pubCode=="")return source;var re=/^([htps]{4,5}\:\/\/)([^\/\:]+)/i;host=host.replace("$pubcode$",pubCode).replace("$zoneprefix$$zone$",brightcove.pubSubdomain);return source.replace(re,"$1"+host);};brightcove.createExperiencesPostLoad=function(){brightcove.removeListeners();brightcove.createExperiences();};brightcove.encode=function(string){string=escape(string);string=string.replace(/\+/g,"%2B");string=string.replace(/\-/g,"%2D");string=string.replace(/\*/g,"%2A");string=string.replace(/\//g,"%2F");string=string.replace(/\./g,"%2E");string=string.replace(/_/g,"%5F");string=string.replace(/@/g,"%40");return string;};if(/KHTML/i.test(navigator.userAgent)){var checkLoad=setInterval(function(){if(/loaded|complete/.test(document.readyState)){clearInterval(checkLoad);brightcove.createExperiencesPostLoad();}},70);document.addEventListener('load',brightcove.createExperiencesPostLoad,false);}
if(typeof document.addEventListener!='undefined'){document.addEventListener('DOMContentLoaded',brightcove.createExperiencesPostLoad,false);document.addEventListener('load',brightcove.createExperiencesPostLoad,false);window.addEventListener("message",brightcove.respondToMessages,false);}else if(typeof window.attachEvent!='undefined'){window.attachEvent('onload',brightcove.createExperiencesPostLoad);}else{alert(brightcove.i18n.BROWSER_TOO_OLD);}}
brightcove.json_parse=(function(){"use strict";var state,stack,container,key,value,escapes={'\\':'\\','"':'"','/':'/','t':'\t','n':'\n','r':'\r','f':'\f','b':'\b'},string={go:function(){state='ok';},firstokey:function(){key=value;state='colon';},okey:function(){key=value;state='colon';},ovalue:function(){state='ocomma';},firstavalue:function(){state='acomma';},avalue:function(){state='acomma';}},number={go:function(){state='ok';},ovalue:function(){state='ocomma';},firstavalue:function(){state='acomma';},avalue:function(){state='acomma';}},action={'{':{go:function(){stack.push({state:'ok'});container={};state='firstokey';},ovalue:function(){stack.push({container:container,state:'ocomma',key:key});container={};state='firstokey';},firstavalue:function(){stack.push({container:container,state:'acomma'});container={};state='firstokey';},avalue:function(){stack.push({container:container,state:'acomma'});container={};state='firstokey';}},'}':{firstokey:function(){var pop=stack.pop();value=container;container=pop.container;key=pop.key;state=pop.state;},ocomma:function(){var pop=stack.pop();container[key]=value;value=container;container=pop.container;key=pop.key;state=pop.state;}},'[':{go:function(){stack.push({state:'ok'});container=[];state='firstavalue';},ovalue:function(){stack.push({container:container,state:'ocomma',key:key});container=[];state='firstavalue';},firstavalue:function(){stack.push({container:container,state:'acomma'});container=[];state='firstavalue';},avalue:function(){stack.push({container:container,state:'acomma'});container=[];state='firstavalue';}},']':{firstavalue:function(){var pop=stack.pop();value=container;container=pop.container;key=pop.key;state=pop.state;},acomma:function(){var pop=stack.pop();container.push(value);value=container;container=pop.container;key=pop.key;state=pop.state;}},':':{colon:function(){if(Object.hasOwnProperty.call(container,key)){throw new SyntaxError('Duplicate key "'+key+'"');}
state='ovalue';}},',':{ocomma:function(){container[key]=value;state='okey';},acomma:function(){container.push(value);state='avalue';}},'true':{go:function(){value=true;state='ok';},ovalue:function(){value=true;state='ocomma';},firstavalue:function(){value=true;state='acomma';},avalue:function(){value=true;state='acomma';}},'false':{go:function(){value=false;state='ok';},ovalue:function(){value=false;state='ocomma';},firstavalue:function(){value=false;state='acomma';},avalue:function(){value=false;state='acomma';}},'null':{go:function(){value=null;state='ok';},ovalue:function(){value=null;state='ocomma';},firstavalue:function(){value=null;state='acomma';},avalue:function(){value=null;state='acomma';}}};function debackslashify(text){return text.replace(/\\(?:u(.{4})|([^u]))/g,function(a,b,c){return b?String.fromCharCode(parseInt(b,16)):escapes[c];});}
return function(source,reviver){var r,tx=/^[\x20\t\n\r]*(?:([,:\[\]{}]|true|false|null)|(-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?)|"((?:[^\r\n\t\\\"]|\\(?:["\\\/trnfb]|u[0-9a-fA-F]{4}))*)")/;state='go';stack=[];try{for(;;){r=tx.exec(source);if(!r){break;}
if(r[1]){action[r[1]][state]();}else if(r[2]){value=+r[2];number[state]();}else{value=debackslashify(r[3]);string[state]();}
source=source.slice(r[0].length);}}catch(e){state=e;}
if(state!=='ok'||(/[^\x20\t\n\r]/).test(source)){throw state instanceof SyntaxError?state:new SyntaxError('JSON');}
return typeof reviver==='function'?(function walk(holder,key){var k,v,value=holder[key];if(value&&typeof value==='object'){for(k in value){if(Object.prototype.hasOwnProperty.call(value,k)){v=walk(value,k);if(v!==undefined){value[k]=v;}else{delete value[k];}}}}
return reviver.call(holder,key,value);}({'':value},'')):value;};}());


	/*
		Ford Global UX - Google Maps Bing Contingency API v1.4.3
	*/
	function googleMapsApi(config) {

		var language = config.language,
			countryCode = config.countryCode,
			countryCodes = config.countryCodes ? config.countryCodes.split(',') : [countryCode],
			imagePath = config.imagePath,
			countryBounds = config.countryBounds,
			autocompleteServiceURL = config.autocompleteCallbackURL,
			autocompleteCallback = config.autocompleteCallbackName,
			boundsString = '',
			countryCodes = config.countryCodes ? config.countryCodes.split(',') : [countryCode],
           	bingKey = config.apiKey? config.apiKey : 'Al1EdZ_aW5T6XNlr-BJxCw1l4KaA0tmXFI_eTl1RITyYptWUS0qit_MprtcG7w2F',
			dealerTableBingURL = config.dealerTableURL ? config.dealerTableURL : 'https://spatial.virtualearth.net/REST/v1/data/1652026ff3b247cd9d1f4cc12b9a080b/FordEuropeDealers_Transition/Dealer',
            autocompleteDealerList = [],
			punctuationRegex = /[\!"#\$%&'\(\)\*\+`\-\.\/\:;\<\=\>\?@\[\\\]\^_'\{\|\}~]/g,
			googleMatrixLimit = 100;

		if(countryBounds) {
			var bounds = [];

			for(var i = 0; i < countryBounds.length; i++) {
				if(countryBounds[i].lat && countryBounds[i].lng) {
					bounds.push(countryBounds[i].lng + ' ' + countryBounds[i].lat);
				}
			}
			if(!(countryBounds[0].lat === countryBounds[countryBounds.length-1].lat && countryBounds[0].lng === countryBounds[countryBounds.length-1].lng)) {
				bounds.push(countryBounds[0].lng + ' ' + countryBounds[0].lat);
			}
					
		}
		
		if(countryBounds){
			
			var nLat = - 91;	//North is +X, so maximise it in the range
			var sLat = 91;		//South is -X, so minimise it in the range
			
			var eLng = - 181;	//East is +Y, so maximise it in the range
			var wLng = 181;		//West is -Y, so minimise it in the range 
					
			for(var i = 0; i < countryBounds.length; i++) {

				var x = countryBounds[i];
				x.lat = Number(x.lat);
				x.lng = Number(x.lng);
			
				if(x.lat !== "" || x.lng !== ""){
			
					if(x.lat > nLat){
						nLat = x.lat;
					}
					if(x.lat < sLat){
						sLat = x.lat;
					}
					if(x.lng > eLng){
						eLng = x.lng;
					}
					if(x.lng < wLng){
						wLng = x.lng;	
					}
				}
			}			
			boundsString = '(' + sLat + ',' + wLng + ',' + nLat + ',' + eLng + ')';						
		}
		

		if(autocompleteServiceURL) {
			jsonpRequest(autocompleteServiceURL);
		}

		window[autocompleteCallback] = function(dealers) {
			autocompleteDealerList = dealers;
		};
		
		function googleMap(element, options) {
			var geocoder,
				self = this;
			
			options.streetViewControl = false;

			if(options.center && options.zoom) {
				this.map = new google.maps.Map(element, options);
			} else {
				this.map = new google.maps.Map(element, options);
				this.setBounds(countryBounds);
			}

			if(!options.enableZoom) {
				this.map.setOptions({
					scrollwheel: false
				});
			}

			if(options.disableBusinessPOI) {
				// Some businesses in Google Maps aren't flagged as businesses, so to disable them, we need to disable all POI, and re-enable all except businesses.
				this.map.setOptions({
					styles: [
						{							
							"featureType": "poi",
							"elementType": "labels",
							"stylers": [
								{ "visibility": "off" }
							]
						},{
							"featureType": "poi.attraction",
							"stylers": [
								{ "visibility": "on" }
							]
						},{
							"featureType": "poi.government",
							"stylers": [
								{ "visibility": "on" }
							]
						},{
							"featureType": "poi.medical",
							"stylers": [
								{ "visibility": "on" }
							]
						},{
							"featureType": "poi.park",
							"stylers": [
								{ "visibility": "on" }
							]
						},{
							"featureType": "poi.place_of_worship",
							"stylers": [
								{ "visibility": "on" }
							]
						},{
							"featureType": "poi.school",
							"stylers": [
								{ "visibility": "on" }
							]
						},{
							"featureType": "poi.sports_complex",
							"stylers": [
								{ "visibility": "on" }
							]
						}
					]
				});
			}

			this.map.setOptions({
				zoomControlOptions: {
					position: google.maps.ControlPosition.RIGHT_TOP
				},
				panControlOptions: {
					position: google.maps.ControlPosition.RIGHT_TOP
				}
			});

			this.markers = [];
			this.autocompleteTimeout = null;
			this.directionsService = new google.maps.DirectionsService();
			this.directionsDisplay = new google.maps.DirectionsRenderer({
				suppressMarkers: true
			});

			this.offsetByPixels = function(latlng, offset) {
				var projection = this.map.getProjection(),
					scale = 1 << this.map.getZoom(),
					gLatLng,
					point,
					newLatLng;

				gLatLng = new google.maps.LatLng(latlng.lat, latlng.lng);
				point = projection.fromLatLngToPoint(gLatLng);
				point.x = point.x + (offset / scale);
				newLatLng = projection.fromPointToLatLng(point);

				return {
					lat: newLatLng.lat(),
					lng: newLatLng.lng()
				};
			};
		}

		googleMap.prototype.setCenter = function(latlng, offset) {
			var self = this;
			this.map.setCenter(latlng);
			if(offset) {
				var listener = google.maps.event.addListener(this.map, 'idle', function() {
					self.map.panBy(offset, 0);
					google.maps.event.removeListener(listener);
				});
			}
		};

		googleMap.prototype.getCenter = function() {
			var center = this.map.getCenter();
			return {
				lat: center.lat(),
				lng: center.lng()
			};
		};

		googleMap.prototype.panTo = function(latlng) {
			this.map.panTo({
				lat: latlng.lat,
				lng: latlng.lng
			});
		};

		googleMap.prototype.setZoom = function(zoomLevel) {
			this.map.setZoom(zoomLevel);
		};

		googleMap.prototype.getZoom = function() {
			return this.map.getZoom();
		};

		googleMap.prototype.setBounds = function(points, offset) {
			var bounds = new google.maps.LatLngBounds(),
				self = this;
			for(var i = 0; i < points.length; i++) {
				if(points[i].lat && points[i].lng) { // For normal latlng objects
					bounds.extend(new google.maps.LatLng(points[i].lat, points[i].lng));
				} else {
					if(points[i].location && points[i].location.lat && points[i].location.lng) { // For dealer object
						bounds.extend(new google.maps.LatLng(points[i].location.lat, points[i].location.lng));
					}
				}
			}
			if(points.length) {
				this.map.fitBounds(bounds);
				if(offset) {
					var listener = google.maps.event.addListener(this.map, 'idle', function() {
						var zoom = self.map.getZoom();
						self.map.setZoom(zoom-1);
						self.map.panBy(offset, 0);
						google.maps.event.removeListener(listener);
					});
				}
			}
		};

		googleMap.prototype.getBounds = function() {
			var bounds = this.map.getBounds(),
				ne = bounds.getNorthEast(),
				sw = bounds.getSouthWest();

			return {
				ne: {
					lat: ne.lat(),
					lng: ne.lng()
				},
				sw: {
					lat: sw.lat(),
					lng: sw.lng()
				}
			};
		};
		
		googleMap.prototype.geocodeLocation = function(location, callback) {
			var geocoder = new google.maps.Geocoder(),
				locations = [];
			
			geocoder.geocode({
					address: location,
					region: countryCode
				},
				function(data) {
					var addLocation = false;
					for(var i = 0; i < data.length; i++) {
						addLocation = false;
						for(var j = 0; j < data[i].address_components.length; j++) {
							for(var k = 0; k < data[i].address_components[j].types.length; k++) {
								if(data[i].address_components[j].types[k] === 'country') {
									for(var m = 0; m < countryCodes.length; m++) {
										if(data[i].address_components[j].short_name === countryCodes[m]) {
											addLocation = true;
										}
									}
								}
							}
						}
						if(addLocation) {
							locations.push({
								lat: data[i].geometry.location.lat(),
								lng: data[i].geometry.location.lng(),
								description: data[i].formatted_address,
								types: data[i].types,
								address_components: data[i].address_components
							});
						}
					}
					callback(locations);
				}
			);
		};

		googleMap.prototype.reverseGeocode = function(latlng, callback) {
			var geocoder = new google.maps.Geocoder();

			geocoder.geocode({
				'latLng': new google.maps.LatLng(latlng.lat, latlng.lng)
			},
			function(results, status) {
				if(results[0]) {
					callback(results[0].formatted_address);
				}
			});
		};

		googleMap.prototype.addMarker = function(latlng) {
			var marker = new google.maps.Marker({
				position: latlng,
				map: this.map
			});
			return marker;
		};

		googleMap.prototype.addGuxMarker = function(latlng, label, infoWindowContent, callback) {
			var overlay;

			overlay = new guxMarker(new google.maps.LatLng(latlng.lat, latlng.lng), this.map, label, infoWindowContent, callback);
			this.markers.unshift(overlay);
			return overlay;
		};

		googleMap.prototype.addListener = function(target, event, handler) {
			return google.maps.event.addListener(target, event, handler);
		};

		googleMap.prototype.removeListener = function(listener) {
			google.maps.event.removeListener(listener);
		};

		googleMap.prototype.trigger = function(target, event) {
			google.maps.event.trigger(target, event);
		};

		googleMap.prototype.clearMarkers = function(markers) {
			for(var i = 0; i < markers.length; i++) {
				markers[i].setMap(null);
			}
		};


		//Bing
		googleMap.prototype.searchDealersByDistance = function(origin, radius, limit, callback, matchParameters, containsParameters) {
			
			var url,
				baseUrl = dealerTableBingURL + '?',
				geoFilter = radius ? 'spatialFilter=nearby(' + origin.lat + ',' + origin.lng + ',' + radius + ')' : 'spatialFilter=bbox' + boundsString,
				select = '&$select=*,__Distance',
				matchArr = [],
				codeArr = [],
				distanceMatrixDealers = [],
				filter = '&$filter=',
				maxResults = '&$top=' + limit,
				format = '&$format=json',
				key = '&key=' + bingKey,
				jsonp = '&Jsonp=processDealerResults'
				matchORClauses = [],
				matchNOTClauses = [];
			
			
			if(matchParameters && matchParameters.OR_CLAUSES) {
				for(var i = 0; i < matchParameters.OR_CLAUSES.length; i++) {
					orArr = [];
					for(var orKey in matchParameters.OR_CLAUSES[i]) {
						if(orKey.indexOf('!') === 0) {
							orArr.push(orKey.slice(1) + '%20Ne%20%27' + matchParameters.OR_CLAUSES[i][orKey] + '%27');
						} else {
							orArr.push(orKey + '%20Eq%20%27' + matchParameters.OR_CLAUSES[i][orKey] + '%27');
						}
					}
					matchArr.push('(' + orArr.join('%20OR%20') + ')');
				}
				delete matchParameters.OR_CLAUSES;
			}
						
			if(matchParameters) {
				for(var k in matchParameters) {
					if(k.indexOf('!') === 0) {
						matchArr.push(k.slice(1) + '%20Ne%20%27' + matchParameters[k] + '%27');
					} else {
						matchArr.push(k + '%20Eq%20%27' + matchParameters[k] + '%27');
					}
				}
			}			
			
						
			if(matchArr.length) {
				filter += matchArr.join('%20And%20');
			} else {
				throw new Error('Must specify at least one match parameter.');
			}
						
			url = baseUrl + geoFilter + select + filter + maxResults + format + key + jsonp;

			jsonpRequest(url);

			window.processDealerResults = function(data) {
				var dealer,
					dealers = [];
				var service = new google.maps.DistanceMatrixService();

				for(var i = 0; i < data.d.results.length; i++) {
					dealer = data.d.results[i];
					dealer.location = {
						lat: data.d.results[i].Latitude,
						lng: data.d.results[i].Longitude
					};
					dealer.distance = data.d.results[i].__Distance * 1000;
					dealers.push(dealer);
				}

				destinationLatLngs = [];
				var newDealers = filterDealers(dealers, containsParameters, googleMatrixLimit);

				//Create parallel array of lat lngs to pass into distance matrix
                for (i = 0; i < newDealers.length; i++) {
					destinationLatLngs.push(new google.maps.LatLng(newDealers[i].location.lat, newDealers[i].location.lng));
				}

				//(Dealers chopped into) Chunks of 25, rounded up.
                //This is the have-I-finished array for AJAX calls.
                distanceResponses = new Array(Math.ceil(destinationLatLngs.length/25));

                if(newDealers.length){

                    var createDistanceCallback = function(index) {
						return function(distances) {
							var count = destinationLatLngs.slice(index*25, index*25 + 25).length, j;

                            if(distances) {
								for(j = 0; j < distances.rows[0].elements.length; j++) {
									if(distances.rows[0].elements[j].status === 'OK') {
										newDealers[index*25 + j].distance = distances.rows[0].elements[j].distance.value;
										newDealers[index*25 + j].drivingTime = distances.rows[0].elements[j].duration.value;
										if(radius) {
                                            //Only push dealers within driving distance of radius, not generic distance
											if(newDealers[index*25+j].distance <= radius * 1000) {
												distanceMatrixDealers.push(newDealers[index*25+j]);
											}
										} else {
											distanceMatrixDealers.push(newDealers[index*25+j]);
										}
									} else {
                                            //Error handling for no distance.
											newDealers[index*25 + j].distanceError = distances.rows[0].elements[j].status;
											newDealers[index*25 + j].distance = null;
											distanceMatrixDealers.push(newDealers[index*25+j]);
									}
								}
							} else {
                                //Error is no distances array returned
								for(j = 0; j < count; j++) {
									newDealers[index*25 + j].distanceError = 'DRIVING DISTANCE UNAVAILABLE';
									newDealers[index*25 + j].distance = null;
									distanceMatrixDealers.push(newDealers[index*25+j]);
								}
							}

                            //This chunk of dealers has come back.
							distanceResponses[index] = true;
							responsesReturned = true;

							//If any of the chunks haven't returned, we fail.
							for(var k = 0; k < distanceResponses.length; k++) {
								if(!distanceResponses[k]) {
									responsesReturned = false;
								}
							}

							if(responsesReturned) {

								//The dealers array becomes our array of dealers that went through the distance matrix.
								//This seems the dealers are in the right order regardless of function-call return order.
								dealers = distanceMatrixDealers.sort(function(a, b) {
									if(typeof a.distance === 'number' && typeof b.distance === 'number') {
										return a.distance - b.distance;
									} else {
										if(typeof a.distance !== 'number' && typeof b.distance !== 'number') {
											return a.directDistance - b.directDistance;
										}
										if(typeof a.distance === 'number') {
											return -1;
										} else {
											return 1;
										}
									}
								});
								callback(dealers.slice(0, limit));
							}
						};
					};

					for(i = 0; i < destinationLatLngs.length / 25; i++) {
						service.getDistanceMatrix(
						{
							origins: [origin],
							destinations: destinationLatLngs.slice(i*25, i*25 + 25),
							travelMode: google.maps.TravelMode.DRIVING
						}, createDistanceCallback(i));
					}

				} else {
					callback(newDealers);
				}			
			};
		};


		//Bing
        //Limit is max results to be given to the application.
		googleMap.prototype.searchDealersByProperties = function(limit, callback, matchParameters, containsParameters) {

			var	url,
				baseUrl = dealerTableBingURL + '?',
				geoFilter = 'spatialFilter=bbox' + boundsString,
				select = '&$select=*',
				matchArr = [],
				filter = '&$filter=',				
				maxResults = '&$top=' + limit,
				format = '&$format=json',
				linecount = '&$inlinecount=allpages'
				key = '&key=' + bingKey,
				jsonp = '&Jsonp=processDealerResults';

            var dealers = [];

			//space is %20, quote is %27
			//Eg: $filter=CountryCode%20Eq%20%27GBR%27%20And%20AccidentRepair%20Eq%20%271%27%20And%20HasSalesDepartmentPV%20Eq%20%271%27
			if(matchParameters && matchParameters.OR_CLAUSES) {
				for(var i = 0; i < matchParameters.OR_CLAUSES.length; i++) {
					orArr = [];
					for(var orKey in matchParameters.OR_CLAUSES[i]) {
						if(orKey.indexOf('!') === 0) {
							orArr.push(orKey.slice(1) + '%20Ne%20%27' + matchParameters.OR_CLAUSES[i][orKey] + '%27');
						} else {
							orArr.push(orKey + '%20Eq%20%27' + matchParameters.OR_CLAUSES[i][orKey] + '%27');
						}
					}
					matchArr.push('(' + orArr.join('%20OR%20') + ')');
				}
				delete matchParameters.OR_CLAUSES;
			}
			

			if(matchParameters) {
				for(var k in matchParameters) {
					if(k.indexOf('!') === 0) {
						matchArr.push(k.slice(1) + '%20Ne%20%27' + matchParameters[k] + '%27');
					} else {
						matchArr.push(k + '%20Eq%20%27' + matchParameters[k] + '%27');
					}
				}
			}

			if(matchArr.length) {
				filter += matchArr.join('%20And%20');
			} else {
				throw new Error('Must specify at least one match parameter.');
			}

			var dealersCompleted = [],
                dealerCount;

			url = baseUrl + geoFilter + select + filter + maxResults + linecount + format + key + jsonp;


			jsonpRequest(url);

            //Initial processing of dealer results.
			window.processDealerResults = function(data) {

                dealerCount = data.d.__count;
            	var dealer;
            	
				for(i = 0; i < (dealerCount / 250); i++){					
					dealersCompleted.push(false); 			
				}				

				for(var i = 0; i < data.d.results.length; i++) {
					dealer = data.d.results[i];
					dealer.location = {
						lat: data.d.results[i].Latitude,
						lng: data.d.results[i].Longitude
					};
					dealer.distance = data.d.results[i].__Distance * 1000;
					dealers.push(dealer);
				}

                if(dealerCount > limit){

                    var iterationCount = parseInt(limit, 10),
                        skip,
                        mResults;

					var completed = 0;	

                    var testLoop = 0;

                    for(var outloop = 0; outloop < (dealerCount / 250); outloop++){	
    
                        //rebuild the string
                        skip = '&$skip=' + iterationCount;
                        mResults = '&$top=' + 250;
                        url = baseUrl + geoFilter + select + filter + skip + mResults + format + key + jsonp;

   						//Increment the loop count.
						iterationCount = iterationCount + 250;

                        //Re do it.
                        jsonpRequest(url);

                        window.processDealerResults = function(data) {

							var dealer;
						
                            for(var i = 0; i < data.d.results.length; i++) {
                                dealer = data.d.results[i];
                                dealer.location = {
                                    lat: data.d.results[i].Latitude,
                                    lng: data.d.results[i].Longitude
                                };
                                dealer.distance = data.d.results[i].__Distance * 1000;
                                dealers.push(dealer);
                            }

                            dealersCompleted[testLoop] = true;
							 testLoop = testLoop + 1;

                            var complete = true;	
                            for(var innerLoop = 0; innerLoop < dealersCompleted.length; innerLoop++){					
                                if(dealersCompleted[innerLoop] == false){
                                    complete = false;
                                }
                            }

                            if(complete == true){
								var newDealers = filterDealers(dealers, containsParameters, limit);
                                callback(newDealers);
                            }

                        };
                    }
                } else {
					var newDealers = filterDealers(dealers, containsParameters, limit);
					callback(newDealers);
                }    
			};
		};


        filterDealers = function(dealers, containsParameters, maxResults) {
		
			if(!containsParameters){
				return dealers;
			}
		
            var dealersFiltered = [];
						
            if(dealers.length > 0) {

				for(var i = 0; i < dealers.length; i++){
				
					var allMatched = true;
					
					for(var key in containsParameters){
						if(containsParameters.hasOwnProperty(key)){					
							
							var check = containsParameters[key];
							var dealerString = dealers[i][key];
														
							if(dealerString.indexOf(check) === -1){
								allMatched = false;
							}							
						}	
					}
					
					if(allMatched === true){
						dealersFiltered.push(dealers[i]);							
					}
				}
          	}

          	var dealersReturned = [];

            if(dealersFiltered.length >= maxResults){
                dealersReturned = dealersFiltered.slice(0,maxResults); 
    		} else {
              	dealersReturned = dealersFiltered;
            }

            return dealersReturned;
        };


		googleMap.prototype.displayDealers = function(dealers) {
				var marker,
					index,
					latlngs = {};

				this.clearMarkers(this.markers);
				this.markers = [];
				for(var i = dealers.length - 1; i >= 0; i--) {
					index = dealers[i].indexOverride || i + 1;
					marker = this.addGuxMarker({lat: dealers[i].location.lat, lng: dealers[i].location.lng }, index, dealers[i].infoWindowMarkup, dealers[i].callback);
					if(latlngs[dealers[i].location.lat + ',' + dealers[i].location.lng]) {
						marker.xOffset = 12;
					}
					latlngs[dealers[i].location.lat + ',' + dealers[i].location.lng] = true;
					
				}
			};

		googleMap.prototype.clearDealers = function() {
			this.clearMarkers(this.markers);
			this.markers = [];
		};

		googleMap.prototype.selectMarker = function(index, delay) {
			if(this.markers[index]) {
				this.markers[index].select(delay);
			}
		};

		googleMap.prototype.deselectMarker = function(index) {
			if(this.markers[index]) {
				this.markers[index].deselect();
			}
		};

		googleMap.prototype.deselectMarkers = function() {
			for (var i = 0; i < this.markers.length; i++) {
				this.markers[i].deselect();
			};
		};

		googleMap.prototype.autocomplete = function(text, limit, callback, type) {
			var ac,
				delay = 300,
				locationPredictions,
				dealerPredictions,
				predictions = {
					dealers: [],
					locations: []
				},
				self = this,			
				placesCompleted = 0,
				places = {};

			if(this.autocompleteTimeout) {
				clearTimeout(this.autocompleteTimeout);
			}

			if(type !== 'dealers') {
				ac = new google.maps.places.AutocompleteService();
			}

			this.autocompleteTimeout = setTimeout(function() {
				if(type === 'dealers') {
					// Get dealer name predictions
					var dealerMatches = [],
						dealerMatch;

					for (var i = 0; i < autocompleteDealerList.length; i++) {
						if(autocompleteMatch(autocompleteDealerList[i].n, text) !== -1) {
							dealerMatch = {
								DealerName: autocompleteDealerList[i].n,
								EntityID: autocompleteDealerList[i].e
							};
							if(autocompleteMatch(autocompleteDealerList[i].n, text) === 0) {
								dealerMatches.splice(0, 0, dealerMatch);
							} else {
								dealerMatches.push(dealerMatch);
							}
						}
					};
					predictions.dealers = dealerMatches.slice(0, limit);
					callback(predictions);

				} else {
					// Get location predictions
					for(var i = 0; i < countryCodes.length; i++) {
						ac.getPlacePredictions(
							{
								input: text,
								componentRestrictions: {country: countryCodes[i]},
								types: ['geocode']
							},
							function(index) {
								return function(results, status) {
									locationPredictions = [];
									if(status == google.maps.places.PlacesServiceStatus.OK) {
										for(var j = 0; j < results.length; j++) {
											locationPredictions.push(results[j].description);
										}
									}
									places[countryCodes[index]] = locationPredictions;
									placesCompleted++;
									
									if(placesCompleted === countryCodes.length) {
										for(var k = 0; k < countryCodes.length; k++) {
											predictions.locations = predictions.locations.concat(places[countryCodes[k]]);
										}
										// predictions.locations = predictions.locations.slice(0, limit);
										if(type !== 'locations') {
											// Get dealer name predictions
											var dealerMatches = [],
												dealerMatch;

											for (var m = 0; m < autocompleteDealerList.length; m++) {
												if(autocompleteMatch(autocompleteDealerList[m].n, text) !== -1) {
													dealerMatch = {
														DealerName: autocompleteDealerList[m].n,
														EntityID: autocompleteDealerList[m].e
													};
													if(autocompleteMatch(autocompleteDealerList[m].n, text) === 0) {
														dealerMatches.splice(0, 0, dealerMatch);
													} else {
														dealerMatches.push(dealerMatch);
													}
												}
											};
											predictions.dealers = dealerMatches.slice(0, limit);
										}
										callback(predictions);
									}
								}
							}(i)
						);
					}
				}	
			}, delay);
		};

		googleMap.prototype.displayRouteToDealer = function(origin, dealer) {
			var self = this;
			this.directionsDisplay.setMap(this.map);
			this.directionsService.route({
				origin: origin.lat + ', ' + origin.lng,
				destination: dealer.location.lat + ', ' + dealer.location.lng,
				travelMode: google.maps.TravelMode.DRIVING
			}, function(response, status) {
				if (status == google.maps.DirectionsStatus.OK) {
					self.directionsDisplay.setDirections(response);
				}
			});
		};

		googleMap.prototype.clearRoutes = function() {
			this.directionsDisplay.setMap(null);
		};

		googleMap.prototype.getDirectionsURL = function(destination, origin) {
			var start,
				end;

			start = origin ? 'saddr=' + origin.lat + ',' + origin.lng + '&': '';
			end = 'daddr=' + destination.lat + ',' + destination.lng;
			return 'https://maps.google.com?' + start + end;
		};

		googleMap.prototype.getAddressDirectionsURL = function(destinationDealer, addressFormat, origin) {

			var start,
				end,
				addressLines = [];

			for(var i = 0; i < addressFormat.length; i++) {
				if(destinationDealer[addressFormat[i]]) {
					addressLines.push(destinationDealer[addressFormat[i]]);
				}
			}

			start = origin ? 'saddr=' + origin.description + '&': '';
			end = 'daddr=' + addressLines.join('+');
			return 'https://maps.google.com?' + start + end + '&output=classic';
		};

		// Custom marker using OverlayView to allow us to use HTML and numbered markers
		guxMarker.prototype = new google.maps.OverlayView();

		function guxMarker(position, map, label, infoWindowContent, callback) {
			this.position_ = position;
			this.map_ = map;
			this.label_ = label;
			this.content_ = infoWindowContent;
			this.div_ = null;
			this.icon = null;
			this.callback = callback;
			this.infoWindow = null;
			this.setMap(map);
		}

				
		guxMarker.prototype.select = function(delay) {
		
			var self = this; 			
							
			if(self.icon && self.div_){
				self.icon.src = imagePath + 'map-marker-active.png';
				self.div_.style.zIndex = 100;
			} else {
				var timeOut = delay || 500;
				setTimeout(function(){
					if(self.icon && self.div_){
						self.icon.src = imagePath + 'map-marker-active.png';
						self.div_.style.zIndex = 100;
					}
				}, timeOut);
			}
		};

		guxMarker.prototype.deselect = function(delay) {
		
			var self = this;
			
			if(self.icon && self.div_){
				self.icon.src = imagePath + 'map-marker.png';
				self.div_.style.zIndex = 1;
				if(self.infoWindow) {
					self.infoWindow.hide();
				}
			} else {
				var timeOut = delay || 500;
				setTimeout(function(){
					if(self.icon && self.div_){
						self.icon.src = imagePath + 'map-marker.png';
						self.div_.style.zIndex = 1;
						if(self.infoWindow) {
							self.infoWindow.hide();
						}
					}
				}, timeOut);
			}			
		};
		
		
		guxMarker.prototype.onAdd = function() {
			var div = document.createElement('div'),
				self = this;
			div.className = "map-marker";
			div.style.width = '35px';
			div.style.height = '46px';

			var img = document.createElement('img');
			img.src = imagePath + 'map-marker.png';
			this.icon = img;
			div.appendChild(img);

			if(this.label_) {
				var span = document.createElement('span');
				span.innerHTML = this.label_;
				span.className = 'marker-label';
				div.appendChild(span);
			}

			this.div_ = div;

			var panes = this.getPanes();
			panes.overlayMouseTarget.appendChild(div);

			if(this.callback) {
				google.maps.event.addDomListener(div, 'click', function() {
					self.callback();
				});
			}
			
			if(this.content_) {
				// var infoWindow;
				google.maps.event.addDomListener(div, 'click', function() {
					self.showInfoWindow();
				});
			}
			
		};

		guxMarker.prototype.showInfoWindow = function() {
			var self = this;
			// If already displayed then hide the current version before showing a new one
			// Perhaps show should be a no-op on an already displayed info window?
			if(this.infoWindow) {
				this.infoWindow.hide();
			}
			self.infoWindow = new guxInfoWindow(self.getPosition(), self.map_, self.content_);
			if(self.xOffset) {
				self.infoWindow.xOffset = self.xOffset;
			}
		};

		guxMarker.prototype.hideInfowindow = function() {
			if(this.infoWindow) {
				this.infoWindow.hide();
			}
		};

		guxMarker.prototype.draw = function() {
			var overlayProjection = this.getProjection();

			var pos = overlayProjection.fromLatLngToDivPixel(this.position_);
			var xOffset = this.xOffset || 0;

			var div = this.div_;
			div.style.position = 'absolute';
			div.style.left = pos.x - (17 + xOffset) + 'px';
			div.style.top = pos.y - 46 + 'px';
			};

		guxMarker.prototype.onRemove = function() {
			this.div_.parentNode.removeChild(this.div_);
			this.div_ = null;
			if(this.infoWindow) {
				this.infoWindow.hide();
			}
		};

		guxMarker.prototype.getPosition = function() {
			return {
				lat: this.position_.lat(),
				lng: this.position_.lng()
			};
		};

		// Custom infowindow
		guxInfoWindow.prototype = new google.maps.OverlayView();

		function guxInfoWindow(position, map, content) {
			this.position_ = new google.maps.LatLng(position.lat, position.lng);
			this.map_ = map;
			this.content_ = content;
			this.div_ = null;

			this.setMap(map);
		}

		guxInfoWindow.prototype.onAdd = function() {
			var div = document.createElement('div');
			div.className = "info-window";
			div.innerHTML = this.content_;
			this.div_ = div;

			var panes = this.getPanes();
			panes.overlayMouseTarget.appendChild(div);

			var self = this;
			google.maps.event.addListener(this.map_, 'click', function() {
				self.setMap(null);
			});

			google.maps.event.addDomListener(div, 'click', function(e) {
				e.stopPropagation();
			});

		};

		guxInfoWindow.prototype.draw = function() {
			var overlayProjection = this.getProjection();

			var pos = overlayProjection.fromLatLngToDivPixel(this.position_);
			var xOffset = this.xOffset || 0;

			var div = this.div_;
			div.style.position = 'absolute';
			div.style.left = pos.x + 30 - xOffset + 'px';
			div.style.top = pos.y - 60 + 'px';
		};

		guxInfoWindow.prototype.onRemove = function() {
			this.div_.parentNode.removeChild(this.div_);
			this.div_ = null;
		};

		guxInfoWindow.prototype.hide = function() {
			this.setMap(null);
		};



		function jsonpRequest(url) {
			var script = document.createElement('script');
			script.setAttribute('type', 'text/javascript');
			script.setAttribute('src', url);
			document.body.appendChild(script);
		}

		function dealerDistance(olat, olon, dlat, dlon) {
			var R = 6371; // Approx. radius of the Earth http://en.wikipedia.org/wiki/Earth_radius
			var lat1 = Math.PI * olat / 180;
			var lon1 = Math.PI * olon / 180;
			var lat2 = Math.PI * dlat / 180;
			var lon2 = Math.PI * dlon / 180;
			var dlon = lon2 - lon1, dlat = lat2 - lat1;
			var a = Math.pow(Math.sin(dlat/2),2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(dlon/2),2);
			var c = 2 * Math.asin(Math.min(1, Math.sqrt(a)));
			var d = R * c;
			return d;
		}

		function characterFolding(character) {
			var characterMap = {
				//'\u0049': '\u0131',
				'\u00B5': '\u03BC',
				'\u00DF': '\u0073\u0073',
				'\u0130': '\u0069\u0307',
				//'\u0130': '\u0069',
				'\u0149': '\u02BC\u006E',
				'\u017F': '\u0073',
				'\u01F0': '\u006A\u030C',
				'\u0345': '\u03B9',
				'\u0390': '\u03B9\u0308\u0301',
				'\u03B0': '\u03C5\u0308\u0301',
				'\u03C2': '\u03C3',
				'\u03D0': '\u03B2',
				'\u03D1': '\u03B8',
				'\u03D5': '\u03C6',
				'\u03D6': '\u03C0',
				'\u03F0': '\u03BA',
				'\u03F1': '\u03C1',
				'\u03F5': '\u03B5',
				'\u0587': '\u0565\u0582',
				'\u1E96': '\u0068\u0331',
				'\u1E97': '\u0074\u0308',
				'\u1E98': '\u0077\u030A',
				'\u1E99': '\u0079\u030A',
				'\u1E9A': '\u0061\u02BE',
				'\u1E9B': '\u1E61',
				'\u1E9E': '\u0073\u0073',
				'\u1F50': '\u03C5\u0313',
				'\u1F52': '\u03C5\u0313\u0300',
				'\u1F54': '\u03C5\u0313\u0301',
				'\u1F56': '\u03C5\u0313\u0342',
				'\u1F80': '\u1F00\u03B9',
				'\u1F81': '\u1F01\u03B9',
				'\u1F82': '\u1F02\u03B9',
				'\u1F83': '\u1F03\u03B9',
				'\u1F84': '\u1F04\u03B9',
				'\u1F85': '\u1F05\u03B9',
				'\u1F86': '\u1F06\u03B9',
				'\u1F87': '\u1F07\u03B9',
				'\u1F88': '\u1F00\u03B9',
				'\u1F89': '\u1F01\u03B9',
				'\u1F8A': '\u1F02\u03B9',
				'\u1F8B': '\u1F03\u03B9',
				'\u1F8C': '\u1F04\u03B9',
				'\u1F8D': '\u1F05\u03B9',
				'\u1F8E': '\u1F06\u03B9',
				'\u1F8F': '\u1F07\u03B9',
				'\u1F90': '\u1F20\u03B9',
				'\u1F91': '\u1F21\u03B9',
				'\u1F92': '\u1F22\u03B9',
				'\u1F93': '\u1F23\u03B9',
				'\u1F94': '\u1F24\u03B9',
				'\u1F95': '\u1F25\u03B9',
				'\u1F96': '\u1F26\u03B9',
				'\u1F97': '\u1F27\u03B9',
				'\u1F98': '\u1F20\u03B9',
				'\u1F99': '\u1F21\u03B9',
				'\u1F9A': '\u1F22\u03B9',
				'\u1F9B': '\u1F23\u03B9',
				'\u1F9C': '\u1F24\u03B9',
				'\u1F9D': '\u1F25\u03B9',
				'\u1F9E': '\u1F26\u03B9',
				'\u1F9F': '\u1F27\u03B9',
				'\u1FA0': '\u1F60\u03B9',
				'\u1FA1': '\u1F61\u03B9',
				'\u1FA2': '\u1F62\u03B9',
				'\u1FA3': '\u1F63\u03B9',
				'\u1FA4': '\u1F64\u03B9',
				'\u1FA5': '\u1F65\u03B9',
				'\u1FA6': '\u1F66\u03B9',
				'\u1FA7': '\u1F67\u03B9',
				'\u1FA8': '\u1F60\u03B9',
				'\u1FA9': '\u1F61\u03B9',
				'\u1FAA': '\u1F62\u03B9',
				'\u1FAB': '\u1F63\u03B9',
				'\u1FAC': '\u1F64\u03B9',
				'\u1FAD': '\u1F65\u03B9',
				'\u1FAE': '\u1F66\u03B9',
				'\u1FAF': '\u1F67\u03B9',
				'\u1FB2': '\u1F70\u03B9',
				'\u1FB3': '\u03B1\u03B9',
				'\u1FB4': '\u03AC\u03B9',
				'\u1FB6': '\u03B1\u0342',
				'\u1FB7': '\u03B1\u0342\u03B9',
				'\u1FBC': '\u03B1\u03B9',
				'\u1FBE': '\u03B9',
				'\u1FC2': '\u1F74\u03B9',
				'\u1FC3': '\u03B7\u03B9',
				'\u1FC4': '\u03AE\u03B9',
				'\u1FC6': '\u03B7\u0342',
				'\u1FC7': '\u03B7\u0342\u03B9',
				'\u1FCC': '\u03B7\u03B9',
				'\u1FD2': '\u03B9\u0308\u0300',
				'\u1FD3': '\u03B9\u0308\u0301',
				'\u1FD6': '\u03B9\u0342',
				'\u1FD7': '\u03B9\u0308\u0342',
				'\u1FE2': '\u03C5\u0308\u0300',
				'\u1FE3': '\u03C5\u0308\u0301',
				'\u1FE4': '\u03C1\u0313',
				'\u1FE6': '\u03C5\u0342',
				'\u1FE7': '\u03C5\u0308\u0342',
				'\u1FF2': '\u1F7C\u03B9',
				'\u1FF3': '\u03C9\u03B9',
				'\u1FF4': '\u03CE\u03B9',
				'\u1FF6': '\u03C9\u0342',
				'\u1FF7': '\u03C9\u0342\u03B9',
				'\u1FFC': '\u03C9\u03B9',
				'\uFB00': '\u0066\u0066',
				'\uFB01': '\u0066\u0069',
				'\uFB02': '\u0066\u006C',
				'\uFB03': '\u0066\u0066\u0069',
				'\uFB04': '\u0066\u0066\u006C',
				'\uFB05': '\u0073\u0074',
				'\uFB06': '\u0073\u0074',
				'\uFB13': '\u0574\u0576',
				'\uFB14': '\u0574\u0565',
				'\uFB15': '\u0574\u056B',
				'\uFB16': '\u057E\u0576',
				'\uFB17': '\u0574\u056D'
			};
			return characterMap[character] || character;
		}

		function autocompleteMatch(dealerName, searchString) {
			searchString = searchString.toLowerCase().replace(punctuationRegex, '').replace(/\s+/g, ' ').replace(/./g, characterFolding);
			dealerName = dealerName.toLowerCase().replace(punctuationRegex, '').replace(/\s+/g, ' ').replace(/./g, characterFolding);
			return dealerName.indexOf(searchString);
		}
		
		return {
			map: googleMap
		};
	}



(function($){
  
  $.pubsubLogging = false;
  
  var o = $({});
  
  $.subscribe = function() {
    o.bind.apply( o, arguments );
  };
  
  $.subscribeOnce = function() {
    o.one.apply( o, arguments );
  };
  
  $.unsubscribe = function() {
    o.unbind.apply( o, arguments );
  };
  
  $.publish = function() {
    if( $.pubsubLogging ) { console.log.apply( console, arguments ); }
	o.trigger.apply( o, arguments );
  };
  
}(jQuery));


/*! jQuery UI - v1.11.0 - 2014-06-26
* http://jqueryui.com
* Includes: core.js, widget.js, mouse.js, position.js, accordion.js, autocomplete.js, button.js, datepicker.js, dialog.js, draggable.js, droppable.js, effect.js, effect-blind.js, effect-bounce.js, effect-clip.js, effect-drop.js, effect-explode.js, effect-fade.js, effect-fold.js, effect-highlight.js, effect-puff.js, effect-pulsate.js, effect-scale.js, effect-shake.js, effect-size.js, effect-slide.js, effect-transfer.js, menu.js, progressbar.js, resizable.js, selectable.js, selectmenu.js, slider.js, sortable.js, spinner.js, tabs.js, tooltip.js
* Copyright 2014 jQuery Foundation and other contributors; Licensed MIT */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([ "jquery" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {
/*!
 * jQuery UI Core 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/ui-core/
 */


// $.ui might exist from components with no dependencies, e.g., $.ui.position
$.ui = $.ui || {};

$.extend( $.ui, {
	version: "1.11.0",

	keyCode: {
		BACKSPACE: 8,
		COMMA: 188,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		LEFT: 37,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SPACE: 32,
		TAB: 9,
		UP: 38
	}
});

// plugins
$.fn.extend({
	scrollParent: function() {
		var position = this.css( "position" ),
			excludeStaticParent = position === "absolute",
			scrollParent = this.parents().filter( function() {
				var parent = $( this );
				if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
					return false;
				}
				return (/(auto|scroll)/).test( parent.css( "overflow" ) + parent.css( "overflow-y" ) + parent.css( "overflow-x" ) );
			}).eq( 0 );

		return position === "fixed" || !scrollParent.length ? $( this[ 0 ].ownerDocument || document ) : scrollParent;
	},

	uniqueId: (function() {
		var uuid = 0;

		return function() {
			return this.each(function() {
				if ( !this.id ) {
					this.id = "ui-id-" + ( ++uuid );
				}
			});
		};
	})(),

	removeUniqueId: function() {
		return this.each(function() {
			if ( /^ui-id-\d+$/.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		});
	}
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var map, mapName, img,
		nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName ) ?
		!element.disabled :
		"a" === nodeName ?
			element.href || isTabIndexNotNaN :
			isTabIndexNotNaN) &&
		// the element and all of its ancestors must be visible
		visible( element );
}

function visible( element ) {
	return $.expr.filters.visible( element ) &&
		!$( element ).parents().addBack().filter(function() {
			return $.css( this, "visibility" ) === "hidden";
		}).length;
}

$.extend( $.expr[ ":" ], {
	data: $.expr.createPseudo ?
		$.expr.createPseudo(function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		}) :
		// support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support: jQuery <1.8
if ( !$( "<a>" ).outerWidth( 1 ).jquery ) {
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			});
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each(function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			});
		};

		$.fn[ "outer" + name] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each(function() {
				$( this).css( type, reduce( this, size, true, margin ) + "px" );
			});
		};
	});
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

// support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
if ( $( "<a>" ).data( "a-b", "a" ).removeData( "a-b" ).data( "a-b" ) ) {
	$.fn.removeData = (function( removeData ) {
		return function( key ) {
			if ( arguments.length ) {
				return removeData.call( this, $.camelCase( key ) );
			} else {
				return removeData.call( this );
			}
		};
	})( $.fn.removeData );
}

// deprecated
$.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

$.fn.extend({
	focus: (function( orig ) {
		return function( delay, fn ) {
			return typeof delay === "number" ?
				this.each(function() {
					var elem = this;
					setTimeout(function() {
						$( elem ).focus();
						if ( fn ) {
							fn.call( elem );
						}
					}, delay );
				}) :
				orig.apply( this, arguments );
		};
	})( $.fn.focus ),

	disableSelection: (function() {
		var eventType = "onselectstart" in document.createElement( "div" ) ?
			"selectstart" :
			"mousedown";

		return function() {
			return this.bind( eventType + ".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
		};
	})(),

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	}
});

// $.ui.plugin is deprecated. Use $.widget() extensions instead.
$.ui.plugin = {
	add: function( module, option, set ) {
		var i,
			proto = $.ui[ module ].prototype;
		for ( i in set ) {
			proto.plugins[ i ] = proto.plugins[ i ] || [];
			proto.plugins[ i ].push( [ option, set[ i ] ] );
		}
	},
	call: function( instance, name, args, allowDisconnected ) {
		var i,
			set = instance.plugins[ name ];

		if ( !set ) {
			return;
		}

		if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode || instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
			return;
		}

		for ( i = 0; i < set.length; i++ ) {
			if ( instance.options[ set[ i ][ 0 ] ] ) {
				set[ i ][ 1 ].apply( instance.element, args );
			}
		}
	}
};


/*!
 * jQuery UI Widget 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */


var widget_uuid = 0,
	widget_slice = Array.prototype.slice;

$.cleanData = (function( orig ) {
	return function( elems ) {
		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			try {
				$( elem ).triggerHandler( "remove" );
			// http://bugs.jquery.com/ticket/8235
			} catch( e ) {}
		}
		orig( elems );
	};
})( $.cleanData );

$.widget = function( name, base, prototype ) {
	var fullName, existingConstructor, constructor, basePrototype,
		// proxiedPrototype allows the provided prototype to remain unmodified
		// so that it can be used as a mixin for multiple widgets (#8876)
		proxiedPrototype = {},
		namespace = name.split( "." )[ 0 ];

	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};
	// extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,
		// copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),
		// track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	});

	basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = (function() {
			var _super = function() {
					return base.prototype[ prop ].apply( this, arguments );
				},
				_superApply = function( args ) {
					return base.prototype[ prop ].apply( this, args );
				};
			return function() {
				var __super = this._super,
					__superApply = this._superApply,
					returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		})();
	});
	constructor.prototype = $.widget.extend( basePrototype, {
		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	});

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto );
		});
		// remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widget_slice.call( arguments, 1 ),
		inputIndex = 0,
		inputLength = input.length,
		key,
		value;
	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {
				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :
						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );
				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = widget_slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.widget.extend.apply( null, [ options ].concat(args) ) :
			options;

		if ( isMethodCall ) {
			this.each(function() {
				var methodValue,
					instance = $.data( this, fullName );
				if ( options === "instance" ) {
					returnValue = instance;
					return false;
				}
				if ( !instance ) {
					return $.error( "cannot call methods on " + name + " prior to initialization; " +
						"attempted to call method '" + options + "'" );
				}
				if ( !$.isFunction( instance[options] ) || options.charAt( 0 ) === "_" ) {
					return $.error( "no such method '" + options + "' for " + name + " widget instance" );
				}
				methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue && methodValue.jquery ?
						returnValue.pushStack( methodValue.get() ) :
						methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",
	options: {
		disabled: false,

		// callbacks
		create: null
	},
	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widget_uuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;
		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			});
			this.document = $( element.style ?
				// element within the document
				element.ownerDocument :
				// element is window or document
				element.document || element );
			this.window = $( this.document[0].defaultView || this.document[0].parentWindow );
		}

		this._create();
		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},
	_getCreateOptions: $.noop,
	_getCreateEventData: $.noop,
	_create: $.noop,
	_init: $.noop,

	destroy: function() {
		this._destroy();
		// we can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.unbind( this.eventNamespace )
			.removeData( this.widgetFullName )
			// support: jquery <1.6.3
			// http://bugs.jquery.com/ticket/9413
			.removeData( $.camelCase( this.widgetFullName ) );
		this.widget()
			.unbind( this.eventNamespace )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetFullName + "-disabled " +
				"ui-state-disabled" );

		// clean up events and states
		this.bindings.unbind( this.eventNamespace );
		this.hoverable.removeClass( "ui-state-hover" );
		this.focusable.removeClass( "ui-state-focus" );
	},
	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key,
			parts,
			curOption,
			i;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {
			// handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				.toggleClass( this.widgetFullName + "-disabled", !!value );

			// If the widget is becoming disabled, then nothing is interactive
			if ( value ) {
				this.hoverable.removeClass( "ui-state-hover" );
				this.focusable.removeClass( "ui-state-focus" );
			}
		}

		return this;
	},

	enable: function() {
		return this._setOptions({ disabled: false });
	},
	disable: function() {
		return this._setOptions({ disabled: true });
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement,
			instance = this;

		// no suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// no element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {
				// allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
							$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ ),
				eventName = match[1] + instance.eventNamespace,
				selector = match[2];
			if ( selector ) {
				delegateElement.delegate( selector, eventName, handlerProxy );
			} else {
				element.bind( eventName, handlerProxy );
			}
		});
	},

	_off: function( element, eventName ) {
		eventName = (eventName || "").split( " " ).join( this.eventNamespace + " " ) + this.eventNamespace;
		element.unbind( eventName ).undelegate( eventName );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-hover" );
			},
			mouseleave: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-hover" );
			}
		});
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				$( event.currentTarget ).addClass( "ui-state-focus" );
			},
			focusout: function( event ) {
				$( event.currentTarget ).removeClass( "ui-state-focus" );
			}
		});
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[0], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}
		var hasOptions,
			effectName = !options ?
				method :
				options === true || typeof options === "number" ?
					defaultEffect :
					options.effect || defaultEffect;
		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}
		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;
		if ( options.delay ) {
			element.delay( options.delay );
		}
		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue(function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			});
		}
	};
});

var widget = $.widget;


/*!
 * jQuery UI Mouse 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/mouse/
 */


var mouseHandled = false;
$( document ).mouseup( function() {
	mouseHandled = false;
});

var mouse = $.widget("ui.mouse", {
	version: "1.11.0",
	options: {
		cancel: "input,textarea,button,select,option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.bind("mousedown." + this.widgetName, function(event) {
				return that._mouseDown(event);
			})
			.bind("click." + this.widgetName, function(event) {
				if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
					$.removeData(event.target, that.widgetName + ".preventClickEvent");
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind("." + this.widgetName);
		if ( this._mouseMoveDelegate ) {
			this.document
				.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate)
				.unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
		}
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if ( mouseHandled ) {
			return;
		}

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = (event.which === 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				that.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
			$.removeData(event.target, this.widgetName + ".preventClickEvent");
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return that._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return that._mouseUp(event);
		};

		this.document
			.bind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.bind( "mouseup." + this.widgetName, this._mouseUpDelegate );

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.ui.ie && ( !document.documentMode || document.documentMode < 9 ) && !event.button) {
			return this._mouseUp(event);

		// Iframe mouseup check - mouseup occurred in another document
		} else if ( !event.which ) {
			return this._mouseUp( event );
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		this.document
			.unbind( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.unbind( "mouseup." + this.widgetName, this._mouseUpDelegate );

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target === this._mouseDownEvent.target) {
				$.data(event.target, this.widgetName + ".preventClickEvent", true);
			}

			this._mouseStop(event);
		}

		mouseHandled = false;
		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(/* event */) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(/* event */) {},
	_mouseDrag: function(/* event */) {},
	_mouseStop: function(/* event */) {},
	_mouseCapture: function(/* event */) { return true; }
});


/*!
 * jQuery UI Position 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */

(function() {

$.ui = $.ui || {};

var cachedScrollbarWidth, supportsOffsetFractions,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[0];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[0];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[0].clientWidth;
		}

		div.remove();

		return (cachedScrollbarWidth = w1 - w2);
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-x" ),
			overflowY = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[0].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[0] ),
			isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9;
		return {
			element: withinElement,
			isWindow: isWindow,
			isDocument: isDocument,
			offset: withinElement.offset() || { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: isWindow ? withinElement.width() : withinElement.outerWidth(),
			height: isWindow ? withinElement.height() : withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[0].preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;
	// clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each(function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// if the browser doesn't support fractions, then round for consistent results
		if ( !supportsOffsetFractions ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem: elem
				});
			}
		});

		if ( options.using ) {
			// adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// element is wider than within
			if ( data.collisionWidth > outerWidth ) {
				// element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				// element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;
				// element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			// too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;
			// too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;
			// adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// element is taller than within
			if ( data.collisionHeight > outerHeight ) {
				// element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				// element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;
				// element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			// too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;
			// too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;
			// adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			} else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
					position.top += myOffset + atOffset + offset;
				}
			} else if ( overBottom > 0 ) {
				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

// fraction support test
(function() {
	var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName( "body" )[ 0 ],
		div = document.createElement( "div" );

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px;";

	offsetLeft = $( div ).offset().left;
	supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );
})();

})();

var position = $.ui.position;


/*!
 * jQuery UI Accordion 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/accordion/
 */


var accordion = $.widget( "ui.accordion", {
	version: "1.11.0",
	options: {
		active: 0,
		animate: {},
		collapsible: false,
		event: "click",
		header: "> li > :first-child,> :not(li):even",
		heightStyle: "auto",
		icons: {
			activeHeader: "ui-icon-triangle-1-s",
			header: "ui-icon-triangle-1-e"
		},

		// callbacks
		activate: null,
		beforeActivate: null
	},

	hideProps: {
		borderTopWidth: "hide",
		borderBottomWidth: "hide",
		paddingTop: "hide",
		paddingBottom: "hide",
		height: "hide"
	},

	showProps: {
		borderTopWidth: "show",
		borderBottomWidth: "show",
		paddingTop: "show",
		paddingBottom: "show",
		height: "show"
	},

	_create: function() {
		var options = this.options;
		this.prevShow = this.prevHide = $();
		this.element.addClass( "ui-accordion ui-widget ui-helper-reset" )
			// ARIA
			.attr( "role", "tablist" );

		// don't allow collapsible: false and active: false / null
		if ( !options.collapsible && (options.active === false || options.active == null) ) {
			options.active = 0;
		}

		this._processPanels();
		// handle negative values
		if ( options.active < 0 ) {
			options.active += this.headers.length;
		}
		this._refresh();
	},

	_getCreateEventData: function() {
		return {
			header: this.active,
			panel: !this.active.length ? $() : this.active.next()
		};
	},

	_createIcons: function() {
		var icons = this.options.icons;
		if ( icons ) {
			$( "<span>" )
				.addClass( "ui-accordion-header-icon ui-icon " + icons.header )
				.prependTo( this.headers );
			this.active.children( ".ui-accordion-header-icon" )
				.removeClass( icons.header )
				.addClass( icons.activeHeader );
			this.headers.addClass( "ui-accordion-icons" );
		}
	},

	_destroyIcons: function() {
		this.headers
			.removeClass( "ui-accordion-icons" )
			.children( ".ui-accordion-header-icon" )
				.remove();
	},

	_destroy: function() {
		var contents;

		// clean up main element
		this.element
			.removeClass( "ui-accordion ui-widget ui-helper-reset" )
			.removeAttr( "role" );

		// clean up headers
		this.headers
			.removeClass( "ui-accordion-header ui-accordion-header-active ui-state-default " +
				"ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )
			.removeAttr( "role" )
			.removeAttr( "aria-expanded" )
			.removeAttr( "aria-selected" )
			.removeAttr( "aria-controls" )
			.removeAttr( "tabIndex" )
			.removeUniqueId();

		this._destroyIcons();

		// clean up content panels
		contents = this.headers.next()
			.removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom " +
				"ui-accordion-content ui-accordion-content-active ui-state-disabled" )
			.css( "display", "" )
			.removeAttr( "role" )
			.removeAttr( "aria-hidden" )
			.removeAttr( "aria-labelledby" )
			.removeUniqueId();

		if ( this.options.heightStyle !== "content" ) {
			contents.css( "height", "" );
		}
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "event" ) {
			if ( this.options.event ) {
				this._off( this.headers, this.options.event );
			}
			this._setupEvents( value );
		}

		this._super( key, value );

		// setting collapsible: false while collapsed; open first panel
		if ( key === "collapsible" && !value && this.options.active === false ) {
			this._activate( 0 );
		}

		if ( key === "icons" ) {
			this._destroyIcons();
			if ( value ) {
				this._createIcons();
			}
		}

		// #5332 - opacity doesn't cascade to positioned elements in IE
		// so we need to add the disabled class to the headers and panels
		if ( key === "disabled" ) {
			this.element
				.toggleClass( "ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
			this.headers.add( this.headers.next() )
				.toggleClass( "ui-state-disabled", !!value );
		}
	},

	_keydown: function( event ) {
		if ( event.altKey || event.ctrlKey ) {
			return;
		}

		var keyCode = $.ui.keyCode,
			length = this.headers.length,
			currentIndex = this.headers.index( event.target ),
			toFocus = false;

		switch ( event.keyCode ) {
			case keyCode.RIGHT:
			case keyCode.DOWN:
				toFocus = this.headers[ ( currentIndex + 1 ) % length ];
				break;
			case keyCode.LEFT:
			case keyCode.UP:
				toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
				break;
			case keyCode.SPACE:
			case keyCode.ENTER:
				this._eventHandler( event );
				break;
			case keyCode.HOME:
				toFocus = this.headers[ 0 ];
				break;
			case keyCode.END:
				toFocus = this.headers[ length - 1 ];
				break;
		}

		if ( toFocus ) {
			$( event.target ).attr( "tabIndex", -1 );
			$( toFocus ).attr( "tabIndex", 0 );
			toFocus.focus();
			event.preventDefault();
		}
	},

	_panelKeyDown: function( event ) {
		if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
			$( event.currentTarget ).prev().focus();
		}
	},

	refresh: function() {
		var options = this.options;
		this._processPanels();

		// was collapsed or no panel
		if ( ( options.active === false && options.collapsible === true ) || !this.headers.length ) {
			options.active = false;
			this.active = $();
		// active false only when collapsible is true
		} else if ( options.active === false ) {
			this._activate( 0 );
		// was active, but active panel is gone
		} else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
			// all remaining panel are disabled
			if ( this.headers.length === this.headers.find(".ui-state-disabled").length ) {
				options.active = false;
				this.active = $();
			// activate previous panel
			} else {
				this._activate( Math.max( 0, options.active - 1 ) );
			}
		// was active, active panel still exists
		} else {
			// make sure active index is correct
			options.active = this.headers.index( this.active );
		}

		this._destroyIcons();

		this._refresh();
	},

	_processPanels: function() {
		this.headers = this.element.find( this.options.header )
			.addClass( "ui-accordion-header ui-state-default ui-corner-all" );

		this.headers.next()
			.addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" )
			.filter( ":not(.ui-accordion-content-active)" )
			.hide();
	},

	_refresh: function() {
		var maxHeight,
			options = this.options,
			heightStyle = options.heightStyle,
			parent = this.element.parent();

		this.active = this._findActive( options.active )
			.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" )
			.removeClass( "ui-corner-all" );
		this.active.next()
			.addClass( "ui-accordion-content-active" )
			.show();

		this.headers
			.attr( "role", "tab" )
			.each(function() {
				var header = $( this ),
					headerId = header.uniqueId().attr( "id" ),
					panel = header.next(),
					panelId = panel.uniqueId().attr( "id" );
				header.attr( "aria-controls", panelId );
				panel.attr( "aria-labelledby", headerId );
			})
			.next()
				.attr( "role", "tabpanel" );

		this.headers
			.not( this.active )
			.attr({
				"aria-selected": "false",
				"aria-expanded": "false",
				tabIndex: -1
			})
			.next()
				.attr({
					"aria-hidden": "true"
				})
				.hide();

		// make sure at least one header is in the tab order
		if ( !this.active.length ) {
			this.headers.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active.attr({
				"aria-selected": "true",
				"aria-expanded": "true",
				tabIndex: 0
			})
			.next()
				.attr({
					"aria-hidden": "false"
				});
		}

		this._createIcons();

		this._setupEvents( options.event );

		if ( heightStyle === "fill" ) {
			maxHeight = parent.height();
			this.element.siblings( ":visible" ).each(function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});

			this.headers.each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.headers.next()
				.each(function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				})
				.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.headers.next()
				.each(function() {
					maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );
				})
				.height( maxHeight );
		}
	},

	_activate: function( index ) {
		var active = this._findActive( index )[ 0 ];

		// trying to activate the already active panel
		if ( active === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the currently active header
		active = active || this.active[ 0 ];

		this._eventHandler({
			target: active,
			currentTarget: active,
			preventDefault: $.noop
		});
	},

	_findActive: function( selector ) {
		return typeof selector === "number" ? this.headers.eq( selector ) : $();
	},

	_setupEvents: function( event ) {
		var events = {
			keydown: "_keydown"
		};
		if ( event ) {
			$.each( event.split( " " ), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			});
		}

		this._off( this.headers.add( this.headers.next() ) );
		this._on( this.headers, events );
		this._on( this.headers.next(), { keydown: "_panelKeyDown" });
		this._hoverable( this.headers );
		this._focusable( this.headers );
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			clicked = $( event.currentTarget ),
			clickedIsActive = clicked[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : clicked.next(),
			toHide = active.next(),
			eventData = {
				oldHeader: active,
				oldPanel: toHide,
				newHeader: collapsing ? $() : clicked,
				newPanel: toShow
			};

		event.preventDefault();

		if (
				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.headers.index( clicked );

		// when the call to ._toggle() comes after the class changes
		// it causes a very odd bug in IE 8 (see #6720)
		this.active = clickedIsActive ? $() : clicked;
		this._toggle( eventData );

		// switch classes
		// corner classes on the previously active header stay after the animation
		active.removeClass( "ui-accordion-header-active ui-state-active" );
		if ( options.icons ) {
			active.children( ".ui-accordion-header-icon" )
				.removeClass( options.icons.activeHeader )
				.addClass( options.icons.header );
		}

		if ( !clickedIsActive ) {
			clicked
				.removeClass( "ui-corner-all" )
				.addClass( "ui-accordion-header-active ui-state-active ui-corner-top" );
			if ( options.icons ) {
				clicked.children( ".ui-accordion-header-icon" )
					.removeClass( options.icons.header )
					.addClass( options.icons.activeHeader );
			}

			clicked
				.next()
				.addClass( "ui-accordion-content-active" );
		}
	},

	_toggle: function( data ) {
		var toShow = data.newPanel,
			toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

		// handle activating a panel during the animation for another activation
		this.prevShow.add( this.prevHide ).stop( true, true );
		this.prevShow = toShow;
		this.prevHide = toHide;

		if ( this.options.animate ) {
			this._animate( toShow, toHide, data );
		} else {
			toHide.hide();
			toShow.show();
			this._toggleComplete( data );
		}

		toHide.attr({
			"aria-hidden": "true"
		});
		toHide.prev().attr( "aria-selected", "false" );
		// if we're switching panels, remove the old header from the tab order
		// if we're opening from collapsed state, remove the previous header from the tab order
		// if we're collapsing, then keep the collapsing header in the tab order
		if ( toShow.length && toHide.length ) {
			toHide.prev().attr({
				"tabIndex": -1,
				"aria-expanded": "false"
			});
		} else if ( toShow.length ) {
			this.headers.filter(function() {
				return $( this ).attr( "tabIndex" ) === 0;
			})
			.attr( "tabIndex", -1 );
		}

		toShow
			.attr( "aria-hidden", "false" )
			.prev()
				.attr({
					"aria-selected": "true",
					tabIndex: 0,
					"aria-expanded": "true"
				});
	},

	_animate: function( toShow, toHide, data ) {
		var total, easing, duration,
			that = this,
			adjust = 0,
			down = toShow.length &&
				( !toHide.length || ( toShow.index() < toHide.index() ) ),
			animate = this.options.animate || {},
			options = down && animate.down || animate,
			complete = function() {
				that._toggleComplete( data );
			};

		if ( typeof options === "number" ) {
			duration = options;
		}
		if ( typeof options === "string" ) {
			easing = options;
		}
		// fall back from options to animation in case of partial down settings
		easing = easing || options.easing || animate.easing;
		duration = duration || options.duration || animate.duration;

		if ( !toHide.length ) {
			return toShow.animate( this.showProps, duration, easing, complete );
		}
		if ( !toShow.length ) {
			return toHide.animate( this.hideProps, duration, easing, complete );
		}

		total = toShow.show().outerHeight();
		toHide.animate( this.hideProps, {
			duration: duration,
			easing: easing,
			step: function( now, fx ) {
				fx.now = Math.round( now );
			}
		});
		toShow
			.hide()
			.animate( this.showProps, {
				duration: duration,
				easing: easing,
				complete: complete,
				step: function( now, fx ) {
					fx.now = Math.round( now );
					if ( fx.prop !== "height" ) {
						adjust += fx.now;
					} else if ( that.options.heightStyle !== "content" ) {
						fx.now = Math.round( total - toHide.outerHeight() - adjust );
						adjust = 0;
					}
				}
			});
	},

	_toggleComplete: function( data ) {
		var toHide = data.oldPanel;

		toHide
			.removeClass( "ui-accordion-content-active" )
			.prev()
				.removeClass( "ui-corner-top" )
				.addClass( "ui-corner-all" );

		// Work around for rendering bug in IE (#5421)
		if ( toHide.length ) {
			toHide.parent()[ 0 ].className = toHide.parent()[ 0 ].className;
		}
		this._trigger( "activate", null, data );
	}
});


/*!
 * jQuery UI Menu 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/menu/
 */


var menu = $.widget( "ui.menu", {
	version: "1.11.0",
	defaultElement: "<ul>",
	delay: 300,
	options: {
		icons: {
			submenu: "ui-icon-carat-1-e"
		},
		items: "> *",
		menus: "ul",
		position: {
			my: "left-1 top",
			at: "right top"
		},
		role: "menu",

		// callbacks
		blur: null,
		focus: null,
		select: null
	},

	_create: function() {
		this.activeMenu = this.element;

		// Flag used to prevent firing of the click handler
		// as the event bubbles up through nested menus
		this.mouseHandled = false;
		this.element
			.uniqueId()
			.addClass( "ui-menu ui-widget ui-widget-content" )
			.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length )
			.attr({
				role: this.options.role,
				tabIndex: 0
			});

		if ( this.options.disabled ) {
			this.element
				.addClass( "ui-state-disabled" )
				.attr( "aria-disabled", "true" );
		}

		this._on({
			// Prevent focus from sticking to links inside menu after clicking
			// them (focus should always stay on UL during navigation).
			"mousedown .ui-menu-item": function( event ) {
				event.preventDefault();
			},
			"click .ui-menu-item": function( event ) {
				var target = $( event.target );
				if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {
					this.select( event );

					// Only set the mouseHandled flag if the event will bubble, see #9469.
					if ( !event.isPropagationStopped() ) {
						this.mouseHandled = true;
					}

					// Open submenu on click
					if ( target.has( ".ui-menu" ).length ) {
						this.expand( event );
					} else if ( !this.element.is( ":focus" ) && $( this.document[ 0 ].activeElement ).closest( ".ui-menu" ).length ) {

						// Redirect focus to the menu
						this.element.trigger( "focus", [ true ] );

						// If the active item is on the top level, let it stay active.
						// Otherwise, blur the active item since it is no longer visible.
						if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
							clearTimeout( this.timer );
						}
					}
				}
			},
			"mouseenter .ui-menu-item": function( event ) {
				var target = $( event.currentTarget );
				// Remove ui-state-active class from siblings of the newly focused menu item
				// to avoid a jump caused by adjacent elements both having a class with a border
				target.siblings( ".ui-state-active" ).removeClass( "ui-state-active" );
				this.focus( event, target );
			},
			mouseleave: "collapseAll",
			"mouseleave .ui-menu": "collapseAll",
			focus: function( event, keepActiveItem ) {
				// If there's already an active item, keep it active
				// If not, activate the first item
				var item = this.active || this.element.find( this.options.items ).eq( 0 );

				if ( !keepActiveItem ) {
					this.focus( event, item );
				}
			},
			blur: function( event ) {
				this._delay(function() {
					if ( !$.contains( this.element[0], this.document[0].activeElement ) ) {
						this.collapseAll( event );
					}
				});
			},
			keydown: "_keydown"
		});

		this.refresh();

		// Clicks outside of a menu collapse any open menus
		this._on( this.document, {
			click: function( event ) {
				if ( this._closeOnDocumentClick( event ) ) {
					this.collapseAll( event );
				}

				// Reset the mouseHandled flag
				this.mouseHandled = false;
			}
		});
	},

	_destroy: function() {
		// Destroy (sub)menus
		this.element
			.removeAttr( "aria-activedescendant" )
			.find( ".ui-menu" ).addBack()
				.removeClass( "ui-menu ui-widget ui-widget-content ui-menu-icons ui-front" )
				.removeAttr( "role" )
				.removeAttr( "tabIndex" )
				.removeAttr( "aria-labelledby" )
				.removeAttr( "aria-expanded" )
				.removeAttr( "aria-hidden" )
				.removeAttr( "aria-disabled" )
				.removeUniqueId()
				.show();

		// Destroy menu items
		this.element.find( ".ui-menu-item" )
			.removeClass( "ui-menu-item" )
			.removeAttr( "role" )
			.removeAttr( "aria-disabled" )
			.removeUniqueId()
			.removeClass( "ui-state-hover" )
			.removeAttr( "tabIndex" )
			.removeAttr( "role" )
			.removeAttr( "aria-haspopup" )
			.children().each( function() {
				var elem = $( this );
				if ( elem.data( "ui-menu-submenu-carat" ) ) {
					elem.remove();
				}
			});

		// Destroy menu dividers
		this.element.find( ".ui-menu-divider" ).removeClass( "ui-menu-divider ui-widget-content" );
	},

	_keydown: function( event ) {
		var match, prev, character, skip, regex,
			preventDefault = true;

		function escape( value ) {
			return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
		}

		switch ( event.keyCode ) {
		case $.ui.keyCode.PAGE_UP:
			this.previousPage( event );
			break;
		case $.ui.keyCode.PAGE_DOWN:
			this.nextPage( event );
			break;
		case $.ui.keyCode.HOME:
			this._move( "first", "first", event );
			break;
		case $.ui.keyCode.END:
			this._move( "last", "last", event );
			break;
		case $.ui.keyCode.UP:
			this.previous( event );
			break;
		case $.ui.keyCode.DOWN:
			this.next( event );
			break;
		case $.ui.keyCode.LEFT:
			this.collapse( event );
			break;
		case $.ui.keyCode.RIGHT:
			if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
				this.expand( event );
			}
			break;
		case $.ui.keyCode.ENTER:
		case $.ui.keyCode.SPACE:
			this._activate( event );
			break;
		case $.ui.keyCode.ESCAPE:
			this.collapse( event );
			break;
		default:
			preventDefault = false;
			prev = this.previousFilter || "";
			character = String.fromCharCode( event.keyCode );
			skip = false;

			clearTimeout( this.filterTimer );

			if ( character === prev ) {
				skip = true;
			} else {
				character = prev + character;
			}

			regex = new RegExp( "^" + escape( character ), "i" );
			match = this.activeMenu.find( this.options.items ).filter(function() {
				return regex.test( $( this ).text() );
			});
			match = skip && match.index( this.active.next() ) !== -1 ?
				this.active.nextAll( ".ui-menu-item" ) :
				match;

			// If no matches on the current filter, reset to the last character pressed
			// to move down the menu to the first item that starts with that character
			if ( !match.length ) {
				character = String.fromCharCode( event.keyCode );
				regex = new RegExp( "^" + escape( character ), "i" );
				match = this.activeMenu.find( this.options.items ).filter(function() {
					return regex.test( $( this ).text() );
				});
			}

			if ( match.length ) {
				this.focus( event, match );
				if ( match.length > 1 ) {
					this.previousFilter = character;
					this.filterTimer = this._delay(function() {
						delete this.previousFilter;
					}, 1000 );
				} else {
					delete this.previousFilter;
				}
			} else {
				delete this.previousFilter;
			}
		}

		if ( preventDefault ) {
			event.preventDefault();
		}
	},

	_activate: function( event ) {
		if ( !this.active.is( ".ui-state-disabled" ) ) {
			if ( this.active.is( "[aria-haspopup='true']" ) ) {
				this.expand( event );
			} else {
				this.select( event );
			}
		}
	},

	refresh: function() {
		var menus, items,
			that = this,
			icon = this.options.icons.submenu,
			submenus = this.element.find( this.options.menus );

		this.element.toggleClass( "ui-menu-icons", !!this.element.find( ".ui-icon" ).length );

		// Initialize nested menus
		submenus.filter( ":not(.ui-menu)" )
			.addClass( "ui-menu ui-widget ui-widget-content ui-front" )
			.hide()
			.attr({
				role: this.options.role,
				"aria-hidden": "true",
				"aria-expanded": "false"
			})
			.each(function() {
				var menu = $( this ),
					item = menu.parent(),
					submenuCarat = $( "<span>" )
						.addClass( "ui-menu-icon ui-icon " + icon )
						.data( "ui-menu-submenu-carat", true );

				item
					.attr( "aria-haspopup", "true" )
					.prepend( submenuCarat );
				menu.attr( "aria-labelledby", item.attr( "id" ) );
			});

		menus = submenus.add( this.element );
		items = menus.find( this.options.items );

		// Initialize menu-items containing spaces and/or dashes only as dividers
		items.not( ".ui-menu-item" ).each(function() {
			var item = $( this );
			if ( that._isDivider( item ) ) {
				item.addClass( "ui-widget-content ui-menu-divider" );
			}
		});

		// Don't refresh list items that are already adapted
		items.not( ".ui-menu-item, .ui-menu-divider" )
			.addClass( "ui-menu-item" )
			.uniqueId()
			.attr({
				tabIndex: -1,
				role: this._itemRole()
			});

		// Add aria-disabled attribute to any disabled menu item
		items.filter( ".ui-state-disabled" ).attr( "aria-disabled", "true" );

		// If the active item has been removed, blur the menu
		if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
			this.blur();
		}
	},

	_itemRole: function() {
		return {
			menu: "menuitem",
			listbox: "option"
		}[ this.options.role ];
	},

	_setOption: function( key, value ) {
		if ( key === "icons" ) {
			this.element.find( ".ui-menu-icon" )
				.removeClass( this.options.icons.submenu )
				.addClass( value.submenu );
		}
		if ( key === "disabled" ) {
			this.element
				.toggleClass( "ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
		}
		this._super( key, value );
	},

	focus: function( event, item ) {
		var nested, focused;
		this.blur( event, event && event.type === "focus" );

		this._scrollIntoView( item );

		this.active = item.first();
		focused = this.active.addClass( "ui-state-focus" ).removeClass( "ui-state-active" );
		// Only update aria-activedescendant if there's a role
		// otherwise we assume focus is managed elsewhere
		if ( this.options.role ) {
			this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
		}

		// Highlight active parent menu item, if any
		this.active
			.parent()
			.closest( ".ui-menu-item" )
			.addClass( "ui-state-active" );

		if ( event && event.type === "keydown" ) {
			this._close();
		} else {
			this.timer = this._delay(function() {
				this._close();
			}, this.delay );
		}

		nested = item.children( ".ui-menu" );
		if ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {
			this._startOpening(nested);
		}
		this.activeMenu = item.parent();

		this._trigger( "focus", event, { item: item } );
	},

	_scrollIntoView: function( item ) {
		var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
		if ( this._hasScroll() ) {
			borderTop = parseFloat( $.css( this.activeMenu[0], "borderTopWidth" ) ) || 0;
			paddingTop = parseFloat( $.css( this.activeMenu[0], "paddingTop" ) ) || 0;
			offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
			scroll = this.activeMenu.scrollTop();
			elementHeight = this.activeMenu.height();
			itemHeight = item.outerHeight();

			if ( offset < 0 ) {
				this.activeMenu.scrollTop( scroll + offset );
			} else if ( offset + itemHeight > elementHeight ) {
				this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
			}
		}
	},

	blur: function( event, fromFocus ) {
		if ( !fromFocus ) {
			clearTimeout( this.timer );
		}

		if ( !this.active ) {
			return;
		}

		this.active.removeClass( "ui-state-focus" );
		this.active = null;

		this._trigger( "blur", event, { item: this.active } );
	},

	_startOpening: function( submenu ) {
		clearTimeout( this.timer );

		// Don't open if already open fixes a Firefox bug that caused a .5 pixel
		// shift in the submenu position when mousing over the carat icon
		if ( submenu.attr( "aria-hidden" ) !== "true" ) {
			return;
		}

		this.timer = this._delay(function() {
			this._close();
			this._open( submenu );
		}, this.delay );
	},

	_open: function( submenu ) {
		var position = $.extend({
			of: this.active
		}, this.options.position );

		clearTimeout( this.timer );
		this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
			.hide()
			.attr( "aria-hidden", "true" );

		submenu
			.show()
			.removeAttr( "aria-hidden" )
			.attr( "aria-expanded", "true" )
			.position( position );
	},

	collapseAll: function( event, all ) {
		clearTimeout( this.timer );
		this.timer = this._delay(function() {
			// If we were passed an event, look for the submenu that contains the event
			var currentMenu = all ? this.element :
				$( event && event.target ).closest( this.element.find( ".ui-menu" ) );

			// If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
			if ( !currentMenu.length ) {
				currentMenu = this.element;
			}

			this._close( currentMenu );

			this.blur( event );
			this.activeMenu = currentMenu;
		}, this.delay );
	},

	// With no arguments, closes the currently active menu - if nothing is active
	// it closes all menus.  If passed an argument, it will search for menus BELOW
	_close: function( startMenu ) {
		if ( !startMenu ) {
			startMenu = this.active ? this.active.parent() : this.element;
		}

		startMenu
			.find( ".ui-menu" )
				.hide()
				.attr( "aria-hidden", "true" )
				.attr( "aria-expanded", "false" )
			.end()
			.find( ".ui-state-active" ).not( ".ui-state-focus" )
				.removeClass( "ui-state-active" );
	},

	_closeOnDocumentClick: function( event ) {
		return !$( event.target ).closest( ".ui-menu" ).length;
	},

	_isDivider: function( item ) {

		// Match hyphen, em dash, en dash
		return !/[^\-\u2014\u2013\s]/.test( item.text() );
	},

	collapse: function( event ) {
		var newItem = this.active &&
			this.active.parent().closest( ".ui-menu-item", this.element );
		if ( newItem && newItem.length ) {
			this._close();
			this.focus( event, newItem );
		}
	},

	expand: function( event ) {
		var newItem = this.active &&
			this.active
				.children( ".ui-menu " )
				.find( this.options.items )
				.first();

		if ( newItem && newItem.length ) {
			this._open( newItem.parent() );

			// Delay so Firefox will not hide activedescendant change in expanding submenu from AT
			this._delay(function() {
				this.focus( event, newItem );
			});
		}
	},

	next: function( event ) {
		this._move( "next", "first", event );
	},

	previous: function( event ) {
		this._move( "prev", "last", event );
	},

	isFirstItem: function() {
		return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
	},

	isLastItem: function() {
		return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
	},

	_move: function( direction, filter, event ) {
		var next;
		if ( this.active ) {
			if ( direction === "first" || direction === "last" ) {
				next = this.active
					[ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
					.eq( -1 );
			} else {
				next = this.active
					[ direction + "All" ]( ".ui-menu-item" )
					.eq( 0 );
			}
		}
		if ( !next || !next.length || !this.active ) {
			next = this.activeMenu.find( this.options.items )[ filter ]();
		}

		this.focus( event, next );
	},

	nextPage: function( event ) {
		var item, base, height;

		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isLastItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.nextAll( ".ui-menu-item" ).each(function() {
				item = $( this );
				return item.offset().top - base - height < 0;
			});

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.find( this.options.items )
				[ !this.active ? "first" : "last" ]() );
		}
	},

	previousPage: function( event ) {
		var item, base, height;
		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isFirstItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.prevAll( ".ui-menu-item" ).each(function() {
				item = $( this );
				return item.offset().top - base + height > 0;
			});

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.find( this.options.items ).first() );
		}
	},

	_hasScroll: function() {
		return this.element.outerHeight() < this.element.prop( "scrollHeight" );
	},

	select: function( event ) {
		// TODO: It should never be possible to not have an active item at this
		// point, but the tests don't trigger mouseenter before click.
		this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
		var ui = { item: this.active };
		if ( !this.active.has( ".ui-menu" ).length ) {
			this.collapseAll( event, true );
		}
		this._trigger( "select", event, ui );
	}
});


/*!
 * jQuery UI Autocomplete 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/autocomplete/
 */


$.widget( "ui.autocomplete", {
	version: "1.11.0",
	defaultElement: "<input>",
	options: {
		appendTo: null,
		autoFocus: false,
		delay: 300,
		minLength: 1,
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		source: null,

		// callbacks
		change: null,
		close: null,
		focus: null,
		open: null,
		response: null,
		search: null,
		select: null
	},

	requestIndex: 0,
	pending: 0,

	_create: function() {
		// Some browsers only repeat keydown events, not keypress events,
		// so we use the suppressKeyPress flag to determine if we've already
		// handled the keydown event. #7269
		// Unfortunately the code for & in keypress is the same as the up arrow,
		// so we use the suppressKeyPressRepeat flag to avoid handling keypress
		// events when we know the keydown event was used to modify the
		// search term. #7799
		var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
			nodeName = this.element[ 0 ].nodeName.toLowerCase(),
			isTextarea = nodeName === "textarea",
			isInput = nodeName === "input";

		this.isMultiLine =
			// Textareas are always multi-line
			isTextarea ? true :
			// Inputs are always single-line, even if inside a contentEditable element
			// IE also treats inputs as contentEditable
			isInput ? false :
			// All other element types are determined by whether or not they're contentEditable
			this.element.prop( "isContentEditable" );

		this.valueMethod = this.element[ isTextarea || isInput ? "val" : "text" ];
		this.isNewMenu = true;

		this.element
			.addClass( "ui-autocomplete-input" )
			.attr( "autocomplete", "off" );

		this._on( this.element, {
			keydown: function( event ) {
				if ( this.element.prop( "readOnly" ) ) {
					suppressKeyPress = true;
					suppressInput = true;
					suppressKeyPressRepeat = true;
					return;
				}

				suppressKeyPress = false;
				suppressInput = false;
				suppressKeyPressRepeat = false;
				var keyCode = $.ui.keyCode;
				switch ( event.keyCode ) {
				case keyCode.PAGE_UP:
					suppressKeyPress = true;
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					suppressKeyPress = true;
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					suppressKeyPress = true;
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					suppressKeyPress = true;
					this._keyEvent( "next", event );
					break;
				case keyCode.ENTER:
					// when menu is open and has focus
					if ( this.menu.active ) {
						// #6055 - Opera still allows the keypress to occur
						// which causes forms to submit
						suppressKeyPress = true;
						event.preventDefault();
						this.menu.select( event );
					}
					break;
				case keyCode.TAB:
					if ( this.menu.active ) {
						this.menu.select( event );
					}
					break;
				case keyCode.ESCAPE:
					if ( this.menu.element.is( ":visible" ) ) {
						this._value( this.term );
						this.close( event );
						// Different browsers have different default behavior for escape
						// Single press can mean undo or clear
						// Double press in IE means clear the whole form
						event.preventDefault();
					}
					break;
				default:
					suppressKeyPressRepeat = true;
					// search timeout should be triggered before the input value is changed
					this._searchTimeout( event );
					break;
				}
			},
			keypress: function( event ) {
				if ( suppressKeyPress ) {
					suppressKeyPress = false;
					if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
						event.preventDefault();
					}
					return;
				}
				if ( suppressKeyPressRepeat ) {
					return;
				}

				// replicate some key handlers to allow them to repeat in Firefox and Opera
				var keyCode = $.ui.keyCode;
				switch ( event.keyCode ) {
				case keyCode.PAGE_UP:
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					this._keyEvent( "next", event );
					break;
				}
			},
			input: function( event ) {
				if ( suppressInput ) {
					suppressInput = false;
					event.preventDefault();
					return;
				}
				this._searchTimeout( event );
			},
			focus: function() {
				this.selectedItem = null;
				this.previous = this._value();
			},
			blur: function( event ) {
				if ( this.cancelBlur ) {
					delete this.cancelBlur;
					return;
				}

				clearTimeout( this.searching );
				this.close( event );
				this._change( event );
			}
		});

		this._initSource();
		this.menu = $( "<ul>" )
			.addClass( "ui-autocomplete ui-front" )
			.appendTo( this._appendTo() )
			.menu({
				// disable ARIA support, the live region takes care of that
				role: null
			})
			.hide()
			.menu( "instance" );

		this._on( this.menu.element, {
			mousedown: function( event ) {
				// prevent moving focus out of the text field
				event.preventDefault();

				// IE doesn't prevent moving focus even with event.preventDefault()
				// so we set a flag to know when we should ignore the blur event
				this.cancelBlur = true;
				this._delay(function() {
					delete this.cancelBlur;
				});

				// clicking on the scrollbar causes focus to shift to the body
				// but we can't detect a mouseup or a click immediately afterward
				// so we have to track the next mousedown and close the menu if
				// the user clicks somewhere outside of the autocomplete
				var menuElement = this.menu.element[ 0 ];
				if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
					this._delay(function() {
						var that = this;
						this.document.one( "mousedown", function( event ) {
							if ( event.target !== that.element[ 0 ] &&
									event.target !== menuElement &&
									!$.contains( menuElement, event.target ) ) {
								that.close();
							}
						});
					});
				}
			},
			menufocus: function( event, ui ) {
				var label, item;
				// support: Firefox
				// Prevent accidental activation of menu items in Firefox (#7024 #9118)
				if ( this.isNewMenu ) {
					this.isNewMenu = false;
					if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
						this.menu.blur();

						this.document.one( "mousemove", function() {
							$( event.target ).trigger( event.originalEvent );
						});

						return;
					}
				}

				item = ui.item.data( "ui-autocomplete-item" );
				if ( false !== this._trigger( "focus", event, { item: item } ) ) {
					// use value to match what will end up in the input, if it was a key event
					if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
						this._value( item.value );
					}
				}

				// Announce the value in the liveRegion
				label = ui.item.attr( "aria-label" ) || item.value;
				if ( label && jQuery.trim( label ).length ) {
					this.liveRegion.children().hide();
					$( "<div>" ).text( label ).appendTo( this.liveRegion );
				}
			},
			menuselect: function( event, ui ) {
				var item = ui.item.data( "ui-autocomplete-item" ),
					previous = this.previous;

				// only trigger when focus was lost (click on menu)
				if ( this.element[ 0 ] !== this.document[ 0 ].activeElement ) {
					this.element.focus();
					this.previous = previous;
					// #6109 - IE triggers two focus events and the second
					// is asynchronous, so we need to reset the previous
					// term synchronously and asynchronously :-(
					this._delay(function() {
						this.previous = previous;
						this.selectedItem = item;
					});
				}

				if ( false !== this._trigger( "select", event, { item: item } ) ) {
					this._value( item.value );
				}
				// reset the term after the select event
				// this allows custom select handling to work properly
				this.term = this._value();

				this.close( event );
				this.selectedItem = item;
			}
		});

		this.liveRegion = $( "<span>", {
				role: "status",
				"aria-live": "assertive",
				"aria-relevant": "additions"
			})
			.addClass( "ui-helper-hidden-accessible" )
			.appendTo( this.document[ 0 ].body );

		// turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		});
	},

	_destroy: function() {
		clearTimeout( this.searching );
		this.element
			.removeClass( "ui-autocomplete-input" )
			.removeAttr( "autocomplete" );
		this.menu.element.remove();
		this.liveRegion.remove();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "source" ) {
			this._initSource();
		}
		if ( key === "appendTo" ) {
			this.menu.element.appendTo( this._appendTo() );
		}
		if ( key === "disabled" && value && this.xhr ) {
			this.xhr.abort();
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;

		if ( element ) {
			element = element.jquery || element.nodeType ?
				$( element ) :
				this.document.find( element ).eq( 0 );
		}

		if ( !element || !element[ 0 ] ) {
			element = this.element.closest( ".ui-front" );
		}

		if ( !element.length ) {
			element = this.document[ 0 ].body;
		}

		return element;
	},

	_initSource: function() {
		var array, url,
			that = this;
		if ( $.isArray( this.options.source ) ) {
			array = this.options.source;
			this.source = function( request, response ) {
				response( $.ui.autocomplete.filter( array, request.term ) );
			};
		} else if ( typeof this.options.source === "string" ) {
			url = this.options.source;
			this.source = function( request, response ) {
				if ( that.xhr ) {
					that.xhr.abort();
				}
				that.xhr = $.ajax({
					url: url,
					data: request,
					dataType: "json",
					success: function( data ) {
						response( data );
					},
					error: function() {
						response([]);
					}
				});
			};
		} else {
			this.source = this.options.source;
		}
	},

	_searchTimeout: function( event ) {
		clearTimeout( this.searching );
		this.searching = this._delay(function() {

			// Search if the value has changed, or if the user retypes the same value (see #7434)
			var equalValues = this.term === this._value(),
				menuVisible = this.menu.element.is( ":visible" ),
				modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;

			if ( !equalValues || ( equalValues && !menuVisible && !modifierKey ) ) {
				this.selectedItem = null;
				this.search( null, event );
			}
		}, this.options.delay );
	},

	search: function( value, event ) {
		value = value != null ? value : this._value();

		// always save the actual value, not the one passed as an argument
		this.term = this._value();

		if ( value.length < this.options.minLength ) {
			return this.close( event );
		}

		if ( this._trigger( "search", event ) === false ) {
			return;
		}

		return this._search( value );
	},

	_search: function( value ) {
		this.pending++;
		this.element.addClass( "ui-autocomplete-loading" );
		this.cancelSearch = false;

		this.source( { term: value }, this._response() );
	},

	_response: function() {
		var index = ++this.requestIndex;

		return $.proxy(function( content ) {
			if ( index === this.requestIndex ) {
				this.__response( content );
			}

			this.pending--;
			if ( !this.pending ) {
				this.element.removeClass( "ui-autocomplete-loading" );
			}
		}, this );
	},

	__response: function( content ) {
		if ( content ) {
			content = this._normalize( content );
		}
		this._trigger( "response", null, { content: content } );
		if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
			this._suggest( content );
			this._trigger( "open" );
		} else {
			// use ._close() instead of .close() so we don't cancel future searches
			this._close();
		}
	},

	close: function( event ) {
		this.cancelSearch = true;
		this._close( event );
	},

	_close: function( event ) {
		if ( this.menu.element.is( ":visible" ) ) {
			this.menu.element.hide();
			this.menu.blur();
			this.isNewMenu = true;
			this._trigger( "close", event );
		}
	},

	_change: function( event ) {
		if ( this.previous !== this._value() ) {
			this._trigger( "change", event, { item: this.selectedItem } );
		}
	},

	_normalize: function( items ) {
		// assume all items have the right format when the first item is complete
		if ( items.length && items[ 0 ].label && items[ 0 ].value ) {
			return items;
		}
		return $.map( items, function( item ) {
			if ( typeof item === "string" ) {
				return {
					label: item,
					value: item
				};
			}
			return $.extend( {}, item, {
				label: item.label || item.value,
				value: item.value || item.label
			});
		});
	},

	_suggest: function( items ) {
		var ul = this.menu.element.empty();
		this._renderMenu( ul, items );
		this.isNewMenu = true;
		this.menu.refresh();

		// size and position menu
		ul.show();
		this._resizeMenu();
		ul.position( $.extend({
			of: this.element
		}, this.options.position ) );

		if ( this.options.autoFocus ) {
			this.menu.next();
		}
	},

	_resizeMenu: function() {
		var ul = this.menu.element;
		ul.outerWidth( Math.max(
			// Firefox wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping (#7513)
			ul.width( "" ).outerWidth() + 1,
			this.element.outerWidth()
		) );
	},

	_renderMenu: function( ul, items ) {
		var that = this;
		$.each( items, function( index, item ) {
			that._renderItemData( ul, item );
		});
	},

	_renderItemData: function( ul, item ) {
		return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
	},

	_renderItem: function( ul, item ) {
		return $( "<li>" ).text( item.label ).appendTo( ul );
	},

	_move: function( direction, event ) {
		if ( !this.menu.element.is( ":visible" ) ) {
			this.search( null, event );
			return;
		}
		if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
				this.menu.isLastItem() && /^next/.test( direction ) ) {

			if ( !this.isMultiLine ) {
				this._value( this.term );
			}

			this.menu.blur();
			return;
		}
		this.menu[ direction ]( event );
	},

	widget: function() {
		return this.menu.element;
	},

	_value: function() {
		return this.valueMethod.apply( this.element, arguments );
	},

	_keyEvent: function( keyEvent, event ) {
		if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
			this._move( keyEvent, event );

			// prevents moving cursor to beginning/end of the text field in some browsers
			event.preventDefault();
		}
	}
});

$.extend( $.ui.autocomplete, {
	escapeRegex: function( value ) {
		return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
	},
	filter: function( array, term ) {
		var matcher = new RegExp( $.ui.autocomplete.escapeRegex( term ), "i" );
		return $.grep( array, function( value ) {
			return matcher.test( value.label || value.value || value );
		});
	}
});

// live region extension, adding a `messages` option
// NOTE: This is an experimental API. We are still investigating
// a full solution for string manipulation and internationalization.
$.widget( "ui.autocomplete", $.ui.autocomplete, {
	options: {
		messages: {
			noResults: "No search results.",
			results: function( amount ) {
				return amount + ( amount > 1 ? " results are" : " result is" ) +
					" available, use up and down arrow keys to navigate.";
			}
		}
	},

	__response: function( content ) {
		var message;
		this._superApply( arguments );
		if ( this.options.disabled || this.cancelSearch ) {
			return;
		}
		if ( content && content.length ) {
			message = this.options.messages.results( content.length );
		} else {
			message = this.options.messages.noResults;
		}
		this.liveRegion.children().hide();
		$( "<div>" ).text( message ).appendTo( this.liveRegion );
	}
});

var autocomplete = $.ui.autocomplete;


/*!
 * jQuery UI Button 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/button/
 */


var lastActive,
	baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
	typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
	formResetHandler = function() {
		var form = $( this );
		setTimeout(function() {
			form.find( ":ui-button" ).button( "refresh" );
		}, 1 );
	},
	radioGroup = function( radio ) {
		var name = radio.name,
			form = radio.form,
			radios = $( [] );
		if ( name ) {
			name = name.replace( /'/g, "\\'" );
			if ( form ) {
				radios = $( form ).find( "[name='" + name + "'][type=radio]" );
			} else {
				radios = $( "[name='" + name + "'][type=radio]", radio.ownerDocument )
					.filter(function() {
						return !this.form;
					});
			}
		}
		return radios;
	};

$.widget( "ui.button", {
	version: "1.11.0",
	defaultElement: "<button>",
	options: {
		disabled: null,
		text: true,
		label: null,
		icons: {
			primary: null,
			secondary: null
		}
	},
	_create: function() {
		this.element.closest( "form" )
			.unbind( "reset" + this.eventNamespace )
			.bind( "reset" + this.eventNamespace, formResetHandler );

		if ( typeof this.options.disabled !== "boolean" ) {
			this.options.disabled = !!this.element.prop( "disabled" );
		} else {
			this.element.prop( "disabled", this.options.disabled );
		}

		this._determineButtonType();
		this.hasTitle = !!this.buttonElement.attr( "title" );

		var that = this,
			options = this.options,
			toggleButton = this.type === "checkbox" || this.type === "radio",
			activeClass = !toggleButton ? "ui-state-active" : "";

		if ( options.label === null ) {
			options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
		}

		this._hoverable( this.buttonElement );

		this.buttonElement
			.addClass( baseClasses )
			.attr( "role", "button" )
			.bind( "mouseenter" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				if ( this === lastActive ) {
					$( this ).addClass( "ui-state-active" );
				}
			})
			.bind( "mouseleave" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( activeClass );
			})
			.bind( "click" + this.eventNamespace, function( event ) {
				if ( options.disabled ) {
					event.preventDefault();
					event.stopImmediatePropagation();
				}
			});

		// Can't use _focusable() because the element that receives focus
		// and the element that gets the ui-state-focus class are different
		this._on({
			focus: function() {
				this.buttonElement.addClass( "ui-state-focus" );
			},
			blur: function() {
				this.buttonElement.removeClass( "ui-state-focus" );
			}
		});

		if ( toggleButton ) {
			this.element.bind( "change" + this.eventNamespace, function() {
				that.refresh();
			});
		}

		if ( this.type === "checkbox" ) {
			this.buttonElement.bind( "click" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return false;
				}
			});
		} else if ( this.type === "radio" ) {
			this.buttonElement.bind( "click" + this.eventNamespace, function() {
				if ( options.disabled ) {
					return false;
				}
				$( this ).addClass( "ui-state-active" );
				that.buttonElement.attr( "aria-pressed", "true" );

				var radio = that.element[ 0 ];
				radioGroup( radio )
					.not( radio )
					.map(function() {
						return $( this ).button( "widget" )[ 0 ];
					})
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			});
		} else {
			this.buttonElement
				.bind( "mousedown" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).addClass( "ui-state-active" );
					lastActive = this;
					that.document.one( "mouseup", function() {
						lastActive = null;
					});
				})
				.bind( "mouseup" + this.eventNamespace, function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).removeClass( "ui-state-active" );
				})
				.bind( "keydown" + this.eventNamespace, function(event) {
					if ( options.disabled ) {
						return false;
					}
					if ( event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER ) {
						$( this ).addClass( "ui-state-active" );
					}
				})
				// see #8559, we bind to blur here in case the button element loses
				// focus between keydown and keyup, it would be left in an "active" state
				.bind( "keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
					$( this ).removeClass( "ui-state-active" );
				});

			if ( this.buttonElement.is("a") ) {
				this.buttonElement.keyup(function(event) {
					if ( event.keyCode === $.ui.keyCode.SPACE ) {
						// TODO pass through original event correctly (just as 2nd argument doesn't work)
						$( this ).click();
					}
				});
			}
		}

		this._setOption( "disabled", options.disabled );
		this._resetButton();
	},

	_determineButtonType: function() {
		var ancestor, labelSelector, checked;

		if ( this.element.is("[type=checkbox]") ) {
			this.type = "checkbox";
		} else if ( this.element.is("[type=radio]") ) {
			this.type = "radio";
		} else if ( this.element.is("input") ) {
			this.type = "input";
		} else {
			this.type = "button";
		}

		if ( this.type === "checkbox" || this.type === "radio" ) {
			// we don't search against the document in case the element
			// is disconnected from the DOM
			ancestor = this.element.parents().last();
			labelSelector = "label[for='" + this.element.attr("id") + "']";
			this.buttonElement = ancestor.find( labelSelector );
			if ( !this.buttonElement.length ) {
				ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
				this.buttonElement = ancestor.filter( labelSelector );
				if ( !this.buttonElement.length ) {
					this.buttonElement = ancestor.find( labelSelector );
				}
			}
			this.element.addClass( "ui-helper-hidden-accessible" );

			checked = this.element.is( ":checked" );
			if ( checked ) {
				this.buttonElement.addClass( "ui-state-active" );
			}
			this.buttonElement.prop( "aria-pressed", checked );
		} else {
			this.buttonElement = this.element;
		}
	},

	widget: function() {
		return this.buttonElement;
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-helper-hidden-accessible" );
		this.buttonElement
			.removeClass( baseClasses + " ui-state-active " + typeClasses )
			.removeAttr( "role" )
			.removeAttr( "aria-pressed" )
			.html( this.buttonElement.find(".ui-button-text").html() );

		if ( !this.hasTitle ) {
			this.buttonElement.removeAttr( "title" );
		}
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "disabled" ) {
			this.widget().toggleClass( "ui-state-disabled", !!value );
			this.element.prop( "disabled", !!value );
			if ( value ) {
				if ( this.type === "checkbox" || this.type === "radio" ) {
					this.buttonElement.removeClass( "ui-state-focus" );
				} else {
					this.buttonElement.removeClass( "ui-state-focus ui-state-active" );
				}
			}
			return;
		}
		this._resetButton();
	},

	refresh: function() {
		//See #8237 & #8828
		var isDisabled = this.element.is( "input, button" ) ? this.element.is( ":disabled" ) : this.element.hasClass( "ui-button-disabled" );

		if ( isDisabled !== this.options.disabled ) {
			this._setOption( "disabled", isDisabled );
		}
		if ( this.type === "radio" ) {
			radioGroup( this.element[0] ).each(function() {
				if ( $( this ).is( ":checked" ) ) {
					$( this ).button( "widget" )
						.addClass( "ui-state-active" )
						.attr( "aria-pressed", "true" );
				} else {
					$( this ).button( "widget" )
						.removeClass( "ui-state-active" )
						.attr( "aria-pressed", "false" );
				}
			});
		} else if ( this.type === "checkbox" ) {
			if ( this.element.is( ":checked" ) ) {
				this.buttonElement
					.addClass( "ui-state-active" )
					.attr( "aria-pressed", "true" );
			} else {
				this.buttonElement
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			}
		}
	},

	_resetButton: function() {
		if ( this.type === "input" ) {
			if ( this.options.label ) {
				this.element.val( this.options.label );
			}
			return;
		}
		var buttonElement = this.buttonElement.removeClass( typeClasses ),
			buttonText = $( "<span></span>", this.document[0] )
				.addClass( "ui-button-text" )
				.html( this.options.label )
				.appendTo( buttonElement.empty() )
				.text(),
			icons = this.options.icons,
			multipleIcons = icons.primary && icons.secondary,
			buttonClasses = [];

		if ( icons.primary || icons.secondary ) {
			if ( this.options.text ) {
				buttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );
			}

			if ( icons.primary ) {
				buttonElement.prepend( "<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>" );
			}

			if ( icons.secondary ) {
				buttonElement.append( "<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>" );
			}

			if ( !this.options.text ) {
				buttonClasses.push( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" );

				if ( !this.hasTitle ) {
					buttonElement.attr( "title", $.trim( buttonText ) );
				}
			}
		} else {
			buttonClasses.push( "ui-button-text-only" );
		}
		buttonElement.addClass( buttonClasses.join( " " ) );
	}
});

$.widget( "ui.buttonset", {
	version: "1.11.0",
	options: {
		items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"
	},

	_create: function() {
		this.element.addClass( "ui-buttonset" );
	},

	_init: function() {
		this.refresh();
	},

	_setOption: function( key, value ) {
		if ( key === "disabled" ) {
			this.buttons.button( "option", key, value );
		}

		this._super( key, value );
	},

	refresh: function() {
		var rtl = this.element.css( "direction" ) === "rtl",
			allButtons = this.element.find( this.options.items ),
			existingButtons = allButtons.filter( ":ui-button" );

		// Initialize new buttons
		allButtons.not( ":ui-button" ).button();

		// Refresh existing buttons
		existingButtons.button( "refresh" );

		this.buttons = allButtons
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-all ui-corner-left ui-corner-right" )
				.filter( ":first" )
					.addClass( rtl ? "ui-corner-right" : "ui-corner-left" )
				.end()
				.filter( ":last" )
					.addClass( rtl ? "ui-corner-left" : "ui-corner-right" )
				.end()
			.end();
	},

	_destroy: function() {
		this.element.removeClass( "ui-buttonset" );
		this.buttons
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-left ui-corner-right" )
			.end()
			.button( "destroy" );
	}
});

var button = $.ui.button;


/*!
 * jQuery UI Datepicker 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/datepicker/
 */


$.extend($.ui, { datepicker: { version: "1.11.0" } });

var datepicker_instActive;

function datepicker_getZindex( elem ) {
	var position, value;
	while ( elem.length && elem[ 0 ] !== document ) {
		// Ignore z-index if position is set to a value where z-index is ignored by the browser
		// This makes behavior of this function consistent across browsers
		// WebKit always returns auto if the element is positioned
		position = elem.css( "position" );
		if ( position === "absolute" || position === "relative" || position === "fixed" ) {
			// IE returns 0 when zIndex is not specified
			// other browsers return a string
			// we ignore the case of nested elements with an explicit value of 0
			// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
			value = parseInt( elem.css( "zIndex" ), 10 );
			if ( !isNaN( value ) && value !== 0 ) {
				return value;
			}
		}
		elem = elem.parent();
	}

	return 0;
}
/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
	this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
	this._appendClass = "ui-datepicker-append"; // The name of the append marker class
	this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
	this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
	this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
	this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
	this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
	this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[""] = { // Default regional settings
		closeText: "Done", // Display text for close link
		prevText: "Prev", // Display text for previous month link
		nextText: "Next", // Display text for next month link
		currentText: "Today", // Display text for current month link
		monthNames: ["January","February","March","April","May","June",
			"July","August","September","October","November","December"], // Names of months for drop-down and formatting
		monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], // For formatting
		dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], // For formatting
		dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], // For formatting
		dayNamesMin: ["Su","Mo","Tu","We","Th","Fr","Sa"], // Column headings for days starting at Sunday
		weekHeader: "Wk", // Column header for week of the year
		dateFormat: "mm/dd/yy", // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: "" // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: "focus", // "focus" for popup on focus,
			// "button" for trigger button, or "both" for either
		showAnim: "fadeIn", // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: "", // Display text following the input box, e.g. showing the format
		buttonText: "...", // Text for trigger button
		buttonImage: "", // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: "c-10:c+10", // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: "+10", // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with "+" for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: "fast", // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: "", // Selector for an alternate field to store selected dates into
		altFormat: "", // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend(this._defaults, this.regional[""]);
	this.regional.en = $.extend( true, {}, this.regional[ "" ]);
	this.regional[ "en-US" ] = $.extend( true, {}, this.regional.en );
	this.dpDiv = datepicker_bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: "hasDatepicker",

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	 * @param  settings  object - the new settings to use as defaults (anonymous object)
	 * @return the manager object
	 */
	setDefaults: function(settings) {
		datepicker_extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
	 */
	_attachDatepicker: function(target, settings) {
		var nodeName, inline, inst;
		nodeName = target.nodeName.toLowerCase();
		inline = (nodeName === "div" || nodeName === "span");
		if (!target.id) {
			this.uuid += 1;
			target.id = "dp" + this.uuid;
		}
		inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {});
		if (nodeName === "input") {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1"); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			datepicker_bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName)) {
			return;
		}
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp);
		this._autoSize(inst);
		$.data(target, "datepicker", inst);
		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var showOn, buttonText, buttonImage,
			appendText = this._get(inst, "appendText"),
			isRTL = this._get(inst, "isRTL");

		if (inst.append) {
			inst.append.remove();
		}
		if (appendText) {
			inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
			input[isRTL ? "before" : "after"](inst.append);
		}

		input.unbind("focus", this._showDatepicker);

		if (inst.trigger) {
			inst.trigger.remove();
		}

		showOn = this._get(inst, "showOn");
		if (showOn === "focus" || showOn === "both") { // pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		}
		if (showOn === "button" || showOn === "both") { // pop-up date picker when button clicked
			buttonText = this._get(inst, "buttonText");
			buttonImage = this._get(inst, "buttonImage");
			inst.trigger = $(this._get(inst, "buttonImageOnly") ?
				$("<img/>").addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$("<button type='button'></button>").addClass(this._triggerClass).
					html(!buttonImage ? buttonText : $("<img/>").attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? "before" : "after"](inst.trigger);
			inst.trigger.click(function() {
				if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
					$.datepicker._hideDatepicker();
				} else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker(input[0]);
				} else {
					$.datepicker._showDatepicker(input[0]);
				}
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, "autoSize") && !inst.inline) {
			var findMax, max, maxI, i,
				date = new Date(2009, 12 - 1, 20), // Ensure double digits
				dateFormat = this._get(inst, "dateFormat");

			if (dateFormat.match(/[DM]/)) {
				findMax = function(names) {
					max = 0;
					maxI = 0;
					for (i = 0; i < names.length; i++) {
						if (names[i].length > max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					"monthNames" : "monthNamesShort"))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					"dayNames" : "dayNamesShort"))) + 20 - date.getDay());
			}
			inst.input.attr("size", this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName)) {
			return;
		}
		divSpan.addClass(this.markerClassName).append(inst.dpDiv);
		$.data(target, "datepicker", inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	 * @param  input element - ignored
	 * @param  date	string or Date - the initial date to display
	 * @param  onSelect  function - the function to call when a date is selected
	 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	 * @param  pos int[2] - coordinates for the dialog's position within the screen or
	 *					event - with x/y coordinates or
	 *					leave empty for default (screen centre)
	 * @return the manager object
	 */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var id, browserWidth, browserHeight, scrollX, scrollY,
			inst = this._dialogInst; // internal instance

		if (!inst) {
			this.uuid += 1;
			id = "dp" + this.uuid;
			this._dialogInput = $("<input type='text' id='" + id +
				"' style='position: absolute; top: -100px; width: 0px;'/>");
			this._dialogInput.keydown(this._doKeyDown);
			$("body").append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], "datepicker", inst);
		}
		datepicker_extendRemove(inst.settings, settings || {});
		date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			browserWidth = document.documentElement.clientWidth;
			browserHeight = document.documentElement.clientHeight;
			scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI) {
			$.blockUI(this.dpDiv);
		}
		$.data(this._dialogInput[0], "datepicker", inst);
		return this;
	},

	/* Detach a datepicker from its control.
	 * @param  target	element - the target input field or division or span
	 */
	_destroyDatepicker: function(target) {
		var nodeName,
			$target = $(target),
			inst = $.data(target, "datepicker");

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		$.removeData(target, "datepicker");
		if (nodeName === "input") {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass(this.markerClassName).
				unbind("focus", this._showDatepicker).
				unbind("keydown", this._doKeyDown).
				unbind("keypress", this._doKeyPress).
				unbind("keyup", this._doKeyUp);
		} else if (nodeName === "div" || nodeName === "span") {
			$target.removeClass(this.markerClassName).empty();
		}
	},

	/* Enable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_enableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, "datepicker");

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = false;
			inst.trigger.filter("button").
				each(function() { this.disabled = false; }).end().
				filter("img").css({opacity: "1.0", cursor: ""});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().removeClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", false);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_disableDatepicker: function(target) {
		var nodeName, inline,
			$target = $(target),
			inst = $.data(target, "datepicker");

		if (!$target.hasClass(this.markerClassName)) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if (nodeName === "input") {
			target.disabled = true;
			inst.trigger.filter("button").
				each(function() { this.disabled = true; }).end().
				filter("img").css({opacity: "0.5", cursor: "default"});
		} else if (nodeName === "div" || nodeName === "span") {
			inline = $target.children("." + this._inlineClass);
			inline.children().addClass("ui-state-disabled");
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				prop("disabled", true);
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value === target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	 * @param  target	element - the target input field or division or span
	 * @return boolean - true if disabled, false if enabled
	 */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i < this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] === target) {
				return true;
			}
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	 * @param  target  element - the target input field or division or span
	 * @return  object - the associated instance data
	 * @throws  error if a jQuery problem getting data
	 */
	_getInst: function(target) {
		try {
			return $.data(target, "datepicker");
		}
		catch (err) {
			throw "Missing instance data for this datepicker";
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 * @param  name	object - the new settings to update or
	 *				string - the name of the setting to change or retrieve,
	 *				when retrieving also "all" for all instance settings or
	 *				"defaults" for all global defaults
	 * @param  value   any - the new value for the setting
	 *				(omit if above is an object or to retrieve a value)
	 */
	_optionDatepicker: function(target, name, value) {
		var settings, date, minDate, maxDate,
			inst = this._getInst(target);

		if (arguments.length === 2 && typeof name === "string") {
			return (name === "defaults" ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name === "all" ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}

		settings = name || {};
		if (typeof name === "string") {
			settings = {};
			settings[name] = value;
		}

		if (inst) {
			if (this._curInst === inst) {
				this._hideDatepicker();
			}

			date = this._getDateDatepicker(target, true);
			minDate = this._getMinMaxDate(inst, "min");
			maxDate = this._getMinMaxDate(inst, "max");
			datepicker_extendRemove(inst.settings, settings);
			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
				inst.settings.minDate = this._formatDate(inst, minDate);
			}
			if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			}
			if ( "disabled" in settings ) {
				if ( settings.disabled ) {
					this._disableDatepicker(target);
				} else {
					this._enableDatepicker(target);
				}
			}
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDate(inst, date);
			this._updateAlternate(inst);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  date	Date - the new date
	 */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  noDefault boolean - true if no default date is to be used
	 * @return Date - the current date
	 */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst && !inst.inline) {
			this._setDateFromField(inst, noDefault);
		}
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var onSelect, dateStr, sel,
			inst = $.datepicker._getInst(event.target),
			handled = true,
			isRTL = inst.dpDiv.is(".ui-datepicker-rtl");

		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing) {
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: sel = $("td." + $.datepicker._dayOverClass + ":not(." +
									$.datepicker._currentClass + ")", inst.dpDiv);
						if (sel[0]) {
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
						}

						onSelect = $.datepicker._get(inst, "onSelect");
						if (onSelect) {
							dateStr = $.datepicker._formatDate(inst);

							// trigger custom callback
							onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
						} else {
							$.datepicker._hideDatepicker();
						}

						return false; // don't submit the form
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, "stepBigMonths") :
							-$.datepicker._get(inst, "stepMonths")), "M");
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, "stepBigMonths") :
							+$.datepicker._get(inst, "stepMonths")), "M");
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) {
							$.datepicker._clearDate(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) {
							$.datepicker._gotoToday(event.target);
						}
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								-$.datepicker._get(inst, "stepBigMonths") :
								-$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, -7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
						}
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) {
							$.datepicker._adjustDate(event.target, (event.ctrlKey ?
								+$.datepicker._get(inst, "stepBigMonths") :
								+$.datepicker._get(inst, "stepMonths")), "M");
						}
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) {
							$.datepicker._adjustDate(event.target, +7, "D");
						}
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		} else if (event.keyCode === 36 && event.ctrlKey) { // display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		} else {
			handled = false;
		}

		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var chars, chr,
			inst = $.datepicker._getInst(event.target);

		if ($.datepicker._get(inst, "constrainInput")) {
			chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
			chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var date,
			inst = $.datepicker._getInst(event.target);

		if (inst.input.val() !== inst.lastVal) {
			try {
				date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));

				if (date) { // only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (err) {
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	 * If false returned from beforeShow event handler do not show.
	 * @param  input  element - the input field attached to the date picker or
	 *					event - if triggered by focus
	 */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() !== "input") { // find from button/image trigger
			input = $("input", input.parentNode)[0];
		}

		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) { // already here
			return;
		}

		var inst, beforeShow, beforeShowSettings, isFixed,
			offset, showAnim, duration;

		inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
			$.datepicker._curInst.dpDiv.stop(true, true);
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
			}
		}

		beforeShow = $.datepicker._get(inst, "beforeShow");
		beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
		if(beforeShowSettings === false){
			return;
		}
		datepicker_extendRemove(inst.settings, beforeShowSettings);

		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);

		if ($.datepicker._inDialog) { // hide cursor
			input.value = "";
		}
		if (!$.datepicker._pos) { // position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; // add the height
		}

		isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css("position") === "fixed";
			return !isFixed;
		});

		offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		//to avoid flashes on Firefox
		inst.dpDiv.empty();
		// determine sizing offscreen
		inst.dpDiv.css({position: "absolute", display: "block", top: "-1000px"});
		$.datepicker._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
			"static" : (isFixed ? "fixed" : "absolute")), display: "none",
			left: offset.left + "px", top: offset.top + "px"});

		if (!inst.inline) {
			showAnim = $.datepicker._get(inst, "showAnim");
			duration = $.datepicker._get(inst, "duration");
			inst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 );
			$.datepicker._datepickerShowing = true;

			if ( $.effects && $.effects.effect[ showAnim ] ) {
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
			} else {
				inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
			}

			if ( $.datepicker._shouldFocusInput( inst ) ) {
				inst.input.focus();
			}

			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		datepicker_instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append(this._generateHTML(inst));
		this._attachHandlers(inst);
		inst.dpDiv.find("." + this._dayOverClass + " a");

		var origyearshtml,
			numMonths = this._getNumberOfMonths(inst),
			cols = numMonths[1],
			width = 17;

		inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
		if (cols > 1) {
			inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
		}
		inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") +
			"Class"]("ui-datepicker-multi");
		inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") +
			"Class"]("ui-datepicker-rtl");

		if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
			inst.input.focus();
		}

		// deffered render of the years select (to avoid flashes on Firefox)
		if( inst.yearshtml ){
			origyearshtml = inst.yearshtml;
			setTimeout(function(){
				//assure that inst.yearshtml didn't change.
				if( origyearshtml === inst.yearshtml && inst.yearshtml ){
					inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	// #6694 - don't focus the input if it's already focused
	// this breaks the change event in IE
	// Support: IE and jQuery <1.9
	_shouldFocusInput: function( inst ) {
		return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth(),
			dpHeight = inst.dpDiv.outerHeight(),
			inputWidth = inst.input ? inst.input.outerWidth() : 0,
			inputHeight = inst.input ? inst.input.outerHeight() : 0,
			viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
			viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());

		offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function(obj) {
		var position,
			inst = this._getInst(obj),
			isRTL = this._get(inst, "isRTL");

		while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
			obj = obj[isRTL ? "previousSibling" : "nextSibling"];
		}

		position = $(obj).offset();
		return [position.left, position.top];
	},

	/* Hide the date picker from view.
	 * @param  input  element - the input field attached to the date picker
	 */
	_hideDatepicker: function(input) {
		var showAnim, duration, postProcess, onClose,
			inst = this._curInst;

		if (!inst || (input && inst !== $.data(input, "datepicker"))) {
			return;
		}

		if (this._datepickerShowing) {
			showAnim = this._get(inst, "showAnim");
			duration = this._get(inst, "duration");
			postProcess = function() {
				$.datepicker._tidyDialog(inst);
			};

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
			} else {
				inst.dpDiv[(showAnim === "slideDown" ? "slideUp" :
					(showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
			}

			if (!showAnim) {
				postProcess();
			}
			this._datepickerShowing = false;

			onClose = this._get(inst, "onClose");
			if (onClose) {
				onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
			}

			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: "absolute", left: "0", top: "-100px" });
				if ($.blockUI) {
					$.unblockUI();
					$("body").append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst) {
			return;
		}

		var $target = $(event.target),
			inst = $.datepicker._getInst($target[0]);

		if ( ( ( $target[0].id !== $.datepicker._mainDivId &&
				$target.parents("#" + $.datepicker._mainDivId).length === 0 &&
				!$target.hasClass($.datepicker.markerClassName) &&
				!$target.closest("." + $.datepicker._triggerClass).length &&
				$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
			( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst ) ) {
				$.datepicker._hideDatepicker();
		}
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period === "M" ? this._get(inst, "showCurrentAtPos") : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var date,
			target = $(id),
			inst = this._getInst(target[0]);

		if (this._get(inst, "gotoCurrent") && inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		} else {
			date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id),
			inst = this._getInst(target[0]);

		inst["selected" + (period === "M" ? "Month" : "Year")] =
		inst["draw" + (period === "M" ? "Month" : "Year")] =
			parseInt(select.options[select.selectedIndex].value,10);

		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var inst,
			target = $(id);

		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}

		inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $("a", td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		this._selectDate(target, "");
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var onSelect,
			target = $(id),
			inst = this._getInst(target[0]);

		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input) {
			inst.input.val(dateStr);
		}
		this._updateAlternate(inst);

		onSelect = this._get(inst, "onSelect");
		if (onSelect) {
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		} else if (inst.input) {
			inst.input.trigger("change"); // fire the change event
		}

		if (inst.inline){
			this._updateDatepicker(inst);
		} else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) !== "object") {
				inst.input.focus(); // restore focus
			}
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altFormat, date, dateStr,
			altField = this._get(inst, "altField");

		if (altField) { // update alternate field too
			altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
			date = this._getDate(inst);
			dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	 * @param  date  Date - the date to customise
	 * @return [boolean, string] - is this date selectable?, what is its CSS class?
	 */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day > 0 && day < 6), ""];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	 * @param  date  Date - the date to get the week for
	 * @return  number - the number of the week within the year that contains this date
	 */
	iso8601Week: function(date) {
		var time,
			checkDate = new Date(date.getTime());

		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));

		time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	 * See formatDate below for the possible formats.
	 *
	 * @param  format string - the expected format of the date
	 * @param  value string - the date in the above format
	 * @param  settings Object - attributes include:
	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  Date - the extracted date value or null if value is blank
	 */
	parseDate: function (format, value, settings) {
		if (format == null || value == null) {
			throw "Invalid arguments";
		}

		value = (typeof value === "object" ? value.toString() : value + "");
		if (value === "") {
			return null;
		}

		var iFormat, dim, extra,
			iValue = 0,
			shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
			shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			year = -1,
			month = -1,
			day = -1,
			doy = -1,
			literal = false,
			date,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Extract a number from the string value
			getNumber = function(match) {
				var isDoubled = lookAhead(match),
					size = (match === "@" ? 14 : (match === "!" ? 20 :
					(match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
					digits = new RegExp("^\\d{1," + size + "}"),
					num = value.substring(iValue).match(digits);
				if (!num) {
					throw "Missing number at position " + iValue;
				}
				iValue += num[0].length;
				return parseInt(num[0], 10);
			},
			// Extract a name from the string value and convert to an index
			getName = function(match, shortNames, longNames) {
				var index = -1,
					names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
						return [ [k, v] ];
					}).sort(function (a, b) {
						return -(a[1].length - b[1].length);
					});

				$.each(names, function (i, pair) {
					var name = pair[1];
					if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
						index = pair[0];
						iValue += name.length;
						return false;
					}
				});
				if (index !== -1) {
					return index + 1;
				} else {
					throw "Unknown name at position " + iValue;
				}
			},
			// Confirm that a literal character matches the string value
			checkLiteral = function() {
				if (value.charAt(iValue) !== format.charAt(iFormat)) {
					throw "Unexpected literal at position " + iValue;
				}
				iValue++;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					checkLiteral();
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d":
						day = getNumber("d");
						break;
					case "D":
						getName("D", dayNamesShort, dayNames);
						break;
					case "o":
						doy = getNumber("o");
						break;
					case "m":
						month = getNumber("m");
						break;
					case "M":
						month = getName("M", monthNamesShort, monthNames);
						break;
					case "y":
						year = getNumber("y");
						break;
					case "@":
						date = new Date(getNumber("@"));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "!":
						date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if (lookAhead("'")){
							checkLiteral();
						} else {
							literal = true;
						}
						break;
					default:
						checkLiteral();
				}
			}
		}

		if (iValue < value.length){
			extra = value.substr(iValue);
			if (!/^\s+/.test(extra)) {
				throw "Extra/unparsed characters found in date: " + extra;
			}
		}

		if (year === -1) {
			year = new Date().getFullYear();
		} else if (year < 100) {
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year <= shortYearCutoff ? 0 : -100);
		}

		if (doy > -1) {
			month = 1;
			day = doy;
			do {
				dim = this._getDaysInMonth(year, month - 1);
				if (day <= dim) {
					break;
				}
				month++;
				day -= dim;
			} while (true);
		}

		date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
			throw "Invalid date"; // E.g. 31/02/00
		}
		return date;
	},

	/* Standard date formats. */
	ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
	COOKIE: "D, dd M yy",
	ISO_8601: "yy-mm-dd",
	RFC_822: "D, d M y",
	RFC_850: "DD, dd-M-y",
	RFC_1036: "D, d M y",
	RFC_1123: "D, d M yy",
	RFC_2822: "D, d M yy",
	RSS: "D, d M y", // RFC 822
	TICKS: "!",
	TIMESTAMP: "@",
	W3C: "yy-mm-dd", // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	 * The format can be combinations of the following:
	 * d  - day of month (no leading zero)
	 * dd - day of month (two digit)
	 * o  - day of year (no leading zeros)
	 * oo - day of year (three digit)
	 * D  - day name short
	 * DD - day name long
	 * m  - month of year (no leading zero)
	 * mm - month of year (two digit)
	 * M  - month name short
	 * MM - month name long
	 * y  - year (two digit)
	 * yy - year (four digit)
	 * @ - Unix timestamp (ms since 01/01/1970)
	 * ! - Windows ticks (100ns since 01/01/0001)
	 * "..." - literal text
	 * '' - single quote
	 *
	 * @param  format string - the desired format of the date
	 * @param  date Date - the date value to format
	 * @param  settings Object - attributes include:
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  string - the date in the above format
	 */
	formatDate: function (format, date, settings) {
		if (!date) {
			return "";
		}

		var iFormat,
			dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
			dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
			monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
			monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			},
			// Format a number, with leading zero if necessary
			formatNumber = function(match, value, len) {
				var num = "" + value;
				if (lookAhead(match)) {
					while (num.length < len) {
						num = "0" + num;
					}
				}
				return num;
			},
			// Format a name, short or long as requested
			formatName = function(match, value, shortNames, longNames) {
				return (lookAhead(match) ? longNames[value] : shortNames[value]);
			},
			output = "",
			literal = false;

		if (date) {
			for (iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal) {
					if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
						literal = false;
					} else {
						output += format.charAt(iFormat);
					}
				} else {
					switch (format.charAt(iFormat)) {
						case "d":
							output += formatNumber("d", date.getDate(), 2);
							break;
						case "D":
							output += formatName("D", date.getDay(), dayNamesShort, dayNames);
							break;
						case "o":
							output += formatNumber("o",
								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
							break;
						case "m":
							output += formatNumber("m", date.getMonth() + 1, 2);
							break;
						case "M":
							output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
							break;
						case "y":
							output += (lookAhead("y") ? date.getFullYear() :
								(date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
							break;
						case "@":
							output += date.getTime();
							break;
						case "!":
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if (lookAhead("'")) {
								output += "'";
							} else {
								literal = true;
							}
							break;
						default:
							output += format.charAt(iFormat);
					}
				}
			}
		}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var iFormat,
			chars = "",
			literal = false,
			// Check whether a format character is doubled
			lookAhead = function(match) {
				var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
				if (matches) {
					iFormat++;
				}
				return matches;
			};

		for (iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal) {
				if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
					literal = false;
				} else {
					chars += format.charAt(iFormat);
				}
			} else {
				switch (format.charAt(iFormat)) {
					case "d": case "m": case "y": case "@":
						chars += "0123456789";
						break;
					case "D": case "M":
						return null; // Accept anything
					case "'":
						if (lookAhead("'")) {
							chars += "'";
						} else {
							literal = true;
						}
						break;
					default:
						chars += format.charAt(iFormat);
				}
			}
		}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() === inst.lastVal) {
			return;
		}

		var dateFormat = this._get(inst, "dateFormat"),
			dates = inst.lastVal = inst.input ? inst.input.val() : null,
			defaultDate = this._getDefaultDate(inst),
			date = defaultDate,
			settings = this._getFormatConfig(inst);

		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			dates = (noDefault ? "" : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
				var date = new Date();
				date.setDate(date.getDate() + offset);
				return date;
			},
			offsetString = function(offset) {
				try {
					return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"),
						offset, $.datepicker._getFormatConfig(inst));
				}
				catch (e) {
					// Ignore
				}

				var date = (offset.toLowerCase().match(/^c/) ?
					$.datepicker._getDate(inst) : null) || new Date(),
					year = date.getFullYear(),
					month = date.getMonth(),
					day = date.getDate(),
					pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
					matches = pattern.exec(offset);

				while (matches) {
					switch (matches[2] || "d") {
						case "d" : case "D" :
							day += parseInt(matches[1],10); break;
						case "w" : case "W" :
							day += parseInt(matches[1],10) * 7; break;
						case "m" : case "M" :
							month += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
						case "y": case "Y" :
							year += parseInt(matches[1],10);
							day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
							break;
					}
					matches = pattern.exec(offset);
				}
				return new Date(year, month, day);
			},
			newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) :
				(typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));

		newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	/* Handle switch to/from daylight saving.
	 * Hours may be non-zero on daylight saving cut-over:
	 * > 12 when midnight changeover, but then cannot generate
	 * midnight datetime, so jump to 1AM, otherwise reset.
	 * @param  date  (Date) the date to check
	 * @return  (Date) the corrected date
	 */
	_daylightSavingAdjust: function(date) {
		if (!date) {
			return null;
		}
		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !date,
			origMonth = inst.selectedMonth,
			origYear = inst.selectedYear,
			newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));

		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
			this._notifyChange(inst);
		}
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? "" : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function(inst) {
		var stepMonths = this._get(inst, "stepMonths"),
			id = "#" + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find("[data-handler]").map(function () {
			var handler = {
				prev: function () {
					$.datepicker._adjustDate(id, -stepMonths, "M");
				},
				next: function () {
					$.datepicker._adjustDate(id, +stepMonths, "M");
				},
				hide: function () {
					$.datepicker._hideDatepicker();
				},
				today: function () {
					$.datepicker._gotoToday(id);
				},
				selectDay: function () {
					$.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
					return false;
				},
				selectMonth: function () {
					$.datepicker._selectMonthYear(id, this, "M");
					return false;
				},
				selectYear: function () {
					$.datepicker._selectMonthYear(id, this, "Y");
					return false;
				}
			};
			$(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
		});
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
			controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
			monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
			selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
			cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
			printDate, dRow, tbody, daySettings, otherMonth, unselectable,
			tempDate = new Date(),
			today = this._daylightSavingAdjust(
				new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())), // clear time
			isRTL = this._get(inst, "isRTL"),
			showButtonPanel = this._get(inst, "showButtonPanel"),
			hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
			navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
			numMonths = this._getNumberOfMonths(inst),
			showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
			stepMonths = this._get(inst, "stepMonths"),
			isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
			currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
				new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			drawMonth = inst.drawMonth - showCurrentAtPos,
			drawYear = inst.drawYear;

		if (drawMonth < 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
				drawMonth--;
				if (drawMonth < 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;

		prevText = this._get(inst, "prevText");
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));

		prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
			" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+ prevText +"'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));

		nextText = this._get(inst, "nextText");
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));

		next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
			" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" :
			(hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+ nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));

		currentText = this._get(inst, "currentText");
		gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));

		controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
			this._get(inst, "closeText") + "</button>" : "");

		buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") +
			(this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
			">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";

		firstDay = parseInt(this._get(inst, "firstDay"),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);

		showWeek = this._get(inst, "showWeek");
		dayNames = this._get(inst, "dayNames");
		dayNamesMin = this._get(inst, "dayNamesMin");
		monthNames = this._get(inst, "monthNames");
		monthNamesShort = this._get(inst, "monthNamesShort");
		beforeShowDay = this._get(inst, "beforeShowDay");
		showOtherMonths = this._get(inst, "showOtherMonths");
		selectOtherMonths = this._get(inst, "selectOtherMonths");
		defaultDate = this._getDefaultDate(inst);
		html = "";
		dow;
		for (row = 0; row < numMonths[0]; row++) {
			group = "";
			this.maxRows = 4;
			for (col = 0; col < numMonths[1]; col++) {
				selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				cornerClass = " ui-corner-all";
				calender = "";
				if (isMultiMonth) {
					calender += "<div class='ui-datepicker-group";
					if (numMonths[1] > 1) {
						switch (col) {
							case 0: calender += " ui-datepicker-group-first";
								cornerClass = " ui-corner-" + (isRTL ? "right" : "left"); break;
							case numMonths[1]-1: calender += " ui-datepicker-group-last";
								cornerClass = " ui-corner-" + (isRTL ? "left" : "right"); break;
							default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
						}
					}
					calender += "'>";
				}
				calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
					(/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") +
					(/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
					"</div><table class='ui-datepicker-calendar'><thead>" +
					"<tr>";
				thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
				for (dow = 0; dow < 7; dow++) { // days of the week
					day = (dow + firstDay) % 7;
					thead += "<th scope='col'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" +
						"<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
				}
				calender += thead + "</tr></thead><tbody>";
				daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				}
				leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
				numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (dRow = 0; dRow < numRows; dRow++) { // create date picker rows
					calender += "<tr>";
					tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
						this._get(inst, "calculateWeek")(printDate) + "</td>");
					for (dow = 0; dow < 7; dow++) { // create date picker days
						daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
						otherMonth = (printDate.getMonth() !== drawMonth);
						unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
							(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
						tbody += "<td class='" +
							((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + // highlight weekends
							(otherMonth ? " ui-datepicker-other-month" : "") + // highlight days from other months
							((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || // user pressed key
							(defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							" " + this._dayOverClass : "") + // highlight selected day
							(unselectable ? " " + this._unselectableClass + " ui-state-disabled": "") +  // highlight unselectable days
							(otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + // highlight custom dates
							(printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + // highlight selected day
							(printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + // highlight today (if different)
							((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + // cell title
							(unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + // actions
							(otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
							(unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
							(printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") +
							(printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + // highlight selected day
							(otherMonth ? " ui-priority-secondary" : "") + // distinguish dates from other months
							"' href='#'>" + printDate.getDate() + "</a>")) + "</td>"; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + "</tr>";
				}
				drawMonth++;
				if (drawMonth > 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += "</tbody></table>" + (isMultiMonth ? "</div>" +
							((numMonths[0] > 0 && col === numMonths[1]-1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
				group += calender;
			}
			html += group;
		}
		html += buttonPanel;
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {

		var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
			changeMonth = this._get(inst, "changeMonth"),
			changeYear = this._get(inst, "changeYear"),
			showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
			html = "<div class='ui-datepicker-title'>",
			monthHtml = "";

		// month selection
		if (secondary || !changeMonth) {
			monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
		} else {
			inMinYear = (minDate && minDate.getFullYear() === drawYear);
			inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
			monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
			for ( month = 0; month < 12; month++) {
				if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
					monthHtml += "<option value='" + month + "'" +
						(month === drawMonth ? " selected='selected'" : "") +
						">" + monthNamesShort[month] + "</option>";
				}
			}
			monthHtml += "</select>";
		}

		if (!showMonthAfterYear) {
			html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
		}

		// year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = "";
			if (secondary || !changeYear) {
				html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
			} else {
				// determine range of years to display
				years = this._get(inst, "yearRange").split(":");
				thisYear = new Date().getFullYear();
				determineYear = function(value) {
					var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) :
						(value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) :
						parseInt(value, 10)));
					return (isNaN(year) ? thisYear : year);
				};
				year = determineYear(years[0]);
				endYear = Math.max(year, determineYear(years[1] || ""));
				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
				inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
				for (; year <= endYear; year++) {
					inst.yearshtml += "<option value='" + year + "'" +
						(year === drawYear ? " selected='selected'" : "") +
						">" + year + "</option>";
				}
				inst.yearshtml += "</select>";

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}

		html += this._get(inst, "yearSuffix");
		if (showMonthAfterYear) {
			html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
		}
		html += "</div>"; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period === "Y" ? offset : 0),
			month = inst.drawMonth + (period === "M" ? offset : 0),
			day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
			date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));

		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period === "M" || period === "Y") {
			this._notifyChange(inst);
		}
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			newDate = (minDate && date < minDate ? minDate : date);
		return (maxDate && newDate > maxDate ? maxDate : newDate);
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, "onChangeMonthYear");
		if (onChange) {
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
		}
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, "numberOfMonths");
		return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst),
			date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));

		if (offset < 0) {
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		}
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var yearSplit, currentYear,
			minDate = this._getMinMaxDate(inst, "min"),
			maxDate = this._getMinMaxDate(inst, "max"),
			minYear = null,
			maxYear = null,
			years = this._get(inst, "yearRange");
			if (years){
				yearSplit = years.split(":");
				currentYear = new Date().getFullYear();
				minYear = parseInt(yearSplit[0], 10);
				maxYear = parseInt(yearSplit[1], 10);
				if ( yearSplit[0].match(/[+\-].*/) ) {
					minYear += currentYear;
				}
				if ( yearSplit[1].match(/[+\-].*/) ) {
					maxYear += currentYear;
				}
			}

		return ((!minDate || date.getTime() >= minDate.getTime()) &&
			(!maxDate || date.getTime() <= maxDate.getTime()) &&
			(!minYear || date.getFullYear() >= minYear) &&
			(!maxYear || date.getFullYear() <= maxYear));
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, "shortYearCutoff");
		shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, "dayNamesShort"), dayNames: this._get(inst, "dayNames"),
			monthNamesShort: this._get(inst, "monthNamesShort"), monthNames: this._get(inst, "monthNames")};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day === "object" ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
	}
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function datepicker_bindHover(dpDiv) {
	var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
	return dpDiv.delegate(selector, "mouseout", function() {
			$(this).removeClass("ui-state-hover");
			if (this.className.indexOf("ui-datepicker-prev") !== -1) {
				$(this).removeClass("ui-datepicker-prev-hover");
			}
			if (this.className.indexOf("ui-datepicker-next") !== -1) {
				$(this).removeClass("ui-datepicker-next-hover");
			}
		})
		.delegate(selector, "mouseover", function(){
			if (!$.datepicker._isDisabledDatepicker( datepicker_instActive.inline ? dpDiv.parent()[0] : datepicker_instActive.input[0])) {
				$(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
				$(this).addClass("ui-state-hover");
				if (this.className.indexOf("ui-datepicker-prev") !== -1) {
					$(this).addClass("ui-datepicker-prev-hover");
				}
				if (this.className.indexOf("ui-datepicker-next") !== -1) {
					$(this).addClass("ui-datepicker-next-hover");
				}
			}
		});
}

/* jQuery extend now ignores nulls! */
function datepicker_extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props) {
		if (props[name] == null) {
			target[name] = props[name];
		}
	}
	return target;
}

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){

	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if (!$.datepicker.initialized) {
		$(document).mousedown($.datepicker._checkExternalClick);
		$.datepicker.initialized = true;
	}

	/* Append datepicker main container to body if not exist. */
	if ($("#"+$.datepicker._mainDivId).length === 0) {
		$("body").append($.datepicker.dpDiv);
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
		return $.datepicker["_" + options + "Datepicker"].
			apply($.datepicker, [this[0]].concat(otherArgs));
	}
	return this.each(function() {
		typeof options === "string" ?
			$.datepicker["_" + options + "Datepicker"].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.11.0";

var datepicker = $.datepicker;


/*!
 * jQuery UI Draggable 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/draggable/
 */


$.widget("ui.draggable", $.ui.mouse, {
	version: "1.11.0",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false,

		// callbacks
		drag: null,
		start: null,
		stop: null
	},
	_create: function() {

		if (this.options.helper === "original" && !(/^(?:r|a|f)/).test(this.element.css("position"))) {
			this.element[0].style.position = "relative";
		}
		if (this.options.addClasses){
			this.element.addClass("ui-draggable");
		}
		if (this.options.disabled){
			this.element.addClass("ui-draggable-disabled");
		}
		this._setHandleClassName();

		this._mouseInit();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "handle" ) {
			this._setHandleClassName();
		}
	},

	_destroy: function() {
		if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {
			this.destroyOnClear = true;
			return;
		}
		this.element.removeClass( "ui-draggable ui-draggable-dragging ui-draggable-disabled" );
		this._removeHandleClassName();
		this._mouseDestroy();
	},

	_mouseCapture: function(event) {

		var document = this.document[ 0 ],
			o = this.options;

		// support: IE9
		// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
		try {
			// Support: IE9+
			// If the <body> is blurred, IE will switch windows, see #9520
			if ( document.activeElement && document.activeElement.nodeName.toLowerCase() !== "body" ) {
				// Blur any element that currently has focus, see #4261
				$( document.activeElement ).blur();
			}
		} catch ( error ) {}

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
			return false;
		}

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle) {
			return false;
		}

		$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
			$("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>")
			.css({
				width: this.offsetWidth + "px", height: this.offsetHeight + "px",
				position: "absolute", opacity: "0.001", zIndex: 1000
			})
			.css($(this).offset())
			.appendTo("body");
		});

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass("ui-draggable-dragging");

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if ($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css( "position" );
		this.scrollParent = this.helper.scrollParent();
		this.offsetParent = this.helper.offsetParent();
		this.offsetParentCssPosition = this.offsetParent.css( "position" );

		//The element's absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		//Reset scroll cache
		this.offset.scroll = false;

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition( event, false );
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		this._setContainment();

		//Trigger event + callbacks
		if (this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}

		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position

		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart(this, event);
		}

		return true;
	},

	_mouseDrag: function(event, noPropagation) {
		// reset any necessary cached properties (see #5009)
		if ( this.offsetParentCssPosition === "fixed" ) {
			this.offset.parent = this._getParentOffset();
		}

		//Compute the helpers position
		this.position = this._generatePosition( event, true );
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if (this._trigger("drag", event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		this.helper[ 0 ].style.left = this.position.left + "px";
		this.helper[ 0 ].style.top = this.position.top + "px";

		if ($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var that = this,
			dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour) {
			dropped = $.ui.ddmanager.drop(this, event);
		}

		//if a drop comes from outside (a sortable)
		if (this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}

		if ((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if (that._trigger("stop", event) !== false) {
					that._clear();
				}
			});
		} else {
			if (this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function(event) {
		//Remove frame helpers
		$("div.ui-draggable-iframeFix").each(function() {
			this.parentNode.removeChild(this);
		});

		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop(this, event);
		}

		// The interaction is over; whether or not the click resulted in a drag, focus the element
		this.element.focus();

		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},

	cancel: function() {

		if (this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function(event) {
		return this.options.handle ?
			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
			true;
	},

	_setHandleClassName: function() {
		this._removeHandleClassName();
		$( this.options.handle || this.element ).addClass( "ui-draggable-handle" );
	},

	_removeHandleClassName: function() {
		this.element.find( ".ui-draggable-handle" )
			.addBack()
			.removeClass( "ui-draggable-handle" );
	},

	_createHelper: function(event) {

		var o = this.options,
			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[ 0 ], [ event ])) : (o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element);

		if (!helper.parents("body").length) {
			helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
		}

		if (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
			helper.css("position", "absolute");
		}

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === "string") {
			obj = obj.split(" ");
		}
		if ($.isArray(obj)) {
			obj = { left: +obj[0], top: +obj[1] || 0 };
		}
		if ("left" in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ("right" in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ("top" in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ("bottom" in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_isRootNode: function( element ) {
		return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		var po = this.offsetParent.offset(),
			document = this.document[ 0 ];

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {
		if ( this.cssPosition !== "relative" ) {
			return { top: 0, left: 0 };
		}

		var p = this.element.position(),
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: p.top - ( parseInt(this.helper.css( "top" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
			left: p.left - ( parseInt(this.helper.css( "left" ), 10) || 0 ) + ( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
		};

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"),10) || 0),
			top: (parseInt(this.element.css("marginTop"),10) || 0),
			right: (parseInt(this.element.css("marginRight"),10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var over, c, ce,
			o = this.options,
			document = this.document[ 0 ];

		this.relative_container = null;

		if ( !o.containment ) {
			this.containment = null;
			return;
		}

		if ( o.containment === "window" ) {
			this.containment = [
				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				$( window ).scrollLeft() + $( window ).width() - this.helperProportions.width - this.margins.left,
				$( window ).scrollTop() + ( $( window ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment === "document") {
			this.containment = [
				0,
				0,
				$( document ).width() - this.helperProportions.width - this.margins.left,
				( $( document ).height() || document.body.parentNode.scrollHeight ) - this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment.constructor === Array ) {
			this.containment = o.containment;
			return;
		}

		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}

		c = $( o.containment );
		ce = c[ 0 ];

		if ( !ce ) {
			return;
		}

		over = c.css( "overflow" ) !== "hidden";

		this.containment = [
			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) + ( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),
			( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) - ( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) - this.helperProportions.width - this.margins.left - this.margins.right,
			( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) - ( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) - ( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) - this.helperProportions.height - this.margins.top  - this.margins.bottom
		];
		this.relative_container = c;
	},

	_convertPositionTo: function(d, pos) {

		if (!pos) {
			pos = this.position;
		}

		var mod = d === "absolute" ? 1 : -1,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod)
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod)
			)
		};

	},

	_generatePosition: function( event, constrainPosition ) {

		var containment, co, top, left,
			o = this.options,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
			pageX = event.pageX,
			pageY = event.pageY;

		// Cache the scroll
		if ( !scrollIsRootNode || !this.offset.scroll ) {
			this.offset.scroll = {
				top: this.scrollParent.scrollTop(),
				left: this.scrollParent.scrollLeft()
			};
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		// If we are not dragging yet, we won't check for options
		if ( constrainPosition ) {
			if ( this.containment ) {
				if ( this.relative_container ){
					co = this.relative_container.offset();
					containment = [
						this.containment[ 0 ] + co.left,
						this.containment[ 1 ] + co.top,
						this.containment[ 2 ] + co.left,
						this.containment[ 3 ] + co.top
					];
				} else {
					containment = this.containment;
				}

				if (event.pageX - this.offset.click.left < containment[0]) {
					pageX = containment[0] + this.offset.click.left;
				}
				if (event.pageY - this.offset.click.top < containment[1]) {
					pageY = containment[1] + this.offset.click.top;
				}
				if (event.pageX - this.offset.click.left > containment[2]) {
					pageX = containment[2] + this.offset.click.left;
				}
				if (event.pageY - this.offset.click.top > containment[3]) {
					pageY = containment[3] + this.offset.click.top;
				}
			}

			if (o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

			if ( o.axis === "y" ) {
				pageX = this.originalPageX;
			}

			if ( o.axis === "x" ) {
				pageY = this.originalPageY;
			}
		}

		return {
			top: (
				pageY -																	// The absolute mouse position
				this.offset.click.top	-												// Click offset (relative to the element)
				this.offset.relative.top -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.offset.scroll.top : ( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
			),
			left: (
				pageX -																	// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left -												// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
				( this.cssPosition === "fixed" ? -this.offset.scroll.left : ( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
		if ( this.destroyOnClear ) {
			this.destroy();
		}
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call( this, type, [ event, ui, this ], true );
		//The absolute position has to be recalculated after plugins
		if (type === "drag") {
			this.positionAbs = this._convertPositionTo("absolute");
		}
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.ui.plugin.add("draggable", "connectToSortable", {
	start: function( event, ui, inst ) {

		var o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $( this ).sortable( "instance" );
			if (sortable && !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger("activate", event, uiSortable);
			}
		});

	},
	stop: function( event, ui, inst ) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var uiSortable = $.extend( {}, ui, {
			item: inst.element
		});

		$.each(inst.sortables, function() {
			if (this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
				if (this.shouldRevert) {
					this.instance.options.revert = this.shouldRevert;
				}

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if (inst.options.helper === "original") {
					this.instance.currentItem.css({ top: "auto", left: "auto" });
				}

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger("deactivate", event, uiSortable);
			}

		});

	},
	drag: function( event, ui, inst ) {

		var that = this;

		$.each(inst.sortables, function() {

			var innermostIntersecting = false,
				thisSortable = this;

			//Copy over some variables to allow calling the sortable's native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;

			if (this.instance._intersectsWith(this.instance.containerCache)) {
				innermostIntersecting = true;
				$.each(inst.sortables, function() {
					this.instance.positionAbs = inst.positionAbs;
					this.instance.helperProportions = inst.helperProportions;
					this.instance.offset.click = inst.offset.click;
					if (this !== thisSortable &&
						this.instance._intersectsWith(this.instance.containerCache) &&
						$.contains(thisSortable.instance.element[0], this.instance.element[0])
					) {
						innermostIntersecting = false;
					}
					return innermostIntersecting;
				});
			}

			if (innermostIntersecting) {
				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if (!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
					this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger("toSortable", event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if (this.instance.currentItem) {
					this.instance._mouseDrag(event);
				}

			} else {

				//If it doesn't intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
				if (this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;

					//Prevent reverting on this forced stop
					this.instance.options.revert = false;

					// The out event needs to be triggered independently
					this.instance._trigger("out", event, this.instance._uiHash(this.instance));

					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
					this.instance.currentItem.remove();
					if (this.instance.placeholder) {
						this.instance.placeholder.remove();
					}

					inst._trigger("fromSortable", event);
					inst.dropped = false; //draggable revert needs that
				}

			}

		});

	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function( event, ui, instance ) {
		var t = $( "body" ),
			o = instance.options;

		if (t.css("cursor")) {
			o._cursor = t.css("cursor");
		}
		t.css("cursor", o.cursor);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if (o._cursor) {
			$("body").css("cursor", o._cursor);
		}
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;
		if (t.css("opacity")) {
			o._opacity = t.css("opacity");
		}
		t.css("opacity", o.opacity);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if (o._opacity) {
			$(ui.helper).css("opacity", o._opacity);
		}
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function( event, ui, i ) {
		if ( i.scrollParent[ 0 ] !== i.document[ 0 ] && i.scrollParent[ 0 ].tagName !== "HTML" ) {
			i.overflowOffset = i.scrollParent.offset();
		}
	},
	drag: function( event, ui, i  ) {

		var o = i.options,
			scrolled = false,
			document = i.document[ 0 ];

		if ( i.scrollParent[ 0 ] !== document && i.scrollParent[ 0 ].tagName !== "HTML" ) {
			if (!o.axis || o.axis !== "x") {
				if ((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				} else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
				}
			}

			if (!o.axis || o.axis !== "y") {
				if ((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				} else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if (!o.axis || o.axis !== "x") {
				if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				} else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
				}
			}

			if (!o.axis || o.axis !== "y") {
				if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				} else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}
			}

		}

		if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(i, event);
		}

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function( event, ui, i ) {

		var o = i.options;

		i.snapElements = [];

		$(o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap).each(function() {
			var $t = $(this),
				$o = $t.offset();
			if (this !== i.element[0]) {
				i.snapElements.push({
					item: this,
					width: $t.outerWidth(), height: $t.outerHeight(),
					top: $o.top, left: $o.left
				});
			}
		});

	},
	drag: function( event, ui, inst ) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (i = inst.snapElements.length - 1; i >= 0; i--){

			l = inst.snapElements[i].left;
			r = l + inst.snapElements[i].width;
			t = inst.snapElements[i].top;
			b = t + inst.snapElements[i].height;

			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains( inst.snapElements[ i ].item.ownerDocument, inst.snapElements[ i ].item ) ) {
				if (inst.snapElements[i].snapping) {
					(inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				}
				inst.snapElements[i].snapping = false;
				continue;
			}

			if (o.snapMode !== "inner") {
				ts = Math.abs(t - y2) <= d;
				bs = Math.abs(b - y1) <= d;
				ls = Math.abs(l - x2) <= d;
				rs = Math.abs(r - x1) <= d;
				if (ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if (bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
				}
				if (ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				}
				if (rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
				}
			}

			first = (ts || bs || ls || rs);

			if (o.snapMode !== "outer") {
				ts = Math.abs(t - y1) <= d;
				bs = Math.abs(b - y2) <= d;
				ls = Math.abs(l - x1) <= d;
				rs = Math.abs(r - x2) <= d;
				if (ts) {
					ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
				}
				if (bs) {
					ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				}
				if (ls) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
				}
				if (rs) {
					ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
				}
			}

			if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			}
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		}

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function( event, ui, instance ) {
		var min,
			o = instance.options,
			group = $.makeArray($(o.stack)).sort(function(a,b) {
				return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
			});

		if (!group.length) { return; }

		min = parseInt($(group[0]).css("zIndex"), 10) || 0;
		$(group).each(function(i) {
			$(this).css("zIndex", min + i);
		});
		this.css("zIndex", (min + group.length));
	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;

		if (t.css("zIndex")) {
			o._zIndex = t.css("zIndex");
		}
		t.css("zIndex", o.zIndex);
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;

		if (o._zIndex) {
			$(ui.helper).css("zIndex", o._zIndex);
		}
	}
});

var draggable = $.ui.draggable;


/*!
 * jQuery UI Resizable 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/resizable/
 */


$.widget("ui.resizable", $.ui.mouse, {
	version: "1.11.0",
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		// See #7960
		zIndex: 90,

		// callbacks
		resize: null,
		start: null,
		stop: null
	},

	_num: function( value ) {
		return parseInt( value, 10 ) || 0;
	},

	_isNumber: function( value ) {
		return !isNaN( parseInt( value , 10 ) );
	},

	_hasScroll: function( el, a ) {

		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	},

	_create: function() {

		var n, i, handle, axis, hname,
			that = this,
			o = this.options;
		this.element.addClass("ui-resizable");

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
		});

		// Wrap the element if it cannot hold child nodes
		if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

			this.element.wrap(
				$("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
					position: this.element.css("position"),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css("top"),
					left: this.element.css("left")
				})
			);

			this.element = this.element.parent().data(
				"ui-resizable", this.element.resizable( "instance" )
			);

			this.elementIsWrapper = true;

			this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
			this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});
			// support: Safari
			// Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css("resize");
			this.originalElement.css("resize", "none");

			this._proportionallyResizeElements.push(this.originalElement.css({ position: "static", zoom: 1, display: "block" }));

			// support: IE9
			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css("margin") });

			this._proportionallyResize();
		}

		this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : { n: ".ui-resizable-n", e: ".ui-resizable-e", s: ".ui-resizable-s", w: ".ui-resizable-w", se: ".ui-resizable-se", sw: ".ui-resizable-sw", ne: ".ui-resizable-ne", nw: ".ui-resizable-nw" });
		if(this.handles.constructor === String) {

			if ( this.handles === "all") {
				this.handles = "n,e,s,w,se,sw,ne,nw";
			}

			n = this.handles.split(",");
			this.handles = {};

			for(i = 0; i < n.length; i++) {

				handle = $.trim(n[i]);
				hname = "ui-resizable-"+handle;
				axis = $("<div class='ui-resizable-handle " + hname + "'></div>");

				axis.css({ zIndex: o.zIndex });

				// TODO : What's going on here?
				if ("se" === handle) {
					axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
				}

				this.handles[handle] = ".ui-resizable-"+handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			var i, axis, padPos, padWrapper;

			target = target || this.element;

			for(i in this.handles) {

				if(this.handles[i].constructor === String) {
					this.handles[i] = this.element.children( this.handles[ i ] ).first().show();
				}

				if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

					axis = $(this.handles[i], this.element);

					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					padPos = [ "padding",
						/ne|nw|n/.test(i) ? "Top" :
						/se|sw|s/.test(i) ? "Bottom" :
						/^e$/.test(i) ? "Right" : "Left" ].join("");

					target.css(padPos, padWrapper);

					this._proportionallyResize();

				}

				// TODO: What's that good for? There's not anything to be executed left
				if(!$(this.handles[i]).length) {
					continue;
				}
			}
		};

		// TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = $(".ui-resizable-handle", this.element)
			.disableSelection();

		this._handles.mouseover(function() {
			if (!that.resizing) {
				if (this.className) {
					axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				}
				that.axis = axis && axis[1] ? axis[1] : "se";
			}
		});

		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass("ui-resizable-autohide")
				.mouseenter(function() {
					if (o.disabled) {
						return;
					}
					$(this).removeClass("ui-resizable-autohide");
					that._handles.show();
				})
				.mouseleave(function(){
					if (o.disabled) {
						return;
					}
					if (!that.resizing) {
						$(this).addClass("ui-resizable-autohide");
						that._handles.hide();
					}
				});
		}

		this._mouseInit();

	},

	_destroy: function() {

		this._mouseDestroy();

		var wrapper,
			_destroy = function(exp) {
				$(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
					.removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
			};

		// TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			wrapper = this.element;
			this.originalElement.css({
				position: wrapper.css("position"),
				width: wrapper.outerWidth(),
				height: wrapper.outerHeight(),
				top: wrapper.css("top"),
				left: wrapper.css("left")
			}).insertAfter( wrapper );
			wrapper.remove();
		}

		this.originalElement.css("resize", this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var i, handle,
			capture = false;

		for (i in this.handles) {
			handle = $(this.handles[i])[0];
			if (handle === event.target || $.contains(handle, event.target)) {
				capture = true;
			}
		}

		return !this.options.disabled && capture;
	},

	_mouseStart: function(event) {

		var curleft, curtop, cursor,
			o = this.options,
			el = this.element;

		this.resizing = true;

		this._renderProxy();

		curleft = this._num(this.helper.css("left"));
		curtop = this._num(this.helper.css("top"));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };
		this.size = this._helper ? { width: this.helper.width(), height: this.helper.height() } : { width: el.width(), height: el.height() };
		this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalPosition = { left: curleft, top: curtop };
		this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		this.aspectRatio = (typeof o.aspectRatio === "number") ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

		cursor = $(".ui-resizable-" + this.axis).css("cursor");
		$("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);

		el.addClass("ui-resizable-resizing");
		this._propagate("start", event);
		return true;
	},

	_mouseDrag: function(event) {

		var data,
			el = this.helper, props = {},
			smp = this.originalMousePosition,
			a = this.axis,
			dx = (event.pageX-smp.left)||0,
			dy = (event.pageY-smp.top)||0,
			trigger = this._change[a];

		this.prevPosition = {
			top: this.position.top,
			left: this.position.left
		};
		this.prevSize = {
			width: this.size.width,
			height: this.size.height
		};

		if (!trigger) {
			return false;
		}

		data = trigger.apply(this, [event, dx, dy]);

		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey) {
			data = this._updateRatio(data, event);
		}

		data = this._respectSize(data, event);

		this._updateCache(data);

		this._propagate("resize", event);

		if ( this.position.top !== this.prevPosition.top ) {
			props.top = this.position.top + "px";
		}
		if ( this.position.left !== this.prevPosition.left ) {
			props.left = this.position.left + "px";
		}
		if ( this.size.width !== this.prevSize.width ) {
			props.width = this.size.width + "px";
		}
		if ( this.size.height !== this.prevSize.height ) {
			props.height = this.size.height + "px";
		}
		el.css( props );

		if ( !this._helper && this._proportionallyResizeElements.length ) {
			this._proportionallyResize();
		}

		if ( !$.isEmptyObject( props ) ) {
			this._trigger( "resize", event, this.ui() );
		}

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var pr, ista, soffseth, soffsetw, s, left, top,
			o = this.options, that = this;

		if(this._helper) {

			pr = this._proportionallyResizeElements;
			ista = pr.length && (/textarea/i).test(pr[0].nodeName);
			soffseth = ista && this._hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height;
			soffsetw = ista ? 0 : that.sizeDiff.width;

			s = { width: (that.helper.width()  - soffsetw), height: (that.helper.height() - soffseth) };
			left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null;
			top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

			if (!o.animate) {
				this.element.css($.extend(s, { top: top, left: left }));
			}

			that.helper.height(that.size.height);
			that.helper.width(that.size.width);

			if (this._helper && !o.animate) {
				this._proportionallyResize();
			}
		}

		$("body").css("cursor", "auto");

		this.element.removeClass("ui-resizable-resizing");

		this._propagate("stop", event);

		if (this._helper) {
			this.helper.remove();
		}

		return false;

	},

	_updateVirtualBoundaries: function(forceAspectRatio) {
		var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
			o = this.options;

		b = {
			minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
			maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
			minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
			maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
		};

		if(this._aspectRatio || forceAspectRatio) {
			pMinWidth = b.minHeight * this.aspectRatio;
			pMinHeight = b.minWidth / this.aspectRatio;
			pMaxWidth = b.maxHeight * this.aspectRatio;
			pMaxHeight = b.maxWidth / this.aspectRatio;

			if(pMinWidth > b.minWidth) {
				b.minWidth = pMinWidth;
			}
			if(pMinHeight > b.minHeight) {
				b.minHeight = pMinHeight;
			}
			if(pMaxWidth < b.maxWidth) {
				b.maxWidth = pMaxWidth;
			}
			if(pMaxHeight < b.maxHeight) {
				b.maxHeight = pMaxHeight;
			}
		}
		this._vBoundaries = b;
	},

	_updateCache: function(data) {
		this.offset = this.helper.offset();
		if (this._isNumber(data.left)) {
			this.position.left = data.left;
		}
		if (this._isNumber(data.top)) {
			this.position.top = data.top;
		}
		if (this._isNumber(data.height)) {
			this.size.height = data.height;
		}
		if (this._isNumber(data.width)) {
			this.size.width = data.width;
		}
	},

	_updateRatio: function( data ) {

		var cpos = this.position,
			csize = this.size,
			a = this.axis;

		if (this._isNumber(data.height)) {
			data.width = (data.height * this.aspectRatio);
		} else if (this._isNumber(data.width)) {
			data.height = (data.width / this.aspectRatio);
		}

		if (a === "sw") {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a === "nw") {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function( data ) {

		var o = this._vBoundaries,
			a = this.axis,
			ismaxw = this._isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = this._isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
			isminw = this._isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = this._isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
			dw = this.originalPosition.left + this.originalSize.width,
			dh = this.position.top + this.size.height,
			cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
		if (isminw) {
			data.width = o.minWidth;
		}
		if (isminh) {
			data.height = o.minHeight;
		}
		if (ismaxw) {
			data.width = o.maxWidth;
		}
		if (ismaxh) {
			data.height = o.maxHeight;
		}

		if (isminw && cw) {
			data.left = dw - o.minWidth;
		}
		if (ismaxw && cw) {
			data.left = dw - o.maxWidth;
		}
		if (isminh && ch) {
			data.top = dh - o.minHeight;
		}
		if (ismaxh && ch) {
			data.top = dh - o.maxHeight;
		}

		// Fixing jump error on top/left - bug #2330
		if (!data.width && !data.height && !data.left && data.top) {
			data.top = null;
		} else if (!data.width && !data.height && !data.top && data.left) {
			data.left = null;
		}

		return data;
	},

	_proportionallyResize: function() {

		if (!this._proportionallyResizeElements.length) {
			return;
		}

		var i, j, borders, paddings, prel,
			element = this.helper || this.element;

		for ( i=0; i < this._proportionallyResizeElements.length; i++) {

			prel = this._proportionallyResizeElements[i];

			if (!this.borderDif) {
				this.borderDif = [];
				borders = [prel.css("borderTopWidth"), prel.css("borderRightWidth"), prel.css("borderBottomWidth"), prel.css("borderLeftWidth")];
				paddings = [prel.css("paddingTop"), prel.css("paddingRight"), prel.css("paddingBottom"), prel.css("paddingLeft")];

				for ( j = 0; j < borders.length; j++ ) {
					this.borderDif[ j ] = ( parseInt( borders[ j ], 10 ) || 0 ) + ( parseInt( paddings[ j ], 10 ) || 0 );
				}
			}

			prel.css({
				height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
				width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
			});

		}

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if(this._helper) {

			this.helper = this.helper || $("<div style='overflow:hidden;'></div>");

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() - 1,
				height: this.element.outerHeight() - 1,
				position: "absolute",
				left: this.elementOffset.left +"px",
				top: this.elementOffset.top +"px",
				zIndex: ++o.zIndex //TODO: Don't modify option
			});

			this.helper
				.appendTo("body")
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [event, this.ui()]);
		(n !== "resize" && this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition,
			prevSize: this.prevSize,
			prevPosition: this.prevPosition
		};
	}

});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "animate", {

	stop: function( event ) {
		var that = $(this).resizable( "instance" ),
			o = that.options,
			pr = that._proportionallyResizeElements,
			ista = pr.length && (/textarea/i).test(pr[0].nodeName),
			soffseth = ista && that._hasScroll(pr[0], "left") /* TODO - jump height */ ? 0 : that.sizeDiff.height,
			soffsetw = ista ? 0 : that.sizeDiff.width,
			style = { width: (that.size.width - soffsetw), height: (that.size.height - soffseth) },
			left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null,
			top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;

		that.element.animate(
			$.extend(style, top && left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(that.element.css("width"), 10),
						height: parseInt(that.element.css("height"), 10),
						top: parseInt(that.element.css("top"), 10),
						left: parseInt(that.element.css("left"), 10)
					};

					if (pr && pr.length) {
						$(pr[0]).css({ width: data.width, height: data.height });
					}

					// propagating resize, and updating values for each animation step
					that._updateCache(data);
					that._propagate("resize", event);

				}
			}
		);
	}

});

$.ui.plugin.add( "resizable", "containment", {

	start: function() {
		var element, p, co, ch, cw, width, height,
			that = $( this ).resizable( "instance" ),
			o = that.options,
			el = that.element,
			oc = o.containment,
			ce = ( oc instanceof $ ) ? oc.get( 0 ) : ( /parent/.test( oc ) ) ? el.parent().get( 0 ) : oc;

		if ( !ce ) {
			return;
		}

		that.containerElement = $( ce );

		if ( /document/.test( oc ) || oc === document ) {
			that.containerOffset = {
				left: 0,
				top: 0
			};
			that.containerPosition = {
				left: 0,
				top: 0
			};

			that.parentData = {
				element: $( document ),
				left: 0,
				top: 0,
				width: $( document ).width(),
				height: $( document ).height() || document.body.parentNode.scrollHeight
			};
		} else {
			element = $( ce );
			p = [];
			$([ "Top", "Right", "Left", "Bottom" ]).each(function( i, name ) {
				p[ i ] = that._num( element.css( "padding" + name ) );
			});

			that.containerOffset = element.offset();
			that.containerPosition = element.position();
			that.containerSize = {
				height: ( element.innerHeight() - p[ 3 ] ),
				width: ( element.innerWidth() - p[ 1 ] )
			};

			co = that.containerOffset;
			ch = that.containerSize.height;
			cw = that.containerSize.width;
			width = ( that._hasScroll ( ce, "left" ) ? ce.scrollWidth : cw );
			height = ( that._hasScroll ( ce ) ? ce.scrollHeight : ch ) ;

			that.parentData = {
				element: ce,
				left: co.left,
				top: co.top,
				width: width,
				height: height
			};
		}
	},

	resize: function( event, ui ) {
		var woset, hoset, isParent, isOffsetRelative,
			that = $( this ).resizable( "instance" ),
			o = that.options,
			co = that.containerOffset,
			cp = that.position,
			pRatio = that._aspectRatio || event.shiftKey,
			cop = {
				top: 0,
				left: 0
			},
			ce = that.containerElement,
			continueResize = true;

		if ( ce[ 0 ] !== document && ( /static/ ).test( ce.css( "position" ) ) ) {
			cop = co;
		}

		if ( cp.left < ( that._helper ? co.left : 0 ) ) {
			that.size.width = that.size.width + ( that._helper ? ( that.position.left - co.left ) : ( that.position.left - cop.left ) );
			if ( pRatio ) {
				that.size.height = that.size.width / that.aspectRatio;
				continueResize = false;
			}
			that.position.left = o.helper ? co.left : 0;
		}

		if ( cp.top < ( that._helper ? co.top : 0 ) ) {
			that.size.height = that.size.height + ( that._helper ? ( that.position.top - co.top ) : that.position.top );
			if ( pRatio ) {
				that.size.width = that.size.height * that.aspectRatio;
				continueResize = false;
			}
			that.position.top = that._helper ? co.top : 0;
		}

		that.offset.left = that.parentData.left + that.position.left;
		that.offset.top = that.parentData.top + that.position.top;

		woset = Math.abs( ( that._helper ? that.offset.left - cop.left : ( that.offset.left - co.left ) ) + that.sizeDiff.width );
		hoset = Math.abs( ( that._helper ? that.offset.top - cop.top : ( that.offset.top - co.top ) ) + that.sizeDiff.height );

		isParent = that.containerElement.get( 0 ) === that.element.parent().get( 0 );
		isOffsetRelative = /relative|absolute/.test( that.containerElement.css( "position" ) );

		if ( isParent && isOffsetRelative ) {
			woset -= Math.abs( that.parentData.left );
		}

		if ( woset + that.size.width >= that.parentData.width ) {
			that.size.width = that.parentData.width - woset;
			if ( pRatio ) {
				that.size.height = that.size.width / that.aspectRatio;
				continueResize = false;
			}
		}

		if ( hoset + that.size.height >= that.parentData.height ) {
			that.size.height = that.parentData.height - hoset;
			if ( pRatio ) {
				that.size.width = that.size.height * that.aspectRatio;
				continueResize = false;
			}
		}

		if ( !continueResize ){
			that.position.left = ui.prevPosition.left;
			that.position.top = ui.prevPosition.top;
			that.size.width = ui.prevSize.width;
			that.size.height = ui.prevSize.height;
		}
	},

	stop: function(){
		var that = $( this ).resizable( "instance" ),
			o = that.options,
			co = that.containerOffset,
			cop = that.containerPosition,
			ce = that.containerElement,
			helper = $( that.helper ),
			ho = helper.offset(),
			w = helper.outerWidth() - that.sizeDiff.width,
			h = helper.outerHeight() - that.sizeDiff.height;

		if ( that._helper && !o.animate && ( /relative/ ).test( ce.css( "position" ) ) ) {
			$( this ).css({
				left: ho.left - cop.left - co.left,
				width: w,
				height: h
			});
		}

		if ( that._helper && !o.animate && ( /static/ ).test( ce.css( "position" ) ) ) {
			$( this ).css({
				left: ho.left - cop.left - co.left,
				width: w,
				height: h
			});
		}
	}
});

$.ui.plugin.add("resizable", "alsoResize", {

	start: function () {
		var that = $(this).resizable( "instance" ),
			o = that.options,
			_store = function (exp) {
				$(exp).each(function() {
					var el = $(this);
					el.data("ui-resizable-alsoresize", {
						width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
						left: parseInt(el.css("left"), 10), top: parseInt(el.css("top"), 10)
					});
				});
			};

		if (typeof(o.alsoResize) === "object" && !o.alsoResize.parentNode) {
			if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
			else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
		}else{
			_store(o.alsoResize);
		}
	},

	resize: function (event, ui) {
		var that = $(this).resizable( "instance" ),
			o = that.options,
			os = that.originalSize,
			op = that.originalPosition,
			delta = {
				height: (that.size.height - os.height) || 0, width: (that.size.width - os.width) || 0,
				top: (that.position.top - op.top) || 0, left: (that.position.left - op.left) || 0
			},

			_alsoResize = function (exp, c) {
				$(exp).each(function() {
					var el = $(this), start = $(this).data("ui-resizable-alsoresize"), style = {},
						css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];

					$.each(css, function (i, prop) {
						var sum = (start[prop]||0) + (delta[prop]||0);
						if (sum && sum >= 0) {
							style[prop] = sum || null;
						}
					});

					el.css(style);
				});
			};

		if (typeof(o.alsoResize) === "object" && !o.alsoResize.nodeType) {
			$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
		}else{
			_alsoResize(o.alsoResize);
		}
	},

	stop: function () {
		$(this).removeData("resizable-alsoresize");
	}
});

$.ui.plugin.add("resizable", "ghost", {

	start: function() {

		var that = $(this).resizable( "instance" ), o = that.options, cs = that.size;

		that.ghost = that.originalElement.clone();
		that.ghost
			.css({ opacity: 0.25, display: "block", position: "relative", height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
			.addClass("ui-resizable-ghost")
			.addClass(typeof o.ghost === "string" ? o.ghost : "");

		that.ghost.appendTo(that.helper);

	},

	resize: function(){
		var that = $(this).resizable( "instance" );
		if (that.ghost) {
			that.ghost.css({ position: "relative", height: that.size.height, width: that.size.width });
		}
	},

	stop: function() {
		var that = $(this).resizable( "instance" );
		if (that.ghost && that.helper) {
			that.helper.get(0).removeChild(that.ghost.get(0));
		}
	}

});

$.ui.plugin.add("resizable", "grid", {

	resize: function() {
		var that = $(this).resizable( "instance" ),
			o = that.options,
			cs = that.size,
			os = that.originalSize,
			op = that.originalPosition,
			a = that.axis,
			grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
			gridX = (grid[0]||1),
			gridY = (grid[1]||1),
			ox = Math.round((cs.width - os.width) / gridX) * gridX,
			oy = Math.round((cs.height - os.height) / gridY) * gridY,
			newWidth = os.width + ox,
			newHeight = os.height + oy,
			isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
			isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
			isMinWidth = o.minWidth && (o.minWidth > newWidth),
			isMinHeight = o.minHeight && (o.minHeight > newHeight);

		o.grid = grid;

		if (isMinWidth) {
			newWidth = newWidth + gridX;
		}
		if (isMinHeight) {
			newHeight = newHeight + gridY;
		}
		if (isMaxWidth) {
			newWidth = newWidth - gridX;
		}
		if (isMaxHeight) {
			newHeight = newHeight - gridY;
		}

		if (/^(se|s|e)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
		} else if (/^(ne)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.top = op.top - oy;
		} else if (/^(sw)$/.test(a)) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.left = op.left - ox;
		} else {
			if ( newHeight - gridY > 0 ) {
				that.size.height = newHeight;
				that.position.top = op.top - oy;
			} else {
				that.size.height = gridY;
				that.position.top = op.top + os.height - gridY;
			}
			if ( newWidth - gridX > 0 ) {
				that.size.width = newWidth;
				that.position.left = op.left - ox;
			} else {
				that.size.width = gridX;
				that.position.left = op.left + os.width - gridX;
			}
		}
	}

});

var resizable = $.ui.resizable;


/*!
 * jQuery UI Dialog 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/dialog/
 */


var dialog = $.widget( "ui.dialog", {
	version: "1.11.0",
	options: {
		appendTo: "body",
		autoOpen: true,
		buttons: [],
		closeOnEscape: true,
		closeText: "Close",
		dialogClass: "",
		draggable: true,
		hide: null,
		height: "auto",
		maxHeight: null,
		maxWidth: null,
		minHeight: 150,
		minWidth: 150,
		modal: false,
		position: {
			my: "center",
			at: "center",
			of: window,
			collision: "fit",
			// Ensure the titlebar is always visible
			using: function( pos ) {
				var topOffset = $( this ).css( pos ).offset().top;
				if ( topOffset < 0 ) {
					$( this ).css( "top", pos.top - topOffset );
				}
			}
		},
		resizable: true,
		show: null,
		title: null,
		width: 300,

		// callbacks
		beforeClose: null,
		close: null,
		drag: null,
		dragStart: null,
		dragStop: null,
		focus: null,
		open: null,
		resize: null,
		resizeStart: null,
		resizeStop: null
	},

	sizeRelatedOptions: {
		buttons: true,
		height: true,
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true,
		width: true
	},

	resizableRelatedOptions: {
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true
	},

	_create: function() {
		this.originalCss = {
			display: this.element[ 0 ].style.display,
			width: this.element[ 0 ].style.width,
			minHeight: this.element[ 0 ].style.minHeight,
			maxHeight: this.element[ 0 ].style.maxHeight,
			height: this.element[ 0 ].style.height
		};
		this.originalPosition = {
			parent: this.element.parent(),
			index: this.element.parent().children().index( this.element )
		};
		this.originalTitle = this.element.attr( "title" );
		this.options.title = this.options.title || this.originalTitle;

		this._createWrapper();

		this.element
			.show()
			.removeAttr( "title" )
			.addClass( "ui-dialog-content ui-widget-content" )
			.appendTo( this.uiDialog );

		this._createTitlebar();
		this._createButtonPane();

		if ( this.options.draggable && $.fn.draggable ) {
			this._makeDraggable();
		}
		if ( this.options.resizable && $.fn.resizable ) {
			this._makeResizable();
		}

		this._isOpen = false;

		this._trackFocus();
	},

	_init: function() {
		if ( this.options.autoOpen ) {
			this.open();
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;
		if ( element && (element.jquery || element.nodeType) ) {
			return $( element );
		}
		return this.document.find( element || "body" ).eq( 0 );
	},

	_destroy: function() {
		var next,
			originalPosition = this.originalPosition;

		this._destroyOverlay();

		this.element
			.removeUniqueId()
			.removeClass( "ui-dialog-content ui-widget-content" )
			.css( this.originalCss )
			// Without detaching first, the following becomes really slow
			.detach();

		this.uiDialog.stop( true, true ).remove();

		if ( this.originalTitle ) {
			this.element.attr( "title", this.originalTitle );
		}

		next = originalPosition.parent.children().eq( originalPosition.index );
		// Don't try to place the dialog next to itself (#8613)
		if ( next.length && next[ 0 ] !== this.element[ 0 ] ) {
			next.before( this.element );
		} else {
			originalPosition.parent.append( this.element );
		}
	},

	widget: function() {
		return this.uiDialog;
	},

	disable: $.noop,
	enable: $.noop,

	close: function( event ) {
		var activeElement,
			that = this;

		if ( !this._isOpen || this._trigger( "beforeClose", event ) === false ) {
			return;
		}

		this._isOpen = false;
		this._focusedElement = null;
		this._destroyOverlay();
		this._untrackInstance();

		if ( !this.opener.filter( ":focusable" ).focus().length ) {

			// support: IE9
			// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
			try {
				activeElement = this.document[ 0 ].activeElement;

				// Support: IE9, IE10
				// If the <body> is blurred, IE will switch windows, see #4520
				if ( activeElement && activeElement.nodeName.toLowerCase() !== "body" ) {

					// Hiding a focused element doesn't trigger blur in WebKit
					// so in case we have nothing to focus on, explicitly blur the active element
					// https://bugs.webkit.org/show_bug.cgi?id=47182
					$( activeElement ).blur();
				}
			} catch ( error ) {}
		}

		this._hide( this.uiDialog, this.options.hide, function() {
			that._trigger( "close", event );
		});
	},

	isOpen: function() {
		return this._isOpen;
	},

	moveToTop: function() {
		this._moveToTop();
	},

	_moveToTop: function( event, silent ) {
		var moved = false,
			zIndicies = this.uiDialog.siblings( ".ui-front:visible" ).map(function() {
				return +$( this ).css( "z-index" );
			}).get(),
			zIndexMax = Math.max.apply( null, zIndicies );

		if ( zIndexMax >= +this.uiDialog.css( "z-index" ) ) {
			this.uiDialog.css( "z-index", zIndexMax + 1 );
			moved = true;
		}

		if ( moved && !silent ) {
			this._trigger( "focus", event );
		}
		return moved;
	},

	open: function() {
		var that = this;
		if ( this._isOpen ) {
			if ( this._moveToTop() ) {
				this._focusTabbable();
			}
			return;
		}

		this._isOpen = true;
		this.opener = $( this.document[ 0 ].activeElement );

		this._size();
		this._position();
		this._createOverlay();
		this._moveToTop( null, true );
		this._show( this.uiDialog, this.options.show, function() {
			that._focusTabbable();
			that._trigger( "focus" );
		});

		this._trigger( "open" );
	},

	_focusTabbable: function() {
		// Set focus to the first match:
		// 1. An element that was focused previously
		// 2. First element inside the dialog matching [autofocus]
		// 3. Tabbable element inside the content element
		// 4. Tabbable element inside the buttonpane
		// 5. The close button
		// 6. The dialog itself
		var hasFocus = this._focusedElement;
		if ( !hasFocus ) {
			hasFocus = this.element.find( "[autofocus]" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.element.find( ":tabbable" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogButtonPane.find( ":tabbable" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogTitlebarClose.filter( ":tabbable" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialog;
		}
		hasFocus.eq( 0 ).focus();
	},

	_keepFocus: function( event ) {
		function checkFocus() {
			var activeElement = this.document[0].activeElement,
				isActive = this.uiDialog[0] === activeElement ||
					$.contains( this.uiDialog[0], activeElement );
			if ( !isActive ) {
				this._focusTabbable();
			}
		}
		event.preventDefault();
		checkFocus.call( this );
		// support: IE
		// IE <= 8 doesn't prevent moving focus even with event.preventDefault()
		// so we check again later
		this._delay( checkFocus );
	},

	_createWrapper: function() {
		this.uiDialog = $("<div>")
			.addClass( "ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " +
				this.options.dialogClass )
			.hide()
			.attr({
				// Setting tabIndex makes the div focusable
				tabIndex: -1,
				role: "dialog"
			})
			.appendTo( this._appendTo() );

		this._on( this.uiDialog, {
			keydown: function( event ) {
				if ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
						event.keyCode === $.ui.keyCode.ESCAPE ) {
					event.preventDefault();
					this.close( event );
					return;
				}

				// prevent tabbing out of dialogs
				if ( event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented() ) {
					return;
				}
				var tabbables = this.uiDialog.find( ":tabbable" ),
					first = tabbables.filter( ":first" ),
					last = tabbables.filter( ":last" );

				if ( ( event.target === last[0] || event.target === this.uiDialog[0] ) && !event.shiftKey ) {
					this._delay(function() {
						first.focus();
					});
					event.preventDefault();
				} else if ( ( event.target === first[0] || event.target === this.uiDialog[0] ) && event.shiftKey ) {
					this._delay(function() {
						last.focus();
					});
					event.preventDefault();
				}
			},
			mousedown: function( event ) {
				if ( this._moveToTop( event ) ) {
					this._focusTabbable();
				}
			}
		});

		// We assume that any existing aria-describedby attribute means
		// that the dialog content is marked up properly
		// otherwise we brute force the content as the description
		if ( !this.element.find( "[aria-describedby]" ).length ) {
			this.uiDialog.attr({
				"aria-describedby": this.element.uniqueId().attr( "id" )
			});
		}
	},

	_createTitlebar: function() {
		var uiDialogTitle;

		this.uiDialogTitlebar = $( "<div>" )
			.addClass( "ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix" )
			.prependTo( this.uiDialog );
		this._on( this.uiDialogTitlebar, {
			mousedown: function( event ) {
				// Don't prevent click on close button (#8838)
				// Focusing a dialog that is partially scrolled out of view
				// causes the browser to scroll it into view, preventing the click event
				if ( !$( event.target ).closest( ".ui-dialog-titlebar-close" ) ) {
					// Dialog isn't getting focus when dragging (#8063)
					this.uiDialog.focus();
				}
			}
		});

		// support: IE
		// Use type="button" to prevent enter keypresses in textboxes from closing the
		// dialog in IE (#9312)
		this.uiDialogTitlebarClose = $( "<button type='button'></button>" )
			.button({
				label: this.options.closeText,
				icons: {
					primary: "ui-icon-closethick"
				},
				text: false
			})
			.addClass( "ui-dialog-titlebar-close" )
			.appendTo( this.uiDialogTitlebar );
		this._on( this.uiDialogTitlebarClose, {
			click: function( event ) {
				event.preventDefault();
				this.close( event );
			}
		});

		uiDialogTitle = $( "<span>" )
			.uniqueId()
			.addClass( "ui-dialog-title" )
			.prependTo( this.uiDialogTitlebar );
		this._title( uiDialogTitle );

		this.uiDialog.attr({
			"aria-labelledby": uiDialogTitle.attr( "id" )
		});
	},

	_title: function( title ) {
		if ( !this.options.title ) {
			title.html( "&#160;" );
		}
		title.text( this.options.title );
	},

	_createButtonPane: function() {
		this.uiDialogButtonPane = $( "<div>" )
			.addClass( "ui-dialog-buttonpane ui-widget-content ui-helper-clearfix" );

		this.uiButtonSet = $( "<div>" )
			.addClass( "ui-dialog-buttonset" )
			.appendTo( this.uiDialogButtonPane );

		this._createButtons();
	},

	_createButtons: function() {
		var that = this,
			buttons = this.options.buttons;

		// if we already have a button pane, remove it
		this.uiDialogButtonPane.remove();
		this.uiButtonSet.empty();

		if ( $.isEmptyObject( buttons ) || ($.isArray( buttons ) && !buttons.length) ) {
			this.uiDialog.removeClass( "ui-dialog-buttons" );
			return;
		}

		$.each( buttons, function( name, props ) {
			var click, buttonOptions;
			props = $.isFunction( props ) ?
				{ click: props, text: name } :
				props;
			// Default to a non-submitting button
			props = $.extend( { type: "button" }, props );
			// Change the context for the click callback to be the main element
			click = props.click;
			props.click = function() {
				click.apply( that.element[ 0 ], arguments );
			};
			buttonOptions = {
				icons: props.icons,
				text: props.showText
			};
			delete props.icons;
			delete props.showText;
			$( "<button></button>", props )
				.button( buttonOptions )
				.appendTo( that.uiButtonSet );
		});
		this.uiDialog.addClass( "ui-dialog-buttons" );
		this.uiDialogButtonPane.appendTo( this.uiDialog );
	},

	_makeDraggable: function() {
		var that = this,
			options = this.options;

		function filteredUi( ui ) {
			return {
				position: ui.position,
				offset: ui.offset
			};
		}

		this.uiDialog.draggable({
			cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
			handle: ".ui-dialog-titlebar",
			containment: "document",
			start: function( event, ui ) {
				$( this ).addClass( "ui-dialog-dragging" );
				that._blockFrames();
				that._trigger( "dragStart", event, filteredUi( ui ) );
			},
			drag: function( event, ui ) {
				that._trigger( "drag", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				var left = ui.offset.left - that.document.scrollLeft(),
					top = ui.offset.top - that.document.scrollTop();

				options.position = {
					my: "left top",
					at: "left" + (left >= 0 ? "+" : "") + left + " " +
						"top" + (top >= 0 ? "+" : "") + top,
					of: that.window
				};
				$( this ).removeClass( "ui-dialog-dragging" );
				that._unblockFrames();
				that._trigger( "dragStop", event, filteredUi( ui ) );
			}
		});
	},

	_makeResizable: function() {
		var that = this,
			options = this.options,
			handles = options.resizable,
			// .ui-resizable has position: relative defined in the stylesheet
			// but dialogs have to use absolute or fixed positioning
			position = this.uiDialog.css("position"),
			resizeHandles = typeof handles === "string" ?
				handles	:
				"n,e,s,w,se,sw,ne,nw";

		function filteredUi( ui ) {
			return {
				originalPosition: ui.originalPosition,
				originalSize: ui.originalSize,
				position: ui.position,
				size: ui.size
			};
		}

		this.uiDialog.resizable({
			cancel: ".ui-dialog-content",
			containment: "document",
			alsoResize: this.element,
			maxWidth: options.maxWidth,
			maxHeight: options.maxHeight,
			minWidth: options.minWidth,
			minHeight: this._minHeight(),
			handles: resizeHandles,
			start: function( event, ui ) {
				$( this ).addClass( "ui-dialog-resizing" );
				that._blockFrames();
				that._trigger( "resizeStart", event, filteredUi( ui ) );
			},
			resize: function( event, ui ) {
				that._trigger( "resize", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				var offset = that.uiDialog.offset(),
					left = offset.left - that.document.scrollLeft(),
					top = offset.top - that.document.scrollTop();

				options.height = that.uiDialog.height();
				options.width = that.uiDialog.width();
				options.position = {
					my: "left top",
					at: "left" + (left >= 0 ? "+" : "") + left + " " +
						"top" + (top >= 0 ? "+" : "") + top,
					of: that.window
				};
				$( this ).removeClass( "ui-dialog-resizing" );
				that._unblockFrames();
				that._trigger( "resizeStop", event, filteredUi( ui ) );
			}
		})
		.css( "position", position );
	},

	_trackFocus: function() {
		this._on( this.widget(), {
			"focusin": function( event ) {
				this._untrackInstance();
				this._trackingInstances().unshift( this );
				this._focusedElement = $( event.target );
			}
		});
	},

	_untrackInstance: function() {
		var instances = this._trackingInstances(),
			exists = $.inArray( this, instances );
		if ( exists !== -1 ) {
			instances.splice( exists, 1 );
		}
	},

	_trackingInstances: function() {
		var instances = this.document.data( "ui-dialog-instances" );
		if ( !instances ) {
			instances = [];
			this.document.data( "ui-dialog-instances", instances );
		}
		return instances;
	},

	_minHeight: function() {
		var options = this.options;

		return options.height === "auto" ?
			options.minHeight :
			Math.min( options.minHeight, options.height );
	},

	_position: function() {
		// Need to show the dialog to get the actual offset in the position plugin
		var isVisible = this.uiDialog.is( ":visible" );
		if ( !isVisible ) {
			this.uiDialog.show();
		}
		this.uiDialog.position( this.options.position );
		if ( !isVisible ) {
			this.uiDialog.hide();
		}
	},

	_setOptions: function( options ) {
		var that = this,
			resize = false,
			resizableOptions = {};

		$.each( options, function( key, value ) {
			that._setOption( key, value );

			if ( key in that.sizeRelatedOptions ) {
				resize = true;
			}
			if ( key in that.resizableRelatedOptions ) {
				resizableOptions[ key ] = value;
			}
		});

		if ( resize ) {
			this._size();
			this._position();
		}
		if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
			this.uiDialog.resizable( "option", resizableOptions );
		}
	},

	_setOption: function( key, value ) {
		var isDraggable, isResizable,
			uiDialog = this.uiDialog;

		if ( key === "dialogClass" ) {
			uiDialog
				.removeClass( this.options.dialogClass )
				.addClass( value );
		}

		if ( key === "disabled" ) {
			return;
		}

		this._super( key, value );

		if ( key === "appendTo" ) {
			this.uiDialog.appendTo( this._appendTo() );
		}

		if ( key === "buttons" ) {
			this._createButtons();
		}

		if ( key === "closeText" ) {
			this.uiDialogTitlebarClose.button({
				// Ensure that we always pass a string
				label: "" + value
			});
		}

		if ( key === "draggable" ) {
			isDraggable = uiDialog.is( ":data(ui-draggable)" );
			if ( isDraggable && !value ) {
				uiDialog.draggable( "destroy" );
			}

			if ( !isDraggable && value ) {
				this._makeDraggable();
			}
		}

		if ( key === "position" ) {
			this._position();
		}

		if ( key === "resizable" ) {
			// currently resizable, becoming non-resizable
			isResizable = uiDialog.is( ":data(ui-resizable)" );
			if ( isResizable && !value ) {
				uiDialog.resizable( "destroy" );
			}

			// currently resizable, changing handles
			if ( isResizable && typeof value === "string" ) {
				uiDialog.resizable( "option", "handles", value );
			}

			// currently non-resizable, becoming resizable
			if ( !isResizable && value !== false ) {
				this._makeResizable();
			}
		}

		if ( key === "title" ) {
			this._title( this.uiDialogTitlebar.find( ".ui-dialog-title" ) );
		}
	},

	_size: function() {
		// If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
		// divs will both have width and height set, so we need to reset them
		var nonContentHeight, minContentHeight, maxContentHeight,
			options = this.options;

		// Reset content sizing
		this.element.show().css({
			width: "auto",
			minHeight: 0,
			maxHeight: "none",
			height: 0
		});

		if ( options.minWidth > options.width ) {
			options.width = options.minWidth;
		}

		// reset wrapper sizing
		// determine the height of all the non-content elements
		nonContentHeight = this.uiDialog.css({
				height: "auto",
				width: options.width
			})
			.outerHeight();
		minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
		maxContentHeight = typeof options.maxHeight === "number" ?
			Math.max( 0, options.maxHeight - nonContentHeight ) :
			"none";

		if ( options.height === "auto" ) {
			this.element.css({
				minHeight: minContentHeight,
				maxHeight: maxContentHeight,
				height: "auto"
			});
		} else {
			this.element.height( Math.max( 0, options.height - nonContentHeight ) );
		}

		if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
			this.uiDialog.resizable( "option", "minHeight", this._minHeight() );
		}
	},

	_blockFrames: function() {
		this.iframeBlocks = this.document.find( "iframe" ).map(function() {
			var iframe = $( this );

			return $( "<div>" )
				.css({
					position: "absolute",
					width: iframe.outerWidth(),
					height: iframe.outerHeight()
				})
				.appendTo( iframe.parent() )
				.offset( iframe.offset() )[0];
		});
	},

	_unblockFrames: function() {
		if ( this.iframeBlocks ) {
			this.iframeBlocks.remove();
			delete this.iframeBlocks;
		}
	},

	_allowInteraction: function( event ) {
		if ( $( event.target ).closest( ".ui-dialog" ).length ) {
			return true;
		}

		// TODO: Remove hack when datepicker implements
		// the .ui-front logic (#8989)
		return !!$( event.target ).closest( ".ui-datepicker" ).length;
	},

	_createOverlay: function() {
		if ( !this.options.modal ) {
			return;
		}

		// We use a delay in case the overlay is created from an
		// event that we're going to be cancelling (#2804)
		var isOpening = true;
		this._delay(function() {
			isOpening = false;
		});

		if ( !this.document.data( "ui-dialog-overlays" ) ) {

			// Prevent use of anchors and inputs
			// Using _on() for an event handler shared across many instances is
			// safe because the dialogs stack and must be closed in reverse order
			this._on( this.document, {
				focusin: function( event ) {
					if ( isOpening ) {
						return;
					}

					if ( !this._allowInteraction( event ) ) {
						event.preventDefault();
						this._trackingInstances()[ 0 ]._focusTabbable();
					}
				}
			});
		}

		this.overlay = $( "<div>" )
			.addClass( "ui-widget-overlay ui-front" )
			.appendTo( this._appendTo() );
		this._on( this.overlay, {
			mousedown: "_keepFocus"
		});
		this.document.data( "ui-dialog-overlays",
			(this.document.data( "ui-dialog-overlays" ) || 0) + 1 );
	},

	_destroyOverlay: function() {
		if ( !this.options.modal ) {
			return;
		}

		if ( this.overlay ) {
			var overlays = this.document.data( "ui-dialog-overlays" ) - 1;

			if ( !overlays ) {
				this.document
					.unbind( "focusin" )
					.removeData( "ui-dialog-overlays" );
			} else {
				this.document.data( "ui-dialog-overlays", overlays );
			}

			this.overlay.remove();
			this.overlay = null;
		}
	}
});


/*!
 * jQuery UI Droppable 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/droppable/
 */


$.widget( "ui.droppable", {
	version: "1.11.0",
	widgetEventPrefix: "drop",
	options: {
		accept: "*",
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: "default",
		tolerance: "intersect",

		// callbacks
		activate: null,
		deactivate: null,
		drop: null,
		out: null,
		over: null
	},
	_create: function() {

		var proportions,
			o = this.options,
			accept = o.accept;

		this.isover = false;
		this.isout = true;

		this.accept = $.isFunction( accept ) ? accept : function( d ) {
			return d.is( accept );
		};

		this.proportions = function( /* valueToWrite */ ) {
			if ( arguments.length ) {
				// Store the droppable's proportions
				proportions = arguments[ 0 ];
			} else {
				// Retrieve or derive the droppable's proportions
				return proportions ?
					proportions :
					proportions = {
						width: this.element[ 0 ].offsetWidth,
						height: this.element[ 0 ].offsetHeight
					};
			}
		};

		this._addToManager( o.scope );

		o.addClasses && this.element.addClass( "ui-droppable" );

	},

	_addToManager: function( scope ) {
		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[ scope ] = $.ui.ddmanager.droppables[ scope ] || [];
		$.ui.ddmanager.droppables[ scope ].push( this );
	},

	_splice: function( drop ) {
		var i = 0;
		for ( ; i < drop.length; i++ ) {
			if ( drop[ i ] === this ) {
				drop.splice( i, 1 );
			}
		}
	},

	_destroy: function() {
		var drop = $.ui.ddmanager.droppables[ this.options.scope ];

		this._splice( drop );

		this.element.removeClass( "ui-droppable ui-droppable-disabled" );
	},

	_setOption: function( key, value ) {

		if ( key === "accept" ) {
			this.accept = $.isFunction( value ) ? value : function( d ) {
				return d.is( value );
			};
		} else if ( key === "scope" ) {
			var drop = $.ui.ddmanager.droppables[ this.options.scope ];

			this._splice( drop );
			this._addToManager( value );
		}

		this._super( key, value );
	},

	_activate: function( event ) {
		var draggable = $.ui.ddmanager.current;
		if ( this.options.activeClass ) {
			this.element.addClass( this.options.activeClass );
		}
		if ( draggable ){
			this._trigger( "activate", event, this.ui( draggable ) );
		}
	},

	_deactivate: function( event ) {
		var draggable = $.ui.ddmanager.current;
		if ( this.options.activeClass ) {
			this.element.removeClass( this.options.activeClass );
		}
		if ( draggable ){
			this._trigger( "deactivate", event, this.ui( draggable ) );
		}
	},

	_over: function( event ) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
			if ( this.options.hoverClass ) {
				this.element.addClass( this.options.hoverClass );
			}
			this._trigger( "over", event, this.ui( draggable ) );
		}

	},

	_out: function( event ) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
			if ( this.options.hoverClass ) {
				this.element.removeClass( this.options.hoverClass );
			}
			this._trigger( "out", event, this.ui( draggable ) );
		}

	},

	_drop: function( event, custom ) {

		var draggable = custom || $.ui.ddmanager.current,
			childrenIntersection = false;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem || draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return false;
		}

		this.element.find( ":data(ui-droppable)" ).not( ".ui-draggable-dragging" ).each(function() {
			var inst = $( this ).droppable( "instance" );
			if (
				inst.options.greedy &&
				!inst.options.disabled &&
				inst.options.scope === draggable.options.scope &&
				inst.accept.call( inst.element[ 0 ], ( draggable.currentItem || draggable.element ) ) &&
				$.ui.intersect( draggable, $.extend( inst, { offset: inst.element.offset() } ), inst.options.tolerance )
			) { childrenIntersection = true; return false; }
		});
		if ( childrenIntersection ) {
			return false;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
			if ( this.options.activeClass ) {
				this.element.removeClass( this.options.activeClass );
			}
			if ( this.options.hoverClass ) {
				this.element.removeClass( this.options.hoverClass );
			}
			this._trigger( "drop", event, this.ui( draggable ) );
			return this.element;
		}

		return false;

	},

	ui: function( c ) {
		return {
			draggable: ( c.currentItem || c.element ),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.ui.intersect = (function() {
	function isOverAxis( x, reference, size ) {
		return ( x >= reference ) && ( x < ( reference + size ) );
	}

	return function( draggable, droppable, toleranceMode ) {

		if ( !droppable.offset ) {
			return false;
		}

		var draggableLeft, draggableTop,
			x1 = ( draggable.positionAbs || draggable.position.absolute ).left,
			y1 = ( draggable.positionAbs || draggable.position.absolute ).top,
			x2 = x1 + draggable.helperProportions.width,
			y2 = y1 + draggable.helperProportions.height,
			l = droppable.offset.left,
			t = droppable.offset.top,
			r = l + droppable.proportions().width,
			b = t + droppable.proportions().height;

		switch ( toleranceMode ) {
		case "fit":
			return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );
		case "intersect":
			return ( l < x1 + ( draggable.helperProportions.width / 2 ) && // Right Half
				x2 - ( draggable.helperProportions.width / 2 ) < r && // Left Half
				t < y1 + ( draggable.helperProportions.height / 2 ) && // Bottom Half
				y2 - ( draggable.helperProportions.height / 2 ) < b ); // Top Half
		case "pointer":
			draggableLeft = ( ( draggable.positionAbs || draggable.position.absolute ).left + ( draggable.clickOffset || draggable.offset.click ).left );
			draggableTop = ( ( draggable.positionAbs || draggable.position.absolute ).top + ( draggable.clickOffset || draggable.offset.click ).top );
			return isOverAxis( draggableTop, t, droppable.proportions().height ) && isOverAxis( draggableLeft, l, droppable.proportions().width );
		case "touch":
			return (
				( y1 >= t && y1 <= b ) || // Top edge touching
				( y2 >= t && y2 <= b ) || // Bottom edge touching
				( y1 < t && y2 > b ) // Surrounded vertically
			) && (
				( x1 >= l && x1 <= r ) || // Left edge touching
				( x2 >= l && x2 <= r ) || // Right edge touching
				( x1 < l && x2 > r ) // Surrounded horizontally
			);
		default:
			return false;
		}
	};
})();

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { "default": [] },
	prepareOffsets: function( t, event ) {

		var i, j,
			m = $.ui.ddmanager.droppables[ t.options.scope ] || [],
			type = event ? event.type : null, // workaround for #2317
			list = ( t.currentItem || t.element ).find( ":data(ui-droppable)" ).addBack();

		droppablesLoop: for ( i = 0; i < m.length; i++ ) {

			// No disabled and non-accepted
			if ( m[ i ].options.disabled || ( t && !m[ i ].accept.call( m[ i ].element[ 0 ], ( t.currentItem || t.element ) ) ) ) {
				continue;
			}

			// Filter out elements in the current dragged item
			for ( j = 0; j < list.length; j++ ) {
				if ( list[ j ] === m[ i ].element[ 0 ] ) {
					m[ i ].proportions().height = 0;
					continue droppablesLoop;
				}
			}

			m[ i ].visible = m[ i ].element.css( "display" ) !== "none";
			if ( !m[ i ].visible ) {
				continue;
			}

			// Activate the droppable if used directly from draggables
			if ( type === "mousedown" ) {
				m[ i ]._activate.call( m[ i ], event );
			}

			m[ i ].offset = m[ i ].element.offset();
			m[ i ].proportions({ width: m[ i ].element[ 0 ].offsetWidth, height: m[ i ].element[ 0 ].offsetHeight });

		}

	},
	drop: function( draggable, event ) {

		var dropped = false;
		// Create a copy of the droppables in case the list changes during the drop (#9116)
		$.each( ( $.ui.ddmanager.droppables[ draggable.options.scope ] || [] ).slice(), function() {

			if ( !this.options ) {
				return;
			}
			if ( !this.options.disabled && this.visible && $.ui.intersect( draggable, this, this.options.tolerance ) ) {
				dropped = this._drop.call( this, event ) || dropped;
			}

			if ( !this.options.disabled && this.visible && this.accept.call( this.element[ 0 ], ( draggable.currentItem || draggable.element ) ) ) {
				this.isout = true;
				this.isover = false;
				this._deactivate.call( this, event );
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		// Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parentsUntil( "body" ).bind( "scroll.droppable", function() {
			if ( !draggable.options.refreshPositions ) {
				$.ui.ddmanager.prepareOffsets( draggable, event );
			}
		});
	},
	drag: function( draggable, event ) {

		// If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if ( draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}

		// Run through all droppables and check their positions based on specific tolerance options
		$.each( $.ui.ddmanager.droppables[ draggable.options.scope ] || [], function() {

			if ( this.options.disabled || this.greedyChild || !this.visible ) {
				return;
			}

			var parentInstance, scope, parent,
				intersects = $.ui.intersect( draggable, this, this.options.tolerance ),
				c = !intersects && this.isover ? "isout" : ( intersects && !this.isover ? "isover" : null );
			if ( !c ) {
				return;
			}

			if ( this.options.greedy ) {
				// find droppable parents with same scope
				scope = this.options.scope;
				parent = this.element.parents( ":data(ui-droppable)" ).filter(function() {
					return $( this ).droppable( "instance" ).options.scope === scope;
				});

				if ( parent.length ) {
					parentInstance = $( parent[ 0 ] ).droppable( "instance" );
					parentInstance.greedyChild = ( c === "isover" );
				}
			}

			// we just moved into a greedy child
			if ( parentInstance && c === "isover" ) {
				parentInstance.isover = false;
				parentInstance.isout = true;
				parentInstance._out.call( parentInstance, event );
			}

			this[ c ] = true;
			this[c === "isout" ? "isover" : "isout"] = false;
			this[c === "isover" ? "_over" : "_out"].call( this, event );

			// we just moved out of a greedy child
			if ( parentInstance && c === "isout" ) {
				parentInstance.isout = false;
				parentInstance.isover = true;
				parentInstance._over.call( parentInstance, event );
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parentsUntil( "body" ).unbind( "scroll.droppable" );
		// Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if ( !draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}
	}
};

var droppable = $.ui.droppable;


/*!
 * jQuery UI Effects 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/category/effects-core/
 */


var dataSpace = "ui-effects-";

$.effects = {
	effect: {}
};

/*!
 * jQuery Color Animations v2.1.2
 * https://github.com/jquery/jquery-color
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Wed Jan 16 08:47:09 2013 -0600
 */
(function( jQuery, undefined ) {

	var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

	// plusequals test for += 100 -= 100
	rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
	// a set of RE's that can match strings and generate color tuples.
	stringParsers = [ {
			re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ],
					execResult[ 3 ],
					execResult[ 4 ]
				];
			}
		}, {
			re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ] * 2.55,
					execResult[ 2 ] * 2.55,
					execResult[ 3 ] * 2.55,
					execResult[ 4 ]
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ], 16 )
				];
			}
		}, {
			// this regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
				];
			}
		}, {
			re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			space: "hsla",
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ] / 100,
					execResult[ 3 ] / 100,
					execResult[ 4 ]
				];
			}
		} ],

	// jQuery.Color( )
	color = jQuery.Color = function( color, green, blue, alpha ) {
		return new jQuery.Color.fn.parse( color, green, blue, alpha );
	},
	spaces = {
		rgba: {
			props: {
				red: {
					idx: 0,
					type: "byte"
				},
				green: {
					idx: 1,
					type: "byte"
				},
				blue: {
					idx: 2,
					type: "byte"
				}
			}
		},

		hsla: {
			props: {
				hue: {
					idx: 0,
					type: "degrees"
				},
				saturation: {
					idx: 1,
					type: "percent"
				},
				lightness: {
					idx: 2,
					type: "percent"
				}
			}
		}
	},
	propTypes = {
		"byte": {
			floor: true,
			max: 255
		},
		"percent": {
			max: 1
		},
		"degrees": {
			mod: 360,
			floor: true
		}
	},
	support = color.support = {},

	// element for support tests
	supportElem = jQuery( "<p>" )[ 0 ],

	// colors = jQuery.Color.names
	colors,

	// local aliases of functions called often
	each = jQuery.each;

// determine rgba support immediately
supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;

// define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
	space.cache = "_" + spaceName;
	space.props.alpha = {
		idx: 3,
		type: "percent",
		def: 1
	};
});

function clamp( value, prop, allowEmpty ) {
	var type = propTypes[ prop.type ] || {};

	if ( value == null ) {
		return (allowEmpty || !prop.def) ? null : prop.def;
	}

	// ~~ is an short way of doing floor for positive numbers
	value = type.floor ? ~~value : parseFloat( value );

	// IE will pass in empty strings as value for alpha,
	// which will hit this case
	if ( isNaN( value ) ) {
		return prop.def;
	}

	if ( type.mod ) {
		// we add mod before modding to make sure that negatives values
		// get converted properly: -10 -> 350
		return (value + type.mod) % type.mod;
	}

	// for now all property types without mod have min and max
	return 0 > value ? 0 : type.max < value ? type.max : value;
}

function stringParse( string ) {
	var inst = color(),
		rgba = inst._rgba = [];

	string = string.toLowerCase();

	each( stringParsers, function( i, parser ) {
		var parsed,
			match = parser.re.exec( string ),
			values = match && parser.parse( match ),
			spaceName = parser.space || "rgba";

		if ( values ) {
			parsed = inst[ spaceName ]( values );

			// if this was an rgba parse the assignment might happen twice
			// oh well....
			inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
			rgba = inst._rgba = parsed._rgba;

			// exit each( stringParsers ) here because we matched
			return false;
		}
	});

	// Found a stringParser that handled it
	if ( rgba.length ) {

		// if this came from a parsed string, force "transparent" when alpha is 0
		// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
		if ( rgba.join() === "0,0,0,0" ) {
			jQuery.extend( rgba, colors.transparent );
		}
		return inst;
	}

	// named colors
	return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
	parse: function( red, green, blue, alpha ) {
		if ( red === undefined ) {
			this._rgba = [ null, null, null, null ];
			return this;
		}
		if ( red.jquery || red.nodeType ) {
			red = jQuery( red ).css( green );
			green = undefined;
		}

		var inst = this,
			type = jQuery.type( red ),
			rgba = this._rgba = [];

		// more than 1 argument specified - assume ( red, green, blue, alpha )
		if ( green !== undefined ) {
			red = [ red, green, blue, alpha ];
			type = "array";
		}

		if ( type === "string" ) {
			return this.parse( stringParse( red ) || colors._default );
		}

		if ( type === "array" ) {
			each( spaces.rgba.props, function( key, prop ) {
				rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
			});
			return this;
		}

		if ( type === "object" ) {
			if ( red instanceof color ) {
				each( spaces, function( spaceName, space ) {
					if ( red[ space.cache ] ) {
						inst[ space.cache ] = red[ space.cache ].slice();
					}
				});
			} else {
				each( spaces, function( spaceName, space ) {
					var cache = space.cache;
					each( space.props, function( key, prop ) {

						// if the cache doesn't exist, and we know how to convert
						if ( !inst[ cache ] && space.to ) {

							// if the value was null, we don't need to copy it
							// if the key was alpha, we don't need to copy it either
							if ( key === "alpha" || red[ key ] == null ) {
								return;
							}
							inst[ cache ] = space.to( inst._rgba );
						}

						// this is the only case where we allow nulls for ALL properties.
						// call clamp with alwaysAllowEmpty
						inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
					});

					// everything defined but alpha?
					if ( inst[ cache ] && jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {
						// use the default of 1
						inst[ cache ][ 3 ] = 1;
						if ( space.from ) {
							inst._rgba = space.from( inst[ cache ] );
						}
					}
				});
			}
			return this;
		}
	},
	is: function( compare ) {
		var is = color( compare ),
			same = true,
			inst = this;

		each( spaces, function( _, space ) {
			var localCache,
				isCache = is[ space.cache ];
			if (isCache) {
				localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
				each( space.props, function( _, prop ) {
					if ( isCache[ prop.idx ] != null ) {
						same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
						return same;
					}
				});
			}
			return same;
		});
		return same;
	},
	_space: function() {
		var used = [],
			inst = this;
		each( spaces, function( spaceName, space ) {
			if ( inst[ space.cache ] ) {
				used.push( spaceName );
			}
		});
		return used.pop();
	},
	transition: function( other, distance ) {
		var end = color( other ),
			spaceName = end._space(),
			space = spaces[ spaceName ],
			startColor = this.alpha() === 0 ? color( "transparent" ) : this,
			start = startColor[ space.cache ] || space.to( startColor._rgba ),
			result = start.slice();

		end = end[ space.cache ];
		each( space.props, function( key, prop ) {
			var index = prop.idx,
				startValue = start[ index ],
				endValue = end[ index ],
				type = propTypes[ prop.type ] || {};

			// if null, don't override start value
			if ( endValue === null ) {
				return;
			}
			// if null - use end
			if ( startValue === null ) {
				result[ index ] = endValue;
			} else {
				if ( type.mod ) {
					if ( endValue - startValue > type.mod / 2 ) {
						startValue += type.mod;
					} else if ( startValue - endValue > type.mod / 2 ) {
						startValue -= type.mod;
					}
				}
				result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
			}
		});
		return this[ spaceName ]( result );
	},
	blend: function( opaque ) {
		// if we are already opaque - return ourself
		if ( this._rgba[ 3 ] === 1 ) {
			return this;
		}

		var rgb = this._rgba.slice(),
			a = rgb.pop(),
			blend = color( opaque )._rgba;

		return color( jQuery.map( rgb, function( v, i ) {
			return ( 1 - a ) * blend[ i ] + a * v;
		}));
	},
	toRgbaString: function() {
		var prefix = "rgba(",
			rgba = jQuery.map( this._rgba, function( v, i ) {
				return v == null ? ( i > 2 ? 1 : 0 ) : v;
			});

		if ( rgba[ 3 ] === 1 ) {
			rgba.pop();
			prefix = "rgb(";
		}

		return prefix + rgba.join() + ")";
	},
	toHslaString: function() {
		var prefix = "hsla(",
			hsla = jQuery.map( this.hsla(), function( v, i ) {
				if ( v == null ) {
					v = i > 2 ? 1 : 0;
				}

				// catch 1 and 2
				if ( i && i < 3 ) {
					v = Math.round( v * 100 ) + "%";
				}
				return v;
			});

		if ( hsla[ 3 ] === 1 ) {
			hsla.pop();
			prefix = "hsl(";
		}
		return prefix + hsla.join() + ")";
	},
	toHexString: function( includeAlpha ) {
		var rgba = this._rgba.slice(),
			alpha = rgba.pop();

		if ( includeAlpha ) {
			rgba.push( ~~( alpha * 255 ) );
		}

		return "#" + jQuery.map( rgba, function( v ) {

			// default to 0 when nulls exist
			v = ( v || 0 ).toString( 16 );
			return v.length === 1 ? "0" + v : v;
		}).join("");
	},
	toString: function() {
		return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
	}
});
color.fn.parse.prototype = color.fn;

// hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
	h = ( h + 1 ) % 1;
	if ( h * 6 < 1 ) {
		return p + ( q - p ) * h * 6;
	}
	if ( h * 2 < 1) {
		return q;
	}
	if ( h * 3 < 2 ) {
		return p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6;
	}
	return p;
}

spaces.hsla.to = function( rgba ) {
	if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
		return [ null, null, null, rgba[ 3 ] ];
	}
	var r = rgba[ 0 ] / 255,
		g = rgba[ 1 ] / 255,
		b = rgba[ 2 ] / 255,
		a = rgba[ 3 ],
		max = Math.max( r, g, b ),
		min = Math.min( r, g, b ),
		diff = max - min,
		add = max + min,
		l = add * 0.5,
		h, s;

	if ( min === max ) {
		h = 0;
	} else if ( r === max ) {
		h = ( 60 * ( g - b ) / diff ) + 360;
	} else if ( g === max ) {
		h = ( 60 * ( b - r ) / diff ) + 120;
	} else {
		h = ( 60 * ( r - g ) / diff ) + 240;
	}

	// chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
	// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
	if ( diff === 0 ) {
		s = 0;
	} else if ( l <= 0.5 ) {
		s = diff / add;
	} else {
		s = diff / ( 2 - add );
	}
	return [ Math.round(h) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function( hsla ) {
	if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
		return [ null, null, null, hsla[ 3 ] ];
	}
	var h = hsla[ 0 ] / 360,
		s = hsla[ 1 ],
		l = hsla[ 2 ],
		a = hsla[ 3 ],
		q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
		p = 2 * l - q;

	return [
		Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
		Math.round( hue2rgb( p, q, h ) * 255 ),
		Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
		a
	];
};

each( spaces, function( spaceName, space ) {
	var props = space.props,
		cache = space.cache,
		to = space.to,
		from = space.from;

	// makes rgba() and hsla()
	color.fn[ spaceName ] = function( value ) {

		// generate a cache for this space if it doesn't exist
		if ( to && !this[ cache ] ) {
			this[ cache ] = to( this._rgba );
		}
		if ( value === undefined ) {
			return this[ cache ].slice();
		}

		var ret,
			type = jQuery.type( value ),
			arr = ( type === "array" || type === "object" ) ? value : arguments,
			local = this[ cache ].slice();

		each( props, function( key, prop ) {
			var val = arr[ type === "object" ? key : prop.idx ];
			if ( val == null ) {
				val = local[ prop.idx ];
			}
			local[ prop.idx ] = clamp( val, prop );
		});

		if ( from ) {
			ret = color( from( local ) );
			ret[ cache ] = local;
			return ret;
		} else {
			return color( local );
		}
	};

	// makes red() green() blue() alpha() hue() saturation() lightness()
	each( props, function( key, prop ) {
		// alpha is included in more than one space
		if ( color.fn[ key ] ) {
			return;
		}
		color.fn[ key ] = function( value ) {
			var vtype = jQuery.type( value ),
				fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
				local = this[ fn ](),
				cur = local[ prop.idx ],
				match;

			if ( vtype === "undefined" ) {
				return cur;
			}

			if ( vtype === "function" ) {
				value = value.call( this, cur );
				vtype = jQuery.type( value );
			}
			if ( value == null && prop.empty ) {
				return this;
			}
			if ( vtype === "string" ) {
				match = rplusequals.exec( value );
				if ( match ) {
					value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
				}
			}
			local[ prop.idx ] = value;
			return this[ fn ]( local );
		};
	});
});

// add cssHook and .fx.step function for each named hook.
// accept a space separated string of properties
color.hook = function( hook ) {
	var hooks = hook.split( " " );
	each( hooks, function( i, hook ) {
		jQuery.cssHooks[ hook ] = {
			set: function( elem, value ) {
				var parsed, curElem,
					backgroundColor = "";

				if ( value !== "transparent" && ( jQuery.type( value ) !== "string" || ( parsed = stringParse( value ) ) ) ) {
					value = color( parsed || value );
					if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
						curElem = hook === "backgroundColor" ? elem.parentNode : elem;
						while (
							(backgroundColor === "" || backgroundColor === "transparent") &&
							curElem && curElem.style
						) {
							try {
								backgroundColor = jQuery.css( curElem, "backgroundColor" );
								curElem = curElem.parentNode;
							} catch ( e ) {
							}
						}

						value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
							backgroundColor :
							"_default" );
					}

					value = value.toRgbaString();
				}
				try {
					elem.style[ hook ] = value;
				} catch( e ) {
					// wrapped to prevent IE from throwing errors on "invalid" values like 'auto' or 'inherit'
				}
			}
		};
		jQuery.fx.step[ hook ] = function( fx ) {
			if ( !fx.colorInit ) {
				fx.start = color( fx.elem, hook );
				fx.end = color( fx.end );
				fx.colorInit = true;
			}
			jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
		};
	});

};

color.hook( stepHooks );

jQuery.cssHooks.borderColor = {
	expand: function( value ) {
		var expanded = {};

		each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
			expanded[ "border" + part + "Color" ] = value;
		});
		return expanded;
	}
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {
	// 4.1. Basic color keywords
	aqua: "#00ffff",
	black: "#000000",
	blue: "#0000ff",
	fuchsia: "#ff00ff",
	gray: "#808080",
	green: "#008000",
	lime: "#00ff00",
	maroon: "#800000",
	navy: "#000080",
	olive: "#808000",
	purple: "#800080",
	red: "#ff0000",
	silver: "#c0c0c0",
	teal: "#008080",
	white: "#ffffff",
	yellow: "#ffff00",

	// 4.2.3. "transparent" color keyword
	transparent: [ null, null, null, 0 ],

	_default: "#ffffff"
};

})( jQuery );

/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/
(function() {

var classAnimationActions = [ "add", "remove", "toggle" ],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

$.each([ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ], function( _, prop ) {
	$.fx.step[ prop ] = function( fx ) {
		if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
			jQuery.style( fx.elem, prop, fx.end );
			fx.setAttr = true;
		}
	};
});

function getElementStyles( elem ) {
	var key, len,
		style = elem.ownerDocument.defaultView ?
			elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
			elem.currentStyle,
		styles = {};

	if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
		len = style.length;
		while ( len-- ) {
			key = style[ len ];
			if ( typeof style[ key ] === "string" ) {
				styles[ $.camelCase( key ) ] = style[ key ];
			}
		}
	// support: Opera, IE <9
	} else {
		for ( key in style ) {
			if ( typeof style[ key ] === "string" ) {
				styles[ key ] = style[ key ];
			}
		}
	}

	return styles;
}

function styleDifference( oldStyle, newStyle ) {
	var diff = {},
		name, value;

	for ( name in newStyle ) {
		value = newStyle[ name ];
		if ( oldStyle[ name ] !== value ) {
			if ( !shorthandStyles[ name ] ) {
				if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
					diff[ name ] = value;
				}
			}
		}
	}

	return diff;
}

// support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

$.effects.animateClass = function( value, duration, easing, callback ) {
	var o = $.speed( duration, easing, callback );

	return this.queue( function() {
		var animated = $( this ),
			baseClass = animated.attr( "class" ) || "",
			applyClassChange,
			allAnimations = o.children ? animated.find( "*" ).addBack() : animated;

		// map the animated objects to store the original styles.
		allAnimations = allAnimations.map(function() {
			var el = $( this );
			return {
				el: el,
				start: getElementStyles( this )
			};
		});

		// apply class change
		applyClassChange = function() {
			$.each( classAnimationActions, function(i, action) {
				if ( value[ action ] ) {
					animated[ action + "Class" ]( value[ action ] );
				}
			});
		};
		applyClassChange();

		// map all animated objects again - calculate new styles and diff
		allAnimations = allAnimations.map(function() {
			this.end = getElementStyles( this.el[ 0 ] );
			this.diff = styleDifference( this.start, this.end );
			return this;
		});

		// apply original class
		animated.attr( "class", baseClass );

		// map all animated objects again - this time collecting a promise
		allAnimations = allAnimations.map(function() {
			var styleInfo = this,
				dfd = $.Deferred(),
				opts = $.extend({}, o, {
					queue: false,
					complete: function() {
						dfd.resolve( styleInfo );
					}
				});

			this.el.animate( this.diff, opts );
			return dfd.promise();
		});

		// once all animations have completed:
		$.when.apply( $, allAnimations.get() ).done(function() {

			// set the final class
			applyClassChange();

			// for each animated element,
			// clear all css properties that were animated
			$.each( arguments, function() {
				var el = this.el;
				$.each( this.diff, function(key) {
					el.css( key, "" );
				});
			});

			// this is guarnteed to be there if you use jQuery.speed()
			// it also handles dequeuing the next anim...
			o.complete.call( animated[ 0 ] );
		});
	});
};

$.fn.extend({
	addClass: (function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return speed ?
				$.effects.animateClass.call( this,
					{ add: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	})( $.fn.addClass ),

	removeClass: (function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return arguments.length > 1 ?
				$.effects.animateClass.call( this,
					{ remove: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	})( $.fn.removeClass ),

	toggleClass: (function( orig ) {
		return function( classNames, force, speed, easing, callback ) {
			if ( typeof force === "boolean" || force === undefined ) {
				if ( !speed ) {
					// without speed parameter
					return orig.apply( this, arguments );
				} else {
					return $.effects.animateClass.call( this,
						(force ? { add: classNames } : { remove: classNames }),
						speed, easing, callback );
				}
			} else {
				// without force parameter
				return $.effects.animateClass.call( this,
					{ toggle: classNames }, force, speed, easing );
			}
		};
	})( $.fn.toggleClass ),

	switchClass: function( remove, add, speed, easing, callback) {
		return $.effects.animateClass.call( this, {
			add: add,
			remove: remove
		}, speed, easing, callback );
	}
});

})();

/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

(function() {

$.extend( $.effects, {
	version: "1.11.0",

	// Saves a set of properties in a data storage
	save: function( element, set ) {
		for ( var i = 0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
			}
		}
	},

	// Restores a set of previously saved properties from a data storage
	restore: function( element, set ) {
		var val, i;
		for ( i = 0; i < set.length; i++ ) {
			if ( set[ i ] !== null ) {
				val = element.data( dataSpace + set[ i ] );
				// support: jQuery 1.6.2
				// http://bugs.jquery.com/ticket/9917
				// jQuery 1.6.2 incorrectly returns undefined for any falsy value.
				// We can't differentiate between "" and 0 here, so we just assume
				// empty string since it's likely to be a more common value...
				if ( val === undefined ) {
					val = "";
				}
				element.css( set[ i ], val );
			}
		}
	},

	setMode: function( el, mode ) {
		if (mode === "toggle") {
			mode = el.is( ":hidden" ) ? "show" : "hide";
		}
		return mode;
	},

	// Translates a [top,left] array into a baseline value
	// this should be a little more flexible in the future to handle a string & hash
	getBaseline: function( origin, original ) {
		var y, x;
		switch ( origin[ 0 ] ) {
			case "top": y = 0; break;
			case "middle": y = 0.5; break;
			case "bottom": y = 1; break;
			default: y = origin[ 0 ] / original.height;
		}
		switch ( origin[ 1 ] ) {
			case "left": x = 0; break;
			case "center": x = 0.5; break;
			case "right": x = 1; break;
			default: x = origin[ 1 ] / original.width;
		}
		return {
			x: x,
			y: y
		};
	},

	// Wraps the element around a wrapper that copies position properties
	createWrapper: function( element ) {

		// if the element is already wrapped, return it
		if ( element.parent().is( ".ui-effects-wrapper" )) {
			return element.parent();
		}

		// wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				"float": element.css( "float" )
			},
			wrapper = $( "<div></div>" )
				.addClass( "ui-effects-wrapper" )
				.css({
					fontSize: "100%",
					background: "transparent",
					border: "none",
					margin: 0,
					padding: 0
				}),
			// Store the size in case width/height are defined in % - Fixes #5245
			size = {
				width: element.width(),
				height: element.height()
			},
			active = document.activeElement;

		// support: Firefox
		// Firefox incorrectly exposes anonymous content
		// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
		try {
			active.id;
		} catch( e ) {
			active = document.body;
		}

		element.wrap( wrapper );

		// Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).focus();
		}

		wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element

		// transfer positioning properties to the wrapper
		if ( element.css( "position" ) === "static" ) {
			wrapper.css({ position: "relative" });
			element.css({ position: "relative" });
		} else {
			$.extend( props, {
				position: element.css( "position" ),
				zIndex: element.css( "z-index" )
			});
			$.each([ "top", "left", "bottom", "right" ], function(i, pos) {
				props[ pos ] = element.css( pos );
				if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
					props[ pos ] = "auto";
				}
			});
			element.css({
				position: "relative",
				top: 0,
				left: 0,
				right: "auto",
				bottom: "auto"
			});
		}
		element.css(size);

		return wrapper.css( props ).show();
	},

	removeWrapper: function( element ) {
		var active = document.activeElement;

		if ( element.parent().is( ".ui-effects-wrapper" ) ) {
			element.parent().replaceWith( element );

			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
		}

		return element;
	},

	setTransition: function( element, list, factor, value ) {
		value = value || {};
		$.each( list, function( i, x ) {
			var unit = element.cssUnit( x );
			if ( unit[ 0 ] > 0 ) {
				value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
			}
		});
		return value;
	}
});

// return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

	// allow passing all options as the first parameter
	if ( $.isPlainObject( effect ) ) {
		options = effect;
		effect = effect.effect;
	}

	// convert to an object
	effect = { effect: effect };

	// catch (effect, null, ...)
	if ( options == null ) {
		options = {};
	}

	// catch (effect, callback)
	if ( $.isFunction( options ) ) {
		callback = options;
		speed = null;
		options = {};
	}

	// catch (effect, speed, ?)
	if ( typeof options === "number" || $.fx.speeds[ options ] ) {
		callback = speed;
		speed = options;
		options = {};
	}

	// catch (effect, options, callback)
	if ( $.isFunction( speed ) ) {
		callback = speed;
		speed = null;
	}

	// add options to effect
	if ( options ) {
		$.extend( effect, options );
	}

	speed = speed || options.duration;
	effect.duration = $.fx.off ? 0 :
		typeof speed === "number" ? speed :
		speed in $.fx.speeds ? $.fx.speeds[ speed ] :
		$.fx.speeds._default;

	effect.complete = callback || options.complete;

	return effect;
}

function standardAnimationOption( option ) {
	// Valid standard speeds (nothing, number, named speed)
	if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {
		return true;
	}

	// Invalid strings - treat as "normal" speed
	if ( typeof option === "string" && !$.effects.effect[ option ] ) {
		return true;
	}

	// Complete callback
	if ( $.isFunction( option ) ) {
		return true;
	}

	// Options hash (but not naming an effect)
	if ( typeof option === "object" && !option.effect ) {
		return true;
	}

	// Didn't match any standard API
	return false;
}

$.fn.extend({
	effect: function( /* effect, options, speed, callback */ ) {
		var args = _normalizeArguments.apply( this, arguments ),
			mode = args.mode,
			queue = args.queue,
			effectMethod = $.effects.effect[ args.effect ];

		if ( $.fx.off || !effectMethod ) {
			// delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args.duration, args.complete );
			} else {
				return this.each( function() {
					if ( args.complete ) {
						args.complete.call( this );
					}
				});
			}
		}

		function run( next ) {
			var elem = $( this ),
				complete = args.complete,
				mode = args.mode;

			function done() {
				if ( $.isFunction( complete ) ) {
					complete.call( elem[0] );
				}
				if ( $.isFunction( next ) ) {
					next();
				}
			}

			// If the element already has the correct final state, delegate to
			// the core methods so the internal tracking of "olddisplay" works.
			if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {
				elem[ mode ]();
				done();
			} else {
				effectMethod.call( elem[0], args, done );
			}
		}

		return queue === false ? this.each( run ) : this.queue( queue || "fx", run );
	},

	show: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "show";
				return this.effect.call( this, args );
			}
		};
	})( $.fn.show ),

	hide: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "hide";
				return this.effect.call( this, args );
			}
		};
	})( $.fn.hide ),

	toggle: (function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) || typeof option === "boolean" ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "toggle";
				return this.effect.call( this, args );
			}
		};
	})( $.fn.toggle ),

	// helper functions
	cssUnit: function(key) {
		var style = this.css( key ),
			val = [];

		$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
			if ( style.indexOf( unit ) > 0 ) {
				val = [ parseFloat( style ), unit ];
			}
		});
		return val;
	}
});

})();

/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

(function() {

// based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
});

$.extend( baseEasings, {
	Sine: function( p ) {
		return 1 - Math.cos( p * Math.PI / 2 );
	},
	Circ: function( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * (p - 1) ) * Math.sin( ( (p - 1) * 80 - 7.5 ) * Math.PI / 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function( p ) {
		var pow2,
			bounce = 4;

		while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
	}
});

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ "easeIn" + name ] = easeIn;
	$.easing[ "easeOut" + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ "easeInOut" + name ] = function( p ) {
		return p < 0.5 ?
			easeIn( p * 2 ) / 2 :
			1 - easeIn( p * -2 + 2 ) / 2;
	};
});

})();

var effect = $.effects;


/*!
 * jQuery UI Effects Blind 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/blind-effect/
 */


var effectBlind = $.effects.effect.blind = function( o, done ) {
	// Create element
	var el = $( this ),
		rvertical = /up|down|vertical/,
		rpositivemotion = /up|left|vertical|horizontal/,
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		direction = o.direction || "up",
		vertical = rvertical.test( direction ),
		ref = vertical ? "height" : "width",
		ref2 = vertical ? "top" : "left",
		motion = rpositivemotion.test( direction ),
		animation = {},
		show = mode === "show",
		wrapper, distance, margin;

	// if already wrapped, the wrapper's properties are my property. #6245
	if ( el.parent().is( ".ui-effects-wrapper" ) ) {
		$.effects.save( el.parent(), props );
	} else {
		$.effects.save( el, props );
	}
	el.show();
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	distance = wrapper[ ref ]();
	margin = parseFloat( wrapper.css( ref2 ) ) || 0;

	animation[ ref ] = show ? distance : 0;
	if ( !motion ) {
		el
			.css( vertical ? "bottom" : "right", 0 )
			.css( vertical ? "top" : "left", "auto" )
			.css({ position: "absolute" });

		animation[ ref2 ] = show ? margin : distance + margin;
	}

	// start at 0 if we are showing
	if ( show ) {
		wrapper.css( ref, 0 );
		if ( !motion ) {
			wrapper.css( ref2, margin + distance );
		}
	}

	// Animate
	wrapper.animate( animation, {
		duration: o.duration,
		easing: o.easing,
		queue: false,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};


/*!
 * jQuery UI Effects Bounce 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/bounce-effect/
 */


var effectBounce = $.effects.effect.bounce = function( o, done ) {
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],

		// defaults:
		mode = $.effects.setMode( el, o.mode || "effect" ),
		hide = mode === "hide",
		show = mode === "show",
		direction = o.direction || "up",
		distance = o.distance,
		times = o.times || 5,

		// number of internal animations
		anims = times * 2 + ( show || hide ? 1 : 0 ),
		speed = o.duration / anims,
		easing = o.easing,

		// utility:
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ),
		i,
		upAnim,
		downAnim,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	// Avoid touching opacity to prevent clearType and PNG issues in IE
	if ( show || hide ) {
		props.push( "opacity" );
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el ); // Create Wrapper

	// default distance for the BIGGEST bounce is the outer Distance / 3
	if ( !distance ) {
		distance = el[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
	}

	if ( show ) {
		downAnim = { opacity: 1 };
		downAnim[ ref ] = 0;

		// if we are showing, force opacity 0 and set the initial position
		// then do the "first" animation
		el.css( "opacity", 0 )
			.css( ref, motion ? -distance * 2 : distance * 2 )
			.animate( downAnim, speed, easing );
	}

	// start at the smallest distance if we are hiding
	if ( hide ) {
		distance = distance / Math.pow( 2, times - 1 );
	}

	downAnim = {};
	downAnim[ ref ] = 0;
	// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
	for ( i = 0; i < times; i++ ) {
		upAnim = {};
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing )
			.animate( downAnim, speed, easing );

		distance = hide ? distance * 2 : distance / 2;
	}

	// Last Bounce when Hiding
	if ( hide ) {
		upAnim = { opacity: 0 };
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		el.animate( upAnim, speed, easing );
	}

	el.queue(function() {
		if ( hide ) {
			el.hide();
		}
		$.effects.restore( el, props );
		$.effects.removeWrapper( el );
		done();
	});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};


/*!
 * jQuery UI Effects Clip 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/clip-effect/
 */


var effectClip = $.effects.effect.clip = function( o, done ) {
	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "vertical",
		vert = direction === "vertical",
		size = vert ? "height" : "width",
		position = vert ? "top" : "left",
		animation = {},
		wrapper, animate, distance;

	// Save & Show
	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	animate = ( el[0].tagName === "IMG" ) ? wrapper : el;
	distance = animate[ size ]();

	// Shift
	if ( show ) {
		animate.css( size, 0 );
		animate.css( position, distance / 2 );
	}

	// Create Animation Object:
	animation[ size ] = show ? distance : 0;
	animation[ position ] = show ? 0 : distance / 2;

	// Animate
	animate.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( !show ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});

};


/*!
 * jQuery UI Effects Drop 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/drop-effect/
 */


var effectDrop = $.effects.effect.drop = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "opacity", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ) ? "pos" : "neg",
		animation = {
			opacity: show ? 1 : 0
		},
		distance;

	// Adjust
	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	distance = o.distance || el[ ref === "top" ? "outerHeight": "outerWidth" ]( true ) / 2;

	if ( show ) {
		el
			.css( "opacity", 0 )
			.css( ref, motion === "pos" ? -distance : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( motion === "pos" ? "+=" : "-=" ) :
		( motion === "pos" ? "-=" : "+=" ) ) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};


/*!
 * jQuery UI Effects Explode 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/explode-effect/
 */


var effectExplode = $.effects.effect.explode = function( o, done ) {

	var rows = o.pieces ? Math.round( Math.sqrt( o.pieces ) ) : 3,
		cells = rows,
		el = $( this ),
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",

		// show and then visibility:hidden the element before calculating offset
		offset = el.show().css( "visibility", "hidden" ).offset(),

		// width and height of a piece
		width = Math.ceil( el.outerWidth() / cells ),
		height = Math.ceil( el.outerHeight() / rows ),
		pieces = [],

		// loop
		i, j, left, top, mx, my;

	// children animate complete:
	function childComplete() {
		pieces.push( this );
		if ( pieces.length === rows * cells ) {
			animComplete();
		}
	}

	// clone the element for each row and cell.
	for ( i = 0; i < rows ; i++ ) { // ===>
		top = offset.top + i * height;
		my = i - ( rows - 1 ) / 2 ;

		for ( j = 0; j < cells ; j++ ) { // |||
			left = offset.left + j * width;
			mx = j - ( cells - 1 ) / 2 ;

			// Create a clone of the now hidden main element that will be absolute positioned
			// within a wrapper div off the -left and -top equal to size of our pieces
			el
				.clone()
				.appendTo( "body" )
				.wrap( "<div></div>" )
				.css({
					position: "absolute",
					visibility: "visible",
					left: -j * width,
					top: -i * height
				})

			// select the wrapper - make it overflow: hidden and absolute positioned based on
			// where the original was located +left and +top equal to the size of pieces
				.parent()
				.addClass( "ui-effects-explode" )
				.css({
					position: "absolute",
					overflow: "hidden",
					width: width,
					height: height,
					left: left + ( show ? mx * width : 0 ),
					top: top + ( show ? my * height : 0 ),
					opacity: show ? 0 : 1
				}).animate({
					left: left + ( show ? 0 : mx * width ),
					top: top + ( show ? 0 : my * height ),
					opacity: show ? 1 : 0
				}, o.duration || 500, o.easing, childComplete );
		}
	}

	function animComplete() {
		el.css({
			visibility: "visible"
		});
		$( pieces ).remove();
		if ( !show ) {
			el.hide();
		}
		done();
	}
};


/*!
 * jQuery UI Effects Fade 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/fade-effect/
 */


var effectFade = $.effects.effect.fade = function( o, done ) {
	var el = $( this ),
		mode = $.effects.setMode( el, o.mode || "toggle" );

	el.animate({
		opacity: mode
	}, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: done
	});
};


/*!
 * jQuery UI Effects Fold 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/fold-effect/
 */


var effectFold = $.effects.effect.fold = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "hide" ),
		show = mode === "show",
		hide = mode === "hide",
		size = o.size || 15,
		percent = /([0-9]+)%/.exec( size ),
		horizFirst = !!o.horizFirst,
		widthFirst = show !== horizFirst,
		ref = widthFirst ? [ "width", "height" ] : [ "height", "width" ],
		duration = o.duration / 2,
		wrapper, distance,
		animation1 = {},
		animation2 = {};

	$.effects.save( el, props );
	el.show();

	// Create Wrapper
	wrapper = $.effects.createWrapper( el ).css({
		overflow: "hidden"
	});
	distance = widthFirst ?
		[ wrapper.width(), wrapper.height() ] :
		[ wrapper.height(), wrapper.width() ];

	if ( percent ) {
		size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
	}
	if ( show ) {
		wrapper.css( horizFirst ? {
			height: 0,
			width: size
		} : {
			height: size,
			width: 0
		});
	}

	// Animation
	animation1[ ref[ 0 ] ] = show ? distance[ 0 ] : size;
	animation2[ ref[ 1 ] ] = show ? distance[ 1 ] : 0;

	// Animate
	wrapper
		.animate( animation1, duration, o.easing )
		.animate( animation2, duration, o.easing, function() {
			if ( hide ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

};


/*!
 * jQuery UI Effects Highlight 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/highlight-effect/
 */


var effectHighlight = $.effects.effect.highlight = function( o, done ) {
	var elem = $( this ),
		props = [ "backgroundImage", "backgroundColor", "opacity" ],
		mode = $.effects.setMode( elem, o.mode || "show" ),
		animation = {
			backgroundColor: elem.css( "backgroundColor" )
		};

	if (mode === "hide") {
		animation.opacity = 0;
	}

	$.effects.save( elem, props );

	elem
		.show()
		.css({
			backgroundImage: "none",
			backgroundColor: o.color || "#ffff99"
		})
		.animate( animation, {
			queue: false,
			duration: o.duration,
			easing: o.easing,
			complete: function() {
				if ( mode === "hide" ) {
					elem.hide();
				}
				$.effects.restore( elem, props );
				done();
			}
		});
};


/*!
 * jQuery UI Effects Size 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/size-effect/
 */


var effectSize = $.effects.effect.size = function( o, done ) {

	// Create element
	var original, baseline, factor,
		el = $( this ),
		props0 = [ "position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity" ],

		// Always restore
		props1 = [ "position", "top", "bottom", "left", "right", "overflow", "opacity" ],

		// Copy for children
		props2 = [ "width", "height", "overflow" ],
		cProps = [ "fontSize" ],
		vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
		hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],

		// Set options
		mode = $.effects.setMode( el, o.mode || "effect" ),
		restore = o.restore || mode !== "effect",
		scale = o.scale || "both",
		origin = o.origin || [ "middle", "center" ],
		position = el.css( "position" ),
		props = restore ? props0 : props1,
		zero = {
			height: 0,
			width: 0,
			outerHeight: 0,
			outerWidth: 0
		};

	if ( mode === "show" ) {
		el.show();
	}
	original = {
		height: el.height(),
		width: el.width(),
		outerHeight: el.outerHeight(),
		outerWidth: el.outerWidth()
	};

	if ( o.mode === "toggle" && mode === "show" ) {
		el.from = o.to || zero;
		el.to = o.from || original;
	} else {
		el.from = o.from || ( mode === "show" ? zero : original );
		el.to = o.to || ( mode === "hide" ? zero : original );
	}

	// Set scaling factor
	factor = {
		from: {
			y: el.from.height / original.height,
			x: el.from.width / original.width
		},
		to: {
			y: el.to.height / original.height,
			x: el.to.width / original.width
		}
	};

	// Scale the css box
	if ( scale === "box" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( vProps );
			el.from = $.effects.setTransition( el, vProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, vProps, factor.to.y, el.to );
		}

		// Horizontal props scaling
		if ( factor.from.x !== factor.to.x ) {
			props = props.concat( hProps );
			el.from = $.effects.setTransition( el, hProps, factor.from.x, el.from );
			el.to = $.effects.setTransition( el, hProps, factor.to.x, el.to );
		}
	}

	// Scale the content
	if ( scale === "content" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			props = props.concat( cProps ).concat( props2 );
			el.from = $.effects.setTransition( el, cProps, factor.from.y, el.from );
			el.to = $.effects.setTransition( el, cProps, factor.to.y, el.to );
		}
	}

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );
	el.css( "overflow", "hidden" ).css( el.from );

	// Adjust
	if (origin) { // Calculate baseline shifts
		baseline = $.effects.getBaseline( origin, original );
		el.from.top = ( original.outerHeight - el.outerHeight() ) * baseline.y;
		el.from.left = ( original.outerWidth - el.outerWidth() ) * baseline.x;
		el.to.top = ( original.outerHeight - el.to.outerHeight ) * baseline.y;
		el.to.left = ( original.outerWidth - el.to.outerWidth ) * baseline.x;
	}
	el.css( el.from ); // set top & left

	// Animate
	if ( scale === "content" || scale === "both" ) { // Scale the children

		// Add margins/font-size
		vProps = vProps.concat([ "marginTop", "marginBottom" ]).concat(cProps);
		hProps = hProps.concat([ "marginLeft", "marginRight" ]);
		props2 = props0.concat(vProps).concat(hProps);

		el.find( "*[width]" ).each( function() {
			var child = $( this ),
				c_original = {
					height: child.height(),
					width: child.width(),
					outerHeight: child.outerHeight(),
					outerWidth: child.outerWidth()
				};
			if (restore) {
				$.effects.save(child, props2);
			}

			child.from = {
				height: c_original.height * factor.from.y,
				width: c_original.width * factor.from.x,
				outerHeight: c_original.outerHeight * factor.from.y,
				outerWidth: c_original.outerWidth * factor.from.x
			};
			child.to = {
				height: c_original.height * factor.to.y,
				width: c_original.width * factor.to.x,
				outerHeight: c_original.height * factor.to.y,
				outerWidth: c_original.width * factor.to.x
			};

			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				child.from = $.effects.setTransition( child, vProps, factor.from.y, child.from );
				child.to = $.effects.setTransition( child, vProps, factor.to.y, child.to );
			}

			// Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				child.from = $.effects.setTransition( child, hProps, factor.from.x, child.from );
				child.to = $.effects.setTransition( child, hProps, factor.to.x, child.to );
			}

			// Animate children
			child.css( child.from );
			child.animate( child.to, o.duration, o.easing, function() {

				// Restore children
				if ( restore ) {
					$.effects.restore( child, props2 );
				}
			});
		});
	}

	// Animate
	el.animate( el.to, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( el.to.opacity === 0 ) {
				el.css( "opacity", el.from.opacity );
			}
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			if ( !restore ) {

				// we need to calculate our new positioning based on the scaling
				if ( position === "static" ) {
					el.css({
						position: "relative",
						top: el.to.top,
						left: el.to.left
					});
				} else {
					$.each([ "top", "left" ], function( idx, pos ) {
						el.css( pos, function( _, str ) {
							var val = parseInt( str, 10 ),
								toRef = idx ? el.to.left : el.to.top;

							// if original was "auto", recalculate the new value from wrapper
							if ( str === "auto" ) {
								return toRef + "px";
							}

							return val + toRef + "px";
						});
					});
				}
			}

			$.effects.removeWrapper( el );
			done();
		}
	});

};


/*!
 * jQuery UI Effects Scale 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/scale-effect/
 */


var effectScale = $.effects.effect.scale = function( o, done ) {

	// Create element
	var el = $( this ),
		options = $.extend( true, {}, o ),
		mode = $.effects.setMode( el, o.mode || "effect" ),
		percent = parseInt( o.percent, 10 ) ||
			( parseInt( o.percent, 10 ) === 0 ? 0 : ( mode === "hide" ? 0 : 100 ) ),
		direction = o.direction || "both",
		origin = o.origin,
		original = {
			height: el.height(),
			width: el.width(),
			outerHeight: el.outerHeight(),
			outerWidth: el.outerWidth()
		},
		factor = {
			y: direction !== "horizontal" ? (percent / 100) : 1,
			x: direction !== "vertical" ? (percent / 100) : 1
		};

	// We are going to pass this effect to the size effect:
	options.effect = "size";
	options.queue = false;
	options.complete = done;

	// Set default origin and restore for show/hide
	if ( mode !== "effect" ) {
		options.origin = origin || [ "middle", "center" ];
		options.restore = true;
	}

	options.from = o.from || ( mode === "show" ? {
		height: 0,
		width: 0,
		outerHeight: 0,
		outerWidth: 0
	} : original );
	options.to = {
		height: original.height * factor.y,
		width: original.width * factor.x,
		outerHeight: original.outerHeight * factor.y,
		outerWidth: original.outerWidth * factor.x
	};

	// Fade option to support puff
	if ( options.fade ) {
		if ( mode === "show" ) {
			options.from.opacity = 0;
			options.to.opacity = 1;
		}
		if ( mode === "hide" ) {
			options.from.opacity = 1;
			options.to.opacity = 0;
		}
	}

	// Animate
	el.effect( options );

};


/*!
 * jQuery UI Effects Puff 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/puff-effect/
 */


var effectPuff = $.effects.effect.puff = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "hide" ),
		hide = mode === "hide",
		percent = parseInt( o.percent, 10 ) || 150,
		factor = percent / 100,
		original = {
			height: elem.height(),
			width: elem.width(),
			outerHeight: elem.outerHeight(),
			outerWidth: elem.outerWidth()
		};

	$.extend( o, {
		effect: "scale",
		queue: false,
		fade: true,
		mode: mode,
		complete: done,
		percent: hide ? percent : 100,
		from: hide ?
			original :
			{
				height: original.height * factor,
				width: original.width * factor,
				outerHeight: original.outerHeight * factor,
				outerWidth: original.outerWidth * factor
			}
	});

	elem.effect( o );
};


/*!
 * jQuery UI Effects Pulsate 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/pulsate-effect/
 */


var effectPulsate = $.effects.effect.pulsate = function( o, done ) {
	var elem = $( this ),
		mode = $.effects.setMode( elem, o.mode || "show" ),
		show = mode === "show",
		hide = mode === "hide",
		showhide = ( show || mode === "hide" ),

		// showing or hiding leaves of the "last" animation
		anims = ( ( o.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
		duration = o.duration / anims,
		animateTo = 0,
		queue = elem.queue(),
		queuelen = queue.length,
		i;

	if ( show || !elem.is(":visible")) {
		elem.css( "opacity", 0 ).show();
		animateTo = 1;
	}

	// anims - 1 opacity "toggles"
	for ( i = 1; i < anims; i++ ) {
		elem.animate({
			opacity: animateTo
		}, duration, o.easing );
		animateTo = 1 - animateTo;
	}

	elem.animate({
		opacity: animateTo
	}, duration, o.easing);

	elem.queue(function() {
		if ( hide ) {
			elem.hide();
		}
		done();
	});

	// We just queued up "anims" animations, we need to put them next in the queue
	if ( queuelen > 1 ) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	elem.dequeue();
};


/*!
 * jQuery UI Effects Shake 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/shake-effect/
 */


var effectShake = $.effects.effect.shake = function( o, done ) {

	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "height", "width" ],
		mode = $.effects.setMode( el, o.mode || "effect" ),
		direction = o.direction || "left",
		distance = o.distance || 20,
		times = o.times || 3,
		anims = times * 2 + 1,
		speed = Math.round( o.duration / anims ),
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		animation = {},
		animation1 = {},
		animation2 = {},
		i,

		// we will need to re-assemble the queue to stack our animations in place
		queue = el.queue(),
		queuelen = queue.length;

	$.effects.save( el, props );
	el.show();
	$.effects.createWrapper( el );

	// Animation
	animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
	animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
	animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;

	// Animate
	el.animate( animation, speed, o.easing );

	// Shakes
	for ( i = 1; i < times; i++ ) {
		el.animate( animation1, speed, o.easing ).animate( animation2, speed, o.easing );
	}
	el
		.animate( animation1, speed, o.easing )
		.animate( animation, speed / 2, o.easing )
		.queue(function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		});

	// inject all the animations we just queued to be first in line (after "inprogress")
	if ( queuelen > 1) {
		queue.splice.apply( queue,
			[ 1, 0 ].concat( queue.splice( queuelen, anims + 1 ) ) );
	}
	el.dequeue();

};


/*!
 * jQuery UI Effects Slide 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/slide-effect/
 */


var effectSlide = $.effects.effect.slide = function( o, done ) {

	// Create element
	var el = $( this ),
		props = [ "position", "top", "bottom", "left", "right", "width", "height" ],
		mode = $.effects.setMode( el, o.mode || "show" ),
		show = mode === "show",
		direction = o.direction || "left",
		ref = (direction === "up" || direction === "down") ? "top" : "left",
		positiveMotion = (direction === "up" || direction === "left"),
		distance,
		animation = {};

	// Adjust
	$.effects.save( el, props );
	el.show();
	distance = o.distance || el[ ref === "top" ? "outerHeight" : "outerWidth" ]( true );

	$.effects.createWrapper( el ).css({
		overflow: "hidden"
	});

	if ( show ) {
		el.css( ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance );
	}

	// Animation
	animation[ ref ] = ( show ?
		( positiveMotion ? "+=" : "-=") :
		( positiveMotion ? "-=" : "+=")) +
		distance;

	// Animate
	el.animate( animation, {
		queue: false,
		duration: o.duration,
		easing: o.easing,
		complete: function() {
			if ( mode === "hide" ) {
				el.hide();
			}
			$.effects.restore( el, props );
			$.effects.removeWrapper( el );
			done();
		}
	});
};


/*!
 * jQuery UI Effects Transfer 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/transfer-effect/
 */


var effectTransfer = $.effects.effect.transfer = function( o, done ) {
	var elem = $( this ),
		target = $( o.to ),
		targetFixed = target.css( "position" ) === "fixed",
		body = $("body"),
		fixTop = targetFixed ? body.scrollTop() : 0,
		fixLeft = targetFixed ? body.scrollLeft() : 0,
		endPosition = target.offset(),
		animation = {
			top: endPosition.top - fixTop,
			left: endPosition.left - fixLeft,
			height: target.innerHeight(),
			width: target.innerWidth()
		},
		startPosition = elem.offset(),
		transfer = $( "<div class='ui-effects-transfer'></div>" )
			.appendTo( document.body )
			.addClass( o.className )
			.css({
				top: startPosition.top - fixTop,
				left: startPosition.left - fixLeft,
				height: elem.innerHeight(),
				width: elem.innerWidth(),
				position: targetFixed ? "fixed" : "absolute"
			})
			.animate( animation, o.duration, o.easing, function() {
				transfer.remove();
				done();
			});
};


/*!
 * jQuery UI Progressbar 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/progressbar/
 */


var progressbar = $.widget( "ui.progressbar", {
	version: "1.11.0",
	options: {
		max: 100,
		value: 0,

		change: null,
		complete: null
	},

	min: 0,

	_create: function() {
		// Constrain initial value
		this.oldValue = this.options.value = this._constrainedValue();

		this.element
			.addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.attr({
				// Only set static values, aria-valuenow and aria-valuemax are
				// set inside _refreshValue()
				role: "progressbar",
				"aria-valuemin": this.min
			});

		this.valueDiv = $( "<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>" )
			.appendTo( this.element );

		this._refreshValue();
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );

		this.valueDiv.remove();
	},

	value: function( newValue ) {
		if ( newValue === undefined ) {
			return this.options.value;
		}

		this.options.value = this._constrainedValue( newValue );
		this._refreshValue();
	},

	_constrainedValue: function( newValue ) {
		if ( newValue === undefined ) {
			newValue = this.options.value;
		}

		this.indeterminate = newValue === false;

		// sanitize value
		if ( typeof newValue !== "number" ) {
			newValue = 0;
		}

		return this.indeterminate ? false :
			Math.min( this.options.max, Math.max( this.min, newValue ) );
	},

	_setOptions: function( options ) {
		// Ensure "value" option is set after other values (like max)
		var value = options.value;
		delete options.value;

		this._super( options );

		this.options.value = this._constrainedValue( value );
		this._refreshValue();
	},

	_setOption: function( key, value ) {
		if ( key === "max" ) {
			// Don't allow a max less than min
			value = Math.max( this.min, value );
		}
		if ( key === "disabled" ) {
			this.element
				.toggleClass( "ui-state-disabled", !!value )
				.attr( "aria-disabled", value );
		}
		this._super( key, value );
	},

	_percentage: function() {
		return this.indeterminate ? 100 : 100 * ( this.options.value - this.min ) / ( this.options.max - this.min );
	},

	_refreshValue: function() {
		var value = this.options.value,
			percentage = this._percentage();

		this.valueDiv
			.toggle( this.indeterminate || value > this.min )
			.toggleClass( "ui-corner-right", value === this.options.max )
			.width( percentage.toFixed(0) + "%" );

		this.element.toggleClass( "ui-progressbar-indeterminate", this.indeterminate );

		if ( this.indeterminate ) {
			this.element.removeAttr( "aria-valuenow" );
			if ( !this.overlayDiv ) {
				this.overlayDiv = $( "<div class='ui-progressbar-overlay'></div>" ).appendTo( this.valueDiv );
			}
		} else {
			this.element.attr({
				"aria-valuemax": this.options.max,
				"aria-valuenow": value
			});
			if ( this.overlayDiv ) {
				this.overlayDiv.remove();
				this.overlayDiv = null;
			}
		}

		if ( this.oldValue !== value ) {
			this.oldValue = value;
			this._trigger( "change" );
		}
		if ( value === this.options.max ) {
			this._trigger( "complete" );
		}
	}
});


/*!
 * jQuery UI Selectable 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/selectable/
 */


var selectable = $.widget("ui.selectable", $.ui.mouse, {
	version: "1.11.0",
	options: {
		appendTo: "body",
		autoRefresh: true,
		distance: 0,
		filter: "*",
		tolerance: "touch",

		// callbacks
		selected: null,
		selecting: null,
		start: null,
		stop: null,
		unselected: null,
		unselecting: null
	},
	_create: function() {
		var selectees,
			that = this;

		this.element.addClass("ui-selectable");

		this.dragged = false;

		// cache selectee children based on filter
		this.refresh = function() {
			selectees = $(that.options.filter, that.element[0]);
			selectees.addClass("ui-selectee");
			selectees.each(function() {
				var $this = $(this),
					pos = $this.offset();
				$.data(this, "selectable-item", {
					element: this,
					$element: $this,
					left: pos.left,
					top: pos.top,
					right: pos.left + $this.outerWidth(),
					bottom: pos.top + $this.outerHeight(),
					startselected: false,
					selected: $this.hasClass("ui-selected"),
					selecting: $this.hasClass("ui-selecting"),
					unselecting: $this.hasClass("ui-unselecting")
				});
			});
		};
		this.refresh();

		this.selectees = selectees.addClass("ui-selectee");

		this._mouseInit();

		this.helper = $("<div class='ui-selectable-helper'></div>");
	},

	_destroy: function() {
		this.selectees
			.removeClass("ui-selectee")
			.removeData("selectable-item");
		this.element
			.removeClass("ui-selectable ui-selectable-disabled");
		this._mouseDestroy();
	},

	_mouseStart: function(event) {
		var that = this,
			options = this.options;

		this.opos = [ event.pageX, event.pageY ];

		if (this.options.disabled) {
			return;
		}

		this.selectees = $(options.filter, this.element[0]);

		this._trigger("start", event);

		$(options.appendTo).append(this.helper);
		// position helper (lasso)
		this.helper.css({
			"left": event.pageX,
			"top": event.pageY,
			"width": 0,
			"height": 0
		});

		if (options.autoRefresh) {
			this.refresh();
		}

		this.selectees.filter(".ui-selected").each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.startselected = true;
			if (!event.metaKey && !event.ctrlKey) {
				selectee.$element.removeClass("ui-selected");
				selectee.selected = false;
				selectee.$element.addClass("ui-unselecting");
				selectee.unselecting = true;
				// selectable UNSELECTING callback
				that._trigger("unselecting", event, {
					unselecting: selectee.element
				});
			}
		});

		$(event.target).parents().addBack().each(function() {
			var doSelect,
				selectee = $.data(this, "selectable-item");
			if (selectee) {
				doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass("ui-selected");
				selectee.$element
					.removeClass(doSelect ? "ui-unselecting" : "ui-selected")
					.addClass(doSelect ? "ui-selecting" : "ui-unselecting");
				selectee.unselecting = !doSelect;
				selectee.selecting = doSelect;
				selectee.selected = doSelect;
				// selectable (UN)SELECTING callback
				if (doSelect) {
					that._trigger("selecting", event, {
						selecting: selectee.element
					});
				} else {
					that._trigger("unselecting", event, {
						unselecting: selectee.element
					});
				}
				return false;
			}
		});

	},

	_mouseDrag: function(event) {

		this.dragged = true;

		if (this.options.disabled) {
			return;
		}

		var tmp,
			that = this,
			options = this.options,
			x1 = this.opos[0],
			y1 = this.opos[1],
			x2 = event.pageX,
			y2 = event.pageY;

		if (x1 > x2) { tmp = x2; x2 = x1; x1 = tmp; }
		if (y1 > y2) { tmp = y2; y2 = y1; y1 = tmp; }
		this.helper.css({ left: x1, top: y1, width: x2 - x1, height: y2 - y1 });

		this.selectees.each(function() {
			var selectee = $.data(this, "selectable-item"),
				hit = false;

			//prevent helper from being selected if appendTo: selectable
			if (!selectee || selectee.element === that.element[0]) {
				return;
			}

			if (options.tolerance === "touch") {
				hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );
			} else if (options.tolerance === "fit") {
				hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
			}

			if (hit) {
				// SELECT
				if (selectee.selected) {
					selectee.$element.removeClass("ui-selected");
					selectee.selected = false;
				}
				if (selectee.unselecting) {
					selectee.$element.removeClass("ui-unselecting");
					selectee.unselecting = false;
				}
				if (!selectee.selecting) {
					selectee.$element.addClass("ui-selecting");
					selectee.selecting = true;
					// selectable SELECTING callback
					that._trigger("selecting", event, {
						selecting: selectee.element
					});
				}
			} else {
				// UNSELECT
				if (selectee.selecting) {
					if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
						selectee.$element.removeClass("ui-selecting");
						selectee.selecting = false;
						selectee.$element.addClass("ui-selected");
						selectee.selected = true;
					} else {
						selectee.$element.removeClass("ui-selecting");
						selectee.selecting = false;
						if (selectee.startselected) {
							selectee.$element.addClass("ui-unselecting");
							selectee.unselecting = true;
						}
						// selectable UNSELECTING callback
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
				if (selectee.selected) {
					if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
						selectee.$element.removeClass("ui-selected");
						selectee.selected = false;

						selectee.$element.addClass("ui-unselecting");
						selectee.unselecting = true;
						// selectable UNSELECTING callback
						that._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
			}
		});

		return false;
	},

	_mouseStop: function(event) {
		var that = this;

		this.dragged = false;

		$(".ui-unselecting", this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass("ui-unselecting");
			selectee.unselecting = false;
			selectee.startselected = false;
			that._trigger("unselected", event, {
				unselected: selectee.element
			});
		});
		$(".ui-selecting", this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
			selectee.selecting = false;
			selectee.selected = true;
			selectee.startselected = true;
			that._trigger("selected", event, {
				selected: selectee.element
			});
		});
		this._trigger("stop", event);

		this.helper.remove();

		return false;
	}

});


/*!
 * jQuery UI Selectmenu 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/selectmenu
 */


var selectmenu = $.widget( "ui.selectmenu", {
	version: "1.11.0",
	defaultElement: "<select>",
	options: {
		appendTo: null,
		disabled: null,
		icons: {
			button: "ui-icon-triangle-1-s"
		},
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		width: null,

		// callbacks
		change: null,
		close: null,
		focus: null,
		open: null,
		select: null
	},

	_create: function() {
		var selectmenuId = this.element.uniqueId().attr( "id" );
		this.ids = {
			element: selectmenuId,
			button: selectmenuId + "-button",
			menu: selectmenuId + "-menu"
		};

		this._drawButton();
		this._drawMenu();

		if ( this.options.disabled ) {
			this.disable();
		}
	},

	_drawButton: function() {
		var that = this,
			tabindex = this.element.attr( "tabindex" );

		// Associate existing label with the new button
		this.label = $( "label[for='" + this.ids.element + "']" ).attr( "for", this.ids.button );
		this._on( this.label, {
			click: function( event ) {
				this.button.focus();
				event.preventDefault();
			}
		});

		// Hide original select element
		this.element.hide();

		// Create button
		this.button = $( "<span>", {
			"class": "ui-selectmenu-button ui-widget ui-state-default ui-corner-all",
			tabindex: tabindex || this.options.disabled ? -1 : 0,
			id: this.ids.button,
			role: "combobox",
			"aria-expanded": "false",
			"aria-autocomplete": "list",
			"aria-owns": this.ids.menu,
			"aria-haspopup": "true"
		})
			.insertAfter( this.element );

		$( "<span>", {
			"class": "ui-icon " + this.options.icons.button
		})
			.prependTo( this.button );

		this.buttonText = $( "<span>", {
			"class": "ui-selectmenu-text"
		})
			.appendTo( this.button );

		this._setText( this.buttonText, this.element.find( "option:selected" ).text() );
		this._setOption( "width", this.options.width );

		this._on( this.button, this._buttonEvents );
		this.button.one( "focusin", function() {

			// Delay rendering the menu items until the button receives focus.
			// The menu may have already been rendered via a programmatic open.
			if ( !that.menuItems ) {
				that._refreshMenu();
			}
		});
		this._hoverable( this.button );
		this._focusable( this.button );
	},

	_drawMenu: function() {
		var that = this;

		// Create menu
		this.menu = $( "<ul>", {
			"aria-hidden": "true",
			"aria-labelledby": this.ids.button,
			id: this.ids.menu
		});

		// Wrap menu
		this.menuWrap = $( "<div>", {
			"class": "ui-selectmenu-menu ui-front"
		})
			.append( this.menu )
			.appendTo( this._appendTo() );

		// Initialize menu widget
		this.menuInstance = this.menu
			.menu({
				role: "listbox",
				select: function( event, ui ) {
					event.preventDefault();
					that._select( ui.item.data( "ui-selectmenu-item" ), event );
				},
				focus: function( event, ui ) {
					var item = ui.item.data( "ui-selectmenu-item" );

					// Prevent inital focus from firing and check if its a newly focused item
					if ( that.focusIndex != null && item.index !== that.focusIndex ) {
						that._trigger( "focus", event, { item: item } );
						if ( !that.isOpen ) {
							that._select( item, event );
						}
					}
					that.focusIndex = item.index;

					that.button.attr( "aria-activedescendant",
						that.menuItems.eq( item.index ).attr( "id" ) );
				}
			})
			.menu( "instance" );

		// Adjust menu styles to dropdown
		this.menu
			.addClass( "ui-corner-bottom" )
			.removeClass( "ui-corner-all" );

		// Don't close the menu on mouseleave
		this.menuInstance._off( this.menu, "mouseleave" );

		// Cancel the menu's collapseAll on document click
		this.menuInstance._closeOnDocumentClick = function() {
			return false;
		};

		// Selects often contain empty items, but never contain dividers
		this.menuInstance._isDivider = function() {
			return false;
		};
	},

	refresh: function() {
		this._refreshMenu();
		this._setText( this.buttonText, this._getSelectedItem().text() );
		this._setOption( "width", this.options.width );
	},

	_refreshMenu: function() {
		this.menu.empty();

		var item,
			options = this.element.find( "option" );

		if ( !options.length ) {
			return;
		}

		this._parseOptions( options );
		this._renderMenu( this.menu, this.items );

		this.menuInstance.refresh();
		this.menuItems = this.menu.find( "li" ).not( ".ui-selectmenu-optgroup" );

		item = this._getSelectedItem();

		// Update the menu to have the correct item focused
		this.menuInstance.focus( null, item );
		this._setAria( item.data( "ui-selectmenu-item" ) );

		// Set disabled state
		this._setOption( "disabled", this.element.prop( "disabled" ) );
	},

	open: function( event ) {
		if ( this.options.disabled ) {
			return;
		}

		// If this is the first time the menu is being opened, render the items
		if ( !this.menuItems ) {
			this._refreshMenu();
		} else {

			// Menu clears focus on close, reset focus to selected item
			this.menu.find( ".ui-state-focus" ).removeClass( "ui-state-focus" );
			this.menuInstance.focus( null, this._getSelectedItem() );
		}

		this.isOpen = true;
		this._toggleAttr();
		this._resizeMenu();
		this._position();

		this._on( this.document, this._documentClick );

		this._trigger( "open", event );
	},

	_position: function() {
		this.menuWrap.position( $.extend( { of: this.button }, this.options.position ) );
	},

	close: function( event ) {
		if ( !this.isOpen ) {
			return;
		}

		this.isOpen = false;
		this._toggleAttr();

		this._off( this.document );

		this._trigger( "close", event );
	},

	widget: function() {
		return this.button;
	},

	menuWidget: function() {
		return this.menu;
	},

	_renderMenu: function( ul, items ) {
		var that = this,
			currentOptgroup = "";

		$.each( items, function( index, item ) {
			if ( item.optgroup !== currentOptgroup ) {
				$( "<li>", {
					"class": "ui-selectmenu-optgroup ui-menu-divider" +
						( item.element.parent( "optgroup" ).prop( "disabled" ) ?
							" ui-state-disabled" :
							"" ),
					text: item.optgroup
				})
					.appendTo( ul );

				currentOptgroup = item.optgroup;
			}

			that._renderItemData( ul, item );
		});
	},

	_renderItemData: function( ul, item ) {
		return this._renderItem( ul, item ).data( "ui-selectmenu-item", item );
	},

	_renderItem: function( ul, item ) {
		var li = $( "<li>" );

		if ( item.disabled ) {
			li.addClass( "ui-state-disabled" );
		}
		this._setText( li, item.label );

		return li.appendTo( ul );
	},

	_setText: function( element, value ) {
		if ( value ) {
			element.text( value );
		} else {
			element.html( "&#160;" );
		}
	},

	_move: function( direction, event ) {
		var item, next,
			filter = ".ui-menu-item";

		if ( this.isOpen ) {
			item = this.menuItems.eq( this.focusIndex );
		} else {
			item = this.menuItems.eq( this.element[ 0 ].selectedIndex );
			filter += ":not(.ui-state-disabled)";
		}

		if ( direction === "first" || direction === "last" ) {
			next = item[ direction === "first" ? "prevAll" : "nextAll" ]( filter ).eq( -1 );
		} else {
			next = item[ direction + "All" ]( filter ).eq( 0 );
		}

		if ( next.length ) {
			this.menuInstance.focus( event, next );
		}
	},

	_getSelectedItem: function() {
		return this.menuItems.eq( this.element[ 0 ].selectedIndex );
	},

	_toggle: function( event ) {
		this[ this.isOpen ? "close" : "open" ]( event );
	},

	_documentClick: {
		mousedown: function( event ) {
			if ( !this.isOpen ) {
				return;
			}

			if ( !$( event.target ).closest( ".ui-selectmenu-menu, #" + this.ids.button ).length ) {
				this.close( event );
			}
		}
	},

	_buttonEvents: {
		click: "_toggle",
		keydown: function( event ) {
			var preventDefault = true;
			switch ( event.keyCode ) {
				case $.ui.keyCode.TAB:
				case $.ui.keyCode.ESCAPE:
					this.close( event );
					preventDefault = false;
					break;
				case $.ui.keyCode.ENTER:
					if ( this.isOpen ) {
						this._selectFocusedItem( event );
					}
					break;
				case $.ui.keyCode.UP:
					if ( event.altKey ) {
						this._toggle( event );
					} else {
						this._move( "prev", event );
					}
					break;
				case $.ui.keyCode.DOWN:
					if ( event.altKey ) {
						this._toggle( event );
					} else {
						this._move( "next", event );
					}
					break;
				case $.ui.keyCode.SPACE:
					if ( this.isOpen ) {
						this._selectFocusedItem( event );
					} else {
						this._toggle( event );
					}
					break;
				case $.ui.keyCode.LEFT:
					this._move( "prev", event );
					break;
				case $.ui.keyCode.RIGHT:
					this._move( "next", event );
					break;
				case $.ui.keyCode.HOME:
				case $.ui.keyCode.PAGE_UP:
					this._move( "first", event );
					break;
				case $.ui.keyCode.END:
				case $.ui.keyCode.PAGE_DOWN:
					this._move( "last", event );
					break;
				default:
					this.menu.trigger( event );
					preventDefault = false;
			}

			if ( preventDefault ) {
				event.preventDefault();
			}
		}
	},

	_selectFocusedItem: function( event ) {
		var item = this.menuItems.eq( this.focusIndex );
		if ( !item.hasClass( "ui-state-disabled" ) ) {
			this._select( item.data( "ui-selectmenu-item" ), event );
		}
	},

	_select: function( item, event ) {
		var oldIndex = this.element[ 0 ].selectedIndex;

		// Change native select element
		this.element[ 0 ].selectedIndex = item.index;
		this._setText( this.buttonText, item.label );
		this._setAria( item );
		this._trigger( "select", event, { item: item } );

		if ( item.index !== oldIndex ) {
			this._trigger( "change", event, { item: item } );
		}

		this.close( event );
	},

	_setAria: function( item ) {
		var id = this.menuItems.eq( item.index ).attr( "id" );

		this.button.attr({
			"aria-labelledby": id,
			"aria-activedescendant": id
		});
		this.menu.attr( "aria-activedescendant", id );
	},

	_setOption: function( key, value ) {
		if ( key === "icons" ) {
			this.button.find( "span.ui-icon" )
				.removeClass( this.options.icons.button )
				.addClass( value.button );
		}

		this._super( key, value );

		if ( key === "appendTo" ) {
			this.menuWrap.appendTo( this._appendTo() );
		}

		if ( key === "disabled" ) {
			this.menuInstance.option( "disabled", value );
			this.button
				.toggleClass( "ui-state-disabled", value )
				.attr( "aria-disabled", value );

			this.element.prop( "disabled", value );
			if ( value ) {
				this.button.attr( "tabindex", -1 );
				this.close();
			} else {
				this.button.attr( "tabindex", 0 );
			}
		}

		if ( key === "width" ) {
			if ( !value ) {
				value = this.element.outerWidth();
			}
			this.button.outerWidth( value );
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;

		if ( element ) {
			element = element.jquery || element.nodeType ?
				$( element ) :
				this.document.find( element ).eq( 0 );
		}

		if ( !element || !element[ 0 ] ) {
			element = this.element.closest( ".ui-front" );
		}

		if ( !element.length ) {
			element = this.document[ 0 ].body;
		}

		return element;
	},

	_toggleAttr: function() {
		this.button
			.toggleClass( "ui-corner-top", this.isOpen )
			.toggleClass( "ui-corner-all", !this.isOpen )
			.attr( "aria-expanded", this.isOpen );
		this.menuWrap.toggleClass( "ui-selectmenu-open", this.isOpen );
		this.menu.attr( "aria-hidden", !this.isOpen );
	},

	_resizeMenu: function() {
		this.menu.outerWidth( Math.max(
			this.button.outerWidth(),

			// support: IE10
			// IE10 wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping
			this.menu.width( "" ).outerWidth() + 1
		) );
	},

	_getCreateOptions: function() {
		return { disabled: this.element.prop( "disabled" ) };
	},

	_parseOptions: function( options ) {
		var data = [];
		options.each(function( index, item ) {
			var option = $( item ),
				optgroup = option.parent( "optgroup" );
			data.push({
				element: option,
				index: index,
				value: option.attr( "value" ),
				label: option.text(),
				optgroup: optgroup.attr( "label" ) || "",
				disabled: optgroup.prop( "disabled" ) || option.prop( "disabled" )
			});
		});
		this.items = data;
	},

	_destroy: function() {
		this.menuWrap.remove();
		this.button.remove();
		this.element.show();
		this.element.removeUniqueId();
		this.label.attr( "for", this.ids.element );
	}
});


/*!
 * jQuery UI Slider 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/slider/
 */


var slider = $.widget( "ui.slider", $.ui.mouse, {
	version: "1.11.0",
	widgetEventPrefix: "slide",

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null,

		// callbacks
		change: null,
		slide: null,
		start: null,
		stop: null
	},

	// number of pages in a slider
	// (how many times can you page up/down to go through the whole range)
	numPages: 5,

	_create: function() {
		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();

		this.element
			.addClass( "ui-slider" +
				" ui-slider-" + this.orientation +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all");

		this._refresh();
		this._setOption( "disabled", this.options.disabled );

		this._animateOff = false;
	},

	_refresh: function() {
		this._createRange();
		this._createHandles();
		this._setupEvents();
		this._refreshValue();
	},

	_createHandles: function() {
		var i, handleCount,
			options = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
			handle = "<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>",
			handles = [];

		handleCount = ( options.values && options.values.length ) || 1;

		if ( existingHandles.length > handleCount ) {
			existingHandles.slice( handleCount ).remove();
			existingHandles = existingHandles.slice( 0, handleCount );
		}

		for ( i = existingHandles.length; i < handleCount; i++ ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

		this.handle = this.handles.eq( 0 );

		this.handles.each(function( i ) {
			$( this ).data( "ui-slider-handle-index", i );
		});
	},

	_createRange: function() {
		var options = this.options,
			classes = "";

		if ( options.range ) {
			if ( options.range === true ) {
				if ( !options.values ) {
					options.values = [ this._valueMin(), this._valueMin() ];
				} else if ( options.values.length && options.values.length !== 2 ) {
					options.values = [ options.values[0], options.values[0] ];
				} else if ( $.isArray( options.values ) ) {
					options.values = options.values.slice(0);
				}
			}

			if ( !this.range || !this.range.length ) {
				this.range = $( "<div></div>" )
					.appendTo( this.element );

				classes = "ui-slider-range" +
				// note: this isn't the most fittingly semantic framework class for this element,
				// but worked best visually with a variety of themes
				" ui-widget-header ui-corner-all";
			} else {
				this.range.removeClass( "ui-slider-range-min ui-slider-range-max" )
					// Handle range switching from true to min/max
					.css({
						"left": "",
						"bottom": ""
					});
			}

			this.range.addClass( classes +
				( ( options.range === "min" || options.range === "max" ) ? " ui-slider-range-" + options.range : "" ) );
		} else {
			if ( this.range ) {
				this.range.remove();
			}
			this.range = null;
		}
	},

	_setupEvents: function() {
		this._off( this.handles );
		this._on( this.handles, this._handleEvents );
		this._hoverable( this.handles );
		this._focusable( this.handles );
	},

	_destroy: function() {
		this.handles.remove();
		if ( this.range ) {
			this.range.remove();
		}

		this.element
			.removeClass( "ui-slider" +
				" ui-slider-horizontal" +
				" ui-slider-vertical" +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" );

		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
			that = this,
			o = this.options;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - that.values(i) );
			if (( distance > thisDistance ) ||
				( distance === thisDistance &&
					(i === that._lastChangedValue || that.values(i) === o.min ))) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		this._handleIndex = index;

		closestHandle
			.addClass( "ui-state-active" )
			.focus();

		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
				( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
				( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function() {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );

		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},

	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( "start", event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values && this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 && this.options.range === true ) &&
					( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( "stop", event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			//store the last changed value index for reference when handles overlap
			this._lastChangedValue = index;

			this._trigger( "change", event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values && this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( key === "range" && this.options.range === true ) {
			if ( value === "min" ) {
				this.options.value = this._values( 0 );
				this.options.values = null;
			} else if ( value === "max" ) {
				this.options.value = this._values( this.options.values.length - 1 );
				this.options.values = null;
			}
		}

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		if ( key === "disabled" ) {
			this.element.toggleClass( "ui-state-disabled", !!value );
		}

		this._super( key, value );

		switch ( key ) {
			case "orientation":
				this._detectOrientation();
				this.element
					.removeClass( "ui-slider-horizontal ui-slider-vertical" )
					.addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i < valsLength; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
			case "min":
			case "max":
				this._animateOff = true;
				this._refreshValue();
				this._animateOff = false;
				break;
			case "range":
				this._animateOff = true;
				this._refresh();
				this._animateOff = false;
				break;
		}
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else if ( this.options.values && this.options.values.length ) {
			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i+= 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		} else {
			return [];
		}
	},

	// returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = (val - this._valueMin()) % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.options.max;
	},

	_refreshValue: function() {
		var lastValPercent, valPercent, value, valueMin, valueMax,
			oRange = this.options.range,
			o = this.options,
			that = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			_set = {};

		if ( this.options.values && this.options.values.length ) {
			this.handles.each(function( i ) {
				valPercent = ( that.values(i) - that._valueMin() ) / ( that._valueMax() - that._valueMin() ) * 100;
				_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( that.options.range === true ) {
					if ( that.orientation === "horizontal" ) {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
		}
	},

	_handleEvents: {
		keydown: function( event ) {
			var allowed, curVal, newVal, step,
				index = $( event.target ).data( "ui-slider-handle-index" );

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
				case $.ui.keyCode.END:
				case $.ui.keyCode.PAGE_UP:
				case $.ui.keyCode.PAGE_DOWN:
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					event.preventDefault();
					if ( !this._keySliding ) {
						this._keySliding = true;
						$( event.target ).addClass( "ui-state-active" );
						allowed = this._start( event, index );
						if ( allowed === false ) {
							return;
						}
					}
					break;
			}

			step = this.options.step;
			if ( this.options.values && this.options.values.length ) {
				curVal = newVal = this.values( index );
			} else {
				curVal = newVal = this.value();
			}

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
					newVal = this._valueMin();
					break;
				case $.ui.keyCode.END:
					newVal = this._valueMax();
					break;
				case $.ui.keyCode.PAGE_UP:
					newVal = this._trimAlignValue(
						curVal + ( ( this._valueMax() - this._valueMin() ) / this.numPages )
					);
					break;
				case $.ui.keyCode.PAGE_DOWN:
					newVal = this._trimAlignValue(
						curVal - ( (this._valueMax() - this._valueMin()) / this.numPages ) );
					break;
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
					if ( curVal === this._valueMax() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal + step );
					break;
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					if ( curVal === this._valueMin() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal - step );
					break;
			}

			this._slide( event, index, newVal );
		},
		keyup: function( event ) {
			var index = $( event.target ).data( "ui-slider-handle-index" );

			if ( this._keySliding ) {
				this._keySliding = false;
				this._stop( event, index );
				this._change( event, index );
				$( event.target ).removeClass( "ui-state-active" );
			}
		}
	}
});


/*!
 * jQuery UI Sortable 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/sortable/
 */


var sortable = $.widget("ui.sortable", $.ui.mouse, {
	version: "1.11.0",
	widgetEventPrefix: "sort",
	ready: false,
	options: {
		appendTo: "parent",
		axis: false,
		connectWith: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: "original",
		items: "> *",
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: "default",
		tolerance: "intersect",
		zIndex: 1000,

		// callbacks
		activate: null,
		beforeStop: null,
		change: null,
		deactivate: null,
		out: null,
		over: null,
		receive: null,
		remove: null,
		sort: null,
		start: null,
		stop: null,
		update: null
	},

	_isOverAxis: function( x, reference, size ) {
		return ( x >= reference ) && ( x < ( reference + size ) );
	},

	_isFloating: function( item ) {
		return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));
	},

	_create: function() {

		var o = this.options;
		this.containerCache = {};
		this.element.addClass("ui-sortable");

		//Get the items
		this.refresh();

		//Let's determine if the items are being displayed horizontally
		this.floating = this.items.length ? o.axis === "x" || this._isFloating(this.items[0].item) : false;

		//Let's determine the parent's offset
		this.offset = this.element.offset();

		//Initialize mouse events for interaction
		this._mouseInit();

		this._setHandleClassName();

		//We're ready to go
		this.ready = true;

	},

	_setOption: function( key, value ) {
		this._super( key, value );

		if ( key === "handle" ) {
			this._setHandleClassName();
		}
	},

	_setHandleClassName: function() {
		this.element.find( ".ui-sortable-handle" ).removeClass( "ui-sortable-handle" );
		$.each( this.items, function() {
			( this.instance.options.handle ?
				this.item.find( this.instance.options.handle ) : this.item )
				.addClass( "ui-sortable-handle" );
		});
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-sortable ui-sortable-disabled" )
			.find( ".ui-sortable-handle" )
				.removeClass( "ui-sortable-handle" );
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i >= 0; i-- ) {
			this.items[i].item.removeData(this.widgetName + "-item");
		}

		return this;
	},

	_mouseCapture: function(event, overrideHandle) {
		var currentItem = null,
			validHandle = false,
			that = this;

		if (this.reverting) {
			return false;
		}

		if(this.options.disabled || this.options.type === "static") {
			return false;
		}

		//We have to refresh the items data once first
		this._refreshItems(event);

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		$(event.target).parents().each(function() {
			if($.data(this, that.widgetName + "-item") === that) {
				currentItem = $(this);
				return false;
			}
		});
		if($.data(event.target, that.widgetName + "-item") === that) {
			currentItem = $(event.target);
		}

		if(!currentItem) {
			return false;
		}
		if(this.options.handle && !overrideHandle) {
			$(this.options.handle, currentItem).find("*").addBack().each(function() {
				if(this === event.target) {
					validHandle = true;
				}
			});
			if(!validHandle) {
				return false;
			}
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function(event, overrideHandle, noActivation) {

		var i, body,
			o = this.options;

		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
		this.refreshPositions();

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		// Only after we got the offset, we can change the helper's position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css("position", "absolute");
		this.cssPosition = this.helper.css("position");

		//Generate the original position
		this.originalPosition = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Cache the former DOM position
		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

		//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
		if(this.helper[0] !== this.currentItem[0]) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Set a containment if given in the options
		if(o.containment) {
			this._setContainment();
		}

		if( o.cursor && o.cursor !== "auto" ) { // cursor option
			body = this.document.find( "body" );

			// support: IE
			this.storedCursor = body.css( "cursor" );
			body.css( "cursor", o.cursor );

			this.storedStylesheet = $( "<style>*{ cursor: "+o.cursor+" !important; }</style>" ).appendTo( body );
		}

		if(o.opacity) { // opacity option
			if (this.helper.css("opacity")) {
				this._storedOpacity = this.helper.css("opacity");
			}
			this.helper.css("opacity", o.opacity);
		}

		if(o.zIndex) { // zIndex option
			if (this.helper.css("zIndex")) {
				this._storedZIndex = this.helper.css("zIndex");
			}
			this.helper.css("zIndex", o.zIndex);
		}

		//Prepare scrolling
		if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
			this.overflowOffset = this.scrollParent.offset();
		}

		//Call callbacks
		this._trigger("start", event, this._uiHash());

		//Recache the helper size
		if(!this._preserveHelperProportions) {
			this._cacheHelperProportions();
		}


		//Post "activate" events to possible containers
		if( !noActivation ) {
			for ( i = this.containers.length - 1; i >= 0; i-- ) {
				this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
			}
		}

		//Prepare possible droppables
		if($.ui.ddmanager) {
			$.ui.ddmanager.current = this;
		}

		if ($.ui.ddmanager && !o.dropBehaviour) {
			$.ui.ddmanager.prepareOffsets(this, event);
		}

		this.dragging = true;

		this.helper.addClass("ui-sortable-helper");
		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		return true;

	},

	_mouseDrag: function(event) {
		var i, item, itemElement, intersection,
			o = this.options,
			scrolled = false;

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		if (!this.lastPositionAbs) {
			this.lastPositionAbs = this.positionAbs;
		}

		//Do scrolling
		if(this.options.scroll) {
			if(this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {

				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
				} else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
				}

				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
				} else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
				}

			} else {

				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				} else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
				}

				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				} else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
				}

			}

			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
				$.ui.ddmanager.prepareOffsets(this, event);
			}
		}

		//Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo("absolute");

		//Set the helper position
		if(!this.options.axis || this.options.axis !== "y") {
			this.helper[0].style.left = this.position.left+"px";
		}
		if(!this.options.axis || this.options.axis !== "x") {
			this.helper[0].style.top = this.position.top+"px";
		}

		//Rearrange
		for (i = this.items.length - 1; i >= 0; i--) {

			//Cache variables and intersection, continue if no intersection
			item = this.items[i];
			itemElement = item.item[0];
			intersection = this._intersectsWithPointer(item);
			if (!intersection) {
				continue;
			}

			// Only put the placeholder inside the current Container, skip all
			// items from other containers. This works because when moving
			// an item from one container to another the
			// currentContainer is switched before the placeholder is moved.
			//
			// Without this, moving items in "sub-sortables" can cause
			// the placeholder to jitter between the outer and inner container.
			if (item.instance !== this.currentContainer) {
				continue;
			}

			// cannot intersect with itself
			// no useless actions that have been done before
			// no action if the item moved is the parent of the item checked
			if (itemElement !== this.currentItem[0] &&
				this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement &&
				!$.contains(this.placeholder[0], itemElement) &&
				(this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)
			) {

				this.direction = intersection === 1 ? "down" : "up";

				if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
					this._rearrange(event, item);
				} else {
					break;
				}

				this._trigger("change", event, this._uiHash());
				break;
			}
		}

		//Post events to containers
		this._contactContainers(event);

		//Interconnect with droppables
		if($.ui.ddmanager) {
			$.ui.ddmanager.drag(this, event);
		}

		//Call callbacks
		this._trigger("sort", event, this._uiHash());

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function(event, noPropagation) {

		if(!event) {
			return;
		}

		//If we are using droppables, inform the manager about the drop
		if ($.ui.ddmanager && !this.options.dropBehaviour) {
			$.ui.ddmanager.drop(this, event);
		}

		if(this.options.revert) {
			var that = this,
				cur = this.placeholder.offset(),
				axis = this.options.axis,
				animation = {};

			if ( !axis || axis === "x" ) {
				animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft);
			}
			if ( !axis || axis === "y" ) {
				animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop);
			}
			this.reverting = true;
			$(this.helper).animate( animation, parseInt(this.options.revert, 10) || 500, function() {
				that._clear(event);
			});
		} else {
			this._clear(event, noPropagation);
		}

		return false;

	},

	cancel: function() {

		if(this.dragging) {

			this._mouseUp({ target: null });

			if(this.options.helper === "original") {
				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
			} else {
				this.currentItem.show();
			}

			//Post deactivating events to containers
			for (var i = this.containers.length - 1; i >= 0; i--){
				this.containers[i]._trigger("deactivate", null, this._uiHash(this));
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", null, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		if (this.placeholder) {
			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			if(this.placeholder[0].parentNode) {
				this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
			}
			if(this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
				this.helper.remove();
			}

			$.extend(this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			});

			if(this.domPosition.prev) {
				$(this.domPosition.prev).after(this.currentItem);
			} else {
				$(this.domPosition.parent).prepend(this.currentItem);
			}
		}

		return this;

	},

	serialize: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected),
			str = [];
		o = o || {};

		$(items).each(function() {
			var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
			if (res) {
				str.push((o.key || res[1]+"[]")+"="+(o.key && o.expression ? res[1] : res[2]));
			}
		});

		if(!str.length && o.key) {
			str.push(o.key + "=");
		}

		return str.join("&");

	},

	toArray: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected),
			ret = [];

		o = o || {};

		items.each(function() { ret.push($(o.item || this).attr(o.attribute || "id") || ""); });
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function(item) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height,
			l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height,
			dyClick = this.offset.click.top,
			dxClick = this.offset.click.left,
			isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t && ( y1 + dyClick ) < b ),
			isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l && ( x1 + dxClick ) < r ),
			isOverElement = isOverElementHeight && isOverElementWidth;

		if ( this.options.tolerance === "pointer" ||
			this.options.forcePointerForContainers ||
			(this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])
		) {
			return isOverElement;
		} else {

			return (l < x1 + (this.helperProportions.width / 2) && // Right Half
				x2 - (this.helperProportions.width / 2) < r && // Left Half
				t < y1 + (this.helperProportions.height / 2) && // Bottom Half
				y2 - (this.helperProportions.height / 2) < b ); // Top Half

		}
	},

	_intersectsWithPointer: function(item) {

		var isOverElementHeight = (this.options.axis === "x") || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
			isOverElementWidth = (this.options.axis === "y") || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
			isOverElement = isOverElementHeight && isOverElementWidth,
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (!isOverElement) {
			return false;
		}

		return this.floating ?
			( ((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1 )
			: ( verticalDirection && (verticalDirection === "down" ? 2 : 1) );

	},

	_intersectsWithSides: function(item) {

		var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
			isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (this.floating && horizontalDirection) {
			return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
		} else {
			return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta !== 0 && (delta > 0 ? "down" : "up");
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta !== 0 && (delta > 0 ? "right" : "left");
	},

	refresh: function(event) {
		this._refreshItems(event);
		this._setHandleClassName();
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
	},

	_getItemsAsjQuery: function(connected) {

		var i, j, cur, inst,
			items = [],
			queries = [],
			connectWith = this._connectWith();

		if(connectWith && connected) {
			for (i = connectWith.length - 1; i >= 0; i--){
				cur = $(connectWith[i]);
				for ( j = cur.length - 1; j >= 0; j--){
					inst = $.data(cur[j], this.widgetFullName);
					if(inst && inst !== this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
					}
				}
			}
		}

		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);

		function addItems() {
			items.push( this );
		}
		for (i = queries.length - 1; i >= 0; i--){
			queries[i][0].each( addItems );
		}

		return $(items);

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

		this.items = $.grep(this.items, function (item) {
			for (var j=0; j < list.length; j++) {
				if(list[j] === item.item[0]) {
					return false;
				}
			}
			return true;
		});

	},

	_refreshItems: function(event) {

		this.items = [];
		this.containers = [this];

		var i, j, cur, inst, targetData, _queries, item, queriesLength,
			items = this.items,
			queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]],
			connectWith = this._connectWith();

		if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
			for (i = connectWith.length - 1; i >= 0; i--){
				cur = $(connectWith[i]);
				for (j = cur.length - 1; j >= 0; j--){
					inst = $.data(cur[j], this.widgetFullName);
					if(inst && inst !== this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
						this.containers.push(inst);
					}
				}
			}
		}

		for (i = queries.length - 1; i >= 0; i--) {
			targetData = queries[i][1];
			_queries = queries[i][0];

			for (j=0, queriesLength = _queries.length; j < queriesLength; j++) {
				item = $(_queries[j]);

				item.data(this.widgetName + "-item", targetData); // Data for target checking (mouse manager)

				items.push({
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				});
			}
		}

	},

	refreshPositions: function(fast) {

		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
		if(this.offsetParent && this.helper) {
			this.offset.parent = this._getParentOffset();
		}

		var i, item, t, p;

		for (i = this.items.length - 1; i >= 0; i--){
			item = this.items[i];

			//We ignore calculating positions of all connected containers when we're not over them
			if(item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
				continue;
			}

			t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

			if (!fast) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			p = t.offset();
			item.left = p.left;
			item.top = p.top;
		}

		if(this.options.custom && this.options.custom.refreshContainers) {
			this.options.custom.refreshContainers.call(this);
		} else {
			for (i = this.containers.length - 1; i >= 0; i--){
				p = this.containers[i].element.offset();
				this.containers[i].containerCache.left = p.left;
				this.containers[i].containerCache.top = p.top;
				this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
			}
		}

		return this;
	},

	_createPlaceholder: function(that) {
		that = that || this;
		var className,
			o = that.options;

		if(!o.placeholder || o.placeholder.constructor === String) {
			className = o.placeholder;
			o.placeholder = {
				element: function() {

					var nodeName = that.currentItem[0].nodeName.toLowerCase(),
						element = $( "<" + nodeName + ">", that.document[0] )
							.addClass(className || that.currentItem[0].className+" ui-sortable-placeholder")
							.removeClass("ui-sortable-helper");

					if ( nodeName === "tr" ) {
						that.currentItem.children().each(function() {
							$( "<td>&#160;</td>", that.document[0] )
								.attr( "colspan", $( this ).attr( "colspan" ) || 1 )
								.appendTo( element );
						});
					} else if ( nodeName === "img" ) {
						element.attr( "src", that.currentItem.attr( "src" ) );
					}

					if ( !className ) {
						element.css( "visibility", "hidden" );
					}

					return element;
				},
				update: function(container, p) {

					// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
					if(className && !o.forcePlaceholderSize) {
						return;
					}

					//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
					if(!p.height()) { p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop")||0, 10) - parseInt(that.currentItem.css("paddingBottom")||0, 10)); }
					if(!p.width()) { p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft")||0, 10) - parseInt(that.currentItem.css("paddingRight")||0, 10)); }
				}
			};
		}

		//Create the placeholder
		that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));

		//Append it after the actual current item
		that.currentItem.after(that.placeholder);

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update(that, that.placeholder);

	},

	_contactContainers: function(event) {
		var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom, floating, axis,
			innermostContainer = null,
			innermostIndex = null;

		// get innermost container that intersects with item
		for (i = this.containers.length - 1; i >= 0; i--) {

			// never consider a container that's located within the item itself
			if($.contains(this.currentItem[0], this.containers[i].element[0])) {
				continue;
			}

			if(this._intersectsWith(this.containers[i].containerCache)) {

				// if we've already found a container and it's more "inner" than this, then continue
				if(innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
					continue;
				}

				innermostContainer = this.containers[i];
				innermostIndex = i;

			} else {
				// container doesn't intersect. trigger "out" event if necessary
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", event, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		// if no intersecting containers found, return
		if(!innermostContainer) {
			return;
		}

		// move the item into the container if it's not there already
		if(this.containers.length === 1) {
			if (!this.containers[innermostIndex].containerCache.over) {
				this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
				this.containers[innermostIndex].containerCache.over = 1;
			}
		} else {

			//When entering a new container, we will find the item with the least distance and append our item near it
			dist = 10000;
			itemWithLeastDistance = null;
			floating = innermostContainer.floating || this._isFloating(this.currentItem);
			posProperty = floating ? "left" : "top";
			sizeProperty = floating ? "width" : "height";
			axis = floating ? "clientX" : "clientY";

			for (j = this.items.length - 1; j >= 0; j--) {
				if(!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
					continue;
				}
				if(this.items[j].item[0] === this.currentItem[0]) {
					continue;
				}

				cur = this.items[j].item.offset()[posProperty];
				nearBottom = false;
				if ( event[ axis ] - cur > this.items[ j ][ sizeProperty ] / 2 ) {
					nearBottom = true;
				}

				if ( Math.abs( event[ axis ] - cur ) < dist ) {
					dist = Math.abs( event[ axis ] - cur );
					itemWithLeastDistance = this.items[ j ];
					this.direction = nearBottom ? "up": "down";
				}
			}

			//Check if dropOnEmpty is enabled
			if(!itemWithLeastDistance && !this.options.dropOnEmpty) {
				return;
			}

			if(this.currentContainer === this.containers[innermostIndex]) {
				return;
			}

			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
			this._trigger("change", event, this._uiHash());
			this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
			this.currentContainer = this.containers[innermostIndex];

			//Update the placeholder
			this.options.placeholder.update(this.currentContainer, this.placeholder);

			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		}


	},

	_createHelper: function(event) {

		var o = this.options,
			helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);

		//Add the helper to the DOM if that didn't happen already
		if(!helper.parents("body").length) {
			$(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
		}

		if(helper[0] === this.currentItem[0]) {
			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };
		}

		if(!helper[0].style.width || o.forceHelperSize) {
			helper.width(this.currentItem.width());
		}
		if(!helper[0].style.height || o.forceHelperSize) {
			helper.height(this.currentItem.height());
		}

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj === "string") {
			obj = obj.split(" ");
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ("left" in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ("right" in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ("top" in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ("bottom" in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {


		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		// This needs to be actually done for all browsers, since pageX/pageY includes this information
		// with an ugly IE fix
		if( this.offsetParent[0] === document.body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition === "relative") {
			var p = this.currentItem.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var ce, co, over,
			o = this.options;
		if(o.containment === "parent") {
			o.containment = this.helper[0].parentNode;
		}
		if(o.containment === "document" || o.containment === "window") {
			this.containment = [
				0 - this.offset.relative.left - this.offset.parent.left,
				0 - this.offset.relative.top - this.offset.parent.top,
				$(o.containment === "document" ? document : window).width() - this.helperProportions.width - this.margins.left,
				($(o.containment === "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
			];
		}

		if(!(/^(document|window|parent)$/).test(o.containment)) {
			ce = $(o.containment)[0];
			co = $(o.containment).offset();
			over = ($(ce).css("overflow") !== "hidden");

			this.containment = [
				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) {
			pos = this.position;
		}
		var mod = d === "absolute" ? 1 : -1,
			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
			scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top	+																// The absolute mouse position
				this.offset.relative.top * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top * mod -											// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left +																// The absolute mouse position
				this.offset.relative.left * mod +										// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left * mod	-										// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var top, left,
			o = this.options,
			pageX = event.pageX,
			pageY = event.pageY,
			scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if(this.cssPosition === "relative" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {
			this.offset.relative = this._getRelativeOffset();
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options

			if(this.containment) {
				if(event.pageX - this.offset.click.left < this.containment[0]) {
					pageX = this.containment[0] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top < this.containment[1]) {
					pageY = this.containment[1] + this.offset.click.top;
				}
				if(event.pageX - this.offset.click.left > this.containment[2]) {
					pageX = this.containment[2] + this.offset.click.left;
				}
				if(event.pageY - this.offset.click.top > this.containment[3]) {
					pageY = this.containment[3] + this.offset.click.top;
				}
			}

			if(o.grid) {
				top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
				pageY = this.containment ? ( (top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
				pageX = this.containment ? ( (left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY -																// The absolute mouse position
				this.offset.click.top -													// Click offset (relative to the element)
				this.offset.relative.top	-											// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.top +												// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX -																// The absolute mouse position
				this.offset.click.left -												// Click offset (relative to the element)
				this.offset.relative.left	-											// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.parent.left +												// The offsetParent's offset without borders (offset + border)
				( ( this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_rearrange: function(event, i, a, hardRefresh) {

		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get's higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var counter = this.counter;

		this._delay(function() {
			if(counter === this.counter) {
				this.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
			}
		});

	},

	_clear: function(event, noPropagation) {

		this.reverting = false;
		// We delay all events that have to be triggered to after the point where the placeholder has been removed and
		// everything else normalized again
		var i,
			delayedTriggers = [];

		// We first have to update the dom position of the actual currentItem
		// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
		if(!this._noFinalSort && this.currentItem.parent().length) {
			this.placeholder.before(this.currentItem);
		}
		this._noFinalSort = null;

		if(this.helper[0] === this.currentItem[0]) {
			for(i in this._storedCSS) {
				if(this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
					this._storedCSS[i] = "";
				}
			}
			this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
		} else {
			this.currentItem.show();
		}

		if(this.fromOutside && !noPropagation) {
			delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
		}
		if((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
			delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
		}

		// Check if the items Container has Changed and trigger appropriate
		// events.
		if (this !== this.currentContainer) {
			if(!noPropagation) {
				delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
				delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.currentContainer));
				delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.currentContainer));
			}
		}


		//Post events to containers
		function delayEvent( type, instance, container ) {
			return function( event ) {
				container._trigger( type, event, instance._uiHash( instance ) );
			};
		}
		for (i = this.containers.length - 1; i >= 0; i--){
			if (!noPropagation) {
				delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );
			}
			if(this.containers[i].containerCache.over) {
				delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );
				this.containers[i].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if ( this.storedCursor ) {
			this.document.find( "body" ).css( "cursor", this.storedCursor );
			this.storedStylesheet.remove();
		}
		if(this._storedOpacity) {
			this.helper.css("opacity", this._storedOpacity);
		}
		if(this._storedZIndex) {
			this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
		}

		this.dragging = false;
		if(this.cancelHelperRemoval) {
			if(!noPropagation) {
				this._trigger("beforeStop", event, this._uiHash());
				for (i=0; i < delayedTriggers.length; i++) {
					delayedTriggers[i].call(this, event);
				} //Trigger all delayed events
				this._trigger("stop", event, this._uiHash());
			}

			this.fromOutside = false;
			return false;
		}

		if(!noPropagation) {
			this._trigger("beforeStop", event, this._uiHash());
		}

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

		if(this.helper[0] !== this.currentItem[0]) {
			this.helper.remove();
		}
		this.helper = null;

		if(!noPropagation) {
			for (i=0; i < delayedTriggers.length; i++) {
				delayedTriggers[i].call(this, event);
			} //Trigger all delayed events
			this._trigger("stop", event, this._uiHash());
		}

		this.fromOutside = false;
		return true;

	},

	_trigger: function() {
		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
			this.cancel();
		}
	},

	_uiHash: function(_inst) {
		var inst = _inst || this;
		return {
			helper: inst.helper,
			placeholder: inst.placeholder || $([]),
			position: inst.position,
			originalPosition: inst.originalPosition,
			offset: inst.positionAbs,
			item: inst.currentItem,
			sender: _inst ? _inst.element : null
		};
	}

});


/*!
 * jQuery UI Spinner 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/spinner/
 */


function spinner_modifier( fn ) {
	return function() {
		var previous = this.element.val();
		fn.apply( this, arguments );
		this._refresh();
		if ( previous !== this.element.val() ) {
			this._trigger( "change" );
		}
	};
}

var spinner = $.widget( "ui.spinner", {
	version: "1.11.0",
	defaultElement: "<input>",
	widgetEventPrefix: "spin",
	options: {
		culture: null,
		icons: {
			down: "ui-icon-triangle-1-s",
			up: "ui-icon-triangle-1-n"
		},
		incremental: true,
		max: null,
		min: null,
		numberFormat: null,
		page: 10,
		step: 1,

		change: null,
		spin: null,
		start: null,
		stop: null
	},

	_create: function() {
		// handle string values that need to be parsed
		this._setOption( "max", this.options.max );
		this._setOption( "min", this.options.min );
		this._setOption( "step", this.options.step );

		// Only format if there is a value, prevents the field from being marked
		// as invalid in Firefox, see #9573.
		if ( this.value() !== "" ) {
			// Format the value, but don't constrain.
			this._value( this.element.val(), true );
		}

		this._draw();
		this._on( this._events );
		this._refresh();

		// turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		});
	},

	_getCreateOptions: function() {
		var options = {},
			element = this.element;

		$.each( [ "min", "max", "step" ], function( i, option ) {
			var value = element.attr( option );
			if ( value !== undefined && value.length ) {
				options[ option ] = value;
			}
		});

		return options;
	},

	_events: {
		keydown: function( event ) {
			if ( this._start( event ) && this._keydown( event ) ) {
				event.preventDefault();
			}
		},
		keyup: "_stop",
		focus: function() {
			this.previous = this.element.val();
		},
		blur: function( event ) {
			if ( this.cancelBlur ) {
				delete this.cancelBlur;
				return;
			}

			this._stop();
			this._refresh();
			if ( this.previous !== this.element.val() ) {
				this._trigger( "change", event );
			}
		},
		mousewheel: function( event, delta ) {
			if ( !delta ) {
				return;
			}
			if ( !this.spinning && !this._start( event ) ) {
				return false;
			}

			this._spin( (delta > 0 ? 1 : -1) * this.options.step, event );
			clearTimeout( this.mousewheelTimer );
			this.mousewheelTimer = this._delay(function() {
				if ( this.spinning ) {
					this._stop( event );
				}
			}, 100 );
			event.preventDefault();
		},
		"mousedown .ui-spinner-button": function( event ) {
			var previous;

			// We never want the buttons to have focus; whenever the user is
			// interacting with the spinner, the focus should be on the input.
			// If the input is focused then this.previous is properly set from
			// when the input first received focus. If the input is not focused
			// then we need to set this.previous based on the value before spinning.
			previous = this.element[0] === this.document[0].activeElement ?
				this.previous : this.element.val();
			function checkFocus() {
				var isActive = this.element[0] === this.document[0].activeElement;
				if ( !isActive ) {
					this.element.focus();
					this.previous = previous;
					// support: IE
					// IE sets focus asynchronously, so we need to check if focus
					// moved off of the input because the user clicked on the button.
					this._delay(function() {
						this.previous = previous;
					});
				}
			}

			// ensure focus is on (or stays on) the text field
			event.preventDefault();
			checkFocus.call( this );

			// support: IE
			// IE doesn't prevent moving focus even with event.preventDefault()
			// so we set a flag to know when we should ignore the blur event
			// and check (again) if focus moved off of the input.
			this.cancelBlur = true;
			this._delay(function() {
				delete this.cancelBlur;
				checkFocus.call( this );
			});

			if ( this._start( event ) === false ) {
				return;
			}

			this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},
		"mouseup .ui-spinner-button": "_stop",
		"mouseenter .ui-spinner-button": function( event ) {
			// button will add ui-state-active if mouse was down while mouseleave and kept down
			if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {
				return;
			}

			if ( this._start( event ) === false ) {
				return false;
			}
			this._repeat( null, $( event.currentTarget ).hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},
		// TODO: do we really want to consider this a stop?
		// shouldn't we just stop the repeater and wait until mouseup before
		// we trigger the stop event?
		"mouseleave .ui-spinner-button": "_stop"
	},

	_draw: function() {
		var uiSpinner = this.uiSpinner = this.element
			.addClass( "ui-spinner-input" )
			.attr( "autocomplete", "off" )
			.wrap( this._uiSpinnerHtml() )
			.parent()
				// add buttons
				.append( this._buttonHtml() );

		this.element.attr( "role", "spinbutton" );

		// button bindings
		this.buttons = uiSpinner.find( ".ui-spinner-button" )
			.attr( "tabIndex", -1 )
			.button()
			.removeClass( "ui-corner-all" );

		// IE 6 doesn't understand height: 50% for the buttons
		// unless the wrapper has an explicit height
		if ( this.buttons.height() > Math.ceil( uiSpinner.height() * 0.5 ) &&
				uiSpinner.height() > 0 ) {
			uiSpinner.height( uiSpinner.height() );
		}

		// disable spinner if element was already disabled
		if ( this.options.disabled ) {
			this.disable();
		}
	},

	_keydown: function( event ) {
		var options = this.options,
			keyCode = $.ui.keyCode;

		switch ( event.keyCode ) {
		case keyCode.UP:
			this._repeat( null, 1, event );
			return true;
		case keyCode.DOWN:
			this._repeat( null, -1, event );
			return true;
		case keyCode.PAGE_UP:
			this._repeat( null, options.page, event );
			return true;
		case keyCode.PAGE_DOWN:
			this._repeat( null, -options.page, event );
			return true;
		}

		return false;
	},

	_uiSpinnerHtml: function() {
		return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
	},

	_buttonHtml: function() {
		return "" +
			"<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" +
				"<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" +
			"</a>" +
			"<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" +
				"<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" +
			"</a>";
	},

	_start: function( event ) {
		if ( !this.spinning && this._trigger( "start", event ) === false ) {
			return false;
		}

		if ( !this.counter ) {
			this.counter = 1;
		}
		this.spinning = true;
		return true;
	},

	_repeat: function( i, steps, event ) {
		i = i || 500;

		clearTimeout( this.timer );
		this.timer = this._delay(function() {
			this._repeat( 40, steps, event );
		}, i );

		this._spin( steps * this.options.step, event );
	},

	_spin: function( step, event ) {
		var value = this.value() || 0;

		if ( !this.counter ) {
			this.counter = 1;
		}

		value = this._adjustValue( value + step * this._increment( this.counter ) );

		if ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false) {
			this._value( value );
			this.counter++;
		}
	},

	_increment: function( i ) {
		var incremental = this.options.incremental;

		if ( incremental ) {
			return $.isFunction( incremental ) ?
				incremental( i ) :
				Math.floor( i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1 );
		}

		return 1;
	},

	_precision: function() {
		var precision = this._precisionOf( this.options.step );
		if ( this.options.min !== null ) {
			precision = Math.max( precision, this._precisionOf( this.options.min ) );
		}
		return precision;
	},

	_precisionOf: function( num ) {
		var str = num.toString(),
			decimal = str.indexOf( "." );
		return decimal === -1 ? 0 : str.length - decimal - 1;
	},

	_adjustValue: function( value ) {
		var base, aboveMin,
			options = this.options;

		// make sure we're at a valid step
		// - find out where we are relative to the base (min or 0)
		base = options.min !== null ? options.min : 0;
		aboveMin = value - base;
		// - round to the nearest step
		aboveMin = Math.round(aboveMin / options.step) * options.step;
		// - rounding is based on 0, so adjust back to our base
		value = base + aboveMin;

		// fix precision from bad JS floating point math
		value = parseFloat( value.toFixed( this._precision() ) );

		// clamp the value
		if ( options.max !== null && value > options.max) {
			return options.max;
		}
		if ( options.min !== null && value < options.min ) {
			return options.min;
		}

		return value;
	},

	_stop: function( event ) {
		if ( !this.spinning ) {
			return;
		}

		clearTimeout( this.timer );
		clearTimeout( this.mousewheelTimer );
		this.counter = 0;
		this.spinning = false;
		this._trigger( "stop", event );
	},

	_setOption: function( key, value ) {
		if ( key === "culture" || key === "numberFormat" ) {
			var prevValue = this._parse( this.element.val() );
			this.options[ key ] = value;
			this.element.val( this._format( prevValue ) );
			return;
		}

		if ( key === "max" || key === "min" || key === "step" ) {
			if ( typeof value === "string" ) {
				value = this._parse( value );
			}
		}
		if ( key === "icons" ) {
			this.buttons.first().find( ".ui-icon" )
				.removeClass( this.options.icons.up )
				.addClass( value.up );
			this.buttons.last().find( ".ui-icon" )
				.removeClass( this.options.icons.down )
				.addClass( value.down );
		}

		this._super( key, value );

		if ( key === "disabled" ) {
			this.widget().toggleClass( "ui-state-disabled", !!value );
			this.element.prop( "disabled", !!value );
			this.buttons.button( value ? "disable" : "enable" );
		}
	},

	_setOptions: spinner_modifier(function( options ) {
		this._super( options );
	}),

	_parse: function( val ) {
		if ( typeof val === "string" && val !== "" ) {
			val = window.Globalize && this.options.numberFormat ?
				Globalize.parseFloat( val, 10, this.options.culture ) : +val;
		}
		return val === "" || isNaN( val ) ? null : val;
	},

	_format: function( value ) {
		if ( value === "" ) {
			return "";
		}
		return window.Globalize && this.options.numberFormat ?
			Globalize.format( value, this.options.numberFormat, this.options.culture ) :
			value;
	},

	_refresh: function() {
		this.element.attr({
			"aria-valuemin": this.options.min,
			"aria-valuemax": this.options.max,
			// TODO: what should we do with values that can't be parsed?
			"aria-valuenow": this._parse( this.element.val() )
		});
	},

	isValid: function() {
		var value = this.value();

		// null is invalid
		if ( value === null ) {
			return false;
		}

		// if value gets adjusted, it's invalid
		return value === this._adjustValue( value );
	},

	// update the value without triggering change
	_value: function( value, allowAny ) {
		var parsed;
		if ( value !== "" ) {
			parsed = this._parse( value );
			if ( parsed !== null ) {
				if ( !allowAny ) {
					parsed = this._adjustValue( parsed );
				}
				value = this._format( parsed );
			}
		}
		this.element.val( value );
		this._refresh();
	},

	_destroy: function() {
		this.element
			.removeClass( "ui-spinner-input" )
			.prop( "disabled", false )
			.removeAttr( "autocomplete" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );
		this.uiSpinner.replaceWith( this.element );
	},

	stepUp: spinner_modifier(function( steps ) {
		this._stepUp( steps );
	}),
	_stepUp: function( steps ) {
		if ( this._start() ) {
			this._spin( (steps || 1) * this.options.step );
			this._stop();
		}
	},

	stepDown: spinner_modifier(function( steps ) {
		this._stepDown( steps );
	}),
	_stepDown: function( steps ) {
		if ( this._start() ) {
			this._spin( (steps || 1) * -this.options.step );
			this._stop();
		}
	},

	pageUp: spinner_modifier(function( pages ) {
		this._stepUp( (pages || 1) * this.options.page );
	}),

	pageDown: spinner_modifier(function( pages ) {
		this._stepDown( (pages || 1) * this.options.page );
	}),

	value: function( newVal ) {
		if ( !arguments.length ) {
			return this._parse( this.element.val() );
		}
		spinner_modifier( this._value ).call( this, newVal );
	},

	widget: function() {
		return this.uiSpinner;
	}
});


/*!
 * jQuery UI Tabs 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/tabs/
 */


var tabs = $.widget( "ui.tabs", {
	version: "1.11.0",
	delay: 300,
	options: {
		active: null,
		collapsible: false,
		event: "click",
		heightStyle: "content",
		hide: null,
		show: null,

		// callbacks
		activate: null,
		beforeActivate: null,
		beforeLoad: null,
		load: null
	},

	_isLocal: (function() {
		var rhash = /#.*$/;

		return function( anchor ) {
			var anchorUrl, locationUrl;

			// support: IE7
			// IE7 doesn't normalize the href property when set via script (#9317)
			anchor = anchor.cloneNode( false );

			anchorUrl = anchor.href.replace( rhash, "" );
			locationUrl = location.href.replace( rhash, "" );

			// decoding may throw an error if the URL isn't UTF-8 (#9518)
			try {
				anchorUrl = decodeURIComponent( anchorUrl );
			} catch ( error ) {}
			try {
				locationUrl = decodeURIComponent( locationUrl );
			} catch ( error ) {}

			return anchor.hash.length > 1 && anchorUrl === locationUrl;
		};
	})(),

	_create: function() {
		var that = this,
			options = this.options;

		this.running = false;

		this.element
			.addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" )
			.toggleClass( "ui-tabs-collapsible", options.collapsible )
			// Prevent users from focusing disabled tabs via click
			.delegate( ".ui-tabs-nav > li", "mousedown" + this.eventNamespace, function( event ) {
				if ( $( this ).is( ".ui-state-disabled" ) ) {
					event.preventDefault();
				}
			})
			// support: IE <9
			// Preventing the default action in mousedown doesn't prevent IE
			// from focusing the element, so if the anchor gets focused, blur.
			// We don't have to worry about focusing the previously focused
			// element since clicking on a non-focusable element should focus
			// the body anyway.
			.delegate( ".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
				if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
					this.blur();
				}
			});

		this._processTabs();
		options.active = this._initialActive();

		// Take disabling tabs via class attribute from HTML
		// into account and update option properly.
		if ( $.isArray( options.disabled ) ) {
			options.disabled = $.unique( options.disabled.concat(
				$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
					return that.tabs.index( li );
				})
			) ).sort();
		}

		// check for length avoids error when initializing empty list
		if ( this.options.active !== false && this.anchors.length ) {
			this.active = this._findActive( options.active );
		} else {
			this.active = $();
		}

		this._refresh();

		if ( this.active.length ) {
			this.load( options.active );
		}
	},

	_initialActive: function() {
		var active = this.options.active,
			collapsible = this.options.collapsible,
			locationHash = location.hash.substring( 1 );

		if ( active === null ) {
			// check the fragment identifier in the URL
			if ( locationHash ) {
				this.tabs.each(function( i, tab ) {
					if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
						active = i;
						return false;
					}
				});
			}

			// check for a tab marked active via a class
			if ( active === null ) {
				active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
			}

			// no active tab, set to false
			if ( active === null || active === -1 ) {
				active = this.tabs.length ? 0 : false;
			}
		}

		// handle numbers: negative, out of range
		if ( active !== false ) {
			active = this.tabs.index( this.tabs.eq( active ) );
			if ( active === -1 ) {
				active = collapsible ? false : 0;
			}
		}

		// don't allow collapsible: false and active: false
		if ( !collapsible && active === false && this.anchors.length ) {
			active = 0;
		}

		return active;
	},

	_getCreateEventData: function() {
		return {
			tab: this.active,
			panel: !this.active.length ? $() : this._getPanelForTab( this.active )
		};
	},

	_tabKeydown: function( event ) {
		var focusedTab = $( this.document[0].activeElement ).closest( "li" ),
			selectedIndex = this.tabs.index( focusedTab ),
			goingForward = true;

		if ( this._handlePageNav( event ) ) {
			return;
		}

		switch ( event.keyCode ) {
			case $.ui.keyCode.RIGHT:
			case $.ui.keyCode.DOWN:
				selectedIndex++;
				break;
			case $.ui.keyCode.UP:
			case $.ui.keyCode.LEFT:
				goingForward = false;
				selectedIndex--;
				break;
			case $.ui.keyCode.END:
				selectedIndex = this.anchors.length - 1;
				break;
			case $.ui.keyCode.HOME:
				selectedIndex = 0;
				break;
			case $.ui.keyCode.SPACE:
				// Activate only, no collapsing
				event.preventDefault();
				clearTimeout( this.activating );
				this._activate( selectedIndex );
				return;
			case $.ui.keyCode.ENTER:
				// Toggle (cancel delayed activation, allow collapsing)
				event.preventDefault();
				clearTimeout( this.activating );
				// Determine if we should collapse or activate
				this._activate( selectedIndex === this.options.active ? false : selectedIndex );
				return;
			default:
				return;
		}

		// Focus the appropriate tab, based on which key was pressed
		event.preventDefault();
		clearTimeout( this.activating );
		selectedIndex = this._focusNextTab( selectedIndex, goingForward );

		// Navigating with control key will prevent automatic activation
		if ( !event.ctrlKey ) {
			// Update aria-selected immediately so that AT think the tab is already selected.
			// Otherwise AT may confuse the user by stating that they need to activate the tab,
			// but the tab will already be activated by the time the announcement finishes.
			focusedTab.attr( "aria-selected", "false" );
			this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );

			this.activating = this._delay(function() {
				this.option( "active", selectedIndex );
			}, this.delay );
		}
	},

	_panelKeydown: function( event ) {
		if ( this._handlePageNav( event ) ) {
			return;
		}

		// Ctrl+up moves focus to the current tab
		if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
			event.preventDefault();
			this.active.focus();
		}
	},

	// Alt+page up/down moves focus to the previous/next tab (and activates)
	_handlePageNav: function( event ) {
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
			this._activate( this._focusNextTab( this.options.active - 1, false ) );
			return true;
		}
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
			this._activate( this._focusNextTab( this.options.active + 1, true ) );
			return true;
		}
	},

	_findNextTab: function( index, goingForward ) {
		var lastTabIndex = this.tabs.length - 1;

		function constrain() {
			if ( index > lastTabIndex ) {
				index = 0;
			}
			if ( index < 0 ) {
				index = lastTabIndex;
			}
			return index;
		}

		while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
			index = goingForward ? index + 1 : index - 1;
		}

		return index;
	},

	_focusNextTab: function( index, goingForward ) {
		index = this._findNextTab( index, goingForward );
		this.tabs.eq( index ).focus();
		return index;
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {
			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "disabled" ) {
			// don't use the widget factory's disabled handling
			this._setupDisabled( value );
			return;
		}

		this._super( key, value);

		if ( key === "collapsible" ) {
			this.element.toggleClass( "ui-tabs-collapsible", value );
			// Setting collapsible: false while collapsed; open first panel
			if ( !value && this.options.active === false ) {
				this._activate( 0 );
			}
		}

		if ( key === "event" ) {
			this._setupEvents( value );
		}

		if ( key === "heightStyle" ) {
			this._setupHeightStyle( value );
		}
	},

	_sanitizeSelector: function( hash ) {
		return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
	},

	refresh: function() {
		var options = this.options,
			lis = this.tablist.children( ":has(a[href])" );

		// get disabled tabs from class attribute from HTML
		// this will get converted to a boolean if needed in _refresh()
		options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
			return lis.index( tab );
		});

		this._processTabs();

		// was collapsed or no tabs
		if ( options.active === false || !this.anchors.length ) {
			options.active = false;
			this.active = $();
		// was active, but active tab is gone
		} else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {
			// all remaining tabs are disabled
			if ( this.tabs.length === options.disabled.length ) {
				options.active = false;
				this.active = $();
			// activate previous tab
			} else {
				this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
			}
		// was active, active tab still exists
		} else {
			// make sure active index is correct
			options.active = this.tabs.index( this.active );
		}

		this._refresh();
	},

	_refresh: function() {
		this._setupDisabled( this.options.disabled );
		this._setupEvents( this.options.event );
		this._setupHeightStyle( this.options.heightStyle );

		this.tabs.not( this.active ).attr({
			"aria-selected": "false",
			"aria-expanded": "false",
			tabIndex: -1
		});
		this.panels.not( this._getPanelForTab( this.active ) )
			.hide()
			.attr({
				"aria-hidden": "true"
			});

		// Make sure one tab is in the tab order
		if ( !this.active.length ) {
			this.tabs.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active
				.addClass( "ui-tabs-active ui-state-active" )
				.attr({
					"aria-selected": "true",
					"aria-expanded": "true",
					tabIndex: 0
				});
			this._getPanelForTab( this.active )
				.show()
				.attr({
					"aria-hidden": "false"
				});
		}
	},

	_processTabs: function() {
		var that = this;

		this.tablist = this._getList()
			.addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.attr( "role", "tablist" );

		this.tabs = this.tablist.find( "> li:has(a[href])" )
			.addClass( "ui-state-default ui-corner-top" )
			.attr({
				role: "tab",
				tabIndex: -1
			});

		this.anchors = this.tabs.map(function() {
				return $( "a", this )[ 0 ];
			})
			.addClass( "ui-tabs-anchor" )
			.attr({
				role: "presentation",
				tabIndex: -1
			});

		this.panels = $();

		this.anchors.each(function( i, anchor ) {
			var selector, panel, panelId,
				anchorId = $( anchor ).uniqueId().attr( "id" ),
				tab = $( anchor ).closest( "li" ),
				originalAriaControls = tab.attr( "aria-controls" );

			// inline tab
			if ( that._isLocal( anchor ) ) {
				selector = anchor.hash;
				panelId = selector.substring( 1 );
				panel = that.element.find( that._sanitizeSelector( selector ) );
			// remote tab
			} else {
				// If the tab doesn't already have aria-controls,
				// generate an id by using a throw-away element
				panelId = tab.attr( "aria-controls" ) || $( {} ).uniqueId()[ 0 ].id;
				selector = "#" + panelId;
				panel = that.element.find( selector );
				if ( !panel.length ) {
					panel = that._createPanel( panelId );
					panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
				}
				panel.attr( "aria-live", "polite" );
			}

			if ( panel.length) {
				that.panels = that.panels.add( panel );
			}
			if ( originalAriaControls ) {
				tab.data( "ui-tabs-aria-controls", originalAriaControls );
			}
			tab.attr({
				"aria-controls": panelId,
				"aria-labelledby": anchorId
			});
			panel.attr( "aria-labelledby", anchorId );
		});

		this.panels
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.attr( "role", "tabpanel" );
	},

	// allow overriding how to find the list for rare usage scenarios (#7715)
	_getList: function() {
		return this.tablist || this.element.find( "ol,ul" ).eq( 0 );
	},

	_createPanel: function( id ) {
		return $( "<div>" )
			.attr( "id", id )
			.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
			.data( "ui-tabs-destroy", true );
	},

	_setupDisabled: function( disabled ) {
		if ( $.isArray( disabled ) ) {
			if ( !disabled.length ) {
				disabled = false;
			} else if ( disabled.length === this.anchors.length ) {
				disabled = true;
			}
		}

		// disable tabs
		for ( var i = 0, li; ( li = this.tabs[ i ] ); i++ ) {
			if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
				$( li )
					.addClass( "ui-state-disabled" )
					.attr( "aria-disabled", "true" );
			} else {
				$( li )
					.removeClass( "ui-state-disabled" )
					.removeAttr( "aria-disabled" );
			}
		}

		this.options.disabled = disabled;
	},

	_setupEvents: function( event ) {
		var events = {};
		if ( event ) {
			$.each( event.split(" "), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			});
		}

		this._off( this.anchors.add( this.tabs ).add( this.panels ) );
		// Always prevent the default action, even when disabled
		this._on( true, this.anchors, {
			click: function( event ) {
				event.preventDefault();
			}
		});
		this._on( this.anchors, events );
		this._on( this.tabs, { keydown: "_tabKeydown" } );
		this._on( this.panels, { keydown: "_panelKeydown" } );

		this._focusable( this.tabs );
		this._hoverable( this.tabs );
	},

	_setupHeightStyle: function( heightStyle ) {
		var maxHeight,
			parent = this.element.parent();

		if ( heightStyle === "fill" ) {
			maxHeight = parent.height();
			maxHeight -= this.element.outerHeight() - this.element.height();

			this.element.siblings( ":visible" ).each(function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			});

			this.element.children().not( this.panels ).each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.panels.each(function() {
				$( this ).height( Math.max( 0, maxHeight -
					$( this ).innerHeight() + $( this ).height() ) );
			})
			.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.panels.each(function() {
				maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
			}).height( maxHeight );
		}
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			anchor = $( event.currentTarget ),
			tab = anchor.closest( "li" ),
			clickedIsActive = tab[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : this._getPanelForTab( tab ),
			toHide = !active.length ? $() : this._getPanelForTab( active ),
			eventData = {
				oldTab: active,
				oldPanel: toHide,
				newTab: collapsing ? $() : tab,
				newPanel: toShow
			};

		event.preventDefault();

		if ( tab.hasClass( "ui-state-disabled" ) ||
				// tab is already loading
				tab.hasClass( "ui-tabs-loading" ) ||
				// can't switch durning an animation
				this.running ||
				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||
				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.tabs.index( tab );

		this.active = clickedIsActive ? $() : tab;
		if ( this.xhr ) {
			this.xhr.abort();
		}

		if ( !toHide.length && !toShow.length ) {
			$.error( "jQuery UI Tabs: Mismatching fragment identifier." );
		}

		if ( toShow.length ) {
			this.load( this.tabs.index( tab ), event );
		}
		this._toggle( event, eventData );
	},

	// handles show/hide for selecting tabs
	_toggle: function( event, eventData ) {
		var that = this,
			toShow = eventData.newPanel,
			toHide = eventData.oldPanel;

		this.running = true;

		function complete() {
			that.running = false;
			that._trigger( "activate", event, eventData );
		}

		function show() {
			eventData.newTab.closest( "li" ).addClass( "ui-tabs-active ui-state-active" );

			if ( toShow.length && that.options.show ) {
				that._show( toShow, that.options.show, complete );
			} else {
				toShow.show();
				complete();
			}
		}

		// start out by hiding, then showing, then completing
		if ( toHide.length && this.options.hide ) {
			this._hide( toHide, this.options.hide, function() {
				eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
				show();
			});
		} else {
			eventData.oldTab.closest( "li" ).removeClass( "ui-tabs-active ui-state-active" );
			toHide.hide();
			show();
		}

		toHide.attr( "aria-hidden", "true" );
		eventData.oldTab.attr({
			"aria-selected": "false",
			"aria-expanded": "false"
		});
		// If we're switching tabs, remove the old tab from the tab order.
		// If we're opening from collapsed state, remove the previous tab from the tab order.
		// If we're collapsing, then keep the collapsing tab in the tab order.
		if ( toShow.length && toHide.length ) {
			eventData.oldTab.attr( "tabIndex", -1 );
		} else if ( toShow.length ) {
			this.tabs.filter(function() {
				return $( this ).attr( "tabIndex" ) === 0;
			})
			.attr( "tabIndex", -1 );
		}

		toShow.attr( "aria-hidden", "false" );
		eventData.newTab.attr({
			"aria-selected": "true",
			"aria-expanded": "true",
			tabIndex: 0
		});
	},

	_activate: function( index ) {
		var anchor,
			active = this._findActive( index );

		// trying to activate the already active panel
		if ( active[ 0 ] === this.active[ 0 ] ) {
			return;
		}

		// trying to collapse, simulate a click on the current active header
		if ( !active.length ) {
			active = this.active;
		}

		anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
		this._eventHandler({
			target: anchor,
			currentTarget: anchor,
			preventDefault: $.noop
		});
	},

	_findActive: function( index ) {
		return index === false ? $() : this.tabs.eq( index );
	},

	_getIndex: function( index ) {
		// meta-function to give users option to provide a href string instead of a numerical index.
		if ( typeof index === "string" ) {
			index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
		}

		return index;
	},

	_destroy: function() {
		if ( this.xhr ) {
			this.xhr.abort();
		}

		this.element.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" );

		this.tablist
			.removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" )
			.removeAttr( "role" );

		this.anchors
			.removeClass( "ui-tabs-anchor" )
			.removeAttr( "role" )
			.removeAttr( "tabIndex" )
			.removeUniqueId();

		this.tabs.add( this.panels ).each(function() {
			if ( $.data( this, "ui-tabs-destroy" ) ) {
				$( this ).remove();
			} else {
				$( this )
					.removeClass( "ui-state-default ui-state-active ui-state-disabled " +
						"ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel" )
					.removeAttr( "tabIndex" )
					.removeAttr( "aria-live" )
					.removeAttr( "aria-busy" )
					.removeAttr( "aria-selected" )
					.removeAttr( "aria-labelledby" )
					.removeAttr( "aria-hidden" )
					.removeAttr( "aria-expanded" )
					.removeAttr( "role" );
			}
		});

		this.tabs.each(function() {
			var li = $( this ),
				prev = li.data( "ui-tabs-aria-controls" );
			if ( prev ) {
				li
					.attr( "aria-controls", prev )
					.removeData( "ui-tabs-aria-controls" );
			} else {
				li.removeAttr( "aria-controls" );
			}
		});

		this.panels.show();

		if ( this.options.heightStyle !== "content" ) {
			this.panels.css( "height", "" );
		}
	},

	enable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === false ) {
			return;
		}

		if ( index === undefined ) {
			disabled = false;
		} else {
			index = this._getIndex( index );
			if ( $.isArray( disabled ) ) {
				disabled = $.map( disabled, function( num ) {
					return num !== index ? num : null;
				});
			} else {
				disabled = $.map( this.tabs, function( li, num ) {
					return num !== index ? num : null;
				});
			}
		}
		this._setupDisabled( disabled );
	},

	disable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === true ) {
			return;
		}

		if ( index === undefined ) {
			disabled = true;
		} else {
			index = this._getIndex( index );
			if ( $.inArray( index, disabled ) !== -1 ) {
				return;
			}
			if ( $.isArray( disabled ) ) {
				disabled = $.merge( [ index ], disabled ).sort();
			} else {
				disabled = [ index ];
			}
		}
		this._setupDisabled( disabled );
	},

	load: function( index, event ) {
		index = this._getIndex( index );
		var that = this,
			tab = this.tabs.eq( index ),
			anchor = tab.find( ".ui-tabs-anchor" ),
			panel = this._getPanelForTab( tab ),
			eventData = {
				tab: tab,
				panel: panel
			};

		// not remote
		if ( this._isLocal( anchor[ 0 ] ) ) {
			return;
		}

		this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );

		// support: jQuery <1.8
		// jQuery <1.8 returns false if the request is canceled in beforeSend,
		// but as of 1.8, $.ajax() always returns a jqXHR object.
		if ( this.xhr && this.xhr.statusText !== "canceled" ) {
			tab.addClass( "ui-tabs-loading" );
			panel.attr( "aria-busy", "true" );

			this.xhr
				.success(function( response ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						panel.html( response );
						that._trigger( "load", event, eventData );
					}, 1 );
				})
				.complete(function( jqXHR, status ) {
					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout(function() {
						if ( status === "abort" ) {
							that.panels.stop( false, true );
						}

						tab.removeClass( "ui-tabs-loading" );
						panel.removeAttr( "aria-busy" );

						if ( jqXHR === that.xhr ) {
							delete that.xhr;
						}
					}, 1 );
				});
		}
	},

	_ajaxSettings: function( anchor, event, eventData ) {
		var that = this;
		return {
			url: anchor.attr( "href" ),
			beforeSend: function( jqXHR, settings ) {
				return that._trigger( "beforeLoad", event,
					$.extend( { jqXHR: jqXHR, ajaxSettings: settings }, eventData ) );
			}
		};
	},

	_getPanelForTab: function( tab ) {
		var id = $( tab ).attr( "aria-controls" );
		return this.element.find( this._sanitizeSelector( "#" + id ) );
	}
});


/*!
 * jQuery UI Tooltip 1.11.0
 * http://jqueryui.com
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/tooltip/
 */


var tooltip = $.widget( "ui.tooltip", {
	version: "1.11.0",
	options: {
		content: function() {
			// support: IE<9, Opera in jQuery <1.7
			// .text() can't accept undefined, so coerce to a string
			var title = $( this ).attr( "title" ) || "";
			// Escape title, since we're going from an attribute to raw HTML
			return $( "<a>" ).text( title ).html();
		},
		hide: true,
		// Disabled elements have inconsistent behavior across browsers (#8661)
		items: "[title]:not([disabled])",
		position: {
			my: "left top+15",
			at: "left bottom",
			collision: "flipfit flip"
		},
		show: true,
		tooltipClass: null,
		track: false,

		// callbacks
		close: null,
		open: null
	},

	_addDescribedBy: function( elem, id ) {
		var describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ );
		describedby.push( id );
		elem
			.data( "ui-tooltip-id", id )
			.attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
	},

	_removeDescribedBy: function( elem ) {
		var id = elem.data( "ui-tooltip-id" ),
			describedby = (elem.attr( "aria-describedby" ) || "").split( /\s+/ ),
			index = $.inArray( id, describedby );

		if ( index !== -1 ) {
			describedby.splice( index, 1 );
		}

		elem.removeData( "ui-tooltip-id" );
		describedby = $.trim( describedby.join( " " ) );
		if ( describedby ) {
			elem.attr( "aria-describedby", describedby );
		} else {
			elem.removeAttr( "aria-describedby" );
		}
	},

	_create: function() {
		this._on({
			mouseover: "open",
			focusin: "open"
		});

		// IDs of generated tooltips, needed for destroy
		this.tooltips = {};
		// IDs of parent tooltips where we removed the title attribute
		this.parents = {};

		if ( this.options.disabled ) {
			this._disable();
		}

		// Append the aria-live region so tooltips announce correctly
		this.liveRegion = $( "<div>" )
			.attr({
				role: "log",
				"aria-live": "assertive",
				"aria-relevant": "additions"
			})
			.addClass( "ui-helper-hidden-accessible" )
			.appendTo( this.document[ 0 ].body );
	},

	_setOption: function( key, value ) {
		var that = this;

		if ( key === "disabled" ) {
			this[ value ? "_disable" : "_enable" ]();
			this.options[ key ] = value;
			// disable element style changes
			return;
		}

		this._super( key, value );

		if ( key === "content" ) {
			$.each( this.tooltips, function( id, element ) {
				that._updateContent( element );
			});
		}
	},

	_disable: function() {
		var that = this;

		// close open tooltips
		$.each( this.tooltips, function( id, element ) {
			var event = $.Event( "blur" );
			event.target = event.currentTarget = element[0];
			that.close( event, true );
		});

		// remove title attributes to prevent native tooltips
		this.element.find( this.options.items ).addBack().each(function() {
			var element = $( this );
			if ( element.is( "[title]" ) ) {
				element
					.data( "ui-tooltip-title", element.attr( "title" ) )
					.removeAttr( "title" );
			}
		});
	},

	_enable: function() {
		// restore title attributes
		this.element.find( this.options.items ).addBack().each(function() {
			var element = $( this );
			if ( element.data( "ui-tooltip-title" ) ) {
				element.attr( "title", element.data( "ui-tooltip-title" ) );
			}
		});
	},

	open: function( event ) {
		var that = this,
			target = $( event ? event.target : this.element )
				// we need closest here due to mouseover bubbling,
				// but always pointing at the same event target
				.closest( this.options.items );

		// No element to show a tooltip for or the tooltip is already open
		if ( !target.length || target.data( "ui-tooltip-id" ) ) {
			return;
		}

		if ( target.attr( "title" ) ) {
			target.data( "ui-tooltip-title", target.attr( "title" ) );
		}

		target.data( "ui-tooltip-open", true );

		// kill parent tooltips, custom or native, for hover
		if ( event && event.type === "mouseover" ) {
			target.parents().each(function() {
				var parent = $( this ),
					blurEvent;
				if ( parent.data( "ui-tooltip-open" ) ) {
					blurEvent = $.Event( "blur" );
					blurEvent.target = blurEvent.currentTarget = this;
					that.close( blurEvent, true );
				}
				if ( parent.attr( "title" ) ) {
					parent.uniqueId();
					that.parents[ this.id ] = {
						element: this,
						title: parent.attr( "title" )
					};
					parent.attr( "title", "" );
				}
			});
		}

		this._updateContent( target, event );
	},

	_updateContent: function( target, event ) {
		var content,
			contentOption = this.options.content,
			that = this,
			eventType = event ? event.type : null;

		if ( typeof contentOption === "string" ) {
			return this._open( event, target, contentOption );
		}

		content = contentOption.call( target[0], function( response ) {
			// ignore async response if tooltip was closed already
			if ( !target.data( "ui-tooltip-open" ) ) {
				return;
			}
			// IE may instantly serve a cached response for ajax requests
			// delay this call to _open so the other call to _open runs first
			that._delay(function() {
				// jQuery creates a special event for focusin when it doesn't
				// exist natively. To improve performance, the native event
				// object is reused and the type is changed. Therefore, we can't
				// rely on the type being correct after the event finished
				// bubbling, so we set it back to the previous value. (#8740)
				if ( event ) {
					event.type = eventType;
				}
				this._open( event, target, response );
			});
		});
		if ( content ) {
			this._open( event, target, content );
		}
	},

	_open: function( event, target, content ) {
		var tooltip, events, delayedShow, a11yContent,
			positionOption = $.extend( {}, this.options.position );

		if ( !content ) {
			return;
		}

		// Content can be updated multiple times. If the tooltip already
		// exists, then just update the content and bail.
		tooltip = this._find( target );
		if ( tooltip.length ) {
			tooltip.find( ".ui-tooltip-content" ).html( content );
			return;
		}

		// if we have a title, clear it to prevent the native tooltip
		// we have to check first to avoid defining a title if none exists
		// (we don't want to cause an element to start matching [title])
		//
		// We use removeAttr only for key events, to allow IE to export the correct
		// accessible attributes. For mouse events, set to empty string to avoid
		// native tooltip showing up (happens only when removing inside mouseover).
		if ( target.is( "[title]" ) ) {
			if ( event && event.type === "mouseover" ) {
				target.attr( "title", "" );
			} else {
				target.removeAttr( "title" );
			}
		}

		tooltip = this._tooltip( target );
		this._addDescribedBy( target, tooltip.attr( "id" ) );
		tooltip.find( ".ui-tooltip-content" ).html( content );

		// Support: Voiceover on OS X, JAWS on IE <= 9
		// JAWS announces deletions even when aria-relevant="additions"
		// Voiceover will sometimes re-read the entire log region's contents from the beginning
		this.liveRegion.children().hide();
		if ( content.clone ) {
			a11yContent = content.clone();
			a11yContent.removeAttr( "id" ).find( "[id]" ).removeAttr( "id" );
		} else {
			a11yContent = content;
		}
		$( "<div>" ).html( a11yContent ).appendTo( this.liveRegion );

		function position( event ) {
			positionOption.of = event;
			if ( tooltip.is( ":hidden" ) ) {
				return;
			}
			tooltip.position( positionOption );
		}
		if ( this.options.track && event && /^mouse/.test( event.type ) ) {
			this._on( this.document, {
				mousemove: position
			});
			// trigger once to override element-relative positioning
			position( event );
		} else {
			tooltip.position( $.extend({
				of: target
			}, this.options.position ) );
		}

		tooltip.hide();

		this._show( tooltip, this.options.show );
		// Handle tracking tooltips that are shown with a delay (#8644). As soon
		// as the tooltip is visible, position the tooltip using the most recent
		// event.
		if ( this.options.show && this.options.show.delay ) {
			delayedShow = this.delayedShow = setInterval(function() {
				if ( tooltip.is( ":visible" ) ) {
					position( positionOption.of );
					clearInterval( delayedShow );
				}
			}, $.fx.interval );
		}

		this._trigger( "open", event, { tooltip: tooltip } );

		events = {
			keyup: function( event ) {
				if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
					var fakeEvent = $.Event(event);
					fakeEvent.currentTarget = target[0];
					this.close( fakeEvent, true );
				}
			}
		};

		// Only bind remove handler for delegated targets. Non-delegated
		// tooltips will handle this in destroy.
		if ( target[ 0 ] !== this.element[ 0 ] ) {
			events.remove = function() {
				this._removeTooltip( tooltip );
			};
		}

		if ( !event || event.type === "mouseover" ) {
			events.mouseleave = "close";
		}
		if ( !event || event.type === "focusin" ) {
			events.focusout = "close";
		}
		this._on( true, target, events );
	},

	close: function( event ) {
		var that = this,
			target = $( event ? event.currentTarget : this.element ),
			tooltip = this._find( target );

		// disabling closes the tooltip, so we need to track when we're closing
		// to avoid an infinite loop in case the tooltip becomes disabled on close
		if ( this.closing ) {
			return;
		}

		// Clear the interval for delayed tracking tooltips
		clearInterval( this.delayedShow );

		// only set title if we had one before (see comment in _open())
		// If the title attribute has changed since open(), don't restore
		if ( target.data( "ui-tooltip-title" ) && !target.attr( "title" ) ) {
			target.attr( "title", target.data( "ui-tooltip-title" ) );
		}

		this._removeDescribedBy( target );

		tooltip.stop( true );
		this._hide( tooltip, this.options.hide, function() {
			that._removeTooltip( $( this ) );
		});

		target.removeData( "ui-tooltip-open" );
		this._off( target, "mouseleave focusout keyup" );

		// Remove 'remove' binding only on delegated targets
		if ( target[ 0 ] !== this.element[ 0 ] ) {
			this._off( target, "remove" );
		}
		this._off( this.document, "mousemove" );

		if ( event && event.type === "mouseleave" ) {
			$.each( this.parents, function( id, parent ) {
				$( parent.element ).attr( "title", parent.title );
				delete that.parents[ id ];
			});
		}

		this.closing = true;
		this._trigger( "close", event, { tooltip: tooltip } );
		this.closing = false;
	},

	_tooltip: function( element ) {
		var tooltip = $( "<div>" )
				.attr( "role", "tooltip" )
				.addClass( "ui-tooltip ui-widget ui-corner-all ui-widget-content " +
					( this.options.tooltipClass || "" ) ),
			id = tooltip.uniqueId().attr( "id" );

		$( "<div>" )
			.addClass( "ui-tooltip-content" )
			.appendTo( tooltip );

		tooltip.appendTo( this.document[0].body );
		this.tooltips[ id ] = element;
		return tooltip;
	},

	_find: function( target ) {
		var id = target.data( "ui-tooltip-id" );
		return id ? $( "#" + id ) : $();
	},

	_removeTooltip: function( tooltip ) {
		tooltip.remove();
		delete this.tooltips[ tooltip.attr( "id" ) ];
	},

	_destroy: function() {
		var that = this;

		// close open tooltips
		$.each( this.tooltips, function( id, element ) {
			// Delegate to close method to handle common cleanup
			var event = $.Event( "blur" );
			event.target = event.currentTarget = element[0];
			that.close( event, true );

			// Remove immediately; destroying an open tooltip doesn't use the
			// hide animation
			$( "#" + id ).remove();

			// Restore the title
			if ( element.data( "ui-tooltip-title" ) ) {
				// If the title attribute has changed since open(), don't restore
				if ( !element.attr( "title" ) ) {
					element.attr( "title", element.data( "ui-tooltip-title" ) );
				}
				element.removeData( "ui-tooltip-title" );
			}
		});
		this.liveRegion.remove();
	}
});



}));


/*!
 * imagesLoaded PACKAGED v3.1.8
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */


/*!
 * EventEmitter v4.2.6 - git.io/ee
 * Oliver Caldwell
 * MIT license
 * @preserve
 */

(function () {
	

	/**
	 * Class for managing events.
	 * Can be extended to provide event functionality in other classes.
	 *
	 * @class EventEmitter Manages event registering and emitting.
	 */
	function EventEmitter() {}

	// Shortcuts to improve speed and size
	var proto = EventEmitter.prototype;
	var exports = this;
	var originalGlobalValue = exports.EventEmitter;

	/**
	 * Finds the index of the listener for the event in it's storage array.
	 *
	 * @param {Function[]} listeners Array of listeners to search through.
	 * @param {Function} listener Method to look for.
	 * @return {Number} Index of the specified listener, -1 if not found
	 * @api private
	 */
	function indexOfListener(listeners, listener) {
		var i = listeners.length;
		while (i--) {
			if (listeners[i].listener === listener) {
				return i;
			}
		}

		return -1;
	}

	/**
	 * Alias a method while keeping the context correct, to allow for overwriting of target method.
	 *
	 * @param {String} name The name of the target method.
	 * @return {Function} The aliased method
	 * @api private
	 */
	function alias(name) {
		return function aliasClosure() {
			return this[name].apply(this, arguments);
		};
	}

	/**
	 * Returns the listener array for the specified event.
	 * Will initialise the event object and listener arrays if required.
	 * Will return an object if you use a regex search. The object contains keys for each matched event. So /ba[rz]/ might return an object containing bar and baz. But only if you have either defined them with defineEvent or added some listeners to them.
	 * Each property in the object response is an array of listener functions.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Function[]|Object} All listener functions for the event.
	 */
	proto.getListeners = function getListeners(evt) {
		var events = this._getEvents();
		var response;
		var key;

		// Return a concatenated array of all matching events if
		// the selector is a regular expression.
		if (typeof evt === 'object') {
			response = {};
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					response[key] = events[key];
				}
			}
		}
		else {
			response = events[evt] || (events[evt] = []);
		}

		return response;
	};

	/**
	 * Takes a list of listener objects and flattens it into a list of listener functions.
	 *
	 * @param {Object[]} listeners Raw listener objects.
	 * @return {Function[]} Just the listener functions.
	 */
	proto.flattenListeners = function flattenListeners(listeners) {
		var flatListeners = [];
		var i;

		for (i = 0; i < listeners.length; i += 1) {
			flatListeners.push(listeners[i].listener);
		}

		return flatListeners;
	};

	/**
	 * Fetches the requested listeners via getListeners but will always return the results inside an object. This is mainly for internal use but others may find it useful.
	 *
	 * @param {String|RegExp} evt Name of the event to return the listeners from.
	 * @return {Object} All listener functions for an event in an object.
	 */
	proto.getListenersAsObject = function getListenersAsObject(evt) {
		var listeners = this.getListeners(evt);
		var response;

		if (listeners instanceof Array) {
			response = {};
			response[evt] = listeners;
		}

		return response || listeners;
	};

	/**
	 * Adds a listener function to the specified event.
	 * The listener will not be added if it is a duplicate.
	 * If the listener returns true then it will be removed after it is called.
	 * If you pass a regular expression as the event name then the listener will be added to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to attach the listener to.
	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListener = function addListener(evt, listener) {
		var listeners = this.getListenersAsObject(evt);
		var listenerIsWrapped = typeof listener === 'object';
		var key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1) {
				listeners[key].push(listenerIsWrapped ? listener : {
					listener: listener,
					once: false
				});
			}
		}

		return this;
	};

	/**
	 * Alias of addListener
	 */
	proto.on = alias('addListener');

	/**
	 * Semi-alias of addListener. It will add a listener that will be
	 * automatically removed after it's first execution.
	 *
	 * @param {String|RegExp} evt Name of the event to attach the listener to.
	 * @param {Function} listener Method to be called when the event is emitted. If the function returns true then it will be removed after calling.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addOnceListener = function addOnceListener(evt, listener) {
		return this.addListener(evt, {
			listener: listener,
			once: true
		});
	};

	/**
	 * Alias of addOnceListener.
	 */
	proto.once = alias('addOnceListener');

	/**
	 * Defines an event name. This is required if you want to use a regex to add a listener to multiple events at once. If you don't do this then how do you expect it to know what event to add to? Should it just add to every possible match for a regex? No. That is scary and bad.
	 * You need to tell it what event names should be matched by a regex.
	 *
	 * @param {String} evt Name of the event to create.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvent = function defineEvent(evt) {
		this.getListeners(evt);
		return this;
	};

	/**
	 * Uses defineEvent to define multiple events.
	 *
	 * @param {String[]} evts An array of event names to define.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.defineEvents = function defineEvents(evts) {
		for (var i = 0; i < evts.length; i += 1) {
			this.defineEvent(evts[i]);
		}
		return this;
	};

	/**
	 * Removes a listener function from the specified event.
	 * When passed a regular expression as the event name, it will remove the listener from all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to remove the listener from.
	 * @param {Function} listener Method to remove from the event.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListener = function removeListener(evt, listener) {
		var listeners = this.getListenersAsObject(evt);
		var index;
		var key;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				index = indexOfListener(listeners[key], listener);

				if (index !== -1) {
					listeners[key].splice(index, 1);
				}
			}
		}

		return this;
	};

	/**
	 * Alias of removeListener
	 */
	proto.off = alias('removeListener');

	/**
	 * Adds listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can add to multiple events at once. The object should contain key value pairs of events and listeners or listener arrays. You can also pass it an event name and an array of listeners to be added.
	 * You can also pass it a regular expression to add the array of listeners to all events that match it.
	 * Yeah, this function does quite a bit. That's probably a bad thing.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add to multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.addListeners = function addListeners(evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(false, evt, listeners);
	};

	/**
	 * Removes listeners in bulk using the manipulateListeners method.
	 * If you pass an object as the second argument you can remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be removed.
	 * You can also pass it a regular expression to remove the listeners from all events that match it.
	 *
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeListeners = function removeListeners(evt, listeners) {
		// Pass through to manipulateListeners
		return this.manipulateListeners(true, evt, listeners);
	};

	/**
	 * Edits listeners in bulk. The addListeners and removeListeners methods both use this to do their job. You should really use those instead, this is a little lower level.
	 * The first argument will determine if the listeners are removed (true) or added (false).
	 * If you pass an object as the second argument you can add/remove from multiple events at once. The object should contain key value pairs of events and listeners or listener arrays.
	 * You can also pass it an event name and an array of listeners to be added/removed.
	 * You can also pass it a regular expression to manipulate the listeners of all events that match it.
	 *
	 * @param {Boolean} remove True if you want to remove listeners, false if you want to add.
	 * @param {String|Object|RegExp} evt An event name if you will pass an array of listeners next. An object if you wish to add/remove from multiple events at once.
	 * @param {Function[]} [listeners] An optional array of listener functions to add/remove.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.manipulateListeners = function manipulateListeners(remove, evt, listeners) {
		var i;
		var value;
		var single = remove ? this.removeListener : this.addListener;
		var multiple = remove ? this.removeListeners : this.addListeners;

		// If evt is an object then pass each of it's properties to this method
		if (typeof evt === 'object' && !(evt instanceof RegExp)) {
			for (i in evt) {
				if (evt.hasOwnProperty(i) && (value = evt[i])) {
					// Pass the single listener straight through to the singular method
					if (typeof value === 'function') {
						single.call(this, i, value);
					}
					else {
						// Otherwise pass back to the multiple function
						multiple.call(this, i, value);
					}
				}
			}
		}
		else {
			// So evt must be a string
			// And listeners must be an array of listeners
			// Loop over it and pass each one to the multiple method
			i = listeners.length;
			while (i--) {
				single.call(this, evt, listeners[i]);
			}
		}

		return this;
	};

	/**
	 * Removes all listeners from a specified event.
	 * If you do not specify an event then all listeners will be removed.
	 * That means every event will be emptied.
	 * You can also pass a regex to remove all events that match it.
	 *
	 * @param {String|RegExp} [evt] Optional name of the event to remove all listeners for. Will remove from every event if not passed.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.removeEvent = function removeEvent(evt) {
		var type = typeof evt;
		var events = this._getEvents();
		var key;

		// Remove different things depending on the state of evt
		if (type === 'string') {
			// Remove all listeners for the specified event
			delete events[evt];
		}
		else if (type === 'object') {
			// Remove all events matching the regex.
			for (key in events) {
				if (events.hasOwnProperty(key) && evt.test(key)) {
					delete events[key];
				}
			}
		}
		else {
			// Remove all listeners in all events
			delete this._events;
		}

		return this;
	};

	/**
	 * Alias of removeEvent.
	 *
	 * Added to mirror the node API.
	 */
	proto.removeAllListeners = alias('removeEvent');

	/**
	 * Emits an event of your choice.
	 * When emitted, every listener attached to that event will be executed.
	 * If you pass the optional argument array then those arguments will be passed to every listener upon execution.
	 * Because it uses `apply`, your array of arguments will be passed as if you wrote them out separately.
	 * So they will not arrive within the array on the other side, they will be separate.
	 * You can also pass a regular expression to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {Array} [args] Optional array of arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emitEvent = function emitEvent(evt, args) {
		var listeners = this.getListenersAsObject(evt);
		var listener;
		var i;
		var key;
		var response;

		for (key in listeners) {
			if (listeners.hasOwnProperty(key)) {
				i = listeners[key].length;

				while (i--) {
					// If the listener returns true then it shall be removed from the event
					// The function is executed either with a basic call or an apply if there is an args array
					listener = listeners[key][i];

					if (listener.once === true) {
						this.removeListener(evt, listener.listener);
					}

					response = listener.listener.apply(this, args || []);

					if (response === this._getOnceReturnValue()) {
						this.removeListener(evt, listener.listener);
					}
				}
			}
		}

		return this;
	};

	/**
	 * Alias of emitEvent
	 */
	proto.trigger = alias('emitEvent');

	/**
	 * Subtly different from emitEvent in that it will pass its arguments on to the listeners, as opposed to taking a single array of arguments to pass on.
	 * As with emitEvent, you can pass a regex in place of the event name to emit to all events that match it.
	 *
	 * @param {String|RegExp} evt Name of the event to emit and execute listeners for.
	 * @param {...*} Optional additional arguments to be passed to each listener.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.emit = function emit(evt) {
		var args = Array.prototype.slice.call(arguments, 1);
		return this.emitEvent(evt, args);
	};

	/**
	 * Sets the current value to check against when executing listeners. If a
	 * listeners return value matches the one set here then it will be removed
	 * after execution. This value defaults to true.
	 *
	 * @param {*} value The new value to check for when executing listeners.
	 * @return {Object} Current instance of EventEmitter for chaining.
	 */
	proto.setOnceReturnValue = function setOnceReturnValue(value) {
		this._onceReturnValue = value;
		return this;
	};

	/**
	 * Fetches the current value to check against when executing listeners. If
	 * the listeners return value matches this one then it should be removed
	 * automatically. It will return true by default.
	 *
	 * @return {*|Boolean} The current value to check for or the default, true.
	 * @api private
	 */
	proto._getOnceReturnValue = function _getOnceReturnValue() {
		if (this.hasOwnProperty('_onceReturnValue')) {
			return this._onceReturnValue;
		}
		else {
			return true;
		}
	};

	/**
	 * Fetches the events object and creates one if required.
	 *
	 * @return {Object} The events storage object.
	 * @api private
	 */
	proto._getEvents = function _getEvents() {
		return this._events || (this._events = {});
	};

	/**
	 * Reverts the global {@link EventEmitter} to its previous value and returns a reference to this version.
	 *
	 * @return {Function} Non conflicting EventEmitter class.
	 */
	EventEmitter.noConflict = function noConflict() {
		exports.EventEmitter = originalGlobalValue;
		return EventEmitter;
	};

	// Expose the class either via AMD, CommonJS or the global object
	if (typeof define === 'function' && define.amd) {
		define('eventEmitter/EventEmitter',[],function () {
			return EventEmitter;
		});
	}
	else if (typeof module === 'object' && module.exports){
		module.exports = EventEmitter;
	}
	else {
		this.EventEmitter = EventEmitter;
	}
}.call(this));

/*!
 * eventie v1.0.4
 * event binding helper
 *   eventie.bind( elem, 'click', myFn )
 *   eventie.unbind( elem, 'click', myFn )
 */

/*jshint browser: true, undef: true, unused: true */
/*global define: false */

( function( window ) {



var docElem = document.documentElement;

var bind = function() {};

function getIEEvent( obj ) {
  var event = window.event;
  // add event.target
  event.target = event.target || event.srcElement || obj;
  return event;
}

if ( docElem.addEventListener ) {
  bind = function( obj, type, fn ) {
    obj.addEventListener( type, fn, false );
  };
} else if ( docElem.attachEvent ) {
  bind = function( obj, type, fn ) {
    obj[ type + fn ] = fn.handleEvent ?
      function() {
        var event = getIEEvent( obj );
        fn.handleEvent.call( fn, event );
      } :
      function() {
        var event = getIEEvent( obj );
        fn.call( obj, event );
      };
    obj.attachEvent( "on" + type, obj[ type + fn ] );
  };
}

var unbind = function() {};

if ( docElem.removeEventListener ) {
  unbind = function( obj, type, fn ) {
    obj.removeEventListener( type, fn, false );
  };
} else if ( docElem.detachEvent ) {
  unbind = function( obj, type, fn ) {
    obj.detachEvent( "on" + type, obj[ type + fn ] );
    try {
      delete obj[ type + fn ];
    } catch ( err ) {
      // can't delete window object properties
      obj[ type + fn ] = undefined;
    }
  };
}

var eventie = {
  bind: bind,
  unbind: unbind
};

// transport
if ( typeof define === 'function' && define.amd ) {
  // AMD
  define( 'eventie/eventie',eventie );
} else {
  // browser global
  window.eventie = eventie;
}

})( this );

/*!
 * imagesLoaded v3.1.8
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */

( function( window, factory ) { 
  // universal module definition

  /*global define: false, module: false, require: false */

  if ( typeof define === 'function' && define.amd ) {
    // AMD
    define( [
      'eventEmitter/EventEmitter',
      'eventie/eventie'
    ], function( EventEmitter, eventie ) {
      return factory( window, EventEmitter, eventie );
    });
  } else if ( typeof exports === 'object' ) {
    // CommonJS
    module.exports = factory(
      window,
      require('wolfy87-eventemitter'),
      require('eventie')
    );
  } else {
    // browser global
    window.imagesLoaded = factory(
      window,
      window.EventEmitter,
      window.eventie
    );
  }

})( window,

// --------------------------  factory -------------------------- //

function factory( window, EventEmitter, eventie ) {



var $ = window.jQuery;
var console = window.console;
var hasConsole = typeof console !== 'undefined';

// -------------------------- helpers -------------------------- //

// extend objects
function extend( a, b ) {
  for ( var prop in b ) {
    a[ prop ] = b[ prop ];
  }
  return a;
}

var objToString = Object.prototype.toString;
function isArray( obj ) {
  return objToString.call( obj ) === '[object Array]';
}

// turn element or nodeList into an array
function makeArray( obj ) {
  var ary = [];
  if ( isArray( obj ) ) {
    // use object if already an array
    ary = obj;
  } else if ( typeof obj.length === 'number' ) {
    // convert nodeList to array
    for ( var i=0, len = obj.length; i < len; i++ ) {
      ary.push( obj[i] );
    }
  } else {
    // array of single index
    ary.push( obj );
  }
  return ary;
}

  // -------------------------- imagesLoaded -------------------------- //

  /**
   * @param {Array, Element, NodeList, String} elem
   * @param {Object or Function} options - if function, use as callback
   * @param {Function} onAlways - callback function
   */
  function ImagesLoaded( elem, options, onAlways ) {
    // coerce ImagesLoaded() without new, to be new ImagesLoaded()
    if ( !( this instanceof ImagesLoaded ) ) {
      return new ImagesLoaded( elem, options );
    }
    // use elem as selector string
    if ( typeof elem === 'string' ) {
      elem = document.querySelectorAll( elem );
    }

    this.elements = makeArray( elem );
    this.options = extend( {}, this.options );

    if ( typeof options === 'function' ) {
      onAlways = options;
    } else {
      extend( this.options, options );
    }

    if ( onAlways ) {
      this.on( 'always', onAlways );
    }

    this.getImages();

    if ( $ ) {
      // add jQuery Deferred object
      this.jqDeferred = new $.Deferred();
    }

    // HACK check async to allow time to bind listeners
    var _this = this;
    setTimeout( function() {
      _this.check();
    });
  }

  ImagesLoaded.prototype = new EventEmitter();

  ImagesLoaded.prototype.options = {};

  ImagesLoaded.prototype.getImages = function() {
    this.images = [];

    // filter & find items if we have an item selector
    for ( var i=0, len = this.elements.length; i < len; i++ ) {
      var elem = this.elements[i];
      // filter siblings
      if ( elem.nodeName === 'IMG' ) {
        this.addImage( elem );
      }
      // find children
      // no non-element nodes, #143
      var nodeType = elem.nodeType;
      if ( !nodeType || !( nodeType === 1 || nodeType === 9 || nodeType === 11 ) ) {
        continue;
      }
      var childElems = elem.querySelectorAll('img');
      // concat childElems to filterFound array
      for ( var j=0, jLen = childElems.length; j < jLen; j++ ) {
        var img = childElems[j];
        this.addImage( img );
      }
    }
  };

  /**
   * @param {Image} img
   */
  ImagesLoaded.prototype.addImage = function( img ) {
    var loadingImage = new LoadingImage( img );
    this.images.push( loadingImage );
  };

  ImagesLoaded.prototype.check = function() {
    var _this = this;
    var checkedCount = 0;
    var length = this.images.length;
    this.hasAnyBroken = false;
    // complete if no images
    if ( !length ) {
      this.complete();
      return;
    }

    function onConfirm( image, message ) {
      if ( _this.options.debug && hasConsole ) {
        console.log( 'confirm', image, message );
      }

      _this.progress( image );
      checkedCount++;
      if ( checkedCount === length ) {
        _this.complete();
      }
      return true; // bind once
    }

    for ( var i=0; i < length; i++ ) {
      var loadingImage = this.images[i];
      loadingImage.on( 'confirm', onConfirm );
      loadingImage.check();
    }
  };

  ImagesLoaded.prototype.progress = function( image ) {
    this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;
    // HACK - Chrome triggers event before object properties have changed. #83
    var _this = this;
    setTimeout( function() {
      _this.emit( 'progress', _this, image );
      if ( _this.jqDeferred && _this.jqDeferred.notify ) {
        _this.jqDeferred.notify( _this, image );
      }
    });
  };

  ImagesLoaded.prototype.complete = function() {
    var eventName = this.hasAnyBroken ? 'fail' : 'done';
    this.isComplete = true;
    var _this = this;
    // HACK - another setTimeout so that confirm happens after progress
    setTimeout( function() {
      _this.emit( eventName, _this );
      _this.emit( 'always', _this );
      if ( _this.jqDeferred ) {
        var jqMethod = _this.hasAnyBroken ? 'reject' : 'resolve';
        _this.jqDeferred[ jqMethod ]( _this );
      }
    });
  };

  // -------------------------- jquery -------------------------- //

  if ( $ ) {
    $.fn.imagesLoaded = function( options, callback ) {
      var instance = new ImagesLoaded( this, options, callback );
      return instance.jqDeferred.promise( $(this) );
    };
  }


  // --------------------------  -------------------------- //

  function LoadingImage( img ) {
    this.img = img;
  }

  LoadingImage.prototype = new EventEmitter();

  LoadingImage.prototype.check = function() {
    // first check cached any previous images that have same src
    var resource = cache[ this.img.src ] || new Resource( this.img.src );
    if ( resource.isConfirmed ) {
      this.confirm( resource.isLoaded, 'cached was confirmed' );
      return;
    }

    // If complete is true and browser supports natural sizes,
    // try to check for image status manually.
    if ( this.img.complete && this.img.naturalWidth !== undefined ) {
      // report based on naturalWidth
      this.confirm( this.img.naturalWidth !== 0, 'naturalWidth' );
      return;
    }

    // If none of the checks above matched, simulate loading on detached element.
    var _this = this;
    resource.on( 'confirm', function( resrc, message ) {
      _this.confirm( resrc.isLoaded, message );
      return true;
    });

    resource.check();
  };

  LoadingImage.prototype.confirm = function( isLoaded, message ) {
    this.isLoaded = isLoaded;
    this.emit( 'confirm', this, message );
  };

  // -------------------------- Resource -------------------------- //

  // Resource checks each src, only once
  // separate class from LoadingImage to prevent memory leaks. See #115

  var cache = {};

  function Resource( src ) {
    this.src = src;
    // add to cache
    cache[ src ] = this;
  }

  Resource.prototype = new EventEmitter();

  Resource.prototype.check = function() {
    // only trigger checking once
    if ( this.isChecked ) {
      return;
    }
    // simulate loading on detached element
    var proxyImage = new Image();
    eventie.bind( proxyImage, 'load', this );
    eventie.bind( proxyImage, 'error', this );
    proxyImage.src = this.src;
    // set flag
    this.isChecked = true;
  };

  // ----- events ----- //

  // trigger specified handler for event type
  Resource.prototype.handleEvent = function( event ) {
    var method = 'on' + event.type;
    if ( this[ method ] ) {
      this[ method ]( event );
    }
  };

  Resource.prototype.onload = function( event ) {
    this.confirm( true, 'onload' );
    this.unbindProxyEvents( event );
  };

  Resource.prototype.onerror = function( event ) {
    this.confirm( false, 'onerror' );
    this.unbindProxyEvents( event );
  };

  // ----- confirm ----- //

  Resource.prototype.confirm = function( isLoaded, message ) {
    this.isConfirmed = true;
    this.isLoaded = isLoaded;
    this.emit( 'confirm', this, message );
  };

  Resource.prototype.unbindProxyEvents = function( event ) {
    eventie.unbind( event.target, 'load', this );
    eventie.unbind( event.target, 'error', this );
  };

  // -----  ----- //

  return ImagesLoaded;

});


/*
 * jQuery Image Reveal - A Simple Before/After Image Viewer
 *
 * Version: Master
 * Homepage: http://github.com/lemoncreative/jquery-image-reveal
 * Licence: MIT
 * Copyright: (c) 2013 Lemon Creative;
 *
 * IMPORTANT:   This plugin has been specifically modified for Ford GUX.
 *              - Removed captions.
 *              - Removed extra width touchbar. The width is now changed in the CSS.
 *              - Changed full width draggable area so now it's dynamic. With of draggable slider can be changed in the HTML
 *                i.e. <div class="imageReveal" data-slider-width="50"> 50 equals 50% of the image/component width.
 */

(function($) {
    $.fn.extend({
        imageReveal: function(options) {
            var $el = {};

            // Merge passed in options with defaults
            options = $.extend({}, {
                barWidth: 30,
                touchBarWidth: 40,
                startPosition: 0.15,
                paddingLeft: 0,
                paddingRight: 0,
                width: 500,
                height: 500,
                ids: [],
                sliderPadding: 0.15
            }, options);

            options.ids = [];

            // Ensure startPosition is valid.
            if (options.startPosition > 1) options.startPosition = 1;
            else if (options.startPosition < 0) options.startPosition = 0;

            // Update - Moves the overlay and drag bar to the new location and displays the correct caption.
            function update(width, id) {

                // The width cannot be set lower than 0 or higher than options.width
                var dragPadding = options.sliderPadding * options.width;
                var dragBaseWidth = width;

                if (width < dragPadding) {
                    width = dragPadding;
                    dragBaseWidth = dragPadding;
                }
                if (width > (options.width - dragPadding)) {
                    width = options.width;
                    dragBaseWidth = options.width - dragPadding;
                }

                // The width must not go outside any specified padding
                if (width < options.paddingLeft) {
                    width = options.paddingLeft;
                    dragBaseWidth = options.paddingLeft;
                }
                if (width > (options.width - options.paddingRight)) {
                    width = options.width - options.paddingRight;
                    dragBaseWidth = options.width - options.paddingRight;
                }

                // Apply new width
                $el[id].overlay.width(width);

                // The drag bar 'left' position should be set to (width - barWidth/2) so we always drag from the center.
                var dragBarPosition = dragBaseWidth - (options.barWidth / 2);

                if (dragBarPosition < 0) dragBarPosition = 0;
                if (dragBarPosition > options.width - options.barWidth) dragBarPosition = options.width - options.barWidth;
                $el[id].drag.css({
                    left: dragBarPosition
                });

            }

            // handleEvent - Calls 'update' if the event is valid
            function handleEvent(e) {
                var id = $(this).data('imageRevealID');

                if (!$el[id].dragging && e.type !== 'click') return false;
                var position;

                // If it was a touch event
                if (e.originalEvent && e.originalEvent.changedTouches) {
                    // Get position from touch event
                    position = e.originalEvent.changedTouches[0].pageX;
                }
                // Otherwise get position from mouse event
                else {
                    position = e.pageX;
                }

                // Call update with new width
                update(position - $el[id].overlay.offset().left, id);
                return false;
            }

            return this.each(function(i) {
                $el[i] = {};
                options.ids.push(i);

                // Container
                $el[i].container = $(this).addClass('imageReveal').data('imageRevealID', i);

                // Get Slider Width
                $el[i].sliderWidth = $el[i].container.data('slider-width');
                options.sliderPadding = ((100 - $el[i].sliderWidth) / 2) / 100;

                // Left Scroller Icon
                var halfSliderWidth=((($el[i].sliderWidth / 100) * options.width) / 2);
                $el[i].scrollerLeft = $el[i].container.children('.scroller-left')
                    .css({
                        'display': 'block',
                        'margin-left': (halfSliderWidth + 128) * 2 > options.width ? (-options.width/2) : (-halfSliderWidth - 128)
                    });

                // Right Scroller Icon
                $el[i].scrollerRight = $el[i].container.children('.scroller-right')
                    .css({
                        'display': 'block',
                        'margin-right': (halfSliderWidth + 132) * 2 > options.width ? (-options.width / 2) : (-halfSliderWidth - 132)
                    });

                // Before Image
                $el[i].before = $el[i].container.children('img').first()
                    .width(options.width)
                    .height(options.height)
                    .hide();

                // After Image
                $el[i].after = $el[i].before.next()
                    .width(options.width)
                    .height(options.height)
                    .hide();

                // Set up container
                $el[i].container
                    .width(options.width)
                    .height(options.height)
                    .css({
                        overflow: 'hidden',
                        position: 'relative'
                    })
                    .append('<div class="imageReveal-overlay"></div>')
                    .append('<div class="imageReveal-background"></div>')
                    .append('<div class="imageReveal-drag-bar"></div>')
                    .append('<div class="imageReveal-drag"></div>');

                // Slider bar
                $el[i].bar = $el[i].container.children('.imageReveal-drag-bar')
                    .width(($el[i].sliderWidth / 100) * options.width)
                    .css({
                        'margin-left': -(($el[i].sliderWidth / 100) * options.width) / 2
                    });

                // Background
                $el[i].bg = $el[i].container.children('.imageReveal-background')
                    .width(options.width)
                    .height(options.height)
                    .css({
                        'background-image': 'url(' + $el[i].after.attr('src') + ')',
                        'background-size': options.width + 'px ' + options.height + 'px'
                    });

                // Overlay
                $el[i].overlay = $el[i].container.children('.imageReveal-overlay')
                    .width(options.width)
                    .height(options.height)
                    .css({
                        'background-image': 'url(' + $el[i].before.attr('src') + ')',
                        'background-size': options.width + 'px ' + options.height + 'px'
                    });
                    //.animate({
                    //    width: options.width - (options.width * options.startPosition)
                    //});

                // Drag Bar
                $el[i].drag = $el[i].container.children('.imageReveal-drag')
                    .css({ right: (options.sliderPadding * options.width) - (options.barWidth / 2)})
                    .on('mousedown touchstart', function() {
                        $el[i].dragging = true;
                        $el[i].drag.addClass('dragging');
                        return false;
                    })
                    .on('mouseup touchend touchcancel', function() {
                        $el[i].dragging = false;
                        $el[i].drag.removeClass('dragging');
                        return false;
                    });

                // Catch mouseup on document for when the user
                // releases the mouse button outside the container.
                $(document).on('mouseup touchend touchcancel', function() {
                    if (!$el[i].dragging) return;
                    $el[i].dragging = false;
                    $el[i].drag.removeClass('dragging');
                });

                // When the bar is dragged outside the container, immediately
                // move it to the min or max position. This avoids the bar
                // getting stuck when the mouse is moved too fast
                $el[i].container.on('mouseout', function(e) {
                    if (!$el[i].dragging) return;
                    update(e.pageX - $el[i].overlay.offset().left, i);
                });

            }).on('mousemove click touchmove', handleEvent);
        }
    });
})(jQuery);


/**
          @@@@@@@@@@@@@@
      @@@@@@@@@@@@@@@@@@@@@@
    @@@@@@@@          @@@@@@@@
  @@@@@@@                @@@@@@@
 @@@@@@@                  @@@@@@@
 @@@@@@@                  @@@@@@@
 @@@@@@@@     @          @@@@@@@@
  @@@@@@@@@  @@@       @@@@@@@@@
   @@@@@@@@@@@@@@   @@@@@@@@@@@
     @@@@@@@@@@@@@    @@@@@@@
       @@@@@@@@@@@@     @@@
          @@@@@@
         @@@@
        @@
 *
 * jQuery Reel
 * ===========
 * The 360? plugin for jQuery
 *
 * @license Copyright (c) 2009-2013 Petr Vostrel (http://petr.vostrel.cz/)
 * Licensed under the MIT License (LICENSE.txt).
 *
 * jQuery Reel
 * http://reel360.org
 * Version: 1.3.0
 * Updated: 2013-11-04
 *
 * Requires jQuery 1.6.2 or higher
 */

/*
 * CDN
 * ---
 * - http://code.vostrel.net/jquery.reel-bundle.js (recommended)
 * - http://code.vostrel.net/jquery.reel.js
 * - http://code.vostrel.net/jquery.reel-debug.js
 * - or http://code.vostrel.net/jquery.reel-edge.js if you feel like it ;)
 *
 * Optional Plugins
 * ----------------
 * - jQuery.mouseWheel [B] (Brandon Aaron, http://plugins.jquery.com/project/mousewheel)
 * - or jQuery.event.special.wheel (Three Dub Media, http://blog.threedubmedia.com/2008/08/eventspecialwheel.html)
 *
 * [B] Marked plugins are contained (with permissions) in the "bundle" version from the CDN
 */

(function(factory){

  // -----------------------
  // [NEW] AMD Compatibility
  // -----------------------
  //
  // Reel registers as an asynchronous module with dependency on jQuery for [AMD][1] compatible script loaders.
  // Besides that it also complies with [CommonJS][2] module definition for Node and such.
  // Of course, no fancy script loader is necessary and good old plain script tag still works too.
  //
  // [1]:http://en.wikipedia.org/wiki/Asynchronous_module_definition
  // [2]:http://en.wikipedia.org/wiki/CommonJS
  //
  var
    amd= typeof define == 'function' && define.amd && (define(['jquery'], factory) || true),
    commonjs= !amd && typeof module == 'object' && typeof module.exports == 'object' && (module.exports= factory),
    plain= !amd && !commonjs && factory()

})(function(){ return jQuery.reel || (function($, window, document, undefined){

  // ------
  // jQuery
  // ------
  //
  // One vital requirement is the correct jQuery. Reel requires at least version 1.6.2
  // and a make sure check is made at the very beginning.
  //
  if (!$) return;
  var
    version= $ && $().jquery.split(/\./)
  if (!version || +(twochar(version[0])+twochar(version[1])+twochar(version[2] || '')) < 10602)
    return error('Too old jQuery library. Please upgrade your jQuery to version 1.6.2 or higher');
  // ----------------
  // Global Namespace
  // ----------------
  //
  // `$.reel` (or `jQuery.reel`) namespace is provided for storage of all Reel belongings.
  // It is locally referenced as just `reel` for speedier access.
  //
  var
    reel= $.reel= {

      // ### `$.reel.version`
      //
      // `String` (major.minor.patch), since 1.1
      //
      version: '1.3.0',

      // Options
      // -------
      //
      // When calling `.reel()` method you have plenty of options (far too many) available.
      // You collect them into one hash and supply them with your call.
      //
      // _**Example:** Initiate a non-looping Reel with 12 frames:_
      //
      //     .reel({
      //       frames: 12,
      //       looping: false
      //     })
      //
      //
      // All options are optional and if omitted, default value is used instead.
      // Defaults are being housed as members of `$.reel.def` hash.
      // If you customize any default value therein, all subsequent `.reel()` calls
      // will use the new value as default.
      //
      // _**Example:** Change default initial frame to 5th:_
      //
      //     $.reel.def.frame = 5
      //
      // ---

      // ### `$.reel.def` ######
      // `Object`, since 1.1
      //
      def: {
        //
        // ### Basic Definition ######
        //
        // Reel is just fine with you not setting any options, however if you don't have
        // 36 frames or beginning at frame 1, you will want to set total number
        // of `frames` and pick a different starting `frame`.
        //
        // ---

        // #### `frame` Option ####
        // `Number` (frames), since 1.0
        //
        frame:                  1,

        // #### `frames` Option ####
        // `Number` (frames), since 1.0
        //
        frames:                36,

        // ~~~
        //
        // Another common characteristics of any Reel is whether it `loops` and covers
        // entire 360? or not.
        //
        // ---

        // #### `loops` Option ####
        // `Boolean`, since 1.0
        //
        loops:               true,


        // ### Interaction ######
        //
        // Using boolean switches many user interaction aspects can be turned on and off.
        // You can disable the mouse wheel control with `wheelable`, the drag & throw
        // action with `throwable`, disallow the dragging completely with `draggable`,
        // on touch devices you can disable the browser's decision to scroll the page
        // instead of Reel script and you can of course disable the stepping of Reel by
        // clicking on either half of the image with `steppable`.
        //
        // You can even enable `clickfree` operation,
        // which will cause Reel to bind to mouse enter/leave events instead of mouse down/up,
        // thus allowing a click-free dragging.
        //
        // ---

        // #### `clickfree` Option ####
        // `Boolean`, since 1.1
        //
        clickfree:          false,

        // #### `draggable` Option ####
        // `Boolean`, since 1.1
        //
        draggable:           true,

        // #### `scrollable` Option ####
        // `Boolean`, since 1.2
        //
        scrollable:          true,

        // #### `steppable` Option ####
        // `Boolean`, since 1.2
        //
        steppable:           true,

        // #### `throwable` Option ####
        // `Boolean`, since 1.1; or `Number`, since 1.2.1
        //
        throwable:           true,

        // #### `wheelable` Option ####
        // `Boolean`, since 1.1
        //
        wheelable:           true,


        // ### [NEW] Gyroscope Support ######
        //
        // When enabled allows gyro-enabled devices (iPad2 for example) to control rotational
        // position using the device's attitude in space. In this more, Reel directly maps the
        // 360? range of your gyro's primary (alpha) axis directly to the value of `fraction`.
        //
        // #### `orientable` Option ####
        // [NEW] `Boolean`, since 1.3
        //
        orientable:         false,


        // ### Order of Images ######
        //
        // Reel presumes counter-clockwise order of the pictures taken. If the nearer facing
        // side doesn't follow your cursor/finger, you did clockwise. Use the `cw` option to
        // correct this.
        //
        // ---

        // #### `cw` Option ####
        // `Boolean`, since 1.1
        //
        cw:                 false,


        // ### Sensitivity ######
        //
        // In Reel sensitivity is set through the `revolution` parameter, which represents horizontal
        // dragging distance one must cover to perform one full revolution. By default this value
        // is calculated based on the setup you have - it is either twice the width of the image
        // or half the width of stitched panorama. You may also set your own.
        //
        // Optionally `revolution` can be set as an Object with `x` member for horizontal revolution
        // and/or `y` member for vertical revolution in multi-row movies.
        //
        // ---

        // #### `revolution` Option ####
        // `Number` (pixels) or `Object`, since 1.1, `Object` support since 1.2
        //
        revolution:     undefined,


        // ### Rectilinear Panorama ######
        //
        // The easiest of all is the stitched panorama mode. For this mode, instead of the sprite,
        // a single seamlessly stitched stretched image is used and the view scrolls the image.
        // This mode is triggered by setting a pixel width of the `stitched` image.
        //
        // ---

        // #### `stitched` Option ####
        // `Number` (pixels), since 1.0
        //
        stitched:               0,


        // ### Directional Mode ######
        //
        // As you may have noticed on Reel's homepage or in [`example/object-movie-directional-sprite`][1]
        // when you drag the arrow will point to either direction. In such `directional` mode, the sprite
        // is actually 2 in 1 - one file contains two sprites one tightly following the other, one
        // for visually going one way (`A`) and one for the other (`B`).
        //
        //     A01 A02 A03 A04 A05 A06
        //     A07 A08 A09 A10 A11 A12
        //     A13 A14 A15 B01 B02 B03
        //     B04 B05 B06 B07 B08 B09
        //     B10 B11 B12 B13 B14 B15
        //
        // Switching between `A` and `B` frames is based on direction of the drag. Directional mode isn't
        // limited to sprites only, sequences also apply. The figure below shows the very same setup like
        // the above figure, only translated into actual frames of the sequence.
        //
        //     001 002 003 004 005 006
        //     007 008 009 010 011 012
        //     013 014 015 016 017 018
        //     019 020 021 022 023 024
        //     025 026 027 028 029 030
        //
        // Frame `016` represents the `B01` so it actually is first frame of the other direction.
        //
        // [1]:../example/object-movie-directional-sprite/
        //
        // ---

        // #### `directional` Option ####
        // `Boolean`, since 1.1
        //
        directional:        false,


        // ### Multi-Row Mode ######
        //
        // As [`example/object-movie-multirow-sequence`][1] very nicely demonstrates, in multi-row arrangement
        // you can perform two-axis manipulation allowing you to add one or more vertical angles. Think of it as
        // a layered cake, each new elevation of the camera during shooting creates one layer of the cake -
        // - a _row_. One plain horizontal object movie full spin is one row:
        //
        //     A01 A02 A03 A04 A05 A06
        //     A07 A08 A09 A10 A11 A12
        //     A13 A14 A15
        //
        // Second row tightly follows after the first one:
        //
        //     A01 A02 A03 A04 A05 A06
        //     A07 A08 A09 A10 A11 A12
        //     A13 A14 A15 B01 B02 B03
        //     B04 B05 B06 B07 B08 B09
        //     B10 B11 B12 B13 B14 B15
        //     C01...
        //
        // This way you stack up any number of __`rows`__ you wish and set the initial `row` to start with.
        // Again, not limited to sprites, sequences also apply.
        //
        // [1]:../example/object-movie-multirow-sequence/
        //
        // ---

        // #### `row` Option ####
        // `Number` (rows), since 1.1
        //
        row:                    1,

        // #### `rows` Option ####
        // `Number` (rows), since 1.1
        //
        rows:                   0,


        // ### [NEW] Multi-Row Locks ######
        //
        // Optionally you can apply a lock on either of the two axes with `rowlock` and/or `framelock`.
        // That will disable direct mouse interaction and will leave using of `.reel()` the only way
        // of changing position on the locked axis.
        //
        // ---

        // #### `rowlock` Option ####
        // [NEW] `Boolean`, since 1.3
        //
        rowlock:            false,

        // #### `framelock` Option ####
        // [NEW] `Boolean`, since 1.3
        //
        framelock:          false,


        // ### Dual-Orbit Mode ######
        //
        // Special form of multi-axis movie is the dual-axis mode. In this mode the object offers two plain
        // spins - horizontal and vertical orbits combined together crossing each other at the `frame`
        // forming sort of a cross if envisioned. [`example/object-movie-dual-orbit-sequence`][1] demonstrates
        // this setup. When the phone in the example is facing you (marked in the example with green square
        // in the top right), you are at the center. That is within the distance (in frames) defined
        // by the `orbital` option. Translation from horizontal to vertical orbit can be achieved on this sweet-spot.
        // By default horizontal orbit is chosen first, unless `vertical` option is used against.
        //
        // In case the image doesn't follow the vertical drag, you may have your vertical orbit `inversed`.
        //
        // Technically it is just a two-layer movie:
        //
        //     A01 A02 A03 A04 A05 A06
        //     A07 A08 A09 A10 A11 A12
        //     A13 A14 A15 B01 B02 B03
        //     B04 B05 B06 B07 B08 B09
        //     B10 B11 B12 B13 B14 B15
        //
        // [1]:../example/object-movie-dual-orbit-sequence/
        //
        // ---

        // #### `orbital` Option ####
        // `Number` (frames), since 1.1
        //
        orbital:                0,

        // #### `vertical` Option ####
        // `Boolean`, since 1.1
        //
        vertical:           false,

        // #### `inversed` Option ####
        // `Boolean`, since 1.1
        //
        inversed:           false,


        // ### Sprite Layout ######
        //
        // For both object movies and panoramas Reel presumes you use a combined _Sprite_ to hold all your
        // frames in a single file. This powerful technique of using a sheet of several individual images
        // has many advantages in terms of compactness, loading, caching, etc. However, know your enemy,
        // be also aware of the limitations, which stem from memory limits of mobile
        // (learn more in [FAQ](https://github.com/pisi/Reel/wiki/FAQ)).
        //
        // Inside the sprite, individual frames are laid down one by one, to the right of the previous one
        // in a straight _Line_:
        //
        //     01 02 03 04 05 06
        //     07...
        //
        // Horizontal length of the line is reffered to as `footage`. Unless frames `spacing` in pixels
        // is set, edges of frames must touch.
        //
        //     01 02 03 04 05 06
        //     07 08 09 10 11 12
        //     13 14 15 16 17 18
        //     19 20 21 22 23 24
        //     25 26 27 28 29 30
        //     31 32 33 34 35 36
        //
        // This is what you'll get by calling `.reel()` without any options. All frames laid out 6 in line.
        // By default nicely even 6 x 6 grid like, which also inherits the aspect ratio of your frames.
        //
        // By setting `horizontal` to `false`, instead of forming lines, frames are expected to form
        // _Columns_. All starts at the top left corner in both cases.
        //
        //     01 07 13 19 25 31
        //     02 08 14 20 26 32
        //     03 09 15 21 27 33
        //     04 10 16 22 28 34
        //     05 11 17 23 29 35
        //     06 12 18 24 30 36
        //
        // URL for the sprite image file is being build from the name of the original `<img>` `src` image
        // by adding a `suffix` to it. By default this results in `"object-reel.jpg"` for `"object.jpg"`.
        // You can also take full control over the sprite `image` URL that will be used.
        //
        // ---

        // #### `footage` Option ####
        // `Number` (frames), since 1.0
        //
        footage:                6,

        // #### `spacing` Option ####
        // `Number` (pixels), since 1.0
        //
        spacing:                0,

        // #### `horizontal` Option ####
        // `Boolean`, since 1.0
        //
        horizontal:          true,

        // #### `suffix` Option ####
        // `String`, since 1.0
        //
        suffix:           '-reel',

        // #### `image` Option ####
        // `String`, since 1.1
        //
        image:          undefined,


        // ### Sequence ######
        //
        // Collection of individual frame images is called _Sequence_ and it this way one HTTP request per
        // frame is made carried out as opposed to sprite with one request per entire sprite. Define it with
        // string like: `"image_###.jpg"`. The `#` placeholders will be replaced with a numeric +1 counter
        // padded to the placeholders length.
        // Learn more about [sequences](Sequences).
        //
        // In case you work with hashed filenames like `64bc654d21cb.jpg`, where no counter element can
        // be indentified, or you prefer direct control, `images` can also accept array of plain URL strings.
        //
        // All images are retrieved from a specified `path`.
        //
        // ---

        // #### `images` Option ####
        // [IMPROVED] `String` or `Array`, since 1.1
        //
        images:                '',

        // #### `path` Option ####
        // `String` (URL path), since 1.1
        //
        path:                  '',


        // ### Images Preload Order ######
        //
        // Given sequence images can be additionally reordered to achieve a perceived faster preloading.
        // Value given to `preload` option must match a name of a pre-registered function within
        // `$.reel.preload` object. There are two functions built-in:
        //
        // - `"fidelity"` - non-linear way that ensures even spreading of preloaded images around the entire
        //   revolution leaving the gaps in-between as small as possible. This results in a gradually
        //   increasing fidelity of the image rather than having one large shrinking gap. This is the default
        //   behavior.
        // - `"linear"` - linear order of preloading
        //
        // ---

        // #### `preload` Option ####
        // `String`, since 1.2
        //
        preload:       'fidelity',

        // ### [NEW] Shy Initialization ######
        //
        // Sometimes, on-demand activation is desirable in order to conserve device resources or bandwidth
        // especially with multiple instances on a single page. If so, enable _shy mode_, in which Reel will
        // hold up the initialization process until the image is clicked by the user. Alternativelly you can
        // initialize shy instance by triggering `"setup"` event.
        //
        // ---

        // #### `shy` Option ####
        // [NEW] `Boolean`, since 1.3
        //
        shy:                false,


        // ### Animation ######
        //
        // Your object movie or a panorama can perform an autonomous sustained motion in one direction.
        // When `speed` is set in revolutions per second (Hz), after a given `delay` the instance will
        // animate and advance frames by itself.
        //
        //     t
        //     |-------???|-----------???
        //       Delay    Animation
        //
        // Start and resume of animation happens when given `timeout` has elapsed since user became idle.
        //
        //     t
        //     |-----------???|= == ==  = === = = |          |-----------???
        //       Animation    User interaction    Timeout    Animation
        //
        // When a scene doesn't loop (see [`loops`](#loops-Option)) and the animation reaches one end,
        // it stays there for a while and then reversing the direction of the animation it bounces back
        // towards the other end. The time spent on the edge can be customized with `rebound`.
        //
        // ---

        // #### `speed` Option ####
        // `Number` (Hz), since 1.1
        //
        speed:                  0,

        // #### `delay` Option ####
        // `Number` (seconds), since 1.1
        //
        delay:                  0,

        // #### `timeout` Option ####
        // `Number` (seconds), since 1.1
        //
        timeout:                2,

        // #### `duration` Option ####
        // `Number` (seconds), since 1.3
        //
        duration:       undefined,

        // #### `rebound` Option ####
        // `Number` (seconds), since 1.1
        //
        rebound:              0.5,


        // ### Opening Animation ######
        //
        // Chance is you want the object to spin a little to attract attention and then stop and wait
        // for the user to engage. This is called "opening animation" and it is performed for given number
        // of seconds (`opening`) at dedicated `entry` speed. The `entry` speed defaults to value of `speed`
        // option. After the opening animation has passed, regular animation procedure begins starting with
        // the delay (if any).
        //
        //     t
        //     |--------???|-------???|-----------???
        //       Opening   Delay    Animation
        //
        // ---

        // #### `entry` Option ####
        // `Number` (Hz), since 1.1
        //
        entry:          undefined,

        // #### `opening` Option ####
        // `Number` (seconds), since 1.1
        //
        opening:                0,


        // ### Momentum ######
        //
        // Often also called inertial motion is a result of measuring a velocity of dragging. This velocity
        // builds up momentum, so when a drag is released, the image still retains the momentum and continues
        // to spin on itself. Naturally the momentum soon wears off as `brake` is being applied.
        //
        // One can utilize this momentum for a different kind of an opening animation. By setting initial
        // `velocity`, the instance gets artificial momentum and spins to slow down to stop.
        //
        // ---

        // #### `brake` Option ####
        // `Number`, since 1.1, where it also has a different default `0.5`
        //
        brake:               0.23,

        // #### `velocity` Option ####
        // `Number`, since 1.2
        //
        velocity:               0,


        // ### Ticker ######
        //
        // For purposes of animation, Reel starts and maintains a timer device which emits ticks timing all
        // animations. There is only one ticker running in the document and all instances subscribe to this
        // one ticker. Ticker is equipped with a mechanism, which compensates for the  measured costs
        // of running Reels to ensure the ticker ticks on time. The `tempo` (in Hz) of the ticker can be
        // specified.
        //
        // Please note, that ticker is synchronized with a _leader_, the oldest living instance on page,
        // and adjusts to his tempo.
        //
        // ---

        // #### `tempo` Option ####
        // `Number` (Hz, ticks per second), since 1.1
        //
        tempo:                 36,

        // ~~~
        //
        // Since many mobile devices are sometimes considerably underpowered in comparison with desktops,
        // they often can keep up with the 36 Hz rhythm. In Reel these are called __lazy devices__
        // and everything mobile qualifies as lazy for the sake of the battery and interaction fluency.
        // The ticker is under-clocked for them by a `laziness` factor, which is used to divide the `tempo`.
        // Default `laziness` of `6` will effectively use 6 Hz instead (6 = 36 / 6) on lazy devices.
        //
        // ---

        // #### `laziness` Option ####
        // `Number`, since 1.1
        //
        laziness:               6,


        // ### Customization ######
        //
        // You can customize Reel on both functional and visual front. The most visible thing you can
        // customize is probably the `cursor`, size of the `preloader`, perhaps add visual `indicator`(s)
        // of Reel's position within the range. You can also set custom `hint` for the tooltip, which appears
        // when you mouse over the image area. Last but not least you can also add custom class name `klass`
        // to the instance.
        //
        // ---

        // #### `cursor` Option ####
        // `String`, since 1.2
        //
        cursor:         undefined,

        // #### `hint` Option ####
        // `String`, since 1.0
        //
        hint:                  '',

        // #### `indicator` Option ####
        // `Number` (pixels), since 1.0
        //
        indicator:              0,

        // #### `klass` Option ####
        // `String`, since 1.0
        //
        klass:                 '',

        // #### `preloader` Option ####
        // `Number` (pixels), since 1.1
        //
        preloader:              2,

        // ~~~
        //
        // You can use custom attributes (`attr`) on the node - it accepts the same name-value pairs object
        // jQuery `.attr()` does. In case you want to delegate full interaction control over the instance
        // to some other DOM element(s) on page, you can with `area`.
        //
        // ---

        // #### `area` Option ####
        // `jQuery`, since 1.1
        //
        area:           undefined,

        // #### `attr` Option ####
        // `Object`, since 1.2
        //
        attr:                  {},


        // ### Annotations ######
        //
        // To further visually describe your scene you can place all kinds of in-picture HTML annotations
        // by defining an `annotations` object. Learn more about [Annotations][1] in a dedicated article.
        //
        // [1]:https://github.com/pisi/Reel/wiki/Annotations
        //
        // ---

        // #### `annotations` Option ####
        // `Object`, since 1.2
        //
        annotations:    undefined,


        // ### [NEW] Responsiveness ######
        //
        // By default, dimensions of Reel are fixed and pixel-match the dimensions of the original image
        // and the responsive mode is disabled. Using `responsive` option you can enable responsiveness.
        // In such a case Reel will adopt dimensions of its parent container element and scale all relevant
        // data store values accordingly.
        // The scale applied is stored in `"ratio"` data key, where `1.0` means 100% or no scale.
        //
        // To take full advantage of this, you can setup your URLs to contain actual dimensions and
        // serve images in appropriate detail.
        // Learn more about [data values in URLs](#Data-Values-in-URLs).
        //
        // ---

        // #### `responsive` Option ####
        // [NEW] `Boolean`, since 1.3
        //
        responsive:         false,


        // ### Mathematics ######
        //
        // When reeling, instance conforms to a graph function, which defines whether it will loop
        // (`$.reel.math.hatch`) or it won't (`$.reel.math.envelope`). My math is far from flawless
        // and I'm sure there are much better ways how to handle things. the `graph` option is there for you
        // shall you need it. It accepts a function, which should process given criteria and return
        // a fraction of 1.
        //
        //     function( x, start, revolution, lo, hi, cwness, y ){
        //       return fraction  // 0.0 - 1.0
        //     }
        //
        // ---

        // #### `graph` Option ####
        // `Function`, since 1.1
        //
        graph:          undefined,


        // ### Monitor ######
        //
        // Specify a string data key and you will see its real-time value dumped in the upper-left corner
        // of the viewport. Its visual can be customized by CSS using `.jquery-reel-monitor` selector.
        //
        // ---

        // #### `monitor` Option ####
        // `String` (data key), since 1.1
        //
        monitor:        undefined

      },

      // -----------------
      // [NEW] Quick Start
      // -----------------
      //
      // For basic Reel initialization, you don't even need to write any Javascript!
      // All it takes is to add __class name__ `"reel"` to your `<img>` HTML tag,
      // assign an unique __`id` attribute__ and decorate the tag with configuration __data attributes__.
      // Result of which will be interactive Reel projection.
      //
      //     <img src="some/image.jpg" width="300" height="200"
      //       id="my_image"
      //       class="reel"
      //       data-images="some/images/01.jpg, some/images/02.jpg"
      //       data-speed="0.5">
      //
      // All otherwise Javascript [options](#Options) are made available as HTML `data-*` attributes.
      //
      // Only the `annotations` option doesn't work this way. To quickly create annotations,
      // simply have any HTML node (`<div>` prefferably) anywhere in the DOM,
      // assign it __class name__ `"reel-annotation"`, an unique __`id` attribute__
      // and add configuration __data attributes__.
      //
      //     <div id="my_annotation"
      //       class="reel-annotation"
      //       data-for="my_image"
      //       data-x="120"
      //       data-y="60">
      //       Whatever HTML I'd like to have in the annotation
      //     </div>
      //
      // Most important is the `data-for` attribute, which references target Reel instance by `id`.
      //
      // ---

      //
      // Responsible for discovery and subsequent conversion of data-configured Reel images is
      // `$.reel.scan()` method, which is being called automagically when the DOM becomes ready.
      // Under normal circumstances you don't need to scan by yourself.
      //
      // It however comes in handy to re-scan when you happen to inject a data-configured Reel `<img>`
      // into already ready DOM.
      //
      // ---

      // ### `$.reel.scan()` Method ######
      // [NEW] returns `jQuery`, since 1.3
      //
      scan: function(){
        return $(dot(klass)+':not('+dot(overlay_klass)+' > '+dot(klass)+')').each(function(ix, image){
          var
            $image= $(image),
            options= $image.data(),
            images= options.images= soft_array(options.images),
            annotations= {}
          $(dot(annotation_klass)+'[data-for='+$image.attr(_id_)+']').each(function(ix, annotation){
            var
              $annotation= $(annotation),
              def= $annotation.data(),
              x= def.x= numerize_array(soft_array(def.x)),
              y= def.y= numerize_array(soft_array(def.y)),
              id= $annotation.attr(_id_),
              node= def.node= $annotation.removeData()
            annotations[id] = def;
          });
          options.annotations = annotations;
          $image.removeData().reel(options);
        });
      },

      // -------
      // Methods
      // -------
      //
      // Reel's methods extend jQuery core functions with members of its `$.reel.fn` object. Despite Reel
      // being a typical one-method plug-in with its `.reel()` function, for convenience it also offers
      // its bipolar twin `.unreel()`.
      //
      // ---

      // ### `$.reel.fn` ######
      // returns `Object`, since 1.1
      //
      fn: {
        // ------------
        // Construction
        // ------------
        //
        // `.reel()` method is the core of Reel and similar to some jQuery functions, it has adaptive interface.
        // It either builds, [reads & writes data](#Data) or [causes events](#Control-Events).
        //
        // ---

        // ### `.reel( [options] )` Method ######
        // returns `jQuery`, since 1.0
        //
        reel: function(){
          var
            args= arguments,
            t= $(this),
            data= t.data(),
            name= args[0] || {},
            value= args[1]

          // The main [core of this procedure](#Construction-Core) is rather bulky, so let's skip it for now
          // and instead let me introduce the other uses first.

          // --------------------
          // [NEW] Control Events
          // --------------------
          //
          // [Event][1] messages are what ties and binds all Reel's internal working components together.
          // Besides being able to binding to any of these events from your script and react on Reel status changes
          // (e.g. position), you can also trigger some of them in order to control Reel's attitude.
          //
          // You can:
          //
          // * control the playback of animated Reels with [`play`](#play-Event), [`pause`](#pause-Event)
          // or [`stop`](#stop-Event)
          // * step the Reel in any direction with [`stepRight`](#stepRight-Event), [`stepLeft`](#stepLeft-Event),
          // [`stepUp`](#stepUp-Event), [`stepDown`](#stepDown-Event), 
          // * reach certain frame with [`reach`](#reach-Event)
          //
          // Triggering Reel's control event is as simple as passing the desired event name to `.reel()`.
          //
          // _**Example:** Stop the animation in progress:_
          //
          //     .reel(':stop')
          //
          // Think of `.reel()` as a convenient shortcut to and synonym for [`.trigger()`][2], only prefix
          // the event name with `:`. Of course you can use simple `.trigger()` instead and without the colon.
          //
          //
          // [1]:http://api.jquery.com/category/events/event-object/
          // [2]:http://api.jquery.com/trigger
          //
          // ---

          // #### `.reel( event, [arguments] )` ######
          // returns `jQuery`, since 1.3
          //
          if (typeof name != 'object'){

            if (name.slice(0, 1) == ':'){
              return t.trigger(name.slice(1), value);
            }

            // ----
            // Data
            // ----
            //
            // Reel stores all its inner state values with the standard DOM [data interface][1] interface
            // while adding an additional change-detecting event layer, which makes Reel entirely data-driven.
            //
            // [1]:http://api.jquery.com/data
            //
            // _**Example:** Find out on what frame a Reel instance currently is:_
            //
            //     .reel('frame') // Returns the frame number
            //
            // This time think of `.reel(data)` as a synonym for `.data()`. Note, that you can therefore easily
            // inspect the entire datastore with `.data()` (without arguments). Use it for debugging only.
            // For real-time data watch use [`monitor`](#Monitor) option instead of manually hooking into
            // the data.
            //
            // ---

            // #### `.reel( data )` ######
            // can return anything, since 1.2
            //
            else{
              if (args.length == 1){
                return data[name]
              }

              // ### Write Access ###
              //
              // You can store any value the very same way by passing the value as the second function
              // argument.
              //
              // _**Example:** Jump to frame 12:_
              //
              //     .reel('frame', 12)
              //
              // Only a handful of data keys is suitable for external manipulation. These include `area`,
              // `backwards`, `brake`, __`fraction`__, __`frame`__, `playing`, `reeling`, __`row`__, `speed`,
              // `stopped`, `velocity` and `vertical`. Use the rest of the keys for reading only, you can
              // mess up easily changing them.
              //
              // ---

              // #### `.reel( data, value )` ######
              // returns `jQuery`, since 1.2
              //
              else{
                if (value !== undefined){
                  reel.normal[name] && (value= reel.normal[name](value, data));

                  // ### Changes ######
                  //
                  // Any value that does not equal (`===`) the old value is considered _new value_ and
                  // in such a case Reel will trigger a _change event_ to announce the change. The event
                  // type takes form of _`key`_`Change`, where _`key`_ will be the data key/name you've
                  // just assigned.
                  //
                  // _**Example:** Setting `"frame"` to `12` in the above example will trigger
                  // `"frameChange"`._
                  //
                  // Some of these _change events_ (like `frame` or `fraction`) have a
                  // default handler attached.
                  //
                  // You can easily bind to any of the data key change with standard event
                  // binding methods.
                  //
                  // _**Example:** React on instance being manipulated or not:_
                  //
                  //     .bind('reelingChange', function(evnt, nothing, reeling){
                  //       if (reeling) console.log('Rock & reel!')
                  //       else console.log('Not reeling...')
                  //     })
                  //
                  // ---

                  // The handler function will be executed every time the value changes and
                  // it will be supplied with three arguments. First one is the event object
                  // as usual, second is `undefined` and the third will be the actual value.
                  // In this case it was a boolean type value.
                  // If the second argument is not `undefined` it is the backward compatible
                  // "before" event triggered from outside Reel.
                  //
                  if (data[name] === undefined) data[name]= value
                  else if (data[name] !== value) t.trigger(name+'Change', [ undefined, data[name]= value ]);
                }
                return t
              }
            }
          }

          //
          // -----------------
          // Construction Core
          // -----------------
          //
          // Now, back to the procedure of [constructing](#Construction) a Reel instance
          // and binding its event handlers.
          //
          // Establish local `opt` object made by extending the defaults.
          //
          else{

          var
            opt= $.extend({}, reel.def, name),
            // Limit the given jQuery collection to just `<img>` tags with `src` attribute
            // and dimensions defined.
            applicable= t.filter(_img_).unreel().filter(function(){
              var
                $this= $(this),
                attr= opt.attr,
                src= attr.src || $this.attr(_src_),
                width= attr.width || $this.attr(_height_) || $this.width(),
                height= attr.height || $this.attr(_width_) || $this.height()
              if (!src) return error('`src` attribute missing on target image');
              if (!width || !height) return error('Dimension(s) of the target image unknown');
              return true;
            }),
            instances= []

          applicable.each(function(){
            var
              t= $(this),

              // Quick data interface
              set= function(name, value){ return t.reel(name, value) && get(name) },
              get= function(name){ return t.data(name) },

              on= {

                // --------------
                // Initialization
                // --------------
                //
                // This internally called private pseudo-handler:
                //
                // - initiates all data store keys,
                // - binds to ticker
                // - and triggers `"setup"` Event when finished.
                //
                setup: function(e){
                  if (t.hasClass(klass) && t.parent().hasClass(overlay_klass)) return;
                  set(_options_, opt);
                  var
                    attr= {
                      src: t.attr(_src_),
                      width: t.attr(_width_) || null,
                      height: t.attr(_height_) || null,
                      style: t.attr(_style_) || null,
                      'class': t.attr(_class_) || null
                    },
                    src= t.attr(opt.attr).attr(_src_),
                    id= set(_id_, t.attr(_id_) || t.attr(_id_, klass+'-'+(+new Date())).attr(_id_)),
                    data= $.extend({}, t.data()),
                    images= set(_images_, opt.images || []),
                    stitched= set(_stitched_, opt.stitched),
                    is_sprite= !images.length || stitched,
                    responsive= set(_responsive_, opt.responsive && (knows_background_size ? true : !is_sprite)),
                    truescale= set(_truescale_, {}),
                    loops= opt.loops,
                    orbital= opt.orbital,
                    revolution= opt.revolution,
                    rows= opt.rows,
                    footage= set(_footage_, min(opt.footage, opt.frames)),
                    spacing= set(_spacing_, opt.spacing),
                    width= set(_width_, +t.attr(_width_) || t.width()),
                    height= set(_height_, +t.attr(_height_) || t.height()),
                    shy= set(_shy_, opt.shy),
                    frames= set(_frames_, orbital && footage || rows <= 1 && images.length || opt.frames),
                    multirow= rows > 1 || orbital,
                    revolution_x= set(_revolution_, axis('x', revolution) || stitched / 2 || width * 2),
                    revolution_y= set(_revolution_y_, !multirow ? 0 : (axis('y', revolution) || (rows > 3 ? height : height / (5 - rows)))),
                    rows= stitched ? 1 : ceil(frames / footage),
                    stitched_travel= set(_stitched_travel_, stitched - (loops ? 0 : width)),
                    stitched_shift= set(_stitched_shift_, 0),
                    stage_id= hash(id+opt.suffix),
                    img_class= t.attr(_class_),
                    classes= !img_class ? __ : img_class+___,
                    $overlay= $(tag(_div_), { id: stage_id.substr(1), 'class': classes+___+overlay_klass+___+frame_klass+'0' }),
                    $instance= t.wrap($overlay.addClass(opt.klass)).addClass(klass),
                    instances_count= instances.push(add_instance($instance)[0]),
                    $overlay= $instance.parent().bind(on.instance)
                  set(_image_, images.length ? __ : opt.image || src.replace(reel.re.image, '$1' + opt.suffix + '.$2'));
                  set(_cache_, $(tag(_div_), { 'class': cache_klass }).appendTo('body'));
                  set(_area_, $()),
                  set(_cached_, []);
                  set(_frame_, null);
                  set(_fraction_, null);
                  set(_row_, opt.row);
                  set(_tier_, 0);
                  set(_rows_, rows);
                  set(_rowlock_, opt.rowlock);
                  set(_framelock_, opt.framelock);
                  set(_departure_, set(_destination_, set(_distance_, 0)));
                  set(_bit_, 1 / frames);
                  set(_stage_, stage_id);
                  set(_backwards_, set(_speed_, opt.speed) < 0);
                  set(_loading_, false);
                  set(_velocity_, 0);
                  set(_vertical_, opt.vertical);
                  set(_preloaded_, 0);
                  set(_cwish_, negative_when(1, !opt.cw && !stitched));
                  set(_clicked_location_, {});
                  set(_clicked_, false);
                  set(_clicked_on_, set(_clicked_tier_, 0));
                  set(_lo_, set(_hi_, 0));
                  set(_reeling_, false);
                  set(_reeled_, false);
                  set(_opening_, false);
                  set(_brake_, opt.brake);
                  set(_center_, !!orbital);
                  set(_tempo_, opt.tempo / (reel.lazy? opt.laziness : 1));
                  set(_opening_ticks_, -1);
                  set(_ticks_, -1);
                  set(_annotations_, opt.annotations || $overlay.unbind(dot(_annotations_)) && {});
                  set(_ratio_, 1);
                  set(_backup_, {
                    attr: attr,
                    data: data
                  });
                  opt.steppable || $overlay.unbind('up.steppable');
                  opt.indicator || $overlay.unbind('.indicator');
                  css(__, { overflow: _hidden_, position: 'relative' });
                  responsive || css(__, { width: width, height: height });
                  responsive && $.each(responsive_keys, function(i, key){ truescale[key]= get(key) });
                  css(____+___+dot(klass), { display: _block_ });
                  css(dot(cache_klass), { position: 'fixed', left: px(-100), top: px(-100) }, true);
                  css(dot(cache_klass)+___+_img_, { position: _absolute_, width: 10, height: 10 }, true);
                  pool.bind(on.pool);
                  t.trigger(shy ? 'prepare' : 'setup')
                },

                // ------
                // Events
                // ------
                //
                // Reel is completely event-driven meaning there are many events, which can be called
                // (triggered). By binding event handler to any of the events you can easily hook on to any
                // event to inject your custom behavior where and when this event was triggered.
                //
                // _**Example:** Make `#image` element reel and execute some code right after the newly
                // created instance is initialized and completely loaded:_
                //
                //     $("#image")
                //     .reel()
                //     .bind("loaded", function(ev){
                //       // Your code
                //     })
                //

                // Events bound to all individual instances.
                //
                instance: {

                  // ### `teardown` Event ######
                  // `Event`, since 1.1
                  //
                  // This event does do how it sounds like. It will teardown an instance with all its
                  // belongings leaving no trace.
                  //
                  // - It reconstructs the original `<img>` element,
                  // - wipes out the data store,
                  // - removes instance stylesheet
                  // - and unbinds all its events.
                  //
                  teardown: function(e){
                    var
                      backup= t.data(_backup_)
                    t.parent().unbind(on.instance);
                    if (get(_shy_)) t.parent().unbind(_click_, shy_setup)
                    else get(_style_).remove() && get(_area_).unbind(ns);
                    get(_cache_).empty();
                    clearTimeout(delay);
                    clearTimeout(gauge_delay);
                    $(window).unbind(_resize_, slow_gauge);
                    $(window).unbind(ns);
                    pool.unbind(on.pool);
                    pools.unbind(pns);
                    t.siblings().unbind(ns).remove();
                    no_bias();
                    t.removeAttr('onloaded');
                    remove_instance(t.unbind(ns).removeData().unwrap().attr(backup.attr).data(backup.data));
                    t.attr(_style_) == __ && t.removeAttr(_style_);
                  },

                  // ### `setup` Event ######
                  // `Event`, since 1.0
                  //
                  // `"setup"` Event continues with what has been started by the private `on.setup()`
                  // handler.
                  //
                  // - It prepares all additional on-stage DOM elements
                  // - and cursors for the instance stylesheet.
                  //
                  setup: function(e){
                    var
                      $overlay= t.parent().append(preloader()),
                      $area= set(_area_, $(opt.area || $overlay )),
                      multirow= opt.rows > 1,
                      cursor= opt.cursor,
                      cursor_up= cursor == _hand_ ? drag_cursor : cursor,
                      cursor_down= cursor == _hand_ ? drag_cursor_down+___+'!important' : undefined
                    css(___+dot(klass), { MozUserSelect: _none_, WebkitUserSelect: _none_, MozTransform: 'translateZ(0)' });
                    t.unbind(_click_, shy_setup);
                    $area
                      .bind(_touchstart_, press)
                      .bind(opt.clickfree ? _mouseenter_ : _mousedown_, press)
                      .bind(opt.wheelable ? _mousewheel_ : null, wheel)
                      .bind(_dragstart_, function(){ return false })
                    css(__, { cursor: cdn(cursor_up) });
                    css(dot(loading_klass), { cursor: 'wait' });
                    css(dot(panning_klass)+____+dot(panning_klass)+' *', { cursor: cdn(cursor_down || cursor_up) }, true);
                    if (get(_responsive_)){
                      css(___+dot(klass), { width: '100%', height: _auto_ });
                      $(window).bind(_resize_, slow_gauge);
                    }
                    function press(e){ return t.trigger('down', [pointer(e).clientX, pointer(e).clientY, e]) && e.give }
                    function wheel(e, delta){ return !delta || t.trigger('wheel', [delta, e]) && e.give }
                    opt.hint && $area.attr('title', opt.hint);
                    opt.indicator && $overlay.append(indicator('x'));
                    multirow && opt.indicator && $overlay.append(indicator('y'));
                    opt.monitor && $overlay.append($monitor= $(tag(_div_), { 'class': monitor_klass }))
                                && css(___+dot(monitor_klass), { position: _absolute_, left: 0, top: 0 });
                  },

                  // ### `preload` Event ######
                  // `Event`, since 1.1
                  //
                  // Reel keeps a cache of all images it needs for its operation. Either a sprite or all
                  // sequence images. It first determines the order of requesting the images and then
                  // asynchronously loads all of them.
                  //
                  // - It preloads all frames and sprites.
                  //
                  preload: function(e){
                    var
                      $overlay= t.parent(),
                      images= get(_images_),
                      is_sprite= !images.length,
                      order= reel.preload[opt.preload] || reel.preload[reel.def.preload],
                      preload= is_sprite ? [get(_image_)] : order(images.slice(0), opt, get),
                      to_load= preload.length,
                      preloaded= set(_preloaded_, is_sprite ? 0.5 : 0),
                      simultaneous= 0,
                      $cache= get(_cache_).empty(),
                      uris= []
                    $overlay.addClass(loading_klass);
                    // It also finalizes the instance stylesheet and prepends it to the head.
                    set(_style_, get(_style_) || $('<'+_style_+' type="text/css">'+css.rules.join('\n')+'</'+_style_+'>').prependTo(_head_));
                    set(_loading_, true);
                    t.trigger('stop');
                    opt.responsive && gauge();
                    t.trigger('resize', true);
                    while(preload.length){
                      var
                        uri= reel.substitute(opt.path+preload.shift(), get),
                        $img= $(tag(_img_)).data(_src_, uri).appendTo($cache)
                      // Each image, which finishes the load triggers `"preloaded"` Event.
                      $img.bind('load error abort', function(e){
                        e.type != 'load' && t.trigger(e.type);
                        return !detached($overlay) && t.trigger('preloaded') && load() && false;
                      });
                      uris.push(uri);
                    }
                    setTimeout(function(){ while (++simultaneous < reel.concurrent_requests) load(); }, 0);
                    set(_cached_, uris);
                    set(_shy_, false);
                    function load(){
                      var
                        $img= $cache.children(':not([src]):first')
                      return $img.attr(_src_, $img.data(_src_))
                    }
                  },

                  // ### `preloaded` Event ######
                  // `Event`, since 1.1
                  //
                  // This event is fired by every preloaded image and adjusts the preloader indicator's
                  // target position. Once all images are preloaded, `"loaded"` Event is triggered.
                  //
                  preloaded: function(e){
                    var
                      images= get(_images_).length || 1,
                      preloaded= set(_preloaded_, min(get(_preloaded_) + 1, images))
                    if (preloaded === 1) var
                      frame= t.trigger('frameChange', [undefined, get(_frame_)])
                    if (preloaded === images){
                      t.parent().removeClass(loading_klass);
                      t.trigger('loaded');
                    }
                  },

                  // ### `loaded` Event ######
                  // `Event`, since 1.1
                  //
                  // `"loaded"` Event is the one announcing when the instance is "locked and loaded".
                  // At this time, all is prepared, preloaded and configured for user interaction
                  // or animation.
                  //
                  loaded: function(e){
                    get(_images_).length > 1 || t.css({ backgroundImage: url(reel.substitute(opt.path+get(_image_), get)) }).attr({ src: cdn(transparent) });
                    get(_stitched_) && t.attr({ src: cdn(transparent) });
                    get(_reeled_) || set(_velocity_, opt.velocity || 0);
                    set(_loading_, false);
                    loaded= true;
                  },

                  // ### `prepare` Event ######
                  // [NEW] `Event`, since 1.3
                  //
                  // In case of `shy` activation, `"prepare"` event is called instead of the full `"setup"`.
                  // It lefts the target image untouched waiting to be clicked to actually setup.
                  //
                  prepare: function(e){
                    t.css('display', _block_).parent().one(_click_, shy_setup);
                  },

                  // ----------------
                  // Animation Events
                  // ----------------
                  //
                  // ### `opening` Event ######
                  // `Event`, since 1.1
                  //
                  // When [opening animation](#Opening-Animation) is configured for the instance, `"opening"`
                  // event engages the animation by pre-calculating some of its properties, which will make
                  // the tick handler
                  //
                  opening: function(e){
                  /*
                  - initiates opening animation
                  - or simply plays the reel when without opening
                  */
                    if (!opt.opening) return t.trigger('openingDone');
                    var
                      opening= set(_opening_, true),
                      stopped= set(_stopped_, !get(_speed_)),
                      speed= opt.entry || opt.speed,
                      end= get(_fraction_),
                      duration= opt.opening,
                      start= set(_fraction_, end - speed * duration),
                      ticks= set(_opening_ticks_, ceil(duration * leader(_tempo_)))
                  },

                  // ### `openingDone` Event ######
                  // `Event`, since 1.1
                  //
                  // `"openingDone"` is fired onceWhen [opening animation](#Opening-Animation) is configured for the instance, `"opening"`
                  // event engages the animation by pre-calculating some of its properties, which will make
                  // the tick handler
                  //
                  openingDone: function(e){
                    var
                      playing= set(_playing_, false),
                      opening= set(_opening_, false),
                      evnt= _tick_+dot(_opening_)
                    pool.unbind(evnt, on.pool[evnt]);
                    opt.orientable && $(window).bind(_deviceorientation_, orient);
                    if (opt.delay > 0) delay= setTimeout(function(){ t.trigger('play') }, opt.delay * 1000)
                    else t.trigger('play');
                    function orient(e){ return t.trigger('orient', [gyro(e).alpha, gyro(e).beta, gyro(e).gamma, e]) && e.give }
                  },

                  // -----------------------
                  // Playback Control Events
                  // -----------------------
                  //
                  // ### `play` Event ######
                  // `Event`, since 1.1
                  //
                  // `"play"` event can optionally accept a `speed` parameter (in Hz) to change the animation
                  // speed on the fly.
                  //
                  play: function(e, speed){
                    var
                      speed= speed ? set(_speed_, speed) : (get(_speed_) * negative_when(1, get(_backwards_))),
                      duration= opt.duration,
                      ticks= duration && set(_ticks_, ceil(duration * leader(_tempo_))),
                      backwards= set(_backwards_, speed < 0),
                      playing= set(_playing_, !!speed),
                      stopped= set(_stopped_, !playing)
                    idle();
                  },

                  // ### `reach` Event ######
                  // [NEW] `Event`, since 1.3
                  //
                  // Use this event to instruct Reel to play and reach a given frame. `"reach"` event requires
                  // `target` parameter, which is the frame to which Reel should animate to and stop.
                  // Optional `speed` parameter allows for custom speed independent on the regular speed.
                  //
                  reach: function(e, target, speed){
                    if (target == get(_frame_)) return;
                    var
                      frames= get(_frames_),
                      row= set(_row_, ceil(target / frames)),
                      departure= set(_departure_, get(_frame_)),
                      target= set(_destination_, target),
                      shortest = set(_distance_, reel.math.distance(departure, target, frames)),
                      speed= abs(speed || get(_speed_)) * negative_when(1, shortest < 0)
                    t.trigger('play', speed);
                  },

                  // ### `pause` Event ######
                  // `Event`, since 1.1
                  //
                  // Triggering `"pause"` event will halt the playback for a time period designated
                  // by the `timeout` option. After this timenout, the playback is resumed again.
                  //
                  pause: function(e){
                    unidle();
                  },

                  // ### `stop` Event ######
                  // `Event`, since 1.1
                  //
                  // After `"stop"` event is triggered, the playback stops and stays still until `"play"`ed again.
                  //
                  stop: function(e){
                    var
                      stopped= set(_stopped_, true),
                      playing= set(_playing_, !stopped)
                  },

                  // ------------------------
                  // Human Interaction Events
                  // ------------------------
                  //
                  // ### `down` Event ######
                  // `Event`, since 1.1
                  //
                  // Marks the very beginning of touch or mouse interaction. It receives `x` and `y`
                  // coordinates in arguments.
                  //
                  // - It calibrates the center point (origin),
                  // - considers user active not idle,
                  // - flags the `<html>` tag with `.reel-panning` class name
                  // - and binds dragging events for move and lift. These
                  // are usually bound to the pool (document itself) to get a consistent treating regardless
                  // the event target element. However in click-free mode, it binds directly to the instance.
                  //
                  down: function(e, x, y, ev){
                    if (!opt.clickfree && ev && ev.button !== undefined && ev.button != DRAG_BUTTON) return;
                    if (opt.draggable){
                      var
                        clicked= set(_clicked_, get(_frame_)),
                        clickfree= opt.clickfree,
                        velocity= set(_velocity_, 0),
                        $area= clickfree ? get(_area_) : pools,
                        origin= last= recenter_mouse(get(_revolution_), x, y)
                      unidle();
                      no_bias();
                      panned= 0;
                      $(_html_, pools).addClass(panning_klass);
                      $area
                        .bind(_touchmove_+___+_mousemove_, drag)
                        .bind(_touchend_+___+_touchcancel_, lift)
                        .bind(clickfree ? _mouseleave_ : _mouseup_, lift)
                    }
                    function drag(e){ return t.trigger('pan', [pointer(e).clientX, pointer(e).clientY, e]) && e.give }
                    function lift(e){ return t.trigger('up', [e]) && e.give }
                  },

                  // ### `up` Event ######
                  // `Event`, since 1.1
                  //
                  // This marks the termination of user's interaction. She either released the mouse button
                  // or lift the finger of the touch screen. This event handler:
                  //
                  // - calculates the velocity of the drag at that very moment,
                  // - removes the `.reel-panning` class from `<body>`
                  // - and unbinds dragging events from the pool.
                  //
                  up: function(e, ev){
                    var
                      clicked= set(_clicked_, false),
                      reeling= set(_reeling_, false),
                      throwable = opt.throwable,
                      biases= abs(bias[0] + bias[1]) / 60,
                      velocity= set(_velocity_, !throwable ? 0 : throwable === true ? biases : min(throwable, biases)),
                      brakes= braking= velocity ? 1 : 0
                    unidle();
                    no_bias();
                    $(_html_, pools).removeClass(panning_klass);
                    (opt.clickfree ? get(_area_) : pools).unbind(pns);
                  },

                  // ### `pan` Event ######
                  // [RENAMED] `Event`, since 1.2
                  //
                  // Regardles the actual source of movement (mouse or touch), this event is always triggered
                  // in response and similar to the `"down"` Event it receives `x` and `y` coordinates
                  // in arguments and in addition it is passed a reference to the original browser event.
                  // This handler:
                  //
                  // - syncs with timer to achieve good performance,
                  // - calculates the distance from drag center and applies graph on it to get `fraction`,
                  // - recenters the drag when dragged over limits,
                  // - detects the direction of the motion
                  // - and builds up inertial motion bias.
                  //
                  // Historically `pan` was once called `slide` (conflicted with Mootools - [GH-51][1])
                  // or `drag` (that conflicted with MSIE).
                  //
                  // [1]:https://github.com/pisi/Reel/issues/51
                  //
                  pan: function(e, x, y, ev){
                    if (opt.draggable && slidable){
                      slidable= false;
                      unidle();
                      var
                        rows= opt.rows,
                        orbital= opt.orbital,
                        scrollable= !get(_reeling_) && rows <= 1 && !orbital && opt.scrollable,
                        delta= { x: x - last.x, y: y - last.y },
                        abs_delta= { x: abs(delta.x), y: abs(delta.y) }
                      if (ev && scrollable && abs_delta.x < abs_delta.y) return ev.give = true;
                      if (abs_delta.x > 0 || abs_delta.y > 0){
                        ev && (ev.give = false);
                        panned= max(abs_delta.x, abs_delta.y);
                        last= { x: x, y: y };
                        var
                          revolution= get(_revolution_),
                          origin= get(_clicked_location_),
                          vertical= get(_vertical_)
                        if (!get(_framelock_)) var
                          fraction= set(_fraction_, graph(vertical ? y - origin.y : x - origin.x, get(_clicked_on_), revolution, get(_lo_), get(_hi_), get(_cwish_), vertical ? y - origin.y : x - origin.x)),
                          reeling= set(_reeling_, get(_reeling_) || get(_frame_) != get(_clicked_)),
                          motion= to_bias(vertical ? delta.y : delta.x || 0),
                          backwards= motion && set(_backwards_, motion < 0)
                        if (orbital && get(_center_)) var
                          vertical= set(_vertical_, abs(y - origin.y) > abs(x - origin.x)),
                          origin= recenter_mouse(revolution, x, y)
                        if (rows > 1 && !get(_rowlock_)) var
                          revolution_y= get(_revolution_y_),
                          start= get(_clicked_tier_),
                          lo= - start * revolution_y,
                          tier= set(_tier_, reel.math.envelope(y - origin.y, start, revolution_y, lo, lo + revolution_y, -1))
                        if (!(fraction % 1) && !opt.loops) var
                          origin= recenter_mouse(revolution, x, y)
                      }
                    }
                  },

                  // ### `wheel` Event ######
                  // `Event`, since 1.0
                  //
                  // Maps Reel to mouse wheel position change event which is provided by a nifty plug-in
                  // written by Brandon Aaron - the [Mousewheel plug-in][1], which you will need to enable
                  // the mousewheel wheel for reeling. You can also choose to use [Wheel Special Event
                  // plug-in][2] by Three Dub Media instead. Either way `"wheel"` Event handler receives
                  // the positive or negative wheeled distance in arguments. This event:
                  //
                  // - calculates wheel input delta and adjusts the `fraction` using the graph,
                  // - recenters the "drag" each and every time,
                  // - detects motion direction
                  // - and nullifies the velocity.
                  //
                  // [1]:https://github.com/brandonaaron/jquery-mousewheel
                  // [2]:http://blog.threedubmedia.com/2008/08/eventspecialwheel.html
                  //
                  wheel: function(e, distance, ev){
                    if (!distance) return;
                    wheeled= true;
                    var
                      delta= ceil(math.sqrt(abs(distance)) / 2),
                      delta= negative_when(delta, distance > 0),
                      revolution= 0.0833 * get(_revolution_), // Wheel's revolution is 1/12 of full revolution
                      origin= recenter_mouse(revolution),
                      backwards= delta && set(_backwards_, delta < 0),
                      velocity= set(_velocity_, 0),
                      fraction= set(_fraction_, graph(delta, get(_clicked_on_), revolution, get(_lo_), get(_hi_), get(_cwish_)))
                    ev && ev.preventDefault();
                    ev && (ev.give = false);
                    unidle();
                    t.trigger('up', [ev]);
                  },

                  // ### `orient` Event ######
                  // [NEW] `Event`, since 1.3
                  //
                  // Maps Reel to device orientation event which is provided by some touch enabled devices
                  // with gyroscope inside. Event handler receives all three device orientation angles 
                  // in arguments. This event:
                  //
                  // - maps alpha angle directly to `fraction`
                  //
                  orient: function(e, alpha, beta, gamma, ev){
                    if (!slidable || operated) return;
                    oriented= true;
                    var
                      alpha_fraction= alpha / 360
                      fraction= set(_fraction_, +((opt.stitched || opt.cw ? 1 - alpha_fraction : alpha_fraction)).toFixed(2))
                    slidable = false;
                  },

                  // ------------------
                  // Data Change Events
                  // ------------------
                  //
                  // Besides Reel being event-driven, it also is data-driven respectively data-change-driven
                  // meaning that there is a mechanism in place, which detects real changes in data being
                  // stored with `.reel(name, value)`. Learn more about [data changes](#Changes).
                  //
                  // These data change bindings are for internal use only and you don't ever trigger them
                  // per se, you change data and that will trigger respective change event. If the value
                  // being stored is the same as the one already stored, nothing will be triggered.
                  //
                  // _**Example:** Change Reel's current `frame`:_
                  //
                  //     .reel("frame", 15)
                  //
                  // Change events always receive the actual data key value in the third argument.
                  //
                  // _**Example:** Log each viewed frame number into the developers console:_
                  //
                  //     .bind("frameChange", function(e, d, frame){
                  //         console.log(frame)
                  //     })
                  //
                  // ---

                  // ### `fractionChange` Event ######
                  // `Event`, since 1.0
                  //
                  // Internally Reel doesn't really work with the frames you set it up with. It uses
                  // __fraction__, which is a numeric value ranging from 0.0 to 1.0. When `fraction` changes
                  // this handler basically calculates and sets new value of `frame`.
                  //
                  fractionChange: function(e, nil, fraction){
                    if (nil !== undefined) return;
                    var
                      frame= 1 + floor(fraction / get(_bit_)),
                      multirow= opt.rows > 1,
                      orbital= opt.orbital,
                      center= set(_center_, !!orbital && (frame <= orbital || frame >= get(_footage_) - orbital + 2))
                    if (multirow) var
                      frame= frame + (get(_row_) - 1) * get(_frames_)
                    var
                      frame= set(_frame_, frame)
                  },

                  // ### `tierChange` Event ######
                  // `Event`, since 1.2
                  //
                  // The situation of `tier` is very much similar to the one of `fraction`. In multi-row
                  // movies, __tier__ is an internal value for the vertical axis. Its value also ranges from
                  // 0.0 to 1.0. Handler calculates and sets new value of `frame`.
                  //
                  tierChange: function(e, nil, tier){
                    if (nil === undefined) var
                      row= set(_row_, round(interpolate(tier, 1, opt.rows))),
                      frames= get(_frames_),
                      frame= get(_frame_) % frames || frames,
                      frame= set(_frame_, frame + row * frames - frames)
                  },

                  // ### `rowChange` Event ######
                  // `Event`, since 1.1
                  //
                  // The physical vertical position of Reel is expressed in __rows__ and ranges
                  // from 1 to the total number of rows defined with [`rows`](#rows-Option). This handler
                  // only converts `row` value to `tier` and sets it.
                  //
                  rowChange: function(e, nil, row){
                    if (nil === undefined) var
                      tier= may_set(_tier_, undefined, row, opt.rows)
                  },

                  // ### `frameChange` Event ######
                  // `Event`, since 1.0
                  //
                  // The physical horizontal position of Reel is expressed in __frames__ and ranges
                  // from 1 to the total number of frames configured with [`frames`](#frames-Option).
                  // This handler converts `row` value to `tier` and sets it. This default handler:
                  //
                  // - flags the instance's outter wrapper with `.frame-X` class name
                  //   (where `X` is the actual frame number),
                  // - calculates and eventually sets `fraction` (and `tier` for multi-rows) from given frame,
                  // - for sequences, it switches the `<img>`'s `src` to the right frame
                  // - and for sprites it recalculates sprite's 'background position shift and applies it.
                  //
                  frameChange: function(e, nil, frame){
                    if (nil !== undefined) return;
                    this.className= this.className.replace(reel.re.frame_klass, frame_klass + frame);
                    var
                      frames= get(_frames_),
                      rows= opt.rows,
                      path= opt.path,
                      base= frame % frames || frames,
                      frame_row= (frame - base) / frames + 1,
                      frame_tier= (frame_row - 1) / (rows - 1),
                      row= get(_row_),
                      tier= !rows ? get(_tier_) : may_set(_tier_, frame_tier, row, rows),
                      fraction= may_set(_fraction_, undefined, base, frames),
                      footage= get(_footage_)
                    if (opt.orbital && get(_vertical_)) var
                      frame= opt.inversed ? footage + 1 - frame : frame,
                      frame= frame + footage
                    var
                      stitched= get(_stitched_),
                      images= get(_images_),
                      is_sprite= !images.length || stitched
                    if (!is_sprite){
                      get(_responsive_) && gauge();
                      get(_preloaded_) && t.attr({ src: reen(reel.substitute(path + images[frame - 1], get)) });
                    }else{
                      var
                        spacing= get(_spacing_),
                        width= get(_width_),
                        height= get(_height_)
                      if (!stitched) var
                        horizontal= opt.horizontal,
                        minor= (frame % footage) - 1,
                        minor= minor < 0 ? footage - 1 : minor,
                        major= floor((frame - 0.1) / footage),
                        major= major + (rows > 1 ? 0 : (get(_backwards_) ? 0 : !opt.directional ? 0 : get(_rows_))),
                        a= major * ((horizontal ? height : width) + spacing),
                        b= minor * ((horizontal ? width : height) + spacing),
                        shift= images.length ? [0, 0] : horizontal ? [px(-b), px(-a)] : [px(-a), px(-b)]
                      else{
                        var
                          x= set(_stitched_shift_, round(interpolate(fraction, 0, get(_stitched_travel_))) % stitched),
                          y= rows <= 1 ? 0 : (height + spacing) * (rows - row),
                          shift= [px(-x), px(-y)],
                          image= images.length > 1 && images[row - 1],
                          fullpath= reel.substitute(path + image, get)
                        image && t.css('backgroundImage').search(fullpath) < 0 && t.css({ backgroundImage: url(fullpath) })
                      }
                      t.css({ backgroundPosition: shift.join(___) })
                    }
                  },

                  // This extra binding takes care of watching frame position while animating the `"reach"` event.
                  //
                  'frameChange.reach': function(e, nil, frame){
                    if (!get(_destination_) || nil !== undefined) return;
                    var
                      travelled= reel.math.distance(get(_departure_), frame, get(_frames_)),
                      onorover= abs(travelled) >= abs(get(_distance_))
                    if (!onorover) return;
                    set(_frame_, set(_destination_));
                    set(_destination_, set(_distance_, set(_departure_, 0)));
                    t.trigger('stop');
                  },

                  // ~~~
                  //
                  // When `image` or `images` is changed on the fly, this handler resets the loading cache and triggers
                  // new preload sequence. Images are actually switched only after the new image is fully loaded.
                  //
                  'imageChange imagesChange': function(e, nil, image){
                    t.trigger('preload');
                  },

                  // ---------
                  // Indicator
                  // ---------
                  //
                  // When configured with the [`indicator`](#indicator-Option) option, Reel adds to the scene
                  // a visual indicator in a form of a black rectangle traveling along the bottom edge
                  // of the image. It bears two distinct messages:
                  //
                  // - its horizontal position accurately reflects actual `fraction`
                  // - and its width reflect one frame's share on the whole (more frames mean narrower
                  //   indicator).
                  //
                  'fractionChange.indicator': function(e, nil, fraction){
                    if (opt.indicator && nil === undefined) var
                      size= opt.indicator,
                      orbital= opt.orbital,
                      travel= orbital && get(_vertical_) ? get(_height_) : get(_width_),
                      slots= orbital ? get(_footage_) : opt.images.length || get(_frames_),
                      weight= ceil(travel / slots),
                      travel= travel - weight,
                      indicate= round(interpolate(fraction, 0, travel)),
                      indicate= !opt.cw || get(_stitched_) ? indicate : travel - indicate,
                      $indicator= indicator.$x.css(get(_vertical_)
                      ? { left: 0, top: px(indicate), bottom: _auto_, width: size, height: weight }
                      : { bottom: 0, left: px(indicate), top: _auto_, width: weight, height: size })
                  },

                  // For multi-row object movies, there's a second indicator sticked to the left edge
                  // and communicates:
                  //
                  // - its vertical position accurately reflects actual `tier`
                  // - and its height reflect one row's share on the whole (more rows mean narrower
                  //   indicator).
                  //
                  'tierChange.indicator': function(e, nil, tier){
                    if (opt.rows > 1 && opt.indicator && nil === undefined) var
                      travel= get(_height_),
                      size= opt.indicator,
                      weight= ceil(travel / opt.rows),
                      travel= travel - weight,
                      indicate= round(tier * travel),
                      $yindicator= indicator.$y.css({ left: 0, top: indicate, width: size, height: weight })
                  },

                  // Indicators are bound to `fraction` or `row` changes, meaning they alone can consume
                  // more CPU resources than the entire Reel scene. Use them for development only.
                  //

                  // -----------
                  // Annotations
                  // -----------
                  //
                  // If you want to annotate features of your scene to better describe the subject,
                  // there's annotations for you. Annotations feature allows you to place virtually any
                  // HTML content over or into the image and have its position and visibility synchronized
                  // with the position of Reel. These two easy looking handlers do a lot more than to fit
                  // in here.
                  //
                  // Learn more about [Annotations][1] in the wiki, where a great care has been taken
                  // to in-depth explain this new exciting functionality.
                  //
                  // [1]:https://github.com/pisi/Reel/wiki/Annotations
                  //
                  'setup.annotations': function(e){
                    var
                      $overlay= t.parent()
                    $.each(get(_annotations_), function(ida, note){
                      var
                        $note= typeof note.node == _string_ ? $(note.node) : note.node || {},
                        $note= $note.jquery ? $note : $(tag(_div_), $note),
                        $note= $note.attr({ id: ida }).addClass(annotation_klass),
                        $image= note.image ? $(tag(_img_), note.image) : $(),
                        $link= note.link ? $(tag('a'), note.link).click(function(){ t.trigger('up.annotations', { target: $link }); }) : $()
                      css(hash(ida), { display: _none_, position: _absolute_ }, true);
                      note.image || note.link && $note.append($link);
                      note.link || note.image && $note.append($image);
                      note.link && note.image && $note.append($link.append($image));
                      $note.appendTo($overlay);
                    });
                  },
                  'prepare.annotations': function(e){
                    $.each(get(_annotations_), function(ida, note){
                      $(hash(ida)).hide();
                    });
                  },
                  'frameChange.annotations': function(e, nil, frame){
                    if (!get(_preloaded_) || nil !== undefined) return;
                    var
                      width= get(_width_),
                      stitched= get(_stitched_),
                      ss= get(_stitched_shift_)
                    $.each(get(_annotations_), function(ida, note){
                      var
                        $note= $(hash(ida)),
                        start= note.start || 1,
                        end= note.end,
                        frame= frame || get(_frame_),
                        offset= frame - 1,
                        at= note.at ? (note.at[offset] == '+') : false,
                        offset= note.at ? offset : offset - start + 1,
                        x= typeof note.x!=_object_ ? note.x : note.x[offset],
                        y= typeof note.y!=_object_ ? note.y : note.y[offset],
                        placed= x !== undefined && y !== undefined,
                        visible= placed && (note.at ? at : (offset >= 0 && (!end || offset <= end - start)))
                      if (stitched) var
                        on_edge= x < width && ss > stitched - width,
                        after_edge= x > stitched - width && ss >= 0 && ss < width,
                        x= !on_edge ? x : x + stitched,
                        x= !after_edge ? x : x - stitched,
                        x= x - ss
                      if (get(_responsive_)) var
                        ratio= get(_ratio_),
                        x= x && x * ratio,
                        y= y && y * ratio
                      var
                        style= { display: visible ? _block_:_none_, left: px(x), top: px(y) }
                      $note.css(style);
                    });
                  },
                  'up.annotations': function(e, ev){
                    if (panned > 10 || wheeled) return;
                    var
                      $target= $(ev.target),
                      $link= ($target.is('a') ? $target : $target.parents('a')),
                      href= $link.attr('href')
                    href && (panned= 10);
                  },

                  // ---------------------
                  // Click Stepping Events
                  // ---------------------
                  //
                  // For devices without drag support or for developers, who want to use some sort
                  // of left & right buttons on their site to control your instance from outside, Reel
                  // supports ordinary click with added detection of left half or right half and resulting
                  // triggering of `stepLeft` and `stepRight` events respectively.
                  //
                  // This behavior can be disabled by the [`steppable`](#steppable-Option) option.
                  //
                  'up.steppable': function(e, ev){
                    if (panned || wheeled) return;
                    t.trigger(get(_clicked_location_).x - t.offset().left > 0.5 * get(_width_) ? 'stepRight' : 'stepLeft')
                  },
                  'stepLeft stepRight': function(e){
                    unidle();
                  },

                  // ### `stepLeft` Event ######
                  // `Event`, since 1.2
                  //
                  stepLeft: function(e){
                    set(_backwards_, false);
                    set(_fraction_, get(_fraction_) - get(_bit_) * get(_cwish_));
                  },

                  // ### `stepRight` Event ######
                  // `Event`, since 1.2
                  //
                  stepRight: function(e){
                    set(_backwards_, true);
                    set(_fraction_, get(_fraction_) + get(_bit_) * get(_cwish_));
                  },

                  // ### `stepUp` Event ######
                  // [NEW] `Event`, since 1.3
                  //
                  stepUp: function(e){
                    set(_row_, get(_row_) - 1);
                  },

                  // ### `stepDown` Event ######
                  // [NEW] `Event`, since 1.3
                  //
                  stepDown: function(e){
                    set(_row_, get(_row_) + 1);
                  },

                  // -----------------------
                  // [NEW] Responsive Events
                  // -----------------------
                  //
                  // In responsive mode in case of parent's size change, in addition to actual recalculations,
                  // the instance starts to emit throttled `resize` events. This handler in turn emulates
                  // images changes event leading to reload of frames.
                  //
                  // ---
                  //
                  // ### `resize` Event ######
                  // [NEW] `Event`, since 1.3
                  //
                  resize: function(e, force){
                    if (get(_loading_) && !force) return;
                    var
                      stitched= get(_stitched_),
                      spacing= get(_spacing_),
                      height= get(_height_),
                      is_sprite= !get(_images_).length || stitched,
                      rows= opt.rows || 1,
                      size= get(_images_).length
                        ? !stitched ? undefined : px(stitched)+___+px(height)
                        : stitched && px(stitched)+___+px((height + spacing) * rows - spacing)
                        || px((get(_width_) + spacing) * get(_footage_) - spacing)+___+px((height + spacing) * get(_rows_) * rows * (opt.directional? 2:1) - spacing)
                    t.css({
                      height: is_sprite ? px(height) : null,
                      backgroundSize: size || null
                    });
                    force || t.trigger('imagesChange');
                  },

                  // ----------------
                  // Follow-up Events
                  // ----------------
                  //
                  // When some event as a result triggers another event, it preferably is not triggered
                  // directly, because it would disallow preventing the event propagation / chaining
                  // to happen. Instead a followup handler is bound to the first event and it triggers the
                  // second one.
                  //
                  'setup.fu': function(e){
                    var
                      frame= set(_frame_, opt.frame + (get(_row_) - 1) * get(_frames_))
                    t.trigger('preload')
                  },
                  'wheel.fu': function(){ wheeled= false },
                  'clean.fu': function(){ t.trigger('teardown') },
                  'loaded.fu': function(){ t.trigger('opening') }
                },

                // -------------
                // Tick Handlers
                // -------------
                //
                // As opposed to the events bound to the instance itself, there is a [ticker](#Ticker)
                // in place, which emits `tick.reel` event on the document level by default every 1/36
                // of a second and drives all the animations. Three handlers currently bind each instance
                // to the tick.
                //
                pool: {

                  // This handler has a responsibility of continuously updating the preloading indicator
                  // until all images are loaded and to unbind itself then.
                  //
                  'tick.reel.preload': function(e){
                    if (!(loaded || get(_loading_)) || get(_shy_)) return;
                    var
                      width= get(_width_),
                      current= number(preloader.$.css(_width_)),
                      images= get(_images_).length || 1,
                      target= round(1 / images * get(_preloaded_) * width)
                    preloader.$.css({ width: current + (target - current) / 3 + 1 })
                    if (get(_preloaded_) === images && current > width - 1){
                      loaded= false;
                      preloader.$.fadeOut(300, function(){ preloader.$.css({ opacity: 1, width: 0 }) });
                    }
                  },

                  // This handler binds to the document's ticks at all times, regardless the situation.
                  // It serves several tasks:
                  //
                  // - keeps track of how long the instance is being operated by the user,
                  // - or for how long it is braking the velocity inertia,
                  // - decreases gained velocity by applying power of the [`brake`](#brake-Option) option,
                  // - flags the instance as `slidable` again, so that `pan` event handler can be executed
                  //   again,
                  // - updates the [`monitor`](#monitor-Option) value,
                  // - bounces off the edges for non-looping panoramas,
                  // - and most importantly it animates the Reel if [`speed`](#speed-Option) is configured.
                  //
                  'tick.reel': function(e){
                    if (get(_shy_)) return;
                    var
                      velocity= get(_velocity_),
                      leader_tempo= leader(_tempo_),
                      monitor= opt.monitor
                    if (!reel.intense && offscreen()) return;
                    if (braking) var
                      braked= velocity - (get(_brake_) / leader_tempo * braking),
                      velocity= set(_velocity_, braked > 0.1 ? braked : (braking= operated= 0))
                    monitor && $monitor.text(get(monitor));
                    velocity && braking++;
                    operated && operated++;
                    to_bias(0);
                    slidable= true;
                    if (operated && !velocity) return mute(e);
                    if (get(_clicked_)) return mute(e, unidle());
                    if (get(_opening_ticks_) > 0) return;
                    if (!opt.loops && opt.rebound) var
                      edgy= !operated && !(get(_fraction_) % 1) ? on_edge++ : (on_edge= 0),
                      bounce= on_edge >= opt.rebound * 1000 / leader_tempo,
                      backwards= bounce && set(_backwards_, !get(_backwards_))
                    var
                      direction= get(_cwish_) * negative_when(1, get(_backwards_)),
                      ticks= get(_ticks_),
                      step= (!get(_playing_) || oriented || !ticks ? velocity : abs(get(_speed_)) + velocity) / leader(_tempo_),
                      fraction= set(_fraction_, get(_fraction_) - step * direction),
                      ticks= !opt.duration ? ticks : ticks > 0 && set(_ticks_, ticks - 1)
                    !ticks && get(_playing_) && t.trigger('stop');
                  },

                  // This handler performs the opening animation duty when during it the normal animation
                  // is halted until the opening finishes.
                  //
                  'tick.reel.opening': function(e){
                    if (!get(_opening_)) return;
                    var
                      speed= opt.entry || opt.speed,
                      step= speed / leader(_tempo_) * (opt.cw? -1:1),
                      ticks= set(_opening_ticks_, get(_opening_ticks_) - 1),
                      fraction= set(_fraction_, get(_fraction_) + step)
                    ticks || t.trigger('openingDone');
                  }
                }
              },

              loaded= false,

              // ------------------------
              // Instance Private Helpers
              // ------------------------
              //
              // - Events propagation stopper / muter
              //
              mute= function(e, result){ return e.stopImmediatePropagation() || result },

              // - Shy initialization helper
              //
              shy_setup= function(){ t.trigger('setup') },

              // - User idle control
              //
              operated,
              braking= 0,
              idle= function(){ return operated= 0 },
              unidle= function(){
                clearTimeout(delay);
                pool.unbind(_tick_+dot(_opening_), on.pool[_tick_+dot(_opening_)]);
                set(_opening_ticks_, 0);
                set(_reeled_, true);
                return operated= -opt.timeout * leader(_tempo_)
              },
              panned= 0,
              wheeled= false,
              oriented= false,

              // - Constructors of UI elements
              //
              $monitor= $(),
              preloader= function(){
                css(___+dot(preloader_klass), {
                  position: _absolute_,
                  left: 0, bottom: 0,
                  height: opt.preloader,
                  overflow: _hidden_,
                  backgroundColor: '#000'
                });
                return preloader.$= $(tag(_div_), { 'class': preloader_klass })
              },
              indicator= function(axis){
                css(___+dot(indicator_klass)+dot(axis), {
                  position: _absolute_,
                  width: 0, height: 0,
                  overflow: _hidden_,
                  backgroundColor: '#000'
                });
                return indicator['$'+axis]= $(tag(_div_), { 'class': indicator_klass+___+axis })
              },

              // - CSS rules & stylesheet
              //
              css= function(selector, definition, global){
                var
                  stage= global ? __ : get(_stage_),
                  selector= selector.replace(/^/, stage).replace(____, ____+stage)
                return css.rules.push(selector+cssize(definition)) && definition
                function cssize(values){
                  var rules= [];
                  $.each(values, function(key, value){ rules.push(key.replace(/([A-Z])/g, '-$1').toLowerCase()+':'+px(value)+';') });
                  return '{'+rules.join(__)+'}'
                }
              },
              $style,

              // - Off screen detection (vertical only for performance)
              //
              offscreen= function(){
                var
                  height= get(_height_),
                  width= get(_width_),
                  rect= t[0].getBoundingClientRect()
                return rect.top < -height
                    || rect.left < -width
                    || rect.right > width + $(window).width()
                    || rect.bottom > height + $(window).height()
              },

              // - Inertia rotation control
              //
              on_edge= 0,
              last= { x: 0, y: 0 },
              to_bias= function(value){ return bias.push(value) && bias.shift() && value },
              no_bias= function(){ return bias= [0,0] },
              bias= no_bias(),

              // - Graph function to be used
              //
              graph= opt.graph || reel.math[opt.loops ? 'hatch' : 'envelope'],
              normal= reel.normal,

              // - Response to the size changes in responsive mode
              //
              slow_gauge= function(){
                clearTimeout(gauge_delay);
                gauge_delay= setTimeout(gauge, reel.resize_gauge);
              },
              gauge= function(){
                if (t.width() == get(_width_)) return;
                var
                  truescale= get(_truescale_),
                  ratio= set(_ratio_, t.width() / truescale.width)
                $.each(truescale, function(key, value){ set(key, round(value * ratio)) })
                t.trigger('resize');
              },

              // - Delay timer pointers
              //
              delay, // openingDone's delayed play
              gauge_delay, // slow_gauge's throttle

              // - Interaction graph's zero point reset
              //
              recenter_mouse= function(revolution, x, y){
                var
                  fraction= set(_clicked_on_, get(_fraction_)),
                  tier= set(_clicked_tier_, get(_tier_)),
                  loops= opt.loops,
                  lo= set(_lo_, loops ? 0 : - fraction * revolution),
                  hi= set(_hi_, loops ? revolution : revolution - fraction * revolution)
                return x !== undefined && set(_clicked_location_, { x: x, y: y }) || undefined
              },
              slidable= true,

              // ~~~
              //
              // Data interface used to set `fraction` and `tier` with the value recalculated through their
              // _cousin_ keys (`frame` for `fraction` and `row` for `tier`). This value is actually set
              // only if it does make a difference in the cousin value.
              //
              may_set= function(key, value, cousin, maximum){
                if (!maximum) return;
                var
                  current= get(key) || 0,
                  recalculated= value !== undefined ? value : (cousin - 1) / (maximum - 1),
                  recalculated= key != _fraction_ ? recalculated : min( recalculated, 0.9999),
                  worthy= +abs(current - recalculated).toFixed(8) >= +(1 / (maximum - 1)).toFixed(8),
                  value= worthy ? set(key, recalculated) : value || current
                return value
              },

              // ~~~
              //
              // Global events are bound to the pool (`document`), but to make it work inside an `<iframe>`
              // we need to bind to the parent document too to maintain the dragging even outside the area
              // of the `<iframe>`.
              //
              pools= pool
            try{ if (pool[0] != top.document) pools= pool.add(top.document) }
            catch(e){}

            // A private flag `$iframe` is established to indicate Reel being viewed inside `<iframe>`.
            //
            var
              $iframe= top === self ? $() : (function sense_iframe($ifr){
                $('iframe', pools.last()).each(function(){
                  try{ if ($(this).contents().find(_head_).html() == $(_head_).html()) return ($ifr= $(this)) && false }
                  catch(e){}
                })
                return $ifr
              })()
            css.rules= [];
            on.setup();
          });

          // ~~~
          //
          // Reel maintains a ticker, which guides all animations. There's only one ticker per document
          // and all instances bind to it. Ticker's mechanism measures and compares times before and after
          // the `tick.reel` event trigger to estimate the time spent on executing `tick.reel`'s handlers.
          // The actual timeout time is then adjusted by the amount to run as close to expected tempo
          // as possible.
          //
          ticker= ticker || (function tick(){
            var
              start= +new Date(),
              tempo= leader(_tempo_)
            if (!tempo) return ticker= null;
            pool.trigger(_tick_);
            reel.cost= (+new Date() + reel.cost - start) / 2;
            return ticker= setTimeout(tick, max(4, 1000 / tempo - reel.cost));
          })();

          return $(instances);
          }
        },

        // -----------
        // Destruction
        // -----------
        //
        // The evil-twin of `.reel()`. Tears down and wipes off entire instance.
        //
        // ---

        // ### `.unreel()` Method ######
        // returns `jQuery`, since 1.2
        //
        unreel: function(){
          return this.trigger('teardown');
        }
      },

      // -------------------
      // Regular Expressions
      // -------------------
      //
      // Few regular expressions is used here and there mostly for options validation and verification
      // levels of user agent's capabilities.
      //
      // ---

      // ### `$.reel.re` ######
      // `RegExp`, since 1.1
      //
      re: {
        /* Valid image file format */
        image:         /^(.*)\.(jpg|jpeg|png|gif)\??.*$/i,
        /* User agent failsafe stack */
        ua: [
                       /(msie|opera|firefox|chrome|safari)[ \/:]([\d.]+)/i,
                       /(webkit)\/([\d.]+)/i,
                       /(mozilla)\/([\d.]+)/i
        ],
        /* Array in a string (comma-separated values) */
        array:         / *, */,
        /* Lazy (low-CPU mobile devices) */
        lazy_agent:    /\(iphone|ipod|android|fennec|blackberry/i,
        /* Format of frame class flag on the instance */
        frame_klass:   /frame-\d+/,
        /* Mask for substitutions in URL */
        substitution:  /(@([A-Z]))/g,
        /* Used for cross-browser detection of Regexp no match situation */
        no_match:      /^(undefined|)$/,
        /* [Sequence](#Sequence) string format */
        sequence:      /(^[^#|]*([#]+)[^#|]*)($|[|]([0-9]+)\.\.([0-9]+))($|[|]([0-9]+)$)/
      },

      // ------------------------
      // Content Delivery Network
      // ------------------------
      //
      // [CDN][1] is used for distributing mouse cursors to all instances running world-wide. It runs
      // on Google cloud infrastructure. If you want to ease up on the servers, please consider setting up
      // your own location with the cursors.
      //
      // [1]:https://github.com/pisi/Reel/wiki/CDN
      //
      // ---

      // ### `$.reel.cdn` ######
      // `String` (URL path), since 1.1
      //
      cdn: '',

      // -----------
      // Math Behind
      // -----------
      //
      // Surprisingly there's very little math behind Reel. Two equations (graph functions), which
      // drive Reel motion and receive the same set of options.
      //
      // ---

      // ### `$.reel.math` ######
      // `Object`, since 1.1
      //
      math: {

        //     1 |  ********
        //       |          **
        //       |            **
        //       |              **
        //       |                **
        //       |                  ********
        //     0  ----------------------------???
        //
        envelope: function(x, start, revolution, lo, hi, cwness, y){
          return start + min_max(lo, hi, - x * cwness) / revolution
        },

        //     1 |        **          **
        //       |          **          **
        //       |            **          **
        //       |  **          **
        //       |    **          **
        //       |      **          **
        //     0  ----------------------------???
        //
        hatch: function(x, start, revolution, lo, hi, cwness, y){
          var
            x= (x < lo ? hi : 0) + x % hi, // Looping
            fraction= start + (- x * cwness) / revolution
          return fraction - floor(fraction)
        },

        // Plus equation for interpolating `fraction` (and `tier`) value into `frame` and `row`.
        //
        interpolate: function(fraction, lo, hi){
          return lo + fraction * (hi - lo)
        },

        // And one for calculation of the shortest frame distance from start to the end.
        // 
        distance: function(start, end, total){
          var
            half= total / 2,
            d= end - start
          return d < -half ? d + total : d > half ? d - total : d
        }
      },

      // ----------------
      // Preloading Modes
      // ----------------
      //
      // Reel doesn't load frames in a linear manner from first to last (alhough it can if configured
      // that way with the [`preload`](#preload-Option) option). Reel will take the linear configured
      // sequence and hand it over to one of `$.reel.preload` functions, along with reference to options
      // and the RO data intearface, and it expects the function to reorder the incoming Array and return
      // it back.
      //
      // ---

      // ### `$.reel.preload` ######
      // `Object`, since 1.2
      //
      preload: {

        // The best (and default) option is the `fidelity` processor, which is designed for a faster and
        // better perceived loading.
        //
        // ![Example](https://camo.githubapp.com/74b73060a50f3cbaf522ec31530d34e3fa5cbcb9/687474703a2f2f6a71756572792e766f737472656c2e637a2f7265656c2f7363617474657265642e6c6f6164696e672e676966)
        //
        fidelity: function(sequence, opt, get){
          var
            orbital= opt.orbital,
            rows= orbital ? 2 : opt.rows || 1,
            frames= orbital ? get(_footage_) : get(_frames_),
            start= (opt.row-1) * frames,
            values= new Array().concat(sequence),
            present= new Array(sequence.length + 1),
            priority= rows < 2 ? [] : values.slice(start, start + frames)
          return spread(priority, 1, start).concat(spread(values, rows, 0))

          function spread(sequence, rows, offset){
            if (!sequence.length) return [];
            var
              order= [],
              passes= 4 * rows,
              start= opt.frame,
              frames= sequence.length,
              plus= true,
              granule= frames / passes
            for(var i= 0; i < passes; i++)
              add(start + round(i * granule));
            while(granule > 1)
              for(var i= 0, length= order.length, granule= granule / 2, p= plus= !plus; i < length; i++)
                add(order[i] + (plus? 1:-1) * round(granule));
            for(var i=0; i <= frames; i++) add(i);
            for(var i= 0; i < order.length; i++)
              order[i]= sequence[order[i] - 1];
            return order
            function add(frame){
              while(!(frame >= 1 && frame <= frames))
                frame+= frame < 1 ? +frames : -frames;
              return present[offset + frame] || (present[offset + frame]= !!order.push(frame))
            }
          }
        },

        // You can opt for a `linear` loading order too, but that has a drawback of leaving large gap
        // of unloaded frames.
        //
        linear: function(sequence, opt, get){
          return sequence
        }
      },

      // -------------------------
      // [NEW] Data Values in URLs
      // -------------------------
      //
      // Reel will process each and every image resource URL and substitute special markup
      // with actual values from the data store. Marks made of `@` character followed by upper case
      // letter will be substituted with values either directly from data store (`@W` and `@H`
      // for `width` and `height`) or calculated (`@T` is substituted with momentary timestamp
      // in milliseconds).
      // Markup can appear anywhere in the folder name, file name or the query params
      // (also in [`path`](#path-Option)) and even multiple times.
      //
      // Comes handy in product configurators
      // and works magic in conjunction with [responsive](#responsive-Option) option.
      //
      // _**Example:** Following URLs:_
      //
      //     image.jpg?size=@Wx@H
      //     pic/@W/@H/rabbit.png
      //     image.php?nocache=@T
      //
      // _... will come out like this for Reel 320 pixels wide and 180 high:_
      //
      //     image.jpg?size=320x180
      //     pic/320/180/rabbit.png
      //     image.php?nocache=1377604502788
      //
      // ---

      // ### `$.reel.substitute()` ######
      // [NEW] `Function`, since 1.3
      //
      substitute: function(uri, get){
        return uri.replace(reel.re.substitution, function(match, mark, key){
          return typeof reel.substitutes[key] == 'function'
                      ? reel.substitutes[key](get) : substitution_keys[key]
                      ? get(substitution_keys[key]) : mark;
        });
      },
      // ### `$.reel.substitutes` ######
      // [NEW] `Object` of `Function`s, since 1.3
      //
      substitutes: {
        T: function(get){ return +new Date() }
      },

      // ------------------------
      // Data Value Normalization
      // ------------------------
      //
      // On all data values being stored with `.reel()` an attempt is made to normalize the value. Like
      // for example normalization of frame `55` when there's just `45` frames total. These are the built-in
      // normalizations. Normalization function has the same name as the data key it is assigned to
      // and is given the raw value in arguments, along with reference to the instances data object,
      // and it has to return the normalized value.
      //
      // ---

      // ### `$.reel.normal` ######
      // `Object`, since 1.2
      //
      normal: {
        fraction: function(fraction, data){
          if (fraction === null) return fraction;
          return data[_options_].loops ? fraction - floor(fraction) : min_max(0, 1, fraction)
        },
        tier: function(tier, data){
          if (tier === null) return tier;
          return min_max(0, 1, tier)
        },
        row: function(row, data){
          if (row === null) return row;
          return round(min_max(1, data[_options_].rows, row))
        },
        frame: function(frame, data){
          if (frame === null) return frame;
          var
            opt= data[_options_],
            frames= data[_frames_] * (opt.orbital ? 2 : opt.rows || 1),
            result= round(opt.loops ? frame % frames || frames : min_max(1, frames, frame))
          return result < 0 ? result + frames : result
        },
        images: function(images, data){
          var
            sequence= reel.re.sequence.exec(images),
            result= !sequence ? images : reel.sequence(sequence, data[_options_])
          return result;
        }
      },

      // -----------------
      // Sequence Build-up
      // -----------------
      //
      // When configured with a String value for [`images`](#images-Option) like `image##.jpg`, it first has
      // to be converted into an actual Array by engaging the counter placeholder.
      //
      // ---

      // ### `$.reel.sequence()` ######
      // `Function`, since 1.2
      //
      sequence: function(sequence, opt){
        if (sequence.length <= 1) return opt.images;
        var
          images= [],
          orbital= opt.orbital,
          url= sequence[1],
          placeholder= sequence[2],
          start= sequence[4],
          start= reel.re.no_match.test(start+__) ? 1 : +start,
          rows= orbital ? 2 : opt.rows || 1,
          frames= orbital ? opt.footage : opt.stitched ? 1 : opt.frames,
          end= +(sequence[5] || rows * frames),
          total= end - start,
          increment= +sequence[7] || 1,
          counter= 0
        while(counter <= total){
          images.push(url.replace(placeholder, pad((start + counter + __), placeholder.length, '0')));
          counter+= increment;
        }
        return images;
      },

      // --------------
      // Reel Instances
      // --------------
      //
      // `$.reel.instances` holds an inventory of all running instances in the DOM document.
      //
      // ---

      // ### `$.reel.instances` ######
      // `jQuery`, since 1.1
      //
      instances: $(),

      // For ticker-synchronization-related purposes Reel maintains a reference to the leaders data object
      // all the time.
      //
      // ---

      // ### `$.reel.leader` ######
      // `Object` (DOM data), since 1.1
      //
      leader: leader,

      // `$.reel.resize_gauge` specifies a throttling interval for triggering of `resize` events,
      // in milliseconds.
      //
      // ---

      // ### `$.reel.resize_gauge` ######
      // [NEW] `Number`, since 1.3
      //
      resize_gauge: 300,
      
      // `$.reel.concurrent_requests` specifies how many preloading requests will run simultaneously.
      //
      // ---

      // ### `$.reel.concurrent_requests` ######
      // [NEW] `Number`, since 1.3
      //
      concurrent_requests: 4,
      
      // `$.reel.cost` holds document-wide costs in miliseconds of running all Reel instances. It is used
      // to adjust actual timeout of the ticker.
      //
      // ---

      // ### `$.reel.cost` ######
      // `Number`, since 1.1
      //
      cost: 0
    },

    // ------------------------
    // Private-scoped Variables
    // ------------------------
    //
    pool= $(document),
    client= navigator.userAgent,
    browser= reel.re.ua[0].exec(client) || reel.re.ua[1].exec(client) || reel.re.ua[2].exec(client),
    browser_version= +browser[2].split('.').slice(0,2).join('.'),
    ie= browser[1] == 'MSIE',
    knows_data_urls= !(ie && browser_version < 8),
    knows_background_size= !(ie && browser_version < 9),
    ticker,

    // ---------------
    // CSS Class Names
    // ---------------
    //
    // These are all the class names assigned by Reel to various DOM elements during initialization of the UI
    // and they all share same base `"reel"`, which in isolation also is the class of the `<img>` node you
    // converted into Reel.
    //
    klass= 'reel',

    // Rest of the class names only extend this base class forming for example `.reel-overlay`, a class
    // assigned to the outter instance wrapper (`<img>`'s injected parent).
    //
    overlay_klass= klass + '-overlay',
    cache_klass= klass + '-cache',
    indicator_klass= klass + '-indicator',
    preloader_klass= klass + '-preloader',
    monitor_klass= klass + '-monitor',
    annotation_klass= klass + '-annotation',
    panning_klass= klass + '-panning',
    loading_klass= klass + '-loading',

    // The instance wrapper is flagged with actual frame number using a this class.
    //
    // _**Example:** Reel on frame 10 will carry a class name `frame-10`._
    //
    frame_klass= 'frame-',

    // --------------------------------
    // Shortcuts And Minification Cache
    // --------------------------------
    //
    // Several math functions are referenced inside the private scope to yield smaller filesize
    // when the code is minified.
    //
    math= Math,
    round= math.round, floor= math.floor, ceil= math.ceil,
    min= math.min, max= math.max, abs= math.abs,
    number= parseInt,
    interpolate= reel.math.interpolate,

    // For the very same reason all storage key Strings are cached into local vars.
    //
    _annotations_= 'annotations', _area_= 'area', _auto_= 'auto',
    _backup_= 'backup', _backwards_= 'backwards', _bit_= 'bit', _brake_= 'brake',
    _cache_= 'cache', _cached_=_cache_+'d', _center_= 'center', _class_= 'class', _click_= 'click',
    _clicked_= _click_+'ed', _clicked_location_= _clicked_+'_location', _clicked_on_= _clicked_+'_on',
    _clicked_tier_= _clicked_+'_tier', _cwish_= 'cwish',
    _departure_= 'departure', _destination_= 'destination', _distance_= 'distance',
    _footage_= 'footage', _fraction_= 'fraction', _frame_= 'frame', _framelock_= 'framelock', _frames_= 'frames',
    _height_= 'height', _hi_= 'hi', _hidden_= 'hidden',
    _image_= 'image', _images_= 'images',
    _lo_= 'lo', _loading_= 'loading',
    _mouse_= 'mouse',
    _opening_= 'opening', _opening_ticks_= _opening_+'_ticks', _options_= 'options',
    _playing_= 'playing', _preloaded_= 'preloaded',
    _ratio_= 'ratio', _reeling_= 'reeling', _reeled_= 'reeled', _responsive_= 'responsive', _revolution_= 'revolution',
    _revolution_y_= 'revolution_y', _row_= 'row', _rowlock_= 'rowlock', _rows_= 'rows',
    _shy_= 'shy', _spacing_= 'spacing', _speed_= 'speed', _src_= 'src', _stage_= 'stage', _stitched_= 'stitched',
    _stitched_shift_= _stitched_+'_shift', _stitched_travel_= _stitched_+'_travel', _stopped_= 'stopped',
    _style_= 'style',
    _tempo_= 'tempo', _ticks_= 'ticks', _tier_= 'tier', _touch_= 'touch', _truescale_= 'truescale',
    _velocity_= 'velocity', _vertical_= 'vertical',
    _width_= 'width',

    // And the same goes for browser events too.
    //
    ns= dot(klass),
    pns= dot('pan') + ns,
    _deviceorientation_= 'deviceorientation'+ns, _dragstart_= 'dragstart'+ns,
    _mousedown_= _mouse_+'down'+ns, _mouseenter_= _mouse_+'enter'+ns, _mouseleave_= _mouse_+'leave'+pns,
    _mousemove_= _mouse_+'move'+pns, _mouseup_= _mouse_+'up'+pns, _mousewheel_= _mouse_+'wheel'+ns,
    _tick_= 'tick'+ns, _touchcancel_= _touch_+'cancel'+pns, _touchend_= _touch_+'end'+pns,
    _touchstart_= _touch_+'start'+ns, _touchmove_= _touch_+'move'+pns,
    _resize_= 'resize'+ns,

    // And some other frequently used Strings.
    //
    __= '', ___= ' ', ____=',', _absolute_= 'absolute', _block_= 'block', _cdn_= '@CDN@', _div_= 'div',
    _hand_= 'hand', _head_= 'head', _html_= 'html', _id_= 'id',
    _img_= 'img', _jquery_reel_= 'jquery.'+klass, _move_= 'move', _none_= 'none', _object_= 'object',
    _preload_= 'preload', _string_= 'string',

    // Collection of data keys holding scalable pixel values responsive to the scale ratio
    // 
    responsive_keys= [_width_, _height_, _spacing_, _revolution_, _revolution_y_, _stitched_, _stitched_shift_, _stitched_travel_],
    substitution_keys= { W: _width_, H: _height_ },

    // ---------------
    // Image Resources
    // ---------------
    //
    // Alhough we do what we can to hide the fact, Reel actually needs a few image resources to support
    // some of its actions. First, we may need a transparent image for the original `<img>` to uncover
    // the sprite applied to its background. This one is embedded in the code as it is very small.
    //
    transparent= knows_data_urls ? embedded('CAAIAIAAAAAAAAAAACH5BAEAAAAALAAAAAAIAAgAAAIHhI+py+1dAAA7') : _cdn_+'blank.gif',

    // Proper cross-browser cursors however need to come in an odd format, which essentially is not
    // compressed at all and this means bigger filesize. While it is no more than ~15k, it is unfit
    // for embedding directly here, so a [`CDN`](#Content-Delivery-Network) is employed to retrieve
    // the images from in an effective gzipped and cachable manner.
    //
    reel_cursor= url(_cdn_+_jquery_reel_+'.cur')+____+_move_,
    drag_cursor= url(_cdn_+_jquery_reel_+'-drag.cur')+____+_move_,
    drag_cursor_down= url(_cdn_+_jquery_reel_+'-drag-down.cur')+____+_move_,

    // ~~~
    //
    // We then only route around MSIE's left button identification quirk (IE 8- reports left as right).
    //
    lazy= reel.lazy= (reel.re.lazy_agent).test(client),

    DRAG_BUTTON= ie && browser_version < 9 ? 1 : 0,

    // ~~~
    //
    // So far jQuery doesn't have a proper built-in mechanism to detect/report DOM node removal.
    // But internally, jQuery calls `$.cleanData()` to flush the DOM data and minimize memory leaks.
    // Reel wraps this function and as a result `clean` event handler is triggered for every element.
    // Note, that the `clean` event does not bubble.
    //
    cleanData= $.cleanData,
    cleanDataEvent= $.cleanData= function(elements){
      $(elements).each(function(){ $(this).triggerHandler('clean'); });
      return cleanData.apply(this, arguments);
    }

  // Expose plugin functions as jQuery methods, do the initial global scan for data-configured
  // `<img`> tags to become enhanced and export the entire namespace module.
  //
  $.extend($.fn, reel.fn) && $(reel.scan);
  return reel;

  // Bunch of very useful helpers.
  //
  function add_instance($instance){ return (reel.instances.push($instance[0])) && $instance }
  function remove_instance($instance){ return (reel.instances= reel.instances.not(hash($instance.attr(_id_)))) && $instance }
  function leader(key){ return reel.instances.first().data(key) }
  function embedded(image){ return 'data:image/gif;base64,R0lGODlh' + image }
  function tag(string){ return '<' + string + '/>' }
  function dot(string){ return '.' + (string || '') }
  function cdn(path){ return path?path.replace(_cdn_, reel.cdn):undefined }
  function url(location){ return 'url(\'' + reen(location) + '\')' }
  function axis(key, value){ return typeof value == _object_ ? value[key] : value }
  function min_max(minimum, maximum, number){ return max(minimum, min(maximum, number)) }
  function negative_when(value, condition){ return abs(value) * (condition ? -1 : 1) }
  function pointer(e){ return e.touch || e.originalEvent.touches && e.originalEvent.touches[0] || e }
  function gyro(e){ return e.originalEvent }
  function px(value){ return value === undefined ? 0 : typeof value == _string_ ? value : value + 'px' }
  function hash(value){ return '#' + value }
  function pad(string, len, fill){ while (string.length < len) string= fill + string; return string }
  function twochar(string){ return pad(string, 2, '0') }
  function reen(uri){ return encodeURI(decodeURI(uri)) }
  function soft_array(string){ return reel.re.array.exec(string) ? string.split(reel.re.array) : string }
  function detached($node){ return !$node.parents(_html_).length }
  function numerize_array(array){ return typeof array == _string_ ? array : $.each(array, function(ix, it){ array[ix]= it ? +it : undefined }) }
  function error(message){ try{ console.error('[ Reel ] '+message) }catch(e){} }
})(jQuery, window, document);

});


/*!
Waypoints - 3.1.1
Copyright ?? 2011-2015 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blog/master/licenses.txt
*/
(function() {
  'use strict'

  var keyCounter = 0
  var allWaypoints = {}

  /* http://imakewebthings.com/waypoints/api/waypoint */
  function Waypoint(options) {
    if (!options) {
      throw new Error('No options passed to Waypoint constructor')
    }
    if (!options.element) {
      throw new Error('No element option passed to Waypoint constructor')
    }
    if (!options.handler) {
      throw new Error('No handler option passed to Waypoint constructor')
    }

    this.key = 'waypoint-' + keyCounter
    this.options = Waypoint.Adapter.extend({}, Waypoint.defaults, options)
    this.element = this.options.element
    this.adapter = new Waypoint.Adapter(this.element)
    this.callback = options.handler
    this.axis = this.options.horizontal ? 'horizontal' : 'vertical'
    this.enabled = this.options.enabled
    this.triggerPoint = null
    this.group = Waypoint.Group.findOrCreate({
      name: this.options.group,
      axis: this.axis
    })
    this.context = Waypoint.Context.findOrCreateByElement(this.options.context)

    if (Waypoint.offsetAliases[this.options.offset]) {
      this.options.offset = Waypoint.offsetAliases[this.options.offset]
    }
    this.group.add(this)
    this.context.add(this)
    allWaypoints[this.key] = this
    keyCounter += 1
  }

  /* Private */
  Waypoint.prototype.queueTrigger = function(direction) {
    this.group.queueTrigger(this, direction)
  }

  /* Private */
  Waypoint.prototype.trigger = function(args) {
    if (!this.enabled) {
      return
    }
    if (this.callback) {
      this.callback.apply(this, args)
    }
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/destroy */
  Waypoint.prototype.destroy = function() {
    this.context.remove(this)
    this.group.remove(this)
    delete allWaypoints[this.key]
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/disable */
  Waypoint.prototype.disable = function() {
    this.enabled = false
    return this
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/enable */
  Waypoint.prototype.enable = function() {
    this.context.refresh()
    this.enabled = true
    return this
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/next */
  Waypoint.prototype.next = function() {
    return this.group.next(this)
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/previous */
  Waypoint.prototype.previous = function() {
    return this.group.previous(this)
  }

  /* Private */
  Waypoint.invokeAll = function(method) {
    var allWaypointsArray = []
    for (var waypointKey in allWaypoints) {
      allWaypointsArray.push(allWaypoints[waypointKey])
    }
    for (var i = 0, end = allWaypointsArray.length; i < end; i++) {
      allWaypointsArray[i][method]()
    }
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/destroy-all */
  Waypoint.destroyAll = function() {
    Waypoint.invokeAll('destroy')
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/disable-all */
  Waypoint.disableAll = function() {
    Waypoint.invokeAll('disable')
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/enable-all */
  Waypoint.enableAll = function() {
    Waypoint.invokeAll('enable')
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/refresh-all */
  Waypoint.refreshAll = function() {
    Waypoint.Context.refreshAll()
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/viewport-height */
  Waypoint.viewportHeight = function() {
    return window.innerHeight || document.documentElement.clientHeight
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/viewport-width */
  Waypoint.viewportWidth = function() {
    return document.documentElement.clientWidth
  }

  Waypoint.adapters = []

  Waypoint.defaults = {
    context: window,
    continuous: true,
    enabled: true,
    group: 'default',
    horizontal: false,
    offset: 0
  }

  Waypoint.offsetAliases = {
    'bottom-in-view': function() {
      return this.context.innerHeight() - this.adapter.outerHeight()
    },
    'right-in-view': function() {
      return this.context.innerWidth() - this.adapter.outerWidth()
    }
  }

  window.Waypoint = Waypoint
}())
;(function() {
  'use strict'

  function requestAnimationFrameShim(callback) {
    window.setTimeout(callback, 1000 / 60)
  }

  var keyCounter = 0
  var contexts = {}
  var Waypoint = window.Waypoint
  var oldWindowLoad = window.onload

  /* http://imakewebthings.com/waypoints/api/context */
  function Context(element) {
    this.element = element
    this.Adapter = Waypoint.Adapter
    this.adapter = new this.Adapter(element)
    this.key = 'waypoint-context-' + keyCounter
    this.didScroll = false
    this.didResize = false
    this.oldScroll = {
      x: this.adapter.scrollLeft(),
      y: this.adapter.scrollTop()
    }
    this.waypoints = {
      vertical: {},
      horizontal: {}
    }

    element.waypointContextKey = this.key
    contexts[element.waypointContextKey] = this
    keyCounter += 1

    this.createThrottledScrollHandler()
    this.createThrottledResizeHandler()
  }

  /* Private */
  Context.prototype.add = function(waypoint) {
    var axis = waypoint.options.horizontal ? 'horizontal' : 'vertical'
    this.waypoints[axis][waypoint.key] = waypoint
    this.refresh()
  }

  /* Private */
  Context.prototype.checkEmpty = function() {
    var horizontalEmpty = this.Adapter.isEmptyObject(this.waypoints.horizontal)
    var verticalEmpty = this.Adapter.isEmptyObject(this.waypoints.vertical)
    if (horizontalEmpty && verticalEmpty) {
      this.adapter.off('.waypoints')
      delete contexts[this.key]
    }
  }

  /* Private */
  Context.prototype.createThrottledResizeHandler = function() {
    var self = this

    function resizeHandler() {
      self.handleResize()
      self.didResize = false
    }

    this.adapter.on('resize.waypoints', function() {
      if (!self.didResize) {
        self.didResize = true
        Waypoint.requestAnimationFrame(resizeHandler)
      }
    })
  }

  /* Private */
  Context.prototype.createThrottledScrollHandler = function() {
    var self = this
    function scrollHandler() {
      self.handleScroll()
      self.didScroll = false
    }

    this.adapter.on('scroll.waypoints', function() {
      if (!self.didScroll || Waypoint.isTouch) {
        self.didScroll = true
        Waypoint.requestAnimationFrame(scrollHandler)
      }
    })
  }

  /* Private */
  Context.prototype.handleResize = function() {
    Waypoint.Context.refreshAll()
  }

  /* Private */
  Context.prototype.handleScroll = function() {
    var triggeredGroups = {}
    var axes = {
      horizontal: {
        newScroll: this.adapter.scrollLeft(),
        oldScroll: this.oldScroll.x,
        forward: 'right',
        backward: 'left'
      },
      vertical: {
        newScroll: this.adapter.scrollTop(),
        oldScroll: this.oldScroll.y,
        forward: 'down',
        backward: 'up'
      }
    }

    for (var axisKey in axes) {
      var axis = axes[axisKey]
      var isForward = axis.newScroll > axis.oldScroll
      var direction = isForward ? axis.forward : axis.backward

      for (var waypointKey in this.waypoints[axisKey]) {
        var waypoint = this.waypoints[axisKey][waypointKey]
        var wasBeforeTriggerPoint = axis.oldScroll < waypoint.triggerPoint
        var nowAfterTriggerPoint = axis.newScroll >= waypoint.triggerPoint
        var crossedForward = wasBeforeTriggerPoint && nowAfterTriggerPoint
        var crossedBackward = !wasBeforeTriggerPoint && !nowAfterTriggerPoint
        if (crossedForward || crossedBackward) {
          waypoint.queueTrigger(direction)
          triggeredGroups[waypoint.group.id] = waypoint.group
        }
      }
    }

    for (var groupKey in triggeredGroups) {
      triggeredGroups[groupKey].flushTriggers()
    }

    this.oldScroll = {
      x: axes.horizontal.newScroll,
      y: axes.vertical.newScroll
    }
  }

  /* Private */
  Context.prototype.innerHeight = function() {
    /*eslint-disable eqeqeq */
    if (this.element == this.element.window) {
      return Waypoint.viewportHeight()
    }
    /*eslint-enable eqeqeq */
    return this.adapter.innerHeight()
  }

  /* Private */
  Context.prototype.remove = function(waypoint) {
    delete this.waypoints[waypoint.axis][waypoint.key]
    this.checkEmpty()
  }

  /* Private */
  Context.prototype.innerWidth = function() {
    /*eslint-disable eqeqeq */
    if (this.element == this.element.window) {
      return Waypoint.viewportWidth()
    }
    /*eslint-enable eqeqeq */
    return this.adapter.innerWidth()
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/context-destroy */
  Context.prototype.destroy = function() {
    var allWaypoints = []
    for (var axis in this.waypoints) {
      for (var waypointKey in this.waypoints[axis]) {
        allWaypoints.push(this.waypoints[axis][waypointKey])
      }
    }
    for (var i = 0, end = allWaypoints.length; i < end; i++) {
      allWaypoints[i].destroy()
    }
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/context-refresh */
  Context.prototype.refresh = function() {
    /*eslint-disable eqeqeq */
    var isWindow = this.element == this.element.window
    /*eslint-enable eqeqeq */
    var contextOffset = this.adapter.offset()
    var triggeredGroups = {}
    var axes

    this.handleScroll()
    axes = {
      horizontal: {
        contextOffset: isWindow ? 0 : contextOffset.left,
        contextScroll: isWindow ? 0 : this.oldScroll.x,
        contextDimension: this.innerWidth(),
        oldScroll: this.oldScroll.x,
        forward: 'right',
        backward: 'left',
        offsetProp: 'left'
      },
      vertical: {
        contextOffset: isWindow ? 0 : contextOffset.top,
        contextScroll: isWindow ? 0 : this.oldScroll.y,
        contextDimension: this.innerHeight(),
        oldScroll: this.oldScroll.y,
        forward: 'down',
        backward: 'up',
        offsetProp: 'top'
      }
    }

    for (var axisKey in axes) {
      var axis = axes[axisKey]
      for (var waypointKey in this.waypoints[axisKey]) {
        var waypoint = this.waypoints[axisKey][waypointKey]
        var adjustment = waypoint.options.offset
        var oldTriggerPoint = waypoint.triggerPoint
        var elementOffset = 0
        var freshWaypoint = oldTriggerPoint == null
        var contextModifier, wasBeforeScroll, nowAfterScroll
        var triggeredBackward, triggeredForward

        if (waypoint.element !== waypoint.element.window) {
          elementOffset = waypoint.adapter.offset()[axis.offsetProp]
        }

        if (typeof adjustment === 'function') {
          adjustment = adjustment.apply(waypoint)
        }
        else if (typeof adjustment === 'string') {
          adjustment = parseFloat(adjustment)
          if (waypoint.options.offset.indexOf('%') > - 1) {
            adjustment = Math.ceil(axis.contextDimension * adjustment / 100)
          }
        }

        contextModifier = axis.contextScroll - axis.contextOffset
        waypoint.triggerPoint = elementOffset + contextModifier - adjustment
        wasBeforeScroll = oldTriggerPoint < axis.oldScroll
        nowAfterScroll = waypoint.triggerPoint >= axis.oldScroll
        triggeredBackward = wasBeforeScroll && nowAfterScroll
        triggeredForward = !wasBeforeScroll && !nowAfterScroll

        if (!freshWaypoint && triggeredBackward) {
          waypoint.queueTrigger(axis.backward)
          triggeredGroups[waypoint.group.id] = waypoint.group
        }
        else if (!freshWaypoint && triggeredForward) {
          waypoint.queueTrigger(axis.forward)
          triggeredGroups[waypoint.group.id] = waypoint.group
        }
        else if (freshWaypoint && axis.oldScroll >= waypoint.triggerPoint) {
          waypoint.queueTrigger(axis.forward)
          triggeredGroups[waypoint.group.id] = waypoint.group
        }
      }
    }

    for (var groupKey in triggeredGroups) {
      triggeredGroups[groupKey].flushTriggers()
    }

    return this
  }

  /* Private */
  Context.findOrCreateByElement = function(element) {
    return Context.findByElement(element) || new Context(element)
  }

  /* Private */
  Context.refreshAll = function() {
    for (var contextId in contexts) {
      contexts[contextId].refresh()
    }
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/context-find-by-element */
  Context.findByElement = function(element) {
    return contexts[element.waypointContextKey]
  }

  window.onload = function() {
    if (oldWindowLoad) {
      oldWindowLoad()
    }
    Context.refreshAll()
  }

  Waypoint.requestAnimationFrame = function(callback) {
    var requestFn = window.requestAnimationFrame ||
      window.mozRequestAnimationFrame ||
      window.webkitRequestAnimationFrame ||
      requestAnimationFrameShim
    requestFn.call(window, callback)
  }
  Waypoint.Context = Context
}())
;(function() {
  'use strict'

  function byTriggerPoint(a, b) {
    return a.triggerPoint - b.triggerPoint
  }

  function byReverseTriggerPoint(a, b) {
    return b.triggerPoint - a.triggerPoint
  }

  var groups = {
    vertical: {},
    horizontal: {}
  }
  var Waypoint = window.Waypoint

  /* http://imakewebthings.com/waypoints/api/group */
  function Group(options) {
    this.name = options.name
    this.axis = options.axis
    this.id = this.name + '-' + this.axis
    this.waypoints = []
    this.clearTriggerQueues()
    groups[this.axis][this.name] = this
  }

  /* Private */
  Group.prototype.add = function(waypoint) {
    this.waypoints.push(waypoint)
  }

  /* Private */
  Group.prototype.clearTriggerQueues = function() {
    this.triggerQueues = {
      up: [],
      down: [],
      left: [],
      right: []
    }
  }

  /* Private */
  Group.prototype.flushTriggers = function() {
    for (var direction in this.triggerQueues) {
      var waypoints = this.triggerQueues[direction]
      var reverse = direction === 'up' || direction === 'left'
      waypoints.sort(reverse ? byReverseTriggerPoint : byTriggerPoint)
      for (var i = 0, end = waypoints.length; i < end; i += 1) {
        var waypoint = waypoints[i]
        if (waypoint.options.continuous || i === waypoints.length - 1) {
          waypoint.trigger([direction])
        }
      }
    }
    this.clearTriggerQueues()
  }

  /* Private */
  Group.prototype.next = function(waypoint) {
    this.waypoints.sort(byTriggerPoint)
    var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)
    var isLast = index === this.waypoints.length - 1
    return isLast ? null : this.waypoints[index + 1]
  }

  /* Private */
  Group.prototype.previous = function(waypoint) {
    this.waypoints.sort(byTriggerPoint)
    var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)
    return index ? this.waypoints[index - 1] : null
  }

  /* Private */
  Group.prototype.queueTrigger = function(waypoint, direction) {
    this.triggerQueues[direction].push(waypoint)
  }

  /* Private */
  Group.prototype.remove = function(waypoint) {
    var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)
    if (index > -1) {
      this.waypoints.splice(index, 1)
    }
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/first */
  Group.prototype.first = function() {
    return this.waypoints[0]
  }

  /* Public */
  /* http://imakewebthings.com/waypoints/api/last */
  Group.prototype.last = function() {
    return this.waypoints[this.waypoints.length - 1]
  }

  /* Private */
  Group.findOrCreate = function(options) {
    return groups[options.axis][options.name] || new Group(options)
  }

  Waypoint.Group = Group
}())
;(function() {
  'use strict'

  var $ = window.jQuery
  var Waypoint = window.Waypoint

  function JQueryAdapter(element) {
    this.$element = $(element)
  }

  $.each([
    'innerHeight',
    'innerWidth',
    'off',
    'offset',
    'on',
    'outerHeight',
    'outerWidth',
    'scrollLeft',
    'scrollTop'
  ], function(i, method) {
    JQueryAdapter.prototype[method] = function() {
      var args = Array.prototype.slice.call(arguments)
      return this.$element[method].apply(this.$element, args)
    }
  })

  $.each([
    'extend',
    'inArray',
    'isEmptyObject'
  ], function(i, method) {
    JQueryAdapter[method] = $[method]
  })

  Waypoint.adapters.push({
    name: 'jquery',
    Adapter: JQueryAdapter
  })
  Waypoint.Adapter = JQueryAdapter
}())
;(function() {
  'use strict'

  var Waypoint = window.Waypoint

  function createExtension(framework) {
    return function() {
      var waypoints = []
      var overrides = arguments[0]

      if (framework.isFunction(arguments[0])) {
        overrides = framework.extend({}, arguments[1])
        overrides.handler = arguments[0]
      }

      this.each(function() {
        var options = framework.extend({}, overrides, {
          element: this
        })
        if (typeof options.context === 'string') {
          options.context = framework(this).closest(options.context)[0]
        }
        waypoints.push(new Waypoint(options))
      })

      return waypoints
    }
  }

  if (window.jQuery) {
    window.jQuery.fn.waypoint = createExtension(window.jQuery)
  }
  if (window.Zepto) {
    window.Zepto.fn.waypoint = createExtension(window.Zepto)
  }
}())
;



(function($,window){
  '$:nomunge'; // Used by YUI compressor.
  
  // Some convenient shortcuts.
  var undefined,
    aps = Array.prototype.slice,
    decode = decodeURIComponent,
    
    // Method / object references.
    jq_param = $.param,
    jq_param_fragment,
    jq_deparam,
    jq_deparam_fragment,
    jq_bbq = $.bbq = $.bbq || {},
    jq_bbq_pushState,
    jq_bbq_getState,
    jq_elemUrlAttr,
    jq_event_special = $.event.special,
    
    // Reused strings.
    str_hashchange = 'hashchange',
    str_querystring = 'querystring',
    str_fragment = 'fragment',
    str_elemUrlAttr = 'elemUrlAttr',
    str_location = 'location',
    str_href = 'href',
    str_src = 'src',
    
    // Reused RegExp.
    re_trim_querystring = /^.*\?|#.*$/g,
    re_trim_fragment = /^.*\#/,
    re_no_escape,
    
    // Used by jQuery.elemUrlAttr.
    elemUrlAttr_cache = {};
  
  // A few commonly used bits, broken out to help reduce minified file size.
  function is_string( arg ) {
    return typeof arg === 'string';
  };
  
  // Why write the same function twice? Let's curry! Mmmm, curry..
  
  function curry( func ) {
    var args = aps.call( arguments, 1 );
    
    return function() {
      return func.apply( this, args.concat( aps.call( arguments ) ) );
    };
  };
  
  // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!
  function get_fragment( url ) {
    return url.replace( /^[^#]*#?(.*)$/, '$1' );
  };
  
  // Get location.search (or what you'd expect location.search to be) sans any
  // leading #. Thanks for making this necessary, IE6!
  function get_querystring( url ) {
    return url.replace( /(?:^[^?#]*\?([^#]*).*$)?.*/, '$1' );
  };
  
  // Section: Param (to string)
  // 
  // Method: jQuery.param.querystring
  // 
  // Retrieve the query string from a URL or if no arguments are passed, the
  // current window.location.
  // 
  // Usage:
  // 
  // > jQuery.param.querystring( [ url ] );
  // 
  // Arguments:
  // 
  //  url - (String) A URL containing query string params to be parsed. If url
  //    is not passed, the current window.location is used.
  // 
  // Returns:
  // 
  //  (String) The parsed query string, with any leading "?" removed.
  //
  
  // Method: jQuery.param.querystring (build url)
  // 
  // Merge a URL, with or without pre-existing query string params, plus any
  // object, params string or URL containing query string params into a new URL.
  // 
  // Usage:
  // 
  // > jQuery.param.querystring( url, params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  url - (String) A valid URL for params to be merged into. This URL may
  //    contain a query string and/or fragment (hash).
  //  params - (String) A params string or URL containing query string params to
  //    be merged into url.
  //  params - (Object) A params object to be merged into url.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  // 
  //    * 0: params in the params argument will override any query string
  //         params in url.
  //    * 1: any query string params in url will override params in the params
  //         argument.
  //    * 2: params argument will completely replace any query string in url.
  // 
  // Returns:
  // 
  //  (String) Either a params string with urlencoded data or a URL with a
  //    urlencoded query string in the format 'a=b&c=d&e=f'.
  
  // Method: jQuery.param.fragment
  // 
  // Retrieve the fragment (hash) from a URL or if no arguments are passed, the
  // current window.location.
  // 
  // Usage:
  // 
  // > jQuery.param.fragment( [ url ] );
  // 
  // Arguments:
  // 
  //  url - (String) A URL containing fragment (hash) params to be parsed. If
  //    url is not passed, the current window.location is used.
  // 
  // Returns:
  // 
  //  (String) The parsed fragment (hash) string, with any leading "#" removed.
  
  // Method: jQuery.param.fragment (build url)
  // 
  // Merge a URL, with or without pre-existing fragment (hash) params, plus any
  // object, params string or URL containing fragment (hash) params into a new
  // URL.
  // 
  // Usage:
  // 
  // > jQuery.param.fragment( url, params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  url - (String) A valid URL for params to be merged into. This URL may
  //    contain a query string and/or fragment (hash).
  //  params - (String) A params string or URL containing fragment (hash) params
  //    to be merged into url.
  //  params - (Object) A params object to be merged into url.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  // 
  //    * 0: params in the params argument will override any fragment (hash)
  //         params in url.
  //    * 1: any fragment (hash) params in url will override params in the
  //         params argument.
  //    * 2: params argument will completely replace any query string in url.
  // 
  // Returns:
  // 
  //  (String) Either a params string with urlencoded data or a URL with a
  //    urlencoded fragment (hash) in the format 'a=b&c=d&e=f'.
  
  function jq_param_sub( is_fragment, get_func, url, params, merge_mode ) {
    var result,
      qs,
      matches,
      url_params,
      hash;
    
    if ( params !== undefined ) {
      // Build URL by merging params into url string.
      
      // matches[1] = url part that precedes params, not including trailing ?/#
      // matches[2] = params, not including leading ?/#
      // matches[3] = if in 'querystring' mode, hash including leading #, otherwise ''
      matches = url.match( is_fragment ? /^([^#]*)\#?(.*)$/ : /^([^#?]*)\??([^#]*)(#?.*)/ );
      
      // Get the hash if in 'querystring' mode, and it exists.
      hash = matches[3] || '';
      
      if ( merge_mode === 2 && is_string( params ) ) {
        // If merge_mode is 2 and params is a string, merge the fragment / query
        // string into the URL wholesale, without converting it into an object.
        qs = params.replace( is_fragment ? re_trim_fragment : re_trim_querystring, '' );
        
      } else {
        // Convert relevant params in url to object.
        url_params = jq_deparam( matches[2] );
        
        params = is_string( params )
          
          // Convert passed params string into object.
          ? jq_deparam[ is_fragment ? str_fragment : str_querystring ]( params )
          
          // Passed params object.
          : params;
        
        qs = merge_mode === 2 ? params                              // passed params replace url params
          : merge_mode === 1  ? $.extend( {}, params, url_params )  // url params override passed params
          : $.extend( {}, url_params, params );                     // passed params override url params
        
        // Convert params object to a string.
        qs = jq_param( qs );
        
        // Unescape characters specified via $.param.noEscape. Since only hash-
        // history users have requested this feature, it's only enabled for
        // fragment-related params strings.
        if ( is_fragment ) {
          qs = qs.replace( re_no_escape, decode );
        }
      }
      
      // Build URL from the base url, querystring and hash. In 'querystring'
      // mode, ? is only added if a query string exists. In 'fragment' mode, #
      // is always added.
      result = matches[1] + ( is_fragment ? '#' : qs || !matches[1] ? '?' : '' ) + qs + hash;
      
    } else {
      // If URL was passed in, parse params from URL string, otherwise parse
      // params from window.location.
      result = get_func( url !== undefined ? url : window[ str_location ][ str_href ] );
    }
    
    return result;
  };
  
  jq_param[ str_querystring ]                  = curry( jq_param_sub, 0, get_querystring );
  jq_param[ str_fragment ] = jq_param_fragment = curry( jq_param_sub, 1, get_fragment );
  
  // Method: jQuery.param.fragment.noEscape
  // 
  // Specify characters that will be left unescaped when fragments are created
  // or merged using <jQuery.param.fragment>, or when the fragment is modified
  // using <jQuery.bbq.pushState>. This option only applies to serialized data
  // object fragments, and not set-as-string fragments. Does not affect the
  // query string. Defaults to ",/" (comma, forward slash).
  // 
  // Note that this is considered a purely aesthetic option, and will help to
  // create URLs that "look pretty" in the address bar or bookmarks, without
  // affecting functionality in any way. That being said, be careful to not
  // unescape characters that are used as delimiters or serve a special
  // purpose, such as the "#?&=+" (octothorpe, question mark, ampersand,
  // equals, plus) characters.
  // 
  // Usage:
  // 
  // > jQuery.param.fragment.noEscape( [ chars ] );
  // 
  // Arguments:
  // 
  //  chars - (String) The characters to not escape in the fragment. If
  //    unspecified, defaults to empty string (escape all characters).
  // 
  // Returns:
  // 
  //  Nothing.
  
  jq_param_fragment.noEscape = function( chars ) {
    chars = chars || '';
    var arr = $.map( chars.split(''), encodeURIComponent );
    re_no_escape = new RegExp( arr.join('|'), 'g' );
  };
  
  // A sensible default. These are the characters people seem to complain about
  // "uglifying up the URL" the most.
  jq_param_fragment.noEscape( ',/' );
  
  // Section: Deparam (from string)
  // 
  // Method: jQuery.deparam
  // 
  // Deserialize a params string into an object, optionally coercing numbers,
  // booleans, null and undefined values; this method is the counterpart to the
  // internal jQuery.param method.
  // 
  // Usage:
  // 
  // > jQuery.deparam( params [, coerce ] );
  // 
  // Arguments:
  // 
  //  params - (String) A params string to be parsed.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  // 
  // Returns:
  // 
  //  (Object) An object representing the deserialized params string.
  
  $.deparam = jq_deparam = function( params, coerce ) {
    var obj = {},
      coerce_types = { 'true': !0, 'false': !1, 'null': null };
    
    // Iterate over all name=value pairs.
    $.each( params.replace( /\+/g, ' ' ).split( '&' ), function(j,v){
      var param = v.split( '=' ),
        key = decode( param[0] ),
        val,
        cur = obj,
        i = 0,
        
        // If key is more complex than 'foo', like 'a[]' or 'a[b][c]', split it
        // into its component parts.
        keys = key.split( '][' ),
        keys_last = keys.length - 1;
      
      // If the first keys part contains [ and the last ends with ], then []
      // are correctly balanced.
      if ( /\[/.test( keys[0] ) && /\]$/.test( keys[ keys_last ] ) ) {
        // Remove the trailing ] from the last keys part.
        keys[ keys_last ] = keys[ keys_last ].replace( /\]$/, '' );
        
        // Split first keys part into two parts on the [ and add them back onto
        // the beginning of the keys array.
        keys = keys.shift().split('[').concat( keys );
        
        keys_last = keys.length - 1;
      } else {
        // Basic 'foo' style key.
        keys_last = 0;
      }
      
      // Are we dealing with a name=value pair, or just a name?
      if ( param.length === 2 ) {
        val = decode( param[1] );
        
        // Coerce values.
        if ( coerce ) {
          val = val && !isNaN(val)            ? +val              // number
            : val === 'undefined'             ? undefined         // undefined
            : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null
            : val;                                                // string
        }
        
        if ( keys_last ) {
          // Complex key, build deep object structure based on a few rules:
          // * The 'cur' pointer starts at the object top-level.
          // * [] = array push (n is set to array length), [n] = array if n is 
          //   numeric, otherwise object.
          // * If at the last keys part, set the value.
          // * For each keys part, if the current level is undefined create an
          //   object or array based on the type of the next keys part.
          // * Move the 'cur' pointer to the next level.
          // * Rinse & repeat.
          for ( ; i <= keys_last; i++ ) {
            key = keys[i] === '' ? cur.length : keys[i];
            cur = cur[key] = i < keys_last
              ? cur[key] || ( keys[i+1] && isNaN( keys[i+1] ) ? {} : [] )
              : val;
          }
          
        } else {
          // Simple key, even simpler rules, since only scalars and shallow
          // arrays are allowed.
          
          if ( $.isArray( obj[key] ) ) {
            // val is already an array, so push on the next value.
            obj[key].push( val );
            
          } else if ( obj[key] !== undefined ) {
            // val isn't an array, but since a second value has been specified,
            // convert val into an array.
            obj[key] = [ obj[key], val ];
            
          } else {
            // val is a scalar.
            obj[key] = val;
          }
        }
        
      } else if ( key ) {
        // No value was defined, so set something meaningful.
        obj[key] = coerce
          ? undefined
          : '';
      }
    });
    
    return obj;
  };
  
  // Method: jQuery.deparam.querystring
  // 
  // Parse the query string from a URL or the current window.location,
  // deserializing it into an object, optionally coercing numbers, booleans,
  // null and undefined values.
  // 
  // Usage:
  // 
  // > jQuery.deparam.querystring( [ url ] [, coerce ] );
  // 
  // Arguments:
  // 
  //  url - (String) An optional params string or URL containing query string
  //    params to be parsed. If url is omitted, the current window.location
  //    is used.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  // 
  // Returns:
  // 
  //  (Object) An object representing the deserialized params string.
  
  // Method: jQuery.deparam.fragment
  // 
  // Parse the fragment (hash) from a URL or the current window.location,
  // deserializing it into an object, optionally coercing numbers, booleans,
  // null and undefined values.
  // 
  // Usage:
  // 
  // > jQuery.deparam.fragment( [ url ] [, coerce ] );
  // 
  // Arguments:
  // 
  //  url - (String) An optional params string or URL containing fragment (hash)
  //    params to be parsed. If url is omitted, the current window.location
  //    is used.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  // 
  // Returns:
  // 
  //  (Object) An object representing the deserialized params string.
  
  function jq_deparam_sub( is_fragment, url_or_params, coerce ) {
    if ( url_or_params === undefined || typeof url_or_params === 'boolean' ) {
      // url_or_params not specified.
      coerce = url_or_params;
      url_or_params = jq_param[ is_fragment ? str_fragment : str_querystring ]();
    } else {
      url_or_params = is_string( url_or_params )
        ? url_or_params.replace( is_fragment ? re_trim_fragment : re_trim_querystring, '' )
        : url_or_params;
    }
    
    return jq_deparam( url_or_params, coerce );
  };
  
  jq_deparam[ str_querystring ]                    = curry( jq_deparam_sub, 0 );
  jq_deparam[ str_fragment ] = jq_deparam_fragment = curry( jq_deparam_sub, 1 );
  
  // Section: Element manipulation
  // 
  // Method: jQuery.elemUrlAttr
  // 
  // Get the internal "Default URL attribute per tag" list, or augment the list
  // with additional tag-attribute pairs, in case the defaults are insufficient.
  // 
  // In the <jQuery.fn.querystring> and <jQuery.fn.fragment> methods, this list
  // is used to determine which attribute contains the URL to be modified, if
  // an "attr" param is not specified.
  // 
  // Default Tag-Attribute List:
  // 
  //  a      - href
  //  base   - href
  //  iframe - src
  //  img    - src
  //  input  - src
  //  form   - action
  //  link   - href
  //  script - src
  // 
  // Usage:
  // 
  // > jQuery.elemUrlAttr( [ tag_attr ] );
  // 
  // Arguments:
  // 
  //  tag_attr - (Object) An object containing a list of tag names and their
  //    associated default attribute names in the format { tag: 'attr', ... } to
  //    be merged into the internal tag-attribute list.
  // 
  // Returns:
  // 
  //  (Object) An object containing all stored tag-attribute values.
  
  // Only define function and set defaults if function doesn't already exist, as
  // the urlInternal plugin will provide this method as well.
  $[ str_elemUrlAttr ] || ($[ str_elemUrlAttr ] = function( obj ) {
    return $.extend( elemUrlAttr_cache, obj );
  })({
    a: str_href,
    base: str_href,
    iframe: str_src,
    img: str_src,
    input: str_src,
    form: 'action',
    link: str_href,
    script: str_src
  });
  
  jq_elemUrlAttr = $[ str_elemUrlAttr ];
  
  // Method: jQuery.fn.querystring
  // 
  // Update URL attribute in one or more elements, merging the current URL (with
  // or without pre-existing query string params) plus any params object or
  // string into a new URL, which is then set into that attribute. Like
  // <jQuery.param.querystring (build url)>, but for all elements in a jQuery
  // collection.
  // 
  // Usage:
  // 
  // > jQuery('selector').querystring( [ attr, ] params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  attr - (String) Optional name of an attribute that will contain a URL to
  //    merge params or url into. See <jQuery.elemUrlAttr> for a list of default
  //    attributes.
  //  params - (Object) A params object to be merged into the URL attribute.
  //  params - (String) A URL containing query string params, or params string
  //    to be merged into the URL attribute.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //    
  //    * 0: params in the params argument will override any params in attr URL.
  //    * 1: any params in attr URL will override params in the params argument.
  //    * 2: params argument will completely replace any query string in attr
  //         URL.
  // 
  // Returns:
  // 
  //  (jQuery) The initial jQuery collection of elements, but with modified URL
  //  attribute values.
  
  // Method: jQuery.fn.fragment
  // 
  // Update URL attribute in one or more elements, merging the current URL (with
  // or without pre-existing fragment/hash params) plus any params object or
  // string into a new URL, which is then set into that attribute. Like
  // <jQuery.param.fragment (build url)>, but for all elements in a jQuery
  // collection.
  // 
  // Usage:
  // 
  // > jQuery('selector').fragment( [ attr, ] params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  attr - (String) Optional name of an attribute that will contain a URL to
  //    merge params into. See <jQuery.elemUrlAttr> for a list of default
  //    attributes.
  //  params - (Object) A params object to be merged into the URL attribute.
  //  params - (String) A URL containing fragment (hash) params, or params
  //    string to be merged into the URL attribute.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //    
  //    * 0: params in the params argument will override any params in attr URL.
  //    * 1: any params in attr URL will override params in the params argument.
  //    * 2: params argument will completely replace any fragment (hash) in attr
  //         URL.
  // 
  // Returns:
  // 
  //  (jQuery) The initial jQuery collection of elements, but with modified URL
  //  attribute values.
  
  function jq_fn_sub( mode, force_attr, params, merge_mode ) {
    if ( !is_string( params ) && typeof params !== 'object' ) {
      // force_attr not specified.
      merge_mode = params;
      params = force_attr;
      force_attr = undefined;
    }
    
    return this.each(function(){
      var that = $(this),
        
        // Get attribute specified, or default specified via $.elemUrlAttr.
        attr = force_attr || jq_elemUrlAttr()[ ( this.nodeName || '' ).toLowerCase() ] || '',
        
        // Get URL value.
        url = attr && that.attr( attr ) || '';
      
      // Update attribute with new URL.
      that.attr( attr, jq_param[ mode ]( url, params, merge_mode ) );
    });
    
  };
  
  $.fn[ str_querystring ] = curry( jq_fn_sub, str_querystring );
  $.fn[ str_fragment ]    = curry( jq_fn_sub, str_fragment );
  
  // Section: History, hashchange event
  // 
  // Method: jQuery.bbq.pushState
  // 
  // Adds a 'state' into the browser history at the current position, setting
  // location.hash and triggering any bound <hashchange event> callbacks
  // (provided the new state is different than the previous state).
  // 
  // If no arguments are passed, an empty state is created, which is just a
  // shortcut for jQuery.bbq.pushState( {}, 2 ).
  // 
  // Usage:
  // 
  // > jQuery.bbq.pushState( [ params [, merge_mode ] ] );
  // 
  // Arguments:
  // 
  //  params - (String) A serialized params string or a hash string beginning
  //    with # to merge into location.hash.
  //  params - (Object) A params object to merge into location.hash.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified (unless a hash string beginning with # is specified, in which
  //    case merge behavior defaults to 2), and is as-follows:
  // 
  //    * 0: params in the params argument will override any params in the
  //         current state.
  //    * 1: any params in the current state will override params in the params
  //         argument.
  //    * 2: params argument will completely replace current state.
  // 
  // Returns:
  // 
  //  Nothing.
  // 
  // Additional Notes:
  // 
  //  * Setting an empty state may cause the browser to scroll.
  //  * Unlike the fragment and querystring methods, if a hash string beginning
  //    with # is specified as the params agrument, merge_mode defaults to 2.
  
  jq_bbq.pushState = jq_bbq_pushState = function( params, merge_mode ) {
    if ( is_string( params ) && /^#/.test( params ) && merge_mode === undefined ) {
      // Params string begins with # and merge_mode not specified, so completely
      // overwrite window.location.hash.
      merge_mode = 2;
    }
    
    var has_args = params !== undefined,
      // Merge params into window.location using $.param.fragment.
      url = jq_param_fragment( window[ str_location ][ str_href ],
        has_args ? params : {}, has_args ? merge_mode : 2 );
    
    // Set new window.location.href. If hash is empty, use just # to prevent
    // browser from reloading the page. Note that Safari 3 & Chrome barf on
    // location.hash = '#'.
    window[ str_location ][ str_href ] = url + ( /#/.test( url ) ? '' : '#' );
  };
  
  // Method: jQuery.bbq.getState
  // 
  // Retrieves the current 'state' from the browser history, parsing
  // location.hash for a specific key or returning an object containing the
  // entire state, optionally coercing numbers, booleans, null and undefined
  // values.
  // 
  // Usage:
  // 
  // > jQuery.bbq.getState( [ key ] [, coerce ] );
  // 
  // Arguments:
  // 
  //  key - (String) An optional state key for which to return a value.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false.
  // 
  // Returns:
  // 
  //  (Anything) If key is passed, returns the value corresponding with that key
  //    in the location.hash 'state', or undefined. If not, an object
  //    representing the entire 'state' is returned.
  
  jq_bbq.getState = jq_bbq_getState = function( key, coerce ) {
    return key === undefined || typeof key === 'boolean'
      ? jq_deparam_fragment( key ) // 'key' really means 'coerce' here
      : jq_deparam_fragment( coerce )[ key ];
  };
  
  // Method: jQuery.bbq.removeState
  // 
  // Remove one or more keys from the current browser history 'state', creating
  // a new state, setting location.hash and triggering any bound
  // <hashchange event> callbacks (provided the new state is different than
  // the previous state).
  // 
  // If no arguments are passed, an empty state is created, which is just a
  // shortcut for jQuery.bbq.pushState( {}, 2 ).
  // 
  // Usage:
  // 
  // > jQuery.bbq.removeState( [ key [, key ... ] ] );
  // 
  // Arguments:
  // 
  //  key - (String) One or more key values to remove from the current state,
  //    passed as individual arguments.
  //  key - (Array) A single array argument that contains a list of key values
  //    to remove from the current state.
  // 
  // Returns:
  // 
  //  Nothing.
  // 
  // Additional Notes:
  // 
  //  * Setting an empty state may cause the browser to scroll.
  
  jq_bbq.removeState = function( arr ) {
    var state = {};
    
    // If one or more arguments is passed..
    if ( arr !== undefined ) {
      
      // Get the current state.
      state = jq_bbq_getState();
      
      // For each passed key, delete the corresponding property from the current
      // state.
      $.each( $.isArray( arr ) ? arr : arguments, function(i,v){
        delete state[ v ];
      });
    }
    
    // Set the state, completely overriding any existing state.
    jq_bbq_pushState( state, 2 );
  };
  
  // Event: hashchange event (BBQ)
  // 
  // Usage in jQuery 1.4 and newer:
  // 
  // In jQuery 1.4 and newer, the event object passed into any hashchange event
  // callback is augmented with a copy of the location.hash fragment at the time
  // the event was triggered as its event.fragment property. In addition, the
  // event.getState method operates on this property (instead of location.hash)
  // which allows this fragment-as-a-state to be referenced later, even after
  // window.location may have changed.
  // 
  // Note that event.fragment and event.getState are not defined according to
  // W3C (or any other) specification, but will still be available whether or
  // not the hashchange event exists natively in the browser, because of the
  // utility they provide.
  // 
  // The event.fragment property contains the output of <jQuery.param.fragment>
  // and the event.getState method is equivalent to the <jQuery.bbq.getState>
  // method.
  // 
  // > $(window).bind( 'hashchange', function( event ) {
  // >   var hash_str = event.fragment,
  // >     param_obj = event.getState(),
  // >     param_val = event.getState( 'param_name' ),
  // >     param_val_coerced = event.getState( 'param_name', true );
  // >   ...
  // > });
  // 
  // Usage in jQuery 1.3.2:
  // 
  // In jQuery 1.3.2, the event object cannot to be augmented as in jQuery 1.4+,
  // so the fragment state isn't bound to the event object and must instead be
  // parsed using the <jQuery.param.fragment> and <jQuery.bbq.getState> methods.
  // 
  // > $(window).bind( 'hashchange', function( event ) {
  // >   var hash_str = $.param.fragment(),
  // >     param_obj = $.bbq.getState(),
  // >     param_val = $.bbq.getState( 'param_name' ),
  // >     param_val_coerced = $.bbq.getState( 'param_name', true );
  // >   ...
  // > });
  // 
  // Additional Notes:
  // 
  // * Due to changes in the special events API, jQuery BBQ v1.2 or newer is
  //   required to enable the augmented event object in jQuery 1.4.2 and newer.
  // * See <jQuery hashchange event> for more detailed information.
  
  jq_event_special[ str_hashchange ] = $.extend( jq_event_special[ str_hashchange ], {
    
    // Augmenting the event object with the .fragment property and .getState
    // method requires jQuery 1.4 or newer. Note: with 1.3.2, everything will
    // work, but the event won't be augmented)
    add: function( handleObj ) {
      var old_handler;
      
      function new_handler(e) {
        // e.fragment is set to the value of location.hash (with any leading #
        // removed) at the time the event is triggered.
        var hash = e[ str_fragment ] = jq_param_fragment();
        
        // e.getState() works just like $.bbq.getState(), but uses the
        // e.fragment property stored on the event object.
        e.getState = function( key, coerce ) {
          return key === undefined || typeof key === 'boolean'
            ? jq_deparam( hash, key ) // 'key' really means 'coerce' here
            : jq_deparam( hash, coerce )[ key ];
        };
        
        old_handler.apply( this, arguments );
      };
      
      // This may seem a little complicated, but it normalizes the special event
      // .add method between jQuery 1.4/1.4.1 and 1.4.2+
      if ( $.isFunction( handleObj ) ) {
        // 1.4, 1.4.1
        old_handler = handleObj;
        return new_handler;
      } else {
        // 1.4.2+
        old_handler = handleObj.handler;
        handleObj.handler = new_handler;
      }
    }
    
  });
  
})(jQuery,this);

/*!
 * jQuery hashchange event - v1.2 - 2/11/2010
 * http://benalman.com/projects/jquery-hashchange-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery hashchange event
//
// *Version: 1.2, Last updated: 2/11/2010*
// 
// Project Home - http://benalman.com/projects/jquery-hashchange-plugin/
// GitHub       - http://github.com/cowboy/jquery-hashchange/
// Source       - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.js
// (Minified)   - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.min.js (1.1kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// This working example, complete with fully commented code, illustrate one way
// in which this plugin can be used.
// 
// hashchange event - http://benalman.com/code/projects/jquery-hashchange/examples/hashchange/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.7, Safari 3-4, Chrome, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-hashchange/unit/
// 
// About: Known issues
// 
// While this jQuery hashchange event implementation is quite stable and robust,
// there are a few unfortunate browser bugs surrounding expected hashchange
// event-based behaviors, independent of any JavaScript window.onhashchange
// abstraction. See the following examples for more information:
// 
// Chrome: Back Button - http://benalman.com/code/projects/jquery-hashchange/examples/bug-chrome-back-button/
// Firefox: Remote XMLHttpRequest - http://benalman.com/code/projects/jquery-hashchange/examples/bug-firefox-remote-xhr/
// WebKit: Back Button in an Iframe - http://benalman.com/code/projects/jquery-hashchange/examples/bug-webkit-hash-iframe/
// Safari: Back Button from a different domain - http://benalman.com/code/projects/jquery-hashchange/examples/bug-safari-back-from-diff-domain/
// 
// About: Release History
// 
// 1.2   - (2/11/2010) Fixed a bug where coming back to a page using this plugin
//         from a page on another domain would cause an error in Safari 4. Also,
//         IE6/7 Iframe is now inserted after the body (this actually works),
//         which prevents the page from scrolling when the event is first bound.
//         Event can also now be bound before DOM ready, but it won't be usable
//         before then in IE6/7.
// 1.1   - (1/21/2010) Incorporated document.documentMode test to fix IE8 bug
//         where browser version is incorrectly reported as 8.0, despite
//         inclusion of the X-UA-Compatible IE=EmulateIE7 meta tag.
// 1.0   - (1/9/2010) Initial Release. Broke out the jQuery BBQ event.special
//         window.onhashchange functionality into a separate plugin for users
//         who want just the basic event & back button support, without all the
//         extra awesomeness that BBQ provides. This plugin will be included as
//         part of jQuery BBQ, but also be available separately.

(function($,window,undefined){
  '$:nomunge'; // Used by YUI compressor.
  
  // Method / object references.
  var fake_onhashchange,
    jq_event_special = $.event.special,
    
    // Reused strings.
    str_location = 'location',
    str_hashchange = 'hashchange',
    str_href = 'href',
    
    // IE6/7 specifically need some special love when it comes to back-button
    // support, so let's do a little browser sniffing..
    browser = $.browser,
    mode = document.documentMode,
    is_old_ie = browser.msie && ( mode === undefined || mode < 8 ),
    
    // Does the browser support window.onhashchange? Test for IE version, since
    // IE8 incorrectly reports this when in "IE7" or "IE8 Compatibility View"!
    supports_onhashchange = 'on' + str_hashchange in window && !is_old_ie;
  
  // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!
  function get_fragment( url ) {
    url = url || window[ str_location ][ str_href ];
    return url.replace( /^[^#]*#?(.*)$/, '$1' );
  };
  
  // Property: jQuery.hashchangeDelay
  // 
  // The numeric interval (in milliseconds) at which the <hashchange event>
  // polling loop executes. Defaults to 100.
  
  $[ str_hashchange + 'Delay' ] = 100;
  
  // Event: hashchange event
  // 
  // Fired when location.hash changes. In browsers that support it, the native
  // window.onhashchange event is used (IE8, FF3.6), otherwise a polling loop is
  // initialized, running every <jQuery.hashchangeDelay> milliseconds to see if
  // the hash has changed. In IE 6 and 7, a hidden Iframe is created to allow
  // the back button and hash-based history to work.
  // 
  // Usage:
  // 
  // > $(window).bind( 'hashchange', function(e) {
  // >   var hash = location.hash;
  // >   ...
  // > });
  // 
  // Additional Notes:
  // 
  // * The polling loop and Iframe are not created until at least one callback
  //   is actually bound to 'hashchange'.
  // * If you need the bound callback(s) to execute immediately, in cases where
  //   the page 'state' exists on page load (via bookmark or page refresh, for
  //   example) use $(window).trigger( 'hashchange' );
  // * The event can be bound before DOM ready, but since it won't be usable
  //   before then in IE6/7 (due to the necessary Iframe), recommended usage is
  //   to bind it inside a $(document).ready() callback.
  
  jq_event_special[ str_hashchange ] = $.extend( jq_event_special[ str_hashchange ], {
    
    // Called only when the first 'hashchange' event is bound to window.
    setup: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to create our own. And we don't want to call this
      // until the user binds to the event, just in case they never do, since it
      // will create a polling loop and possibly even a hidden Iframe.
      $( fake_onhashchange.start );
    },
    
    // Called only when the last 'hashchange' event is unbound from window.
    teardown: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to stop ours (if possible).
      $( fake_onhashchange.stop );
    }
    
  });
  
  // fake_onhashchange does all the work of triggering the window.onhashchange
  // event for browsers that don't natively support it, including creating a
  // polling loop to watch for hash changes and in IE 6/7 creating a hidden
  // Iframe to enable back and forward.
  fake_onhashchange = (function(){
    var self = {},
      timeout_id,
      iframe,
      set_history,
      get_history;
    
    // Initialize. In IE 6/7, creates a hidden Iframe for history handling.
    function init(){
      // Most browsers don't need special methods here..
      set_history = get_history = function(val){ return val; };
      
      // But IE6/7 do!
      if ( is_old_ie ) {
        
        // Create hidden Iframe after the end of the body to prevent initial
        // page load from scrolling unnecessarily.
        iframe = $('<iframe src="javascript:0"/>').hide().insertAfter( 'body' )[0].contentWindow;
        
        // Get history by looking at the hidden Iframe's location.hash.
        get_history = function() {
          return get_fragment( iframe.document[ str_location ][ str_href ] );
        };
        
        // Set a new history item by opening and then closing the Iframe
        // document, *then* setting its location.hash.
        set_history = function( hash, history_hash ) {
          if ( hash !== history_hash ) {
            var doc = iframe.document;
            doc.open().close();
            doc[ str_location ].hash = '#' + hash;
          }
        };
        
        // Set initial history.
        set_history( get_fragment() );
      }
    };
    
    // Start the polling loop.
    self.start = function() {
      // Polling loop is already running!
      if ( timeout_id ) { return; }
      
      // Remember the initial hash so it doesn't get triggered immediately.
      var last_hash = get_fragment();
      
      // Initialize if not yet initialized.
      set_history || init();
      
      // This polling loop checks every $.hashchangeDelay milliseconds to see if
      // location.hash has changed, and triggers the 'hashchange' event on
      // window when necessary.
      (function loopy(){
        var hash = get_fragment(),
          history_hash = get_history( last_hash );
        
        if ( hash !== last_hash ) {
          set_history( last_hash = hash, history_hash );
          
          $(window).trigger( str_hashchange );
          
        } else if ( history_hash !== last_hash ) {
          window[ str_location ][ str_href ] = window[ str_location ][ str_href ].replace( /#.*/, '' ) + '#' + history_hash;
        }
        
        timeout_id = setTimeout( loopy, $[ str_hashchange + 'Delay' ] );
      })();
    };
    
    // Stop the polling loop, but only if an IE6/7 Iframe wasn't created. In
    // that case, even if there are no longer any bound event handlers, the
    // polling loop is still necessary for back/next to work at all!
    self.stop = function() {
      if ( !iframe ) {
        timeout_id && clearTimeout( timeout_id );
        timeout_id = 0;
      }
    };
    
    return self;
  })();
  
})(jQuery,this);


/*!
 * typeahead.js 0.10.5
 * https://github.com/twitter/typeahead.js
 * Copyright 2013-2014 Twitter, Inc. and other contributors; Licensed MIT
 */

(function($) {
    var _ = function() {
        "use strict";
        return {
            isMsie: function() {
                return /(msie|trident)/i.test(navigator.userAgent) ? navigator.userAgent.match(/(msie |rv:)(\d+(.\d+)?)/i)[2] : false;
            },
            isBlankString: function(str) {
                return !str || /^\s*$/.test(str);
            },
            escapeRegExChars: function(str) {
                return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
            },
            isString: function(obj) {
                return typeof obj === "string";
            },
            isNumber: function(obj) {
                return typeof obj === "number";
            },
            isArray: $.isArray,
            isFunction: $.isFunction,
            isObject: $.isPlainObject,
            isUndefined: function(obj) {
                return typeof obj === "undefined";
            },
            toStr: function toStr(s) {
                return _.isUndefined(s) || s === null ? "" : s + "";
            },
            bind: $.proxy,
            each: function(collection, cb) {
                $.each(collection, reverseArgs);
                function reverseArgs(index, value) {
                    return cb(value, index);
                }
            },
            map: $.map,
            filter: $.grep,
            every: function(obj, test) {
                var result = true;
                if (!obj) {
                    return result;
                }
                $.each(obj, function(key, val) {
                    if (!(result = test.call(null, val, key, obj))) {
                        return false;
                    }
                });
                return !!result;
            },
            some: function(obj, test) {
                var result = false;
                if (!obj) {
                    return result;
                }
                $.each(obj, function(key, val) {
                    if (result = test.call(null, val, key, obj)) {
                        return false;
                    }
                });
                return !!result;
            },
            mixin: $.extend,
            getUniqueId: function() {
                var counter = 0;
                return function() {
                    return counter++;
                };
            }(),
            templatify: function templatify(obj) {
                return $.isFunction(obj) ? obj : template;
                function template() {
                    return String(obj);
                }
            },
            defer: function(fn) {
                setTimeout(fn, 0);
            },
            debounce: function(func, wait, immediate) {
                var timeout, result;
                return function() {
                    var context = this, args = arguments, later, callNow;
                    later = function() {
                        timeout = null;
                        if (!immediate) {
                            result = func.apply(context, args);
                        }
                    };
                    callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                    if (callNow) {
                        result = func.apply(context, args);
                    }
                    return result;
                };
            },
            throttle: function(func, wait) {
                var context, args, timeout, result, previous, later;
                previous = 0;
                later = function() {
                    previous = new Date();
                    timeout = null;
                    result = func.apply(context, args);
                };
                return function() {
                    var now = new Date(), remaining = wait - (now - previous);
                    context = this;
                    args = arguments;
                    if (remaining <= 0) {
                        clearTimeout(timeout);
                        timeout = null;
                        previous = now;
                        result = func.apply(context, args);
                    } else if (!timeout) {
                        timeout = setTimeout(later, remaining);
                    }
                    return result;
                };
            },
            noop: function() {}
        };
    }();
    var VERSION = "0.10.5";
    var tokenizers = function() {
        "use strict";
        return {
            nonword: nonword,
            whitespace: whitespace,
            obj: {
                nonword: getObjTokenizer(nonword),
                whitespace: getObjTokenizer(whitespace)
            }
        };
        function whitespace(str) {
            str = _.toStr(str);
            return str ? str.split(/\s+/) : [];
        }
        function nonword(str) {
            str = _.toStr(str);
            return str ? str.split(/\W+/) : [];
        }
        function getObjTokenizer(tokenizer) {
            return function setKey() {
                var args = [].slice.call(arguments, 0);
                return function tokenize(o) {
                    var tokens = [];
                    _.each(args, function(k) {
                        tokens = tokens.concat(tokenizer(_.toStr(o[k])));
                    });
                    return tokens;
                };
            };
        }
    }();
    var LruCache = function() {
        "use strict";
        function LruCache(maxSize) {
            this.maxSize = _.isNumber(maxSize) ? maxSize : 100;
            this.reset();
            if (this.maxSize <= 0) {
                this.set = this.get = $.noop;
            }
        }
        _.mixin(LruCache.prototype, {
            set: function set(key, val) {
                var tailItem = this.list.tail, node;
                if (this.size >= this.maxSize) {
                    this.list.remove(tailItem);
                    delete this.hash[tailItem.key];
                }
                if (node = this.hash[key]) {
                    node.val = val;
                    this.list.moveToFront(node);
                } else {
                    node = new Node(key, val);
                    this.list.add(node);
                    this.hash[key] = node;
                    this.size++;
                }
            },
            get: function get(key) {
                var node = this.hash[key];
                if (node) {
                    this.list.moveToFront(node);
                    return node.val;
                }
            },
            reset: function reset() {
                this.size = 0;
                this.hash = {};
                this.list = new List();
            }
        });
        function List() {
            this.head = this.tail = null;
        }
        _.mixin(List.prototype, {
            add: function add(node) {
                if (this.head) {
                    node.next = this.head;
                    this.head.prev = node;
                }
                this.head = node;
                this.tail = this.tail || node;
            },
            remove: function remove(node) {
                node.prev ? node.prev.next = node.next : this.head = node.next;
                node.next ? node.next.prev = node.prev : this.tail = node.prev;
            },
            moveToFront: function(node) {
                this.remove(node);
                this.add(node);
            }
        });
        function Node(key, val) {
            this.key = key;
            this.val = val;
            this.prev = this.next = null;
        }
        return LruCache;
    }();
    var PersistentStorage = function() {
        "use strict";
        var ls, methods;
        try {
            ls = window.localStorage;
            ls.setItem("~~~", "!");
            ls.removeItem("~~~");
        } catch (err) {
            ls = null;
        }
        function PersistentStorage(namespace) {
            this.prefix = [ "__", namespace, "__" ].join("");
            this.ttlKey = "__ttl__";
            this.keyMatcher = new RegExp("^" + _.escapeRegExChars(this.prefix));
        }
        if (ls && window.JSON) {
            methods = {
                _prefix: function(key) {
                    return this.prefix + key;
                },
                _ttlKey: function(key) {
                    return this._prefix(key) + this.ttlKey;
                },
                get: function(key) {
                    if (this.isExpired(key)) {
                        this.remove(key);
                    }
                    return decode(ls.getItem(this._prefix(key)));
                },
                set: function(key, val, ttl) {
                    if (_.isNumber(ttl)) {
                        ls.setItem(this._ttlKey(key), encode(now() + ttl));
                    } else {
                        ls.removeItem(this._ttlKey(key));
                    }
                    return ls.setItem(this._prefix(key), encode(val));
                },
                remove: function(key) {
                    ls.removeItem(this._ttlKey(key));
                    ls.removeItem(this._prefix(key));
                    return this;
                },
                clear: function() {
                    var i, key, keys = [], len = ls.length;
                    for (i = 0; i < len; i++) {
                        if ((key = ls.key(i)).match(this.keyMatcher)) {
                            keys.push(key.replace(this.keyMatcher, ""));
                        }
                    }
                    for (i = keys.length; i--; ) {
                        this.remove(keys[i]);
                    }
                    return this;
                },
                isExpired: function(key) {
                    var ttl = decode(ls.getItem(this._ttlKey(key)));
                    return _.isNumber(ttl) && now() > ttl ? true : false;
                }
            };
        } else {
            methods = {
                get: _.noop,
                set: _.noop,
                remove: _.noop,
                clear: _.noop,
                isExpired: _.noop
            };
        }
        _.mixin(PersistentStorage.prototype, methods);
        return PersistentStorage;
        function now() {
            return new Date().getTime();
        }
        function encode(val) {
            return JSON.stringify(_.isUndefined(val) ? null : val);
        }
        function decode(val) {
            return JSON.parse(val);
        }
    }();
    var Transport = function() {
        "use strict";
        var pendingRequestsCount = 0, pendingRequests = {}, maxPendingRequests = 6, sharedCache = new LruCache(10);
        function Transport(o) {
            o = o || {};
            this.cancelled = false;
            this.lastUrl = null;
            this._send = o.transport ? callbackToDeferred(o.transport) : $.ajax;
            this._get = o.rateLimiter ? o.rateLimiter(this._get) : this._get;
            this._cache = o.cache === false ? new LruCache(0) : sharedCache;
        }
        Transport.setMaxPendingRequests = function setMaxPendingRequests(num) {
            maxPendingRequests = num;
        };
        Transport.resetCache = function resetCache() {
            sharedCache.reset();
        };
        _.mixin(Transport.prototype, {
            _get: function(url, o, cb) {
                var that = this, jqXhr;
                if (this.cancelled || url !== this.lastUrl) {
                    return;
                }
                if (jqXhr = pendingRequests[url]) {
                    jqXhr.done(done).fail(fail);
                } else if (pendingRequestsCount < maxPendingRequests) {
                    pendingRequestsCount++;
                    pendingRequests[url] = this._send(url, o).done(done).fail(fail).always(always);
                } else {
                    this.onDeckRequestArgs = [].slice.call(arguments, 0);
                }
                function done(resp) {
                    cb && cb(null, resp);
                    that._cache.set(url, resp);
                }
                function fail() {
                    cb && cb(true);
                }
                function always() {
                    pendingRequestsCount--;
                    delete pendingRequests[url];
                    if (that.onDeckRequestArgs) {
                        that._get.apply(that, that.onDeckRequestArgs);
                        that.onDeckRequestArgs = null;
                    }
                }
            },
            get: function(url, o, cb) {
                var resp;
                if (_.isFunction(o)) {
                    cb = o;
                    o = {};
                }
                this.cancelled = false;
                this.lastUrl = url;
                if (resp = this._cache.get(url)) {
                    _.defer(function() {
                        cb && cb(null, resp);
                    });
                } else {
                    this._get(url, o, cb);
                }
                return !!resp;
            },
            cancel: function() {
                this.cancelled = true;
            }
        });
        return Transport;
        function callbackToDeferred(fn) {
            return function customSendWrapper(url, o) {
                var deferred = $.Deferred();
                fn(url, o, onSuccess, onError);
                return deferred;
                function onSuccess(resp) {
                    _.defer(function() {
                        deferred.resolve(resp);
                    });
                }
                function onError(err) {
                    _.defer(function() {
                        deferred.reject(err);
                    });
                }
            };
        }
    }();
    var SearchIndex = function() {
        "use strict";
        function SearchIndex(o) {
            o = o || {};
            if (!o.datumTokenizer || !o.queryTokenizer) {
                $.error("datumTokenizer and queryTokenizer are both required");
            }
            this.datumTokenizer = o.datumTokenizer;
            this.queryTokenizer = o.queryTokenizer;
            this.reset();
        }
        _.mixin(SearchIndex.prototype, {
            bootstrap: function bootstrap(o) {
                this.datums = o.datums;
                this.trie = o.trie;
            },
            add: function(data) {
                var that = this;
                data = _.isArray(data) ? data : [ data ];
                _.each(data, function(datum) {
                    var id, tokens;
                    id = that.datums.push(datum) - 1;
                    tokens = normalizeTokens(that.datumTokenizer(datum));
                    _.each(tokens, function(token) {
                        var node, chars, ch;
                        node = that.trie;
                        chars = token.split("");
                        while (ch = chars.shift()) {
                            node = node.children[ch] || (node.children[ch] = newNode());
                            node.ids.push(id);
                        }
                    });
                });
            },
            get: function get(query) {
                var that = this, tokens, matches;
                tokens = normalizeTokens(this.queryTokenizer(query));
                _.each(tokens, function(token) {
                    var node, chars, ch, ids;
                    if (matches && matches.length === 0) {
                        return false;
                    }
                    node = that.trie;
                    chars = token.split("");
                    while (node && (ch = chars.shift())) {
                        node = node.children[ch];
                    }
                    if (node && chars.length === 0) {
                        ids = node.ids.slice(0);
                        matches = matches ? getIntersection(matches, ids) : ids;
                    } else {
                        matches = [];
                        return false;
                    }
                });
                return matches ? _.map(unique(matches), function(id) {
                    return that.datums[id];
                }) : [];
            },
            reset: function reset() {
                this.datums = [];
                this.trie = newNode();
            },
            serialize: function serialize() {
                return {
                    datums: this.datums,
                    trie: this.trie
                };
            }
        });
        return SearchIndex;
        function normalizeTokens(tokens) {
            tokens = _.filter(tokens, function(token) {
                return !!token;
            });
            tokens = _.map(tokens, function(token) {
                return token.toLowerCase();
            });
            return tokens;
        }
        function newNode() {
            return {
                ids: [],
                children: {}
            };
        }
        function unique(array) {
            var seen = {}, uniques = [];
            for (var i = 0, len = array.length; i < len; i++) {
                if (!seen[array[i]]) {
                    seen[array[i]] = true;
                    uniques.push(array[i]);
                }
            }
            return uniques;
        }
        function getIntersection(arrayA, arrayB) {
            var ai = 0, bi = 0, intersection = [];
            arrayA = arrayA.sort(compare);
            arrayB = arrayB.sort(compare);
            var lenArrayA = arrayA.length, lenArrayB = arrayB.length;
            while (ai < lenArrayA && bi < lenArrayB) {
                if (arrayA[ai] < arrayB[bi]) {
                    ai++;
                } else if (arrayA[ai] > arrayB[bi]) {
                    bi++;
                } else {
                    intersection.push(arrayA[ai]);
                    ai++;
                    bi++;
                }
            }
            return intersection;
            function compare(a, b) {
                return a - b;
            }
        }
    }();
    var oParser = function() {
        "use strict";
        return {
            local: getLocal,
            prefetch: getPrefetch,
            remote: getRemote
        };
        function getLocal(o) {
            return o.local || null;
        }
        function getPrefetch(o) {
            var prefetch, defaults;
            defaults = {
                url: null,
                thumbprint: "",
                ttl: 24 * 60 * 60 * 1e3,
                filter: null,
                ajax: {}
            };
            if (prefetch = o.prefetch || null) {
                prefetch = _.isString(prefetch) ? {
                    url: prefetch
                } : prefetch;
                prefetch = _.mixin(defaults, prefetch);
                prefetch.thumbprint = VERSION + prefetch.thumbprint;
                prefetch.ajax.type = prefetch.ajax.type || "GET";
                prefetch.ajax.dataType = prefetch.ajax.dataType || "json";
                !prefetch.url && $.error("prefetch requires url to be set");
            }
            return prefetch;
        }
        function getRemote(o) {
            var remote, defaults;
            defaults = {
                url: null,
                cache: true,
                wildcard: "%QUERY",
                replace: null,
                rateLimitBy: "debounce",
                rateLimitWait: 300,
                send: null,
                filter: null,
                ajax: {}
            };
            if (remote = o.remote || null) {
                remote = _.isString(remote) ? {
                    url: remote
                } : remote;
                remote = _.mixin(defaults, remote);
                remote.rateLimiter = /^throttle$/i.test(remote.rateLimitBy) ? byThrottle(remote.rateLimitWait) : byDebounce(remote.rateLimitWait);
                remote.ajax.type = remote.ajax.type || "GET";
                remote.ajax.dataType = remote.ajax.dataType || "json";
                delete remote.rateLimitBy;
                delete remote.rateLimitWait;
                !remote.url && $.error("remote requires url to be set");
            }
            return remote;
            function byDebounce(wait) {
                return function(fn) {
                    return _.debounce(fn, wait);
                };
            }
            function byThrottle(wait) {
                return function(fn) {
                    return _.throttle(fn, wait);
                };
            }
        }
    }();
    (function(root) {
        "use strict";
        var old, keys;
        old = root.Bloodhound;
        keys = {
            data: "data",
            protocol: "protocol",
            thumbprint: "thumbprint"
        };
        root.Bloodhound = Bloodhound;
        function Bloodhound(o) {
            if (!o || !o.local && !o.prefetch && !o.remote) {
                $.error("one of local, prefetch, or remote is required");
            }
            this.limit = o.limit || 5;
            this.sorter = getSorter(o.sorter);
            this.dupDetector = o.dupDetector || ignoreDuplicates;
            this.local = oParser.local(o);
            this.prefetch = oParser.prefetch(o);
            this.remote = oParser.remote(o);
            this.cacheKey = this.prefetch ? this.prefetch.cacheKey || this.prefetch.url : null;
            this.index = new SearchIndex({
                datumTokenizer: o.datumTokenizer,
                queryTokenizer: o.queryTokenizer
            });
            this.storage = this.cacheKey ? new PersistentStorage(this.cacheKey) : null;
        }
        Bloodhound.noConflict = function noConflict() {
            root.Bloodhound = old;
            return Bloodhound;
        };
        Bloodhound.tokenizers = tokenizers;
        _.mixin(Bloodhound.prototype, {
            _loadPrefetch: function loadPrefetch(o) {
                var that = this, serialized, deferred;
                if (serialized = this._readFromStorage(o.thumbprint)) {
                    this.index.bootstrap(serialized);
                    deferred = $.Deferred().resolve();
                } else {
                    deferred = $.ajax(o.url, o.ajax).done(handlePrefetchResponse);
                }
                return deferred;
                function handlePrefetchResponse(resp) {
                    that.clear();
                    that.add(o.filter ? o.filter(resp) : resp);
                    that._saveToStorage(that.index.serialize(), o.thumbprint, o.ttl);
                }
            },
            _getFromRemote: function getFromRemote(query, cb) {
                var that = this, url, uriEncodedQuery;
                if (!this.transport) {
                    return;
                }
                query = query || "";
                uriEncodedQuery = encodeURIComponent(query);
                url = this.remote.replace ? this.remote.replace(this.remote.url, query) : this.remote.url.replace(this.remote.wildcard, uriEncodedQuery);
                return this.transport.get(url, this.remote.ajax, handleRemoteResponse);
                function handleRemoteResponse(err, resp) {
                    err ? cb([]) : cb(that.remote.filter ? that.remote.filter(resp) : resp);
                }
            },
            _cancelLastRemoteRequest: function cancelLastRemoteRequest() {
                this.transport && this.transport.cancel();
            },
            _saveToStorage: function saveToStorage(data, thumbprint, ttl) {
                if (this.storage) {
                    this.storage.set(keys.data, data, ttl);
                    this.storage.set(keys.protocol, location.protocol, ttl);
                    this.storage.set(keys.thumbprint, thumbprint, ttl);
                }
            },
            _readFromStorage: function readFromStorage(thumbprint) {
                var stored = {}, isExpired;
                if (this.storage) {
                    stored.data = this.storage.get(keys.data);
                    stored.protocol = this.storage.get(keys.protocol);
                    stored.thumbprint = this.storage.get(keys.thumbprint);
                }
                isExpired = stored.thumbprint !== thumbprint || stored.protocol !== location.protocol;
                return stored.data && !isExpired ? stored.data : null;
            },
            _initialize: function initialize() {
                var that = this, local = this.local, deferred;
                deferred = this.prefetch ? this._loadPrefetch(this.prefetch) : $.Deferred().resolve();
                local && deferred.done(addLocalToIndex);
                this.transport = this.remote ? new Transport(this.remote) : null;
                return this.initPromise = deferred.promise();
                function addLocalToIndex() {
                    that.add(_.isFunction(local) ? local() : local);
                }
            },
            initialize: function initialize(force) {
                return !this.initPromise || force ? this._initialize() : this.initPromise;
            },
            add: function add(data) {
                this.index.add(data);
            },
            get: function get(query, cb) {
                var that = this, matches = [], cacheHit = false;
                matches = this.index.get(query);
                matches = this.sorter(matches).slice(0, this.limit);
                matches.length < this.limit ? cacheHit = this._getFromRemote(query, returnRemoteMatches) : this._cancelLastRemoteRequest();
                if (!cacheHit) {
                    (matches.length > 0 || !this.transport) && cb && cb(matches);
                }
                function returnRemoteMatches(remoteMatches) {
                    var matchesWithBackfill = matches.slice(0);
                    _.each(remoteMatches, function(remoteMatch) {
                        var isDuplicate;
                        isDuplicate = _.some(matchesWithBackfill, function(match) {
                            return that.dupDetector(remoteMatch, match);
                        });
                        !isDuplicate && matchesWithBackfill.push(remoteMatch);
                        return matchesWithBackfill.length < that.limit;
                    });
                    cb && cb(that.sorter(matchesWithBackfill));
                }
            },
            clear: function clear() {
                this.index.reset();
            },
            clearPrefetchCache: function clearPrefetchCache() {
                this.storage && this.storage.clear();
            },
            clearRemoteCache: function clearRemoteCache() {
                this.transport && Transport.resetCache();
            },
            ttAdapter: function ttAdapter() {
                return _.bind(this.get, this);
            }
        });
        return Bloodhound;
        function getSorter(sortFn) {
            return _.isFunction(sortFn) ? sort : noSort;
            function sort(array) {
                return array.sort(sortFn);
            }
            function noSort(array) {
                return array;
            }
        }
        function ignoreDuplicates() {
            return false;
        }
    })(this);
    var html = function() {
        return {
            wrapper: '<span class="twitter-typeahead"></span>',
            dropdown: '<span class="tt-dropdown-menu"></span>',
            dataset: '<div class="tt-dataset-%CLASS%"></div>',
            suggestions: '<span class="tt-suggestions"></span>',
            suggestion: '<div class="tt-suggestion"></div>'
        };
    }();
    var css = function() {
        "use strict";
        var css = {
            wrapper: {
                position: "relative",
                display: "inline-block"
            },
            hint: {
                position: "absolute",
                top: "0",
                left: "0",
                borderColor: "transparent",
                boxShadow: "none",
                opacity: "1"
            },
            input: {
                position: "relative",
                verticalAlign: "top",
                backgroundColor: "transparent"
            },
            inputWithNoHint: {
                position: "relative",
                verticalAlign: "top"
            },
            dropdown: {
                position: "absolute",
                top: "100%",
                left: "0",
                zIndex: "100",
                display: "none"
            },
            suggestions: {
                display: "block"
            },
            suggestion: {
                whiteSpace: "nowrap",
                cursor: "pointer"
            },
            suggestionChild: {
                whiteSpace: "normal"
            },
            ltr: {
                left: "0",
                right: "auto"
            },
            rtl: {
                left: "auto",
                right: " 0"
            }
        };
        if (_.isMsie()) {
            _.mixin(css.input, {
                backgroundImage: "url(data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7)"
            });
        }
        if (_.isMsie() && _.isMsie() <= 7) {
            _.mixin(css.input, {
                marginTop: "-1px"
            });
        }
        return css;
    }();
    var EventBus = function() {
        "use strict";
        var namespace = "typeahead:";
        function EventBus(o) {
            if (!o || !o.el) {
                $.error("EventBus initialized without el");
            }
            this.$el = $(o.el);
        }
        _.mixin(EventBus.prototype, {
            trigger: function(type) {
                var args = [].slice.call(arguments, 1);
                this.$el.trigger(namespace + type, args);
            }
        });
        return EventBus;
    }();
    var EventEmitter = function() {
        "use strict";
        var splitter = /\s+/, nextTick = getNextTick();
        return {
            onSync: onSync,
            onAsync: onAsync,
            off: off,
            trigger: trigger
        };
        function on(method, types, cb, context) {
            var type;
            if (!cb) {
                return this;
            }
            types = types.split(splitter);
            cb = context ? bindContext(cb, context) : cb;
            this._callbacks = this._callbacks || {};
            while (type = types.shift()) {
                this._callbacks[type] = this._callbacks[type] || {
                    sync: [],
                    async: []
                };
                this._callbacks[type][method].push(cb);
            }
            return this;
        }
        function onAsync(types, cb, context) {
            return on.call(this, "async", types, cb, context);
        }
        function onSync(types, cb, context) {
            return on.call(this, "sync", types, cb, context);
        }
        function off(types) {
            var type;
            if (!this._callbacks) {
                return this;
            }
            types = types.split(splitter);
            while (type = types.shift()) {
                delete this._callbacks[type];
            }
            return this;
        }
        function trigger(types) {
            var type, callbacks, args, syncFlush, asyncFlush;
            if (!this._callbacks) {
                return this;
            }
            types = types.split(splitter);
            args = [].slice.call(arguments, 1);
            while ((type = types.shift()) && (callbacks = this._callbacks[type])) {
                syncFlush = getFlush(callbacks.sync, this, [ type ].concat(args));
                asyncFlush = getFlush(callbacks.async, this, [ type ].concat(args));
                syncFlush() && nextTick(asyncFlush);
            }
            return this;
        }
        function getFlush(callbacks, context, args) {
            return flush;
            function flush() {
                var cancelled;
                for (var i = 0, len = callbacks.length; !cancelled && i < len; i += 1) {
                    cancelled = callbacks[i].apply(context, args) === false;
                }
                return !cancelled;
            }
        }
        function getNextTick() {
            var nextTickFn;
            if (window.setImmediate) {
                nextTickFn = function nextTickSetImmediate(fn) {
                    setImmediate(function() {
                        fn();
                    });
                };
            } else {
                nextTickFn = function nextTickSetTimeout(fn) {
                    setTimeout(function() {
                        fn();
                    }, 0);
                };
            }
            return nextTickFn;
        }
        function bindContext(fn, context) {
            return fn.bind ? fn.bind(context) : function() {
                fn.apply(context, [].slice.call(arguments, 0));
            };
        }
    }();
    var highlight = function(doc) {
        "use strict";
        var defaults = {
            node: null,
            pattern: null,
            tagName: "strong",
            className: null,
            wordsOnly: false,
            caseSensitive: false
        };
        return function hightlight(o) {
            var regex;
            o = _.mixin({}, defaults, o);
            if (!o.node || !o.pattern) {
                return;
            }
            o.pattern = _.isArray(o.pattern) ? o.pattern : [ o.pattern ];
            regex = getRegex(o.pattern, o.caseSensitive, o.wordsOnly);
            traverse(o.node, hightlightTextNode);
            function hightlightTextNode(textNode) {
                var match, patternNode, wrapperNode;
                if (match = regex.exec(textNode.data)) {
                    wrapperNode = doc.createElement(o.tagName);
                    o.className && (wrapperNode.className = o.className);
                    patternNode = textNode.splitText(match.index);
                    patternNode.splitText(match[0].length);
                    wrapperNode.appendChild(patternNode.cloneNode(true));
                    textNode.parentNode.replaceChild(wrapperNode, patternNode);
                }
                return !!match;
            }
            function traverse(el, hightlightTextNode) {
                var childNode, TEXT_NODE_TYPE = 3;
                for (var i = 0; i < el.childNodes.length; i++) {
                    childNode = el.childNodes[i];
                    if (childNode.nodeType === TEXT_NODE_TYPE) {
                        i += hightlightTextNode(childNode) ? 1 : 0;
                    } else {
                        traverse(childNode, hightlightTextNode);
                    }
                }
            }
        };
        function getRegex(patterns, caseSensitive, wordsOnly) {
            var escapedPatterns = [], regexStr;
            for (var i = 0, len = patterns.length; i < len; i++) {
                escapedPatterns.push(_.escapeRegExChars(patterns[i]));
            }
            regexStr = wordsOnly ? "\\b(" + escapedPatterns.join("|") + ")\\b" : "(" + escapedPatterns.join("|") + ")";
            return caseSensitive ? new RegExp(regexStr) : new RegExp(regexStr, "i");
        }
    }(window.document);
    var Input = function() {
        "use strict";
        var specialKeyCodeMap;
        specialKeyCodeMap = {
            9: "tab",
            27: "esc",
            37: "left",
            39: "right",
            13: "enter",
            38: "up",
            40: "down"
        };
        function Input(o) {
            var that = this, onBlur, onFocus, onKeydown, onInput;
            o = o || {};
            if (!o.input) {
                $.error("input is missing");
            }
            onBlur = _.bind(this._onBlur, this);
            onFocus = _.bind(this._onFocus, this);
            onKeydown = _.bind(this._onKeydown, this);
            onInput = _.bind(this._onInput, this);
            this.$hint = $(o.hint);
            this.$input = $(o.input).on("blur.tt", onBlur).on("focus.tt", onFocus).on("keydown.tt", onKeydown);
            if (this.$hint.length === 0) {
                this.setHint = this.getHint = this.clearHint = this.clearHintIfInvalid = _.noop;
            }
            if (!_.isMsie()) {
                this.$input.on("input.tt", onInput);
            } else {
                this.$input.on("keydown.tt keypress.tt cut.tt paste.tt", function($e) {
                    if (specialKeyCodeMap[$e.which || $e.keyCode]) {
                        return;
                    }
                    _.defer(_.bind(that._onInput, that, $e));
                });
            }
            this.query = this.$input.val();
            this.$overflowHelper = buildOverflowHelper(this.$input);
        }
        Input.normalizeQuery = function(str) {
            return (str || "").replace(/^\s*/g, "").replace(/\s{2,}/g, " ");
        };
        _.mixin(Input.prototype, EventEmitter, {
            _onBlur: function onBlur() {
                this.resetInputValue();
                this.trigger("blurred");
            },
            _onFocus: function onFocus() {
                this.trigger("focused");
            },
            _onKeydown: function onKeydown($e) {
                var keyName = specialKeyCodeMap[$e.which || $e.keyCode];
                this._managePreventDefault(keyName, $e);
                if (keyName && this._shouldTrigger(keyName, $e)) {
                    this.trigger(keyName + "Keyed", $e);
                }
            },
            _onInput: function onInput() {
                this._checkInputValue();
            },
            _managePreventDefault: function managePreventDefault(keyName, $e) {
                var preventDefault, hintValue, inputValue;
                switch (keyName) {
                  case "tab":
                    hintValue = this.getHint();
                    inputValue = this.getInputValue();
                    preventDefault = hintValue && hintValue !== inputValue && !withModifier($e);
                    break;

                  case "up":
                  case "down":
                    preventDefault = !withModifier($e);
                    break;

                  default:
                    preventDefault = false;
                }
                preventDefault && $e.preventDefault();
            },
            _shouldTrigger: function shouldTrigger(keyName, $e) {
                var trigger;
                switch (keyName) {
                  case "tab":
                    trigger = !withModifier($e);
                    break;

                  default:
                    trigger = true;
                }
                return trigger;
            },
            _checkInputValue: function checkInputValue() {
                var inputValue, areEquivalent, hasDifferentWhitespace;
                inputValue = this.getInputValue();
                areEquivalent = areQueriesEquivalent(inputValue, this.query);
                hasDifferentWhitespace = areEquivalent ? this.query.length !== inputValue.length : false;
                this.query = inputValue;
                if (!areEquivalent) {
                    this.trigger("queryChanged", this.query);
                } else if (hasDifferentWhitespace) {
                    this.trigger("whitespaceChanged", this.query);
                }
            },
            focus: function focus() {
                this.$input.focus();
            },
            blur: function blur() {
                this.$input.blur();
            },
            getQuery: function getQuery() {
                return this.query;
            },
            setQuery: function setQuery(query) {
                this.query = query;
            },
            getInputValue: function getInputValue() {
                return this.$input.val();
            },
            setInputValue: function setInputValue(value, silent) {
                this.$input.val(value);
                silent ? this.clearHint() : this._checkInputValue();
            },
            resetInputValue: function resetInputValue() {
                this.setInputValue(this.query, true);
            },
            getHint: function getHint() {
                return this.$hint.val();
            },
            setHint: function setHint(value) {
                this.$hint.val(value);
            },
            clearHint: function clearHint() {
                this.setHint("");
            },
            clearHintIfInvalid: function clearHintIfInvalid() {
                var val, hint, valIsPrefixOfHint, isValid;
                val = this.getInputValue();
                hint = this.getHint();
                valIsPrefixOfHint = val !== hint && hint.indexOf(val) === 0;
                isValid = val !== "" && valIsPrefixOfHint && !this.hasOverflow();
                !isValid && this.clearHint();
            },
            getLanguageDirection: function getLanguageDirection() {
                return (this.$input.css("direction") || "ltr").toLowerCase();
            },
            hasOverflow: function hasOverflow() {
                var constraint = this.$input.width() - 2;
                this.$overflowHelper.text(this.getInputValue());
                return this.$overflowHelper.width() >= constraint;
            },
            isCursorAtEnd: function() {
                var valueLength, selectionStart, range;
                valueLength = this.$input.val().length;
                selectionStart = this.$input[0].selectionStart;
                if (_.isNumber(selectionStart)) {
                    return selectionStart === valueLength;
                } else if (document.selection) {
                    range = document.selection.createRange();
                    range.moveStart("character", -valueLength);
                    return valueLength === range.text.length;
                }
                return true;
            },
            destroy: function destroy() {
                this.$hint.off(".tt");
                this.$input.off(".tt");
                this.$hint = this.$input = this.$overflowHelper = null;
            }
        });
        return Input;
        function buildOverflowHelper($input) {
            return $('<pre aria-hidden="true"></pre>').css({
                position: "absolute",
                visibility: "hidden",
                whiteSpace: "pre",
                fontFamily: $input.css("font-family"),
                fontSize: $input.css("font-size"),
                fontStyle: $input.css("font-style"),
                fontVariant: $input.css("font-variant"),
                fontWeight: $input.css("font-weight"),
                wordSpacing: $input.css("word-spacing"),
                letterSpacing: $input.css("letter-spacing"),
                textIndent: $input.css("text-indent"),
                textRendering: $input.css("text-rendering"),
                textTransform: $input.css("text-transform")
            }).insertAfter($input);
        }
        function areQueriesEquivalent(a, b) {
            return Input.normalizeQuery(a) === Input.normalizeQuery(b);
        }
        function withModifier($e) {
            return $e.altKey || $e.ctrlKey || $e.metaKey || $e.shiftKey;
        }
    }();
    var Dataset = function() {
        "use strict";
        var datasetKey = "ttDataset", valueKey = "ttValue", datumKey = "ttDatum";
        function Dataset(o) {
            o = o || {};
            o.templates = o.templates || {};
            if (!o.source) {
                $.error("missing source");
            }
            if (o.name && !isValidName(o.name)) {
                $.error("invalid dataset name: " + o.name);
            }
            this.query = null;
            this.highlight = !!o.highlight;
            this.name = o.name || _.getUniqueId();
            this.source = o.source;
            this.displayFn = getDisplayFn(o.display || o.displayKey);
            this.templates = getTemplates(o.templates, this.displayFn);
            this.$el = $(html.dataset.replace("%CLASS%", this.name));
        }
        Dataset.extractDatasetName = function extractDatasetName(el) {
            return $(el).data(datasetKey);
        };
        Dataset.extractValue = function extractDatum(el) {
            return $(el).data(valueKey);
        };
        Dataset.extractDatum = function extractDatum(el) {
            return $(el).data(datumKey);
        };
        _.mixin(Dataset.prototype, EventEmitter, {
            _render: function render(query, suggestions) {
                if (!this.$el) {
                    return;
                }
                var that = this, hasSuggestions;
                this.$el.empty();
                hasSuggestions = suggestions && suggestions.length;
                if (!hasSuggestions && this.templates.empty) {
                    this.$el.html(getEmptyHtml()).prepend(that.templates.header ? getHeaderHtml() : null).append(that.templates.footer ? getFooterHtml() : null);
                } else if (hasSuggestions) {
                    this.$el.html(getSuggestionsHtml()).prepend(that.templates.header ? getHeaderHtml() : null).append(that.templates.footer ? getFooterHtml() : null);
                }
                this.trigger("rendered");
                function getEmptyHtml() {
                    return that.templates.empty({
                        query: query,
                        isEmpty: true
                    });
                }
                function getSuggestionsHtml() {
                    var $suggestions, nodes;
                    $suggestions = $(html.suggestions).css(css.suggestions);
                    nodes = _.map(suggestions, getSuggestionNode);
                    $suggestions.append.apply($suggestions, nodes);
                    that.highlight && highlight({
                        className: "tt-highlight",
                        node: $suggestions[0],
                        pattern: query
                    });
                    return $suggestions;
                    function getSuggestionNode(suggestion) {
                        var $el;
                        $el = $(html.suggestion).append(that.templates.suggestion(suggestion)).data(datasetKey, that.name).data(valueKey, that.displayFn(suggestion)).data(datumKey, suggestion);
                        $el.children().each(function() {
                            $(this).css(css.suggestionChild);
                        });
                        return $el;
                    }
                }
                function getHeaderHtml() {
                    return that.templates.header({
                        query: query,
                        isEmpty: !hasSuggestions
                    });
                }
                function getFooterHtml() {
                    return that.templates.footer({
                        query: query,
                        isEmpty: !hasSuggestions
                    });
                }
            },
            getRoot: function getRoot() {
                return this.$el;
            },
            update: function update(query) {
                var that = this;
                this.query = query;
                this.canceled = false;
                this.source(query, render);
                function render(suggestions) {
                    if (!that.canceled && query === that.query) {
                        that._render(query, suggestions);
                    }
                }
            },
            cancel: function cancel() {
                this.canceled = true;
            },
            clear: function clear() {
                this.cancel();
                this.$el.empty();
                this.trigger("rendered");
            },
            isEmpty: function isEmpty() {
                return this.$el.is(":empty");
            },
            destroy: function destroy() {
                this.$el = null;
            }
        });
        return Dataset;
        function getDisplayFn(display) {
            display = display || "value";
            return _.isFunction(display) ? display : displayFn;
            function displayFn(obj) {
                return obj[display];
            }
        }
        function getTemplates(templates, displayFn) {
            return {
                empty: templates.empty && _.templatify(templates.empty),
                header: templates.header && _.templatify(templates.header),
                footer: templates.footer && _.templatify(templates.footer),
                suggestion: templates.suggestion || suggestionTemplate
            };
            function suggestionTemplate(context) {
                return "<p>" + displayFn(context) + "</p>";
            }
        }
        function isValidName(str) {
            return /^[_a-zA-Z0-9-]+$/.test(str);
        }
    }();
    var Dropdown = function() {
        "use strict";
        function Dropdown(o) {
            var that = this, onSuggestionClick, onSuggestionMouseEnter, onSuggestionMouseLeave;
            o = o || {};
            if (!o.menu) {
                $.error("menu is required");
            }
            this.isOpen = false;
            this.isEmpty = true;
            this.datasets = _.map(o.datasets, initializeDataset);
            onSuggestionClick = _.bind(this._onSuggestionClick, this);
            onSuggestionMouseEnter = _.bind(this._onSuggestionMouseEnter, this);
            onSuggestionMouseLeave = _.bind(this._onSuggestionMouseLeave, this);
            this.$menu = $(o.menu).on("click.tt", ".tt-suggestion", onSuggestionClick).on("mouseenter.tt", ".tt-suggestion", onSuggestionMouseEnter).on("mouseleave.tt", ".tt-suggestion", onSuggestionMouseLeave);
            _.each(this.datasets, function(dataset) {
                that.$menu.append(dataset.getRoot());
                dataset.onSync("rendered", that._onRendered, that);
            });
        }
        _.mixin(Dropdown.prototype, EventEmitter, {
            _onSuggestionClick: function onSuggestionClick($e) {
                this.trigger("suggestionClicked", $($e.currentTarget));
            },
            _onSuggestionMouseEnter: function onSuggestionMouseEnter($e) {
                this._removeCursor();
                this._setCursor($($e.currentTarget), true);
            },
            _onSuggestionMouseLeave: function onSuggestionMouseLeave() {
                this._removeCursor();
            },
            _onRendered: function onRendered() {
                this.isEmpty = _.every(this.datasets, isDatasetEmpty);
                this.isEmpty ? this._hide() : this.isOpen && this._show();
                this.trigger("datasetRendered");
                function isDatasetEmpty(dataset) {
                    return dataset.isEmpty();
                }
            },
            _hide: function() {
                this.$menu.hide();
            },
            _show: function() {
                this.$menu.css("display", "block");
            },
            _getSuggestions: function getSuggestions() {
                return this.$menu.find(".tt-suggestion");
            },
            _getCursor: function getCursor() {
                return this.$menu.find(".tt-cursor").first();
            },
            _setCursor: function setCursor($el, silent) {
                $el.first().addClass("tt-cursor");
                !silent && this.trigger("cursorMoved");
            },
            _removeCursor: function removeCursor() {
                this._getCursor().removeClass("tt-cursor");
            },
            _moveCursor: function moveCursor(increment) {
                var $suggestions, $oldCursor, newCursorIndex, $newCursor;
                if (!this.isOpen) {
                    return;
                }
                $oldCursor = this._getCursor();
                $suggestions = this._getSuggestions();
                this._removeCursor();
                newCursorIndex = $suggestions.index($oldCursor) + increment;
                newCursorIndex = (newCursorIndex + 1) % ($suggestions.length + 1) - 1;
                if (newCursorIndex === -1) {
                    this.trigger("cursorRemoved");
                    return;
                } else if (newCursorIndex < -1) {
                    newCursorIndex = $suggestions.length - 1;
                }
                this._setCursor($newCursor = $suggestions.eq(newCursorIndex));
                this._ensureVisible($newCursor);
            },
            _ensureVisible: function ensureVisible($el) {
                var elTop, elBottom, menuScrollTop, menuHeight;
                elTop = $el.position().top;
                elBottom = elTop + $el.outerHeight(true);
                menuScrollTop = this.$menu.scrollTop();
                menuHeight = this.$menu.height() + parseInt(this.$menu.css("paddingTop"), 10) + parseInt(this.$menu.css("paddingBottom"), 10);
                if (elTop < 0) {
                    this.$menu.scrollTop(menuScrollTop + elTop);
                } else if (menuHeight < elBottom) {
                    this.$menu.scrollTop(menuScrollTop + (elBottom - menuHeight));
                }
            },
            close: function close() {
                if (this.isOpen) {
                    this.isOpen = false;
                    this._removeCursor();
                    this._hide();
                    this.trigger("closed");
                }
            },
            open: function open() {
                if (!this.isOpen) {
                    this.isOpen = true;
                    !this.isEmpty && this._show();
                    this.trigger("opened");
                }
            },
            setLanguageDirection: function setLanguageDirection(dir) {
                this.$menu.css(dir === "ltr" ? css.ltr : css.rtl);
            },
            moveCursorUp: function moveCursorUp() {
                this._moveCursor(-1);
            },
            moveCursorDown: function moveCursorDown() {
                this._moveCursor(+1);
            },
            getDatumForSuggestion: function getDatumForSuggestion($el) {
                var datum = null;
                if ($el.length) {
                    datum = {
                        raw: Dataset.extractDatum($el),
                        value: Dataset.extractValue($el),
                        datasetName: Dataset.extractDatasetName($el)
                    };
                }
                return datum;
            },
            getDatumForCursor: function getDatumForCursor() {
                return this.getDatumForSuggestion(this._getCursor().first());
            },
            getDatumForTopSuggestion: function getDatumForTopSuggestion() {
                return this.getDatumForSuggestion(this._getSuggestions().first());
            },
            update: function update(query) {
                _.each(this.datasets, updateDataset);
                function updateDataset(dataset) {
                    dataset.update(query);
                }
            },
            empty: function empty() {
                _.each(this.datasets, clearDataset);
                this.isEmpty = true;
                function clearDataset(dataset) {
                    dataset.clear();
                }
            },
            isVisible: function isVisible() {
                return this.isOpen && !this.isEmpty;
            },
            destroy: function destroy() {
                this.$menu.off(".tt");
                this.$menu = null;
                _.each(this.datasets, destroyDataset);
                function destroyDataset(dataset) {
                    dataset.destroy();
                }
            }
        });
        return Dropdown;
        function initializeDataset(oDataset) {
            return new Dataset(oDataset);
        }
    }();
    var Typeahead = function() {
        "use strict";
        var attrsKey = "ttAttrs";
        function Typeahead(o) {
            var $menu, $input, $hint;
            o = o || {};
            if (!o.input) {
                $.error("missing input");
            }
            this.isActivated = false;
            this.autoselect = !!o.autoselect;
            this.minLength = _.isNumber(o.minLength) ? o.minLength : 1;
            this.$node = buildDom(o.input, o.withHint);
            $menu = this.$node.find(".tt-dropdown-menu");
            $input = this.$node.find(".tt-input");
            $hint = this.$node.find(".tt-hint");
            $input.on("blur.tt", function($e) {
                var active, isActive, hasActive;
                active = document.activeElement;
                isActive = $menu.is(active);
                hasActive = $menu.has(active).length > 0;
                if (_.isMsie() && (isActive || hasActive)) {
                    $e.preventDefault();
                    $e.stopImmediatePropagation();
                    _.defer(function() {
                        $input.focus();
                    });
                }
            });
            $menu.on("mousedown.tt", function($e) {
                $e.preventDefault();
            });
            this.eventBus = o.eventBus || new EventBus({
                el: $input
            });
            this.dropdown = new Dropdown({
                menu: $menu,
                datasets: o.datasets
            }).onSync("suggestionClicked", this._onSuggestionClicked, this).onSync("cursorMoved", this._onCursorMoved, this).onSync("cursorRemoved", this._onCursorRemoved, this).onSync("opened", this._onOpened, this).onSync("closed", this._onClosed, this).onAsync("datasetRendered", this._onDatasetRendered, this);
            this.input = new Input({
                input: $input,
                hint: $hint
            }).onSync("focused", this._onFocused, this).onSync("blurred", this._onBlurred, this).onSync("enterKeyed", this._onEnterKeyed, this).onSync("tabKeyed", this._onTabKeyed, this).onSync("escKeyed", this._onEscKeyed, this).onSync("upKeyed", this._onUpKeyed, this).onSync("downKeyed", this._onDownKeyed, this).onSync("leftKeyed", this._onLeftKeyed, this).onSync("rightKeyed", this._onRightKeyed, this).onSync("queryChanged", this._onQueryChanged, this).onSync("whitespaceChanged", this._onWhitespaceChanged, this);
            this._setLanguageDirection();
        }
        _.mixin(Typeahead.prototype, {
            _onSuggestionClicked: function onSuggestionClicked(type, $el) {
                var datum;
                if (datum = this.dropdown.getDatumForSuggestion($el)) {
                    this._select(datum);
                }
            },
            _onCursorMoved: function onCursorMoved() {
                var datum = this.dropdown.getDatumForCursor();
                this.input.setInputValue(datum.value, true);
                this.eventBus.trigger("cursorchanged", datum.raw, datum.datasetName);
            },
            _onCursorRemoved: function onCursorRemoved() {
                this.input.resetInputValue();
                this._updateHint();
            },
            _onDatasetRendered: function onDatasetRendered() {
                this._updateHint();
            },
            _onOpened: function onOpened() {
                this._updateHint();
                this.eventBus.trigger("opened");
            },
            _onClosed: function onClosed() {
                this.input.clearHint();
                this.eventBus.trigger("closed");
            },
            _onFocused: function onFocused() {
                this.isActivated = true;
                this.dropdown.open();
            },
            _onBlurred: function onBlurred() {
                this.isActivated = false;
                this.dropdown.empty();
                this.dropdown.close();
            },
            _onEnterKeyed: function onEnterKeyed(type, $e) {
                var cursorDatum, topSuggestionDatum;
                cursorDatum = this.dropdown.getDatumForCursor();
                topSuggestionDatum = this.dropdown.getDatumForTopSuggestion();
                if (cursorDatum) {
                    this._select(cursorDatum);
                    $e.preventDefault();
                } else if (this.autoselect && topSuggestionDatum) {
                    this._select(topSuggestionDatum);
                    $e.preventDefault();
                }
            },
            _onTabKeyed: function onTabKeyed(type, $e) {
                var datum;
                if (datum = this.dropdown.getDatumForCursor()) {
                    this._select(datum);
                    $e.preventDefault();
                } else {
                    this._autocomplete(true);
                }
            },
            _onEscKeyed: function onEscKeyed() {
                this.dropdown.close();
                this.input.resetInputValue();
            },
            _onUpKeyed: function onUpKeyed() {
                var query = this.input.getQuery();
                this.dropdown.isEmpty && query.length >= this.minLength ? this.dropdown.update(query) : this.dropdown.moveCursorUp();
                this.dropdown.open();
            },
            _onDownKeyed: function onDownKeyed() {
                var query = this.input.getQuery();
                this.dropdown.isEmpty && query.length >= this.minLength ? this.dropdown.update(query) : this.dropdown.moveCursorDown();
                this.dropdown.open();
            },
            _onLeftKeyed: function onLeftKeyed() {
                this.dir === "rtl" && this._autocomplete();
            },
            _onRightKeyed: function onRightKeyed() {
                this.dir === "ltr" && this._autocomplete();
            },
            _onQueryChanged: function onQueryChanged(e, query) {
                this.input.clearHintIfInvalid();
                query.length >= this.minLength ? this.dropdown.update(query) : this.dropdown.empty();
                this.dropdown.open();
                this._setLanguageDirection();
            },
            _onWhitespaceChanged: function onWhitespaceChanged() {
                this._updateHint();
                this.dropdown.open();
            },
            _setLanguageDirection: function setLanguageDirection() {
                var dir;
                if (this.dir !== (dir = this.input.getLanguageDirection())) {
                    this.dir = dir;
                    this.$node.css("direction", dir);
                    this.dropdown.setLanguageDirection(dir);
                }
            },
            _updateHint: function updateHint() {
                var datum, val, query, escapedQuery, frontMatchRegEx, match;
                datum = this.dropdown.getDatumForTopSuggestion();
                if (datum && this.dropdown.isVisible() && !this.input.hasOverflow()) {
                    val = this.input.getInputValue();
                    query = Input.normalizeQuery(val);
                    escapedQuery = _.escapeRegExChars(query);
                    frontMatchRegEx = new RegExp("^(?:" + escapedQuery + ")(.+$)", "i");
                    match = frontMatchRegEx.exec(datum.value);
                    match ? this.input.setHint(val + match[1]) : this.input.clearHint();
                } else {
                    this.input.clearHint();
                }
            },
            _autocomplete: function autocomplete(laxCursor) {
                var hint, query, isCursorAtEnd, datum;
                hint = this.input.getHint();
                query = this.input.getQuery();
                isCursorAtEnd = laxCursor || this.input.isCursorAtEnd();
                if (hint && query !== hint && isCursorAtEnd) {
                    datum = this.dropdown.getDatumForTopSuggestion();
                    datum && this.input.setInputValue(datum.value);
                    this.eventBus.trigger("autocompleted", datum.raw, datum.datasetName);
                }
            },
            _select: function select(datum) {
                this.input.setQuery(datum.value);
                this.input.setInputValue(datum.value, true);
                this._setLanguageDirection();
                this.eventBus.trigger("selected", datum.raw, datum.datasetName);
                this.dropdown.close();
                _.defer(_.bind(this.dropdown.empty, this.dropdown));
            },
            open: function open() {
                this.dropdown.open();
            },
            close: function close() {
                this.dropdown.close();
            },
            setVal: function setVal(val) {
                val = _.toStr(val);
                if (this.isActivated) {
                    this.input.setInputValue(val);
                } else {
                    this.input.setQuery(val);
                    this.input.setInputValue(val, true);
                }
                this._setLanguageDirection();
            },
            getVal: function getVal() {
                return this.input.getQuery();
            },
            destroy: function destroy() {
                this.input.destroy();
                this.dropdown.destroy();
                destroyDomStructure(this.$node);
                this.$node = null;
            }
        });
        return Typeahead;
        function buildDom(input, withHint) {
            var $input, $wrapper, $dropdown, $hint;
            $input = $(input);
            $wrapper = $(html.wrapper).css(css.wrapper);
            $dropdown = $(html.dropdown).css(css.dropdown);
            $hint = $input.clone().css(css.hint).css(getBackgroundStyles($input));
            $hint.val("").removeData().addClass("tt-hint").removeAttr("id name placeholder required").prop("readonly", true).attr({
                autocomplete: "off",
                spellcheck: "false",
                tabindex: -1
            });
            $input.data(attrsKey, {
                dir: $input.attr("dir"),
                autocomplete: $input.attr("autocomplete"),
                spellcheck: $input.attr("spellcheck"),
                style: $input.attr("style")
            });
            $input.addClass("tt-input").attr({
                autocomplete: "off",
                spellcheck: false
            }).css(withHint ? css.input : css.inputWithNoHint);
            try {
                !$input.attr("dir") && $input.attr("dir", "auto");
            } catch (e) {}
            return $input.wrap($wrapper).parent().prepend(withHint ? $hint : null).append($dropdown);
        }
        function getBackgroundStyles($el) {
            return {
                backgroundAttachment: $el.css("background-attachment"),
                backgroundClip: $el.css("background-clip"),
                backgroundColor: $el.css("background-color"),
                backgroundImage: $el.css("background-image"),
                backgroundOrigin: $el.css("background-origin"),
                backgroundPosition: $el.css("background-position"),
                backgroundRepeat: $el.css("background-repeat"),
                backgroundSize: $el.css("background-size")
            };
        }
        function destroyDomStructure($node) {
            var $input = $node.find(".tt-input");
            _.each($input.data(attrsKey), function(val, key) {
                _.isUndefined(val) ? $input.removeAttr(key) : $input.attr(key, val);
            });
            $input.detach().removeData(attrsKey).removeClass("tt-input").insertAfter($node);
            $node.remove();
        }
    }();
    (function() {
        "use strict";
        var old, typeaheadKey, methods;
        old = $.fn.typeahead;
        typeaheadKey = "ttTypeahead";
        methods = {
            initialize: function initialize(o, datasets) {
                datasets = _.isArray(datasets) ? datasets : [].slice.call(arguments, 1);
                o = o || {};
                return this.each(attach);
                function attach() {
                    var $input = $(this), eventBus, typeahead;
                    _.each(datasets, function(d) {
                        d.highlight = !!o.highlight;
                    });
                    typeahead = new Typeahead({
                        input: $input,
                        eventBus: eventBus = new EventBus({
                            el: $input
                        }),
                        withHint: _.isUndefined(o.hint) ? true : !!o.hint,
                        minLength: o.minLength,
                        autoselect: o.autoselect,
                        datasets: datasets
                    });
                    $input.data(typeaheadKey, typeahead);
                }
            },
            open: function open() {
                return this.each(openTypeahead);
                function openTypeahead() {
                    var $input = $(this), typeahead;
                    if (typeahead = $input.data(typeaheadKey)) {
                        typeahead.open();
                    }
                }
            },
            close: function close() {
                return this.each(closeTypeahead);
                function closeTypeahead() {
                    var $input = $(this), typeahead;
                    if (typeahead = $input.data(typeaheadKey)) {
                        typeahead.close();
                    }
                }
            },
            val: function val(newVal) {
                return !arguments.length ? getVal(this.first()) : this.each(setVal);
                function setVal() {
                    var $input = $(this), typeahead;
                    if (typeahead = $input.data(typeaheadKey)) {
                        typeahead.setVal(newVal);
                    }
                }
                function getVal($input) {
                    var typeahead, query;
                    if (typeahead = $input.data(typeaheadKey)) {
                        query = typeahead.getVal();
                    }
                    return query;
                }
            },
            destroy: function destroy() {
                return this.each(unattach);
                function unattach() {
                    var $input = $(this), typeahead;
                    if (typeahead = $input.data(typeaheadKey)) {
                        typeahead.destroy();
                        $input.removeData(typeaheadKey);
                    }
                }
            }
        };
        $.fn.typeahead = function(method) {
            var tts;
            if (methods[method] && method !== "initialize") {
                tts = this.filter(function() {
                    return !!$(this).data(typeaheadKey);
                });
                return methods[method].apply(tts, [].slice.call(arguments, 1));
            } else {
                return methods.initialize.apply(this, arguments);
            }
        };
        $.fn.typeahead.noConflict = function noConflict() {
            $.fn.typeahead = old;
            return this;
        };
    })();
})(window.jQuery);



(function($,window){
  '$:nomunge'; // Used by YUI compressor.
  
  // Some convenient shortcuts.
  var undefined,
    aps = Array.prototype.slice,
    decode = decodeURIComponent,
    
    // Method / object references.
    jq_param = $.param,
    jq_param_fragment,
    jq_deparam,
    jq_deparam_fragment,
    jq_bbq = $.bbq = $.bbq || {},
    jq_bbq_pushState,
    jq_bbq_getState,
    jq_elemUrlAttr,
    jq_event_special = $.event.special,
    
    // Reused strings.
    str_hashchange = 'hashchange',
    str_querystring = 'querystring',
    str_fragment = 'fragment',
    str_elemUrlAttr = 'elemUrlAttr',
    str_location = 'location',
    str_href = 'href',
    str_src = 'src',
    
    // Reused RegExp.
    re_trim_querystring = /^.*\?|#.*$/g,
    re_trim_fragment = /^.*\#/,
    re_no_escape,
    
    // Used by jQuery.elemUrlAttr.
    elemUrlAttr_cache = {};
  
  // A few commonly used bits, broken out to help reduce minified file size.
  function is_string( arg ) {
    return typeof arg === 'string';
  };
  
  // Why write the same function twice? Let's curry! Mmmm, curry..
  
  function curry( func ) {
    var args = aps.call( arguments, 1 );
    
    return function() {
      return func.apply( this, args.concat( aps.call( arguments ) ) );
    };
  };
  
  // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!
  function get_fragment( url ) {
    return url.replace( /^[^#]*#?(.*)$/, '$1' );
  };
  
  // Get location.search (or what you'd expect location.search to be) sans any
  // leading #. Thanks for making this necessary, IE6!
  function get_querystring( url ) {
    return url.replace( /(?:^[^?#]*\?([^#]*).*$)?.*/, '$1' );
  };
  
  // Section: Param (to string)
  // 
  // Method: jQuery.param.querystring
  // 
  // Retrieve the query string from a URL or if no arguments are passed, the
  // current window.location.
  // 
  // Usage:
  // 
  // > jQuery.param.querystring( [ url ] );
  // 
  // Arguments:
  // 
  //  url - (String) A URL containing query string params to be parsed. If url
  //    is not passed, the current window.location is used.
  // 
  // Returns:
  // 
  //  (String) The parsed query string, with any leading "?" removed.
  //
  
  // Method: jQuery.param.querystring (build url)
  // 
  // Merge a URL, with or without pre-existing query string params, plus any
  // object, params string or URL containing query string params into a new URL.
  // 
  // Usage:
  // 
  // > jQuery.param.querystring( url, params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  url - (String) A valid URL for params to be merged into. This URL may
  //    contain a query string and/or fragment (hash).
  //  params - (String) A params string or URL containing query string params to
  //    be merged into url.
  //  params - (Object) A params object to be merged into url.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  // 
  //    * 0: params in the params argument will override any query string
  //         params in url.
  //    * 1: any query string params in url will override params in the params
  //         argument.
  //    * 2: params argument will completely replace any query string in url.
  // 
  // Returns:
  // 
  //  (String) Either a params string with urlencoded data or a URL with a
  //    urlencoded query string in the format 'a=b&c=d&e=f'.
  
  // Method: jQuery.param.fragment
  // 
  // Retrieve the fragment (hash) from a URL or if no arguments are passed, the
  // current window.location.
  // 
  // Usage:
  // 
  // > jQuery.param.fragment( [ url ] );
  // 
  // Arguments:
  // 
  //  url - (String) A URL containing fragment (hash) params to be parsed. If
  //    url is not passed, the current window.location is used.
  // 
  // Returns:
  // 
  //  (String) The parsed fragment (hash) string, with any leading "#" removed.
  
  // Method: jQuery.param.fragment (build url)
  // 
  // Merge a URL, with or without pre-existing fragment (hash) params, plus any
  // object, params string or URL containing fragment (hash) params into a new
  // URL.
  // 
  // Usage:
  // 
  // > jQuery.param.fragment( url, params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  url - (String) A valid URL for params to be merged into. This URL may
  //    contain a query string and/or fragment (hash).
  //  params - (String) A params string or URL containing fragment (hash) params
  //    to be merged into url.
  //  params - (Object) A params object to be merged into url.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  // 
  //    * 0: params in the params argument will override any fragment (hash)
  //         params in url.
  //    * 1: any fragment (hash) params in url will override params in the
  //         params argument.
  //    * 2: params argument will completely replace any query string in url.
  // 
  // Returns:
  // 
  //  (String) Either a params string with urlencoded data or a URL with a
  //    urlencoded fragment (hash) in the format 'a=b&c=d&e=f'.
  
  function jq_param_sub( is_fragment, get_func, url, params, merge_mode ) {
    var result,
      qs,
      matches,
      url_params,
      hash;
    
    if ( params !== undefined ) {
      // Build URL by merging params into url string.
      
      // matches[1] = url part that precedes params, not including trailing ?/#
      // matches[2] = params, not including leading ?/#
      // matches[3] = if in 'querystring' mode, hash including leading #, otherwise ''
      matches = url.match( is_fragment ? /^([^#]*)\#?(.*)$/ : /^([^#?]*)\??([^#]*)(#?.*)/ );
      
      // Get the hash if in 'querystring' mode, and it exists.
      hash = matches[3] || '';
      
      if ( merge_mode === 2 && is_string( params ) ) {
        // If merge_mode is 2 and params is a string, merge the fragment / query
        // string into the URL wholesale, without converting it into an object.
        qs = params.replace( is_fragment ? re_trim_fragment : re_trim_querystring, '' );
        
      } else {
        // Convert relevant params in url to object.
        url_params = jq_deparam( matches[2] );
        
        params = is_string( params )
          
          // Convert passed params string into object.
          ? jq_deparam[ is_fragment ? str_fragment : str_querystring ]( params )
          
          // Passed params object.
          : params;
        
        qs = merge_mode === 2 ? params                              // passed params replace url params
          : merge_mode === 1  ? $.extend( {}, params, url_params )  // url params override passed params
          : $.extend( {}, url_params, params );                     // passed params override url params
        
        // Convert params object to a string.
        qs = jq_param( qs );
        
        // Unescape characters specified via $.param.noEscape. Since only hash-
        // history users have requested this feature, it's only enabled for
        // fragment-related params strings.
        if ( is_fragment ) {
          qs = qs.replace( re_no_escape, decode );
        }
      }
      
      // Build URL from the base url, querystring and hash. In 'querystring'
      // mode, ? is only added if a query string exists. In 'fragment' mode, #
      // is always added.
      result = matches[1] + ( is_fragment ? '#' : qs || !matches[1] ? '?' : '' ) + qs + hash;
      
    } else {
      // If URL was passed in, parse params from URL string, otherwise parse
      // params from window.location.
      result = get_func( url !== undefined ? url : window[ str_location ][ str_href ] );
    }
    
    return result;
  };
  
  jq_param[ str_querystring ]                  = curry( jq_param_sub, 0, get_querystring );
  jq_param[ str_fragment ] = jq_param_fragment = curry( jq_param_sub, 1, get_fragment );
  
  // Method: jQuery.param.fragment.noEscape
  // 
  // Specify characters that will be left unescaped when fragments are created
  // or merged using <jQuery.param.fragment>, or when the fragment is modified
  // using <jQuery.bbq.pushState>. This option only applies to serialized data
  // object fragments, and not set-as-string fragments. Does not affect the
  // query string. Defaults to ",/" (comma, forward slash).
  // 
  // Note that this is considered a purely aesthetic option, and will help to
  // create URLs that "look pretty" in the address bar or bookmarks, without
  // affecting functionality in any way. That being said, be careful to not
  // unescape characters that are used as delimiters or serve a special
  // purpose, such as the "#?&=+" (octothorpe, question mark, ampersand,
  // equals, plus) characters.
  // 
  // Usage:
  // 
  // > jQuery.param.fragment.noEscape( [ chars ] );
  // 
  // Arguments:
  // 
  //  chars - (String) The characters to not escape in the fragment. If
  //    unspecified, defaults to empty string (escape all characters).
  // 
  // Returns:
  // 
  //  Nothing.
  
  jq_param_fragment.noEscape = function( chars ) {
    chars = chars || '';
    var arr = $.map( chars.split(''), encodeURIComponent );
    re_no_escape = new RegExp( arr.join('|'), 'g' );
  };
  
  // A sensible default. These are the characters people seem to complain about
  // "uglifying up the URL" the most.
  jq_param_fragment.noEscape( ',/' );
  
  // Section: Deparam (from string)
  // 
  // Method: jQuery.deparam
  // 
  // Deserialize a params string into an object, optionally coercing numbers,
  // booleans, null and undefined values; this method is the counterpart to the
  // internal jQuery.param method.
  // 
  // Usage:
  // 
  // > jQuery.deparam( params [, coerce ] );
  // 
  // Arguments:
  // 
  //  params - (String) A params string to be parsed.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  // 
  // Returns:
  // 
  //  (Object) An object representing the deserialized params string.
  
  $.deparam = jq_deparam = function( params, coerce ) {
    var obj = {},
      coerce_types = { 'true': !0, 'false': !1, 'null': null };
    
    // Iterate over all name=value pairs.
    $.each( params.replace( /\+/g, ' ' ).split( '&' ), function(j,v){
      var param = v.split( '=' ),
        key = decode( param[0] ),
        val,
        cur = obj,
        i = 0,
        
        // If key is more complex than 'foo', like 'a[]' or 'a[b][c]', split it
        // into its component parts.
        keys = key.split( '][' ),
        keys_last = keys.length - 1;
      
      // If the first keys part contains [ and the last ends with ], then []
      // are correctly balanced.
      if ( /\[/.test( keys[0] ) && /\]$/.test( keys[ keys_last ] ) ) {
        // Remove the trailing ] from the last keys part.
        keys[ keys_last ] = keys[ keys_last ].replace( /\]$/, '' );
        
        // Split first keys part into two parts on the [ and add them back onto
        // the beginning of the keys array.
        keys = keys.shift().split('[').concat( keys );
        
        keys_last = keys.length - 1;
      } else {
        // Basic 'foo' style key.
        keys_last = 0;
      }
      
      // Are we dealing with a name=value pair, or just a name?
      if ( param.length === 2 ) {
        val = decode( param[1] );
        
        // Coerce values.
        if ( coerce ) {
          val = val && !isNaN(val)            ? +val              // number
            : val === 'undefined'             ? undefined         // undefined
            : coerce_types[val] !== undefined ? coerce_types[val] // true, false, null
            : val;                                                // string
        }
        
        if ( keys_last ) {
          // Complex key, build deep object structure based on a few rules:
          // * The 'cur' pointer starts at the object top-level.
          // * [] = array push (n is set to array length), [n] = array if n is 
          //   numeric, otherwise object.
          // * If at the last keys part, set the value.
          // * For each keys part, if the current level is undefined create an
          //   object or array based on the type of the next keys part.
          // * Move the 'cur' pointer to the next level.
          // * Rinse & repeat.
          for ( ; i <= keys_last; i++ ) {
            key = keys[i] === '' ? cur.length : keys[i];
            cur = cur[key] = i < keys_last
              ? cur[key] || ( keys[i+1] && isNaN( keys[i+1] ) ? {} : [] )
              : val;
          }
          
        } else {
          // Simple key, even simpler rules, since only scalars and shallow
          // arrays are allowed.
          
          if ( $.isArray( obj[key] ) ) {
            // val is already an array, so push on the next value.
            obj[key].push( val );
            
          } else if ( obj[key] !== undefined ) {
            // val isn't an array, but since a second value has been specified,
            // convert val into an array.
            obj[key] = [ obj[key], val ];
            
          } else {
            // val is a scalar.
            obj[key] = val;
          }
        }
        
      } else if ( key ) {
        // No value was defined, so set something meaningful.
        obj[key] = coerce
          ? undefined
          : '';
      }
    });
    
    return obj;
  };
  
  // Method: jQuery.deparam.querystring
  // 
  // Parse the query string from a URL or the current window.location,
  // deserializing it into an object, optionally coercing numbers, booleans,
  // null and undefined values.
  // 
  // Usage:
  // 
  // > jQuery.deparam.querystring( [ url ] [, coerce ] );
  // 
  // Arguments:
  // 
  //  url - (String) An optional params string or URL containing query string
  //    params to be parsed. If url is omitted, the current window.location
  //    is used.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  // 
  // Returns:
  // 
  //  (Object) An object representing the deserialized params string.
  
  // Method: jQuery.deparam.fragment
  // 
  // Parse the fragment (hash) from a URL or the current window.location,
  // deserializing it into an object, optionally coercing numbers, booleans,
  // null and undefined values.
  // 
  // Usage:
  // 
  // > jQuery.deparam.fragment( [ url ] [, coerce ] );
  // 
  // Arguments:
  // 
  //  url - (String) An optional params string or URL containing fragment (hash)
  //    params to be parsed. If url is omitted, the current window.location
  //    is used.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false if omitted.
  // 
  // Returns:
  // 
  //  (Object) An object representing the deserialized params string.
  
  function jq_deparam_sub( is_fragment, url_or_params, coerce ) {
    if ( url_or_params === undefined || typeof url_or_params === 'boolean' ) {
      // url_or_params not specified.
      coerce = url_or_params;
      url_or_params = jq_param[ is_fragment ? str_fragment : str_querystring ]();
    } else {
      url_or_params = is_string( url_or_params )
        ? url_or_params.replace( is_fragment ? re_trim_fragment : re_trim_querystring, '' )
        : url_or_params;
    }
    
    return jq_deparam( url_or_params, coerce );
  };
  
  jq_deparam[ str_querystring ]                    = curry( jq_deparam_sub, 0 );
  jq_deparam[ str_fragment ] = jq_deparam_fragment = curry( jq_deparam_sub, 1 );
  
  // Section: Element manipulation
  // 
  // Method: jQuery.elemUrlAttr
  // 
  // Get the internal "Default URL attribute per tag" list, or augment the list
  // with additional tag-attribute pairs, in case the defaults are insufficient.
  // 
  // In the <jQuery.fn.querystring> and <jQuery.fn.fragment> methods, this list
  // is used to determine which attribute contains the URL to be modified, if
  // an "attr" param is not specified.
  // 
  // Default Tag-Attribute List:
  // 
  //  a      - href
  //  base   - href
  //  iframe - src
  //  img    - src
  //  input  - src
  //  form   - action
  //  link   - href
  //  script - src
  // 
  // Usage:
  // 
  // > jQuery.elemUrlAttr( [ tag_attr ] );
  // 
  // Arguments:
  // 
  //  tag_attr - (Object) An object containing a list of tag names and their
  //    associated default attribute names in the format { tag: 'attr', ... } to
  //    be merged into the internal tag-attribute list.
  // 
  // Returns:
  // 
  //  (Object) An object containing all stored tag-attribute values.
  
  // Only define function and set defaults if function doesn't already exist, as
  // the urlInternal plugin will provide this method as well.
  $[ str_elemUrlAttr ] || ($[ str_elemUrlAttr ] = function( obj ) {
    return $.extend( elemUrlAttr_cache, obj );
  })({
    a: str_href,
    base: str_href,
    iframe: str_src,
    img: str_src,
    input: str_src,
    form: 'action',
    link: str_href,
    script: str_src
  });
  
  jq_elemUrlAttr = $[ str_elemUrlAttr ];
  
  // Method: jQuery.fn.querystring
  // 
  // Update URL attribute in one or more elements, merging the current URL (with
  // or without pre-existing query string params) plus any params object or
  // string into a new URL, which is then set into that attribute. Like
  // <jQuery.param.querystring (build url)>, but for all elements in a jQuery
  // collection.
  // 
  // Usage:
  // 
  // > jQuery('selector').querystring( [ attr, ] params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  attr - (String) Optional name of an attribute that will contain a URL to
  //    merge params or url into. See <jQuery.elemUrlAttr> for a list of default
  //    attributes.
  //  params - (Object) A params object to be merged into the URL attribute.
  //  params - (String) A URL containing query string params, or params string
  //    to be merged into the URL attribute.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //    
  //    * 0: params in the params argument will override any params in attr URL.
  //    * 1: any params in attr URL will override params in the params argument.
  //    * 2: params argument will completely replace any query string in attr
  //         URL.
  // 
  // Returns:
  // 
  //  (jQuery) The initial jQuery collection of elements, but with modified URL
  //  attribute values.
  
  // Method: jQuery.fn.fragment
  // 
  // Update URL attribute in one or more elements, merging the current URL (with
  // or without pre-existing fragment/hash params) plus any params object or
  // string into a new URL, which is then set into that attribute. Like
  // <jQuery.param.fragment (build url)>, but for all elements in a jQuery
  // collection.
  // 
  // Usage:
  // 
  // > jQuery('selector').fragment( [ attr, ] params [, merge_mode ] );
  // 
  // Arguments:
  // 
  //  attr - (String) Optional name of an attribute that will contain a URL to
  //    merge params into. See <jQuery.elemUrlAttr> for a list of default
  //    attributes.
  //  params - (Object) A params object to be merged into the URL attribute.
  //  params - (String) A URL containing fragment (hash) params, or params
  //    string to be merged into the URL attribute.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified, and is as-follows:
  //    
  //    * 0: params in the params argument will override any params in attr URL.
  //    * 1: any params in attr URL will override params in the params argument.
  //    * 2: params argument will completely replace any fragment (hash) in attr
  //         URL.
  // 
  // Returns:
  // 
  //  (jQuery) The initial jQuery collection of elements, but with modified URL
  //  attribute values.
  
  function jq_fn_sub( mode, force_attr, params, merge_mode ) {
    if ( !is_string( params ) && typeof params !== 'object' ) {
      // force_attr not specified.
      merge_mode = params;
      params = force_attr;
      force_attr = undefined;
    }
    
    return this.each(function(){
      var that = $(this),
        
        // Get attribute specified, or default specified via $.elemUrlAttr.
        attr = force_attr || jq_elemUrlAttr()[ ( this.nodeName || '' ).toLowerCase() ] || '',
        
        // Get URL value.
        url = attr && that.attr( attr ) || '';
      
      // Update attribute with new URL.
      that.attr( attr, jq_param[ mode ]( url, params, merge_mode ) );
    });
    
  };
  
  $.fn[ str_querystring ] = curry( jq_fn_sub, str_querystring );
  $.fn[ str_fragment ]    = curry( jq_fn_sub, str_fragment );
  
  // Section: History, hashchange event
  // 
  // Method: jQuery.bbq.pushState
  // 
  // Adds a 'state' into the browser history at the current position, setting
  // location.hash and triggering any bound <hashchange event> callbacks
  // (provided the new state is different than the previous state).
  // 
  // If no arguments are passed, an empty state is created, which is just a
  // shortcut for jQuery.bbq.pushState( {}, 2 ).
  // 
  // Usage:
  // 
  // > jQuery.bbq.pushState( [ params [, merge_mode ] ] );
  // 
  // Arguments:
  // 
  //  params - (String) A serialized params string or a hash string beginning
  //    with # to merge into location.hash.
  //  params - (Object) A params object to merge into location.hash.
  //  merge_mode - (Number) Merge behavior defaults to 0 if merge_mode is not
  //    specified (unless a hash string beginning with # is specified, in which
  //    case merge behavior defaults to 2), and is as-follows:
  // 
  //    * 0: params in the params argument will override any params in the
  //         current state.
  //    * 1: any params in the current state will override params in the params
  //         argument.
  //    * 2: params argument will completely replace current state.
  // 
  // Returns:
  // 
  //  Nothing.
  // 
  // Additional Notes:
  // 
  //  * Setting an empty state may cause the browser to scroll.
  //  * Unlike the fragment and querystring methods, if a hash string beginning
  //    with # is specified as the params agrument, merge_mode defaults to 2.
  
  jq_bbq.pushState = jq_bbq_pushState = function( params, merge_mode ) {
    if ( is_string( params ) && /^#/.test( params ) && merge_mode === undefined ) {
      // Params string begins with # and merge_mode not specified, so completely
      // overwrite window.location.hash.
      merge_mode = 2;
    }
    
    var has_args = params !== undefined,
      // Merge params into window.location using $.param.fragment.
      url = jq_param_fragment( window[ str_location ][ str_href ],
        has_args ? params : {}, has_args ? merge_mode : 2 );
    
    // Set new window.location.href. If hash is empty, use just # to prevent
    // browser from reloading the page. Note that Safari 3 & Chrome barf on
    // location.hash = '#'.
    window[ str_location ][ str_href ] = url + ( /#/.test( url ) ? '' : '#' );
  };
  
  // Method: jQuery.bbq.getState
  // 
  // Retrieves the current 'state' from the browser history, parsing
  // location.hash for a specific key or returning an object containing the
  // entire state, optionally coercing numbers, booleans, null and undefined
  // values.
  // 
  // Usage:
  // 
  // > jQuery.bbq.getState( [ key ] [, coerce ] );
  // 
  // Arguments:
  // 
  //  key - (String) An optional state key for which to return a value.
  //  coerce - (Boolean) If true, coerces any numbers or true, false, null, and
  //    undefined to their actual value. Defaults to false.
  // 
  // Returns:
  // 
  //  (Anything) If key is passed, returns the value corresponding with that key
  //    in the location.hash 'state', or undefined. If not, an object
  //    representing the entire 'state' is returned.
  
  jq_bbq.getState = jq_bbq_getState = function( key, coerce ) {
    return key === undefined || typeof key === 'boolean'
      ? jq_deparam_fragment( key ) // 'key' really means 'coerce' here
      : jq_deparam_fragment( coerce )[ key ];
  };
  
  // Method: jQuery.bbq.removeState
  // 
  // Remove one or more keys from the current browser history 'state', creating
  // a new state, setting location.hash and triggering any bound
  // <hashchange event> callbacks (provided the new state is different than
  // the previous state).
  // 
  // If no arguments are passed, an empty state is created, which is just a
  // shortcut for jQuery.bbq.pushState( {}, 2 ).
  // 
  // Usage:
  // 
  // > jQuery.bbq.removeState( [ key [, key ... ] ] );
  // 
  // Arguments:
  // 
  //  key - (String) One or more key values to remove from the current state,
  //    passed as individual arguments.
  //  key - (Array) A single array argument that contains a list of key values
  //    to remove from the current state.
  // 
  // Returns:
  // 
  //  Nothing.
  // 
  // Additional Notes:
  // 
  //  * Setting an empty state may cause the browser to scroll.
  
  jq_bbq.removeState = function( arr ) {
    var state = {};
    
    // If one or more arguments is passed..
    if ( arr !== undefined ) {
      
      // Get the current state.
      state = jq_bbq_getState();
      
      // For each passed key, delete the corresponding property from the current
      // state.
      $.each( $.isArray( arr ) ? arr : arguments, function(i,v){
        delete state[ v ];
      });
    }
    
    // Set the state, completely overriding any existing state.
    jq_bbq_pushState( state, 2 );
  };
  
  // Event: hashchange event (BBQ)
  // 
  // Usage in jQuery 1.4 and newer:
  // 
  // In jQuery 1.4 and newer, the event object passed into any hashchange event
  // callback is augmented with a copy of the location.hash fragment at the time
  // the event was triggered as its event.fragment property. In addition, the
  // event.getState method operates on this property (instead of location.hash)
  // which allows this fragment-as-a-state to be referenced later, even after
  // window.location may have changed.
  // 
  // Note that event.fragment and event.getState are not defined according to
  // W3C (or any other) specification, but will still be available whether or
  // not the hashchange event exists natively in the browser, because of the
  // utility they provide.
  // 
  // The event.fragment property contains the output of <jQuery.param.fragment>
  // and the event.getState method is equivalent to the <jQuery.bbq.getState>
  // method.
  // 
  // > $(window).bind( 'hashchange', function( event ) {
  // >   var hash_str = event.fragment,
  // >     param_obj = event.getState(),
  // >     param_val = event.getState( 'param_name' ),
  // >     param_val_coerced = event.getState( 'param_name', true );
  // >   ...
  // > });
  // 
  // Usage in jQuery 1.3.2:
  // 
  // In jQuery 1.3.2, the event object cannot to be augmented as in jQuery 1.4+,
  // so the fragment state isn't bound to the event object and must instead be
  // parsed using the <jQuery.param.fragment> and <jQuery.bbq.getState> methods.
  // 
  // > $(window).bind( 'hashchange', function( event ) {
  // >   var hash_str = $.param.fragment(),
  // >     param_obj = $.bbq.getState(),
  // >     param_val = $.bbq.getState( 'param_name' ),
  // >     param_val_coerced = $.bbq.getState( 'param_name', true );
  // >   ...
  // > });
  // 
  // Additional Notes:
  // 
  // * Due to changes in the special events API, jQuery BBQ v1.2 or newer is
  //   required to enable the augmented event object in jQuery 1.4.2 and newer.
  // * See <jQuery hashchange event> for more detailed information.
  
  jq_event_special[ str_hashchange ] = $.extend( jq_event_special[ str_hashchange ], {
    
    // Augmenting the event object with the .fragment property and .getState
    // method requires jQuery 1.4 or newer. Note: with 1.3.2, everything will
    // work, but the event won't be augmented)
    add: function( handleObj ) {
      var old_handler;
      
      function new_handler(e) {
        // e.fragment is set to the value of location.hash (with any leading #
        // removed) at the time the event is triggered.
        var hash = e[ str_fragment ] = jq_param_fragment();
        
        // e.getState() works just like $.bbq.getState(), but uses the
        // e.fragment property stored on the event object.
        e.getState = function( key, coerce ) {
          return key === undefined || typeof key === 'boolean'
            ? jq_deparam( hash, key ) // 'key' really means 'coerce' here
            : jq_deparam( hash, coerce )[ key ];
        };
        
        old_handler.apply( this, arguments );
      };
      
      // This may seem a little complicated, but it normalizes the special event
      // .add method between jQuery 1.4/1.4.1 and 1.4.2+
      if ( $.isFunction( handleObj ) ) {
        // 1.4, 1.4.1
        old_handler = handleObj;
        return new_handler;
      } else {
        // 1.4.2+
        old_handler = handleObj.handler;
        handleObj.handler = new_handler;
      }
    }
    
  });
  
})(jQuery,this);

/*!
 * jQuery hashchange event - v1.2 - 2/11/2010
 * http://benalman.com/projects/jquery-hashchange-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery hashchange event
//
// *Version: 1.2, Last updated: 2/11/2010*
// 
// Project Home - http://benalman.com/projects/jquery-hashchange-plugin/
// GitHub       - http://github.com/cowboy/jquery-hashchange/
// Source       - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.js
// (Minified)   - http://github.com/cowboy/jquery-hashchange/raw/master/jquery.ba-hashchange.min.js (1.1kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// This working example, complete with fully commented code, illustrate one way
// in which this plugin can be used.
// 
// hashchange event - http://benalman.com/code/projects/jquery-hashchange/examples/hashchange/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - 1.3.2, 1.4.1, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.7, Safari 3-4, Chrome, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-hashchange/unit/
// 
// About: Known issues
// 
// While this jQuery hashchange event implementation is quite stable and robust,
// there are a few unfortunate browser bugs surrounding expected hashchange
// event-based behaviors, independent of any JavaScript window.onhashchange
// abstraction. See the following examples for more information:
// 
// Chrome: Back Button - http://benalman.com/code/projects/jquery-hashchange/examples/bug-chrome-back-button/
// Firefox: Remote XMLHttpRequest - http://benalman.com/code/projects/jquery-hashchange/examples/bug-firefox-remote-xhr/
// WebKit: Back Button in an Iframe - http://benalman.com/code/projects/jquery-hashchange/examples/bug-webkit-hash-iframe/
// Safari: Back Button from a different domain - http://benalman.com/code/projects/jquery-hashchange/examples/bug-safari-back-from-diff-domain/
// 
// About: Release History
// 
// 1.2   - (2/11/2010) Fixed a bug where coming back to a page using this plugin
//         from a page on another domain would cause an error in Safari 4. Also,
//         IE6/7 Iframe is now inserted after the body (this actually works),
//         which prevents the page from scrolling when the event is first bound.
//         Event can also now be bound before DOM ready, but it won't be usable
//         before then in IE6/7.
// 1.1   - (1/21/2010) Incorporated document.documentMode test to fix IE8 bug
//         where browser version is incorrectly reported as 8.0, despite
//         inclusion of the X-UA-Compatible IE=EmulateIE7 meta tag.
// 1.0   - (1/9/2010) Initial Release. Broke out the jQuery BBQ event.special
//         window.onhashchange functionality into a separate plugin for users
//         who want just the basic event & back button support, without all the
//         extra awesomeness that BBQ provides. This plugin will be included as
//         part of jQuery BBQ, but also be available separately.

(function($,window,undefined){
  '$:nomunge'; // Used by YUI compressor.
  
  // Method / object references.
  var fake_onhashchange,
    jq_event_special = $.event.special,
    
    // Reused strings.
    str_location = 'location',
    str_hashchange = 'hashchange',
    str_href = 'href',
    
    // IE6/7 specifically need some special love when it comes to back-button
    // support, so let's do a little browser sniffing..
    browser = $.browser,
    mode = document.documentMode,
    is_old_ie = browser.msie && ( mode === undefined || mode < 8 ),
    
    // Does the browser support window.onhashchange? Test for IE version, since
    // IE8 incorrectly reports this when in "IE7" or "IE8 Compatibility View"!
    supports_onhashchange = 'on' + str_hashchange in window && !is_old_ie;
  
  // Get location.hash (or what you'd expect location.hash to be) sans any
  // leading #. Thanks for making this necessary, Firefox!
  function get_fragment( url ) {
    url = url || window[ str_location ][ str_href ];
    return url.replace( /^[^#]*#?(.*)$/, '$1' );
  };
  
  // Property: jQuery.hashchangeDelay
  // 
  // The numeric interval (in milliseconds) at which the <hashchange event>
  // polling loop executes. Defaults to 100.
  
  $[ str_hashchange + 'Delay' ] = 100;
  
  // Event: hashchange event
  // 
  // Fired when location.hash changes. In browsers that support it, the native
  // window.onhashchange event is used (IE8, FF3.6), otherwise a polling loop is
  // initialized, running every <jQuery.hashchangeDelay> milliseconds to see if
  // the hash has changed. In IE 6 and 7, a hidden Iframe is created to allow
  // the back button and hash-based history to work.
  // 
  // Usage:
  // 
  // > $(window).bind( 'hashchange', function(e) {
  // >   var hash = location.hash;
  // >   ...
  // > });
  // 
  // Additional Notes:
  // 
  // * The polling loop and Iframe are not created until at least one callback
  //   is actually bound to 'hashchange'.
  // * If you need the bound callback(s) to execute immediately, in cases where
  //   the page 'state' exists on page load (via bookmark or page refresh, for
  //   example) use $(window).trigger( 'hashchange' );
  // * The event can be bound before DOM ready, but since it won't be usable
  //   before then in IE6/7 (due to the necessary Iframe), recommended usage is
  //   to bind it inside a $(document).ready() callback.
  
  jq_event_special[ str_hashchange ] = $.extend( jq_event_special[ str_hashchange ], {
    
    // Called only when the first 'hashchange' event is bound to window.
    setup: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to create our own. And we don't want to call this
      // until the user binds to the event, just in case they never do, since it
      // will create a polling loop and possibly even a hidden Iframe.
      $( fake_onhashchange.start );
    },
    
    // Called only when the last 'hashchange' event is unbound from window.
    teardown: function() {
      // If window.onhashchange is supported natively, there's nothing to do..
      if ( supports_onhashchange ) { return false; }
      
      // Otherwise, we need to stop ours (if possible).
      $( fake_onhashchange.stop );
    }
    
  });
  
  // fake_onhashchange does all the work of triggering the window.onhashchange
  // event for browsers that don't natively support it, including creating a
  // polling loop to watch for hash changes and in IE 6/7 creating a hidden
  // Iframe to enable back and forward.
  fake_onhashchange = (function(){
    var self = {},
      timeout_id,
      iframe,
      set_history,
      get_history;
    
    // Initialize. In IE 6/7, creates a hidden Iframe for history handling.
    function init(){
      // Most browsers don't need special methods here..
      set_history = get_history = function(val){ return val; };
      
      // But IE6/7 do!
      if ( is_old_ie ) {
        
        // Create hidden Iframe after the end of the body to prevent initial
        // page load from scrolling unnecessarily.
        iframe = $('<iframe src="javascript:0"/>').hide().insertAfter( 'body' )[0].contentWindow;
        
        // Get history by looking at the hidden Iframe's location.hash.
        get_history = function() {
          return get_fragment( iframe.document[ str_location ][ str_href ] );
        };
        
        // Set a new history item by opening and then closing the Iframe
        // document, *then* setting its location.hash.
        set_history = function( hash, history_hash ) {
          if ( hash !== history_hash ) {
            var doc = iframe.document;
            doc.open().close();
            doc[ str_location ].hash = '#' + hash;
          }
        };
        
        // Set initial history.
        set_history( get_fragment() );
      }
    };
    
    // Start the polling loop.
    self.start = function() {
      // Polling loop is already running!
      if ( timeout_id ) { return; }
      
      // Remember the initial hash so it doesn't get triggered immediately.
      var last_hash = get_fragment();
      
      // Initialize if not yet initialized.
      set_history || init();
      
      // This polling loop checks every $.hashchangeDelay milliseconds to see if
      // location.hash has changed, and triggers the 'hashchange' event on
      // window when necessary.
      (function loopy(){
        var hash = get_fragment(),
          history_hash = get_history( last_hash );
        
        if ( hash !== last_hash ) {
          set_history( last_hash = hash, history_hash );
          
          $(window).trigger( str_hashchange );
          
        } else if ( history_hash !== last_hash ) {
          window[ str_location ][ str_href ] = window[ str_location ][ str_href ].replace( /#.*/, '' ) + '#' + history_hash;
        }
        
        timeout_id = setTimeout( loopy, $[ str_hashchange + 'Delay' ] );
      })();
    };
    
    // Stop the polling loop, but only if an IE6/7 Iframe wasn't created. In
    // that case, even if there are no longer any bound event handlers, the
    // polling loop is still necessary for back/next to work at all!
    self.stop = function() {
      if ( !iframe ) {
        timeout_id && clearTimeout( timeout_id );
        timeout_id = 0;
      }
    };
    
    return self;
  })();
  
})(jQuery,this);



(function(b){b.support.touch="ontouchend" in document;if(!b.support.touch){return;}var c=b.ui.mouse.prototype,e=c._mouseInit,a;function d(g,h){if(g.originalEvent.touches.length>1){return;}g.preventDefault();var i=g.originalEvent.changedTouches[0],f=document.createEvent("MouseEvents");f.initMouseEvent(h,true,true,window,1,i.screenX,i.screenY,i.clientX,i.clientY,false,false,false,false,0,null);g.target.dispatchEvent(f);}c._touchStart=function(g){var f=this;if(a||!f._mouseCapture(g.originalEvent.changedTouches[0])){return;}a=true;f._touchMoved=false;d(g,"mouseover");d(g,"mousemove");d(g,"mousedown");};c._touchMove=function(f){if(!a){return;}this._touchMoved=true;d(f,"mousemove");};c._touchEnd=function(f){if(!a){return;}d(f,"mouseup");d(f,"mouseout");if(!this._touchMoved){d(f,"click");}a=false;};c._mouseInit=function(){var f=this;f.element.bind("touchstart",b.proxy(f,"_touchStart")).bind("touchmove",b.proxy(f,"_touchMove")).bind("touchend",b.proxy(f,"_touchEnd"));e.call(f);};})(jQuery);


// WebTrends SmartSource Data Collector Tag
// Version: 9.4.0     
// Tag Builder Version: 3.2
// Created: 9/7/2011 1:58:01 AM

/* Dragonfly Changes.
 * Patched by gbaker 26/09/2011 
 *	- document.write can't be used with LABjs script loader.
 * 	- remove the inbuilt dcsid, timezone and fpcdom.
 */

function WebTrends(){
	var that=this;
	// begin: user modifiable
	//this.dcsid="dcs3e9phnuz5bdfu8tzlamfrh_8n7o";
	this.domain="statse.webtrendslive.com";
	//this.timezone=10;
	//this.fpcdom=".intpublish.dragonfly.ford.com";
	this.onsitedoms="";
	this.downloadtypes="xls,doc,pdf,txt,csv,zip,docx,xlsx";
	this.navigationtag="div,table";
	this.trackevents=true;
	this.trimoffsiteparams=true;
	this.enabled=true;
	this.i18n=true;
	this.fpc="WT_FPC";
	this.paidsearchparams="gclid";
	this.splitvalue="";
	this.preserve=true;
	// end: user modifiable
	this.DCS={};
	this.WT={};
	this.DCSext={};
	this.images=[];
	this.index=0;
	this.exre=(function(){return(window.RegExp?new RegExp("dcs(uri)|(ref)|(aut)|(met)|(sta)|(sip)|(pro)|(byt)|(dat)|(p3p)|(cfg)|(redirect)|(cip)","i"):"");})();
	this.re=(function(){return(window.RegExp?(that.i18n?{"%25":/\%/g,"%26":/\&/g}:{"%09":/\t/g,"%20":/ /g,"%23":/\#/g,"%26":/\&/g,"%2B":/\+/g,"%3F":/\?/g,"%5C":/\\/g,"%22":/\"/g,"%7F":/\x7F/g,"%A0":/\xA0/g}):"");})();
}
WebTrends.prototype.dcsGetId=function(){
	if (this.enabled&&(document.cookie.indexOf(this.fpc+"=")==-1)&&(document.cookie.indexOf("WTLOPTOUT=")==-1)){
		// document.write("<scr"+"ipt type='text/javascript' src='"+"http"+(window.location.protocol.indexOf('https:')==0?'s':'')+"://"+this.domain+"/"+this.dcsid+"/wtid.js"+"'><\/scr"+"ipt>");
		// 26/09/2011 Patch
		var wtid = document.createElement('script'); 
		wtid.type = 'text/javascript';
		wtid.async = true;
		wtid.src = "http"+(window.location.protocol.indexOf('https:')==0?'s':'')+"://"+this.domain+"/"+this.dcsid+"/wtid.js";
		var sibling = document.getElementsByTagName('script')[0]; 
		sibling.parentNode.insertBefore(wtid, sibling);
	}
}
WebTrends.prototype.dcsGetCookie=function(name){
	var cookies=document.cookie.split("; ");
	var cmatch=[];
	var idx=0;
	var i=0;
	var namelen=name.length;
	var clen=cookies.length;
	for (i=0;i<clen;i++){
		var c=cookies[i];
		if ((c.substring(0,namelen+1))==(name+"=")){
			cmatch[idx++]=c;
		}
	}
	var cmatchCount=cmatch.length;
	if (cmatchCount>0){
		idx=0;
		if ((cmatchCount>1)&&(name==this.fpc)){
			var dLatest=new Date(0);
			for (i=0;i<cmatchCount;i++){
				var lv=parseInt(this.dcsGetCrumb(cmatch[i],"lv"));
				var dLst=new Date(lv);
				if (dLst>dLatest){
					dLatest.setTime(dLst.getTime());
					idx=i;
				}
			}
		}
		return unescape(cmatch[idx].substring(namelen+1));
	}
	else{
		return null;
	}
}
WebTrends.prototype.dcsGetCrumb=function(cval,crumb,sep){
	var aCookie=cval.split(sep||":");
	for (var i=0;i<aCookie.length;i++){
		var aCrumb=aCookie[i].split("=");
		if (crumb==aCrumb[0]){
			return aCrumb[1];
		}
	}
	return null;
}
WebTrends.prototype.dcsGetIdCrumb=function(cval,crumb){
	var id=cval.substring(0,cval.indexOf(":lv="));
	var aCrumb=id.split("=");
	for (var i=0;i<aCrumb.length;i++){
		if (crumb==aCrumb[0]){
			return aCrumb[1];
		}
	}
	return null;
}
WebTrends.prototype.dcsIsFpcSet=function(name,id,lv,ss){
	var c=this.dcsGetCookie(name);
	if (c){
		return ((id==this.dcsGetIdCrumb(c,"id"))&&(lv==this.dcsGetCrumb(c,"lv"))&&(ss==this.dcsGetCrumb(c,"ss")))?0:3;
	}
	return 2;
}
WebTrends.prototype.dcsFPC=function(){
	if (document.cookie.indexOf("WTLOPTOUT=")!=-1){
		return;
	}
	var WT=this.WT;
	var name=this.fpc;
	var dCur=new Date();
	var adj=(dCur.getTimezoneOffset()*60000)+(this.timezone*3600000);
	dCur.setTime(dCur.getTime()+adj);
	var dExp=new Date(dCur.getTime()+315360000000);
	var dSes=new Date(dCur.getTime());
	WT.co_f=WT.vtid=WT.vtvs=WT.vt_f=WT.vt_f_a=WT.vt_f_s=WT.vt_f_d=WT.vt_f_tlh=WT.vt_f_tlv="";
	if (document.cookie.indexOf(name+"=")==-1){
		if ((typeof(gWtId)!="undefined")&&(gWtId!="")){
			WT.co_f=gWtId;
		}
		else if ((typeof(gTempWtId)!="undefined")&&(gTempWtId!="")){
			WT.co_f=gTempWtId;
			WT.vt_f="1";
		}
		else{
			WT.co_f="2";
			var curt=dCur.getTime().toString();
			for (var i=2;i<=(32-curt.length);i++){
				WT.co_f+=Math.floor(Math.random()*16.0).toString(16);
			}
			WT.co_f+=curt;
			WT.vt_f="1";
		}
		if (typeof(gWtAccountRollup)=="undefined"){
			WT.vt_f_a="1";
		}
		WT.vt_f_s=WT.vt_f_d="1";
		WT.vt_f_tlh=WT.vt_f_tlv="0";
	}
	else{
		var c=this.dcsGetCookie(name);
		var id=this.dcsGetIdCrumb(c,"id");
		var lv=parseInt(this.dcsGetCrumb(c,"lv"));
		var ss=parseInt(this.dcsGetCrumb(c,"ss"));
		if ((id==null)||(id=="null")||isNaN(lv)||isNaN(ss)){
			return;
		}
		WT.co_f=id;
		var dLst=new Date(lv);
		WT.vt_f_tlh=Math.floor((dLst.getTime()-adj)/1000);
		dSes.setTime(ss);
		if ((dCur.getTime()>(dLst.getTime()+1800000))||(dCur.getTime()>(dSes.getTime()+28800000))){
			WT.vt_f_tlv=Math.floor((dSes.getTime()-adj)/1000);
			dSes.setTime(dCur.getTime());
			WT.vt_f_s="1";
		}
		if ((dCur.getDay()!=dLst.getDay())||(dCur.getMonth()!=dLst.getMonth())||(dCur.getYear()!=dLst.getYear())){
			WT.vt_f_d="1";
		}
	}
	WT.co_f=escape(WT.co_f);
	WT.vtid=(typeof(this.vtid)=="undefined")?WT.co_f:(this.vtid||"");
	WT.vtvs=(dSes.getTime()-adj).toString();
	var expiry="; expires="+dExp.toGMTString();
	var cur=dCur.getTime().toString();
	var ses=dSes.getTime().toString();
	document.cookie=name+"="+"id="+WT.co_f+":lv="+cur+":ss="+ses+expiry+"; path=/"+(((this.fpcdom!=""))?("; domain="+this.fpcdom):(""));
	var rc=this.dcsIsFpcSet(name,WT.co_f,cur,ses);
	if (rc!=0){
		WT.co_f=WT.vtvs=WT.vt_f_s=WT.vt_f_d=WT.vt_f_tlh=WT.vt_f_tlv="";
		if (typeof(this.vtid)=="undefined"){
			WT.vtid="";
		}
		WT.vt_f=WT.vt_f_a=rc;
    }
}
// Code section for Enable SmartView Transition Page tracking
WebTrends.prototype.dcsTP = function() {
    if (document.cookie.indexOf("WTLOPTOUT=") != -1) {
        return;
    }
    var name = "WT_DC";
    var expiry = "; expires=Thu, 31-Dec-2020 08:00:00 GMT";
    var pth = "; path=/";
    var domain = "";
    if (document.cookie.indexOf(name + "=tsp=1") != -1) {
        this.WT.ttp = "1";
    }
    if (this.dcsGetMeta("SmartView_Page") == "1") {
        this.WT.tsp = "1";
        document.cookie = name + "=tsp=1" + expiry + pth + domain;
    }
    else {
        document.cookie = name + "=; expires=Sun, 1-Jan-1995 00:00:00 GMT;" + pth + domain;
    }
}
WebTrends.prototype.dcsGetMeta = function(name) {
    var elems;
    if (document.documentElement) {
        elems = document.getElementsByTagName("meta");
    }
    else if (document.all) {
        elems = document.all.tags("meta");
    }
    if (typeof (elems) != "undefined") {
        for (var i = 1; i <= elems.length; i++) {
            var meta = elems.item(i - 1);
            if (meta.name && (meta.name.indexOf(name) == 0)) {
                return meta.content;
                break;
            }
        }
    }
    return null;
}
WebTrends.prototype.dcsIsOnsite=function(host){
	if (host.length>0){
	    host=host.toLowerCase();
	    if (host==window.location.hostname.toLowerCase()){
		    return true;
	    }
	    if (typeof(this.onsitedoms.test)=="function"){
		    return this.onsitedoms.test(host);
	    }
	    else if (this.onsitedoms.length>0){
		    var doms=this.dcsSplit(this.onsitedoms);
		    var len=doms.length;
		    for (var i=0;i<len;i++){
			    if (host==doms[i]){
			        return true;
			    }
		    }
	    }
	}
	return false;
}
WebTrends.prototype.dcsTypeMatch=function(pth, typelist){
	var type=pth.toLowerCase().substring(pth.lastIndexOf(".")+1,pth.length);
	var types=this.dcsSplit(typelist);
	var tlen=types.length;	
	for (var i=0;i<tlen;i++){
		if (type==types[i]){
			return true;
		}
	}
	return false;
}
WebTrends.prototype.dcsEvt=function(evt,tag){
	var e=evt.target||evt.srcElement;
	while (e&&e.tagName&&(e.tagName.toLowerCase()!=tag.toLowerCase())){
		e=e.parentElement||e.parentNode;
	}
	return e;
}
WebTrends.prototype.dcsNavigation=function(evt){
	var id="";
	var cname="";
	var elems=this.dcsSplit(this.navigationtag);
	var elen=elems.length;	
	var i,e,elem;
	for (i=0;i<elen;i++){
		elem=elems[i];
		if (elem.length){
			e=this.dcsEvt(evt,elem);
			id=(e.getAttribute&&e.getAttribute("id"))?e.getAttribute("id"):"";
			cname=e.className||"";
			if (id.length||cname.length){
				break;
			}
		}
	}
	return id.length?id:cname;
}
WebTrends.prototype.dcsBind=function(event,func){
	if ((typeof(func)=="function")&&document.body){
		if (document.body.addEventListener){
			document.body.addEventListener(event, func.wtbind(this), true);
		}
		else if(document.body.attachEvent){
			document.body.attachEvent("on"+event, func.wtbind(this));
		}
	}
}
WebTrends.prototype.dcsET=function(){
	var e=(navigator.appVersion.indexOf("MSIE")!=-1)?"click":"mousedown";
	this.dcsBind(e,this.dcsDownload);
	this.dcsBind(e,this.dcsJavaScript);
	this.dcsBind(e,this.dcsMailTo);
	this.dcsBind(e,this.dcsFormButton);
	this.dcsBind(e,this.dcsOffsite);
	this.dcsBind(e,this.dcsAnchor);
	this.dcsBind("contextmenu",this.dcsRightClick);
	this.dcsBind(e,this.dcsImageMap);
}
WebTrends.prototype.dcsMultiTrack=function(){
	var args=dcsMultiTrack.arguments?dcsMultiTrack.arguments:arguments;
	if (args.length%2==0){
	    this.dcsSaveProps(args);
		this.dcsSetProps(args);
		var dCurrent=new Date();
		this.DCS.dcsdat=dCurrent.getTime();
		this.dcsFPC();
		this.dcsTag();
		this.dcsRestoreProps();
	}
}

WebTrends.prototype.dcsCleanUp=function(){
	this.DCS={};
	this.WT={};
	this.DCSext={};
	if (arguments.length%2==0){
		this.dcsSetProps(arguments);
	}
}
WebTrends.prototype.dcsSetProps=function(args){
	for (var i=0;i<args.length;i+=2){
		if (args[i].indexOf('WT.')==0){
			this.WT[args[i].substring(3)]=args[i+1];
		}
		else if (args[i].indexOf('DCS.')==0){
			this.DCS[args[i].substring(4)]=args[i+1];
		}
		else if (args[i].indexOf('DCSext.')==0){
			this.DCSext[args[i].substring(7)]=args[i+1];
		}
	}
}
WebTrends.prototype.dcsSaveProps=function(args){
	var i,x,key,param;
	if (this.preserve){
		this.args=[];
		for (i=0,x=0;i<args.length;i+=2){
			param=args[i];
			if (param.indexOf('WT.')==0){
				key=param.substring(3);
				this.args[x]=param;
				this.args[x+1]=this.WT[key]||"";
				x+=2;
			}
			else if (param.indexOf('DCS.')==0){
				key=param.substring(4);
				this.args[x]=param;
				this.args[x+1]=this.DCS[key]||"";
				x+=2;
			}
			else if (param.indexOf('DCSext.')==0){
				key=param.substring(7);
				this.args[x]=param;
				this.args[x+1]=this.DCSext[key]||"";
				x+=2;
			}
		}
	}
}
WebTrends.prototype.dcsRestoreProps=function(){
	if (this.preserve){
		this.dcsSetProps(this.args);
		this.args=[];
	}
}
WebTrends.prototype.dcsSplit=function(list){
	var items=list.toLowerCase().split(",");
	var len=items.length;
	for (var i=0;i<len;i++){
		items[i]=items[i].replace(/^\s*/,"").replace(/\s*$/,"");
	}
	return items;
}
// Code section for Track clicks to download links.
WebTrends.prototype.dcsDownload=function(evt){
	evt=evt||(window.event||"");
	if (evt&&((typeof(evt.which)!="number")||(evt.which==1))){
		var e=this.dcsEvt(evt,"A");
		if (e.href){
		    var hn=e.hostname?(e.hostname.split(":")[0]):"";
		    if (this.dcsIsOnsite(hn)&&this.dcsTypeMatch(e.pathname,this.downloadtypes)){
		        var qry=e.search?e.search.substring(e.search.indexOf("?")+1,e.search.length):"";
		        var pth=e.pathname?((e.pathname.indexOf("/")!=0)?"/"+e.pathname:e.pathname):"/";
		        var ttl="";
		        var text=document.all?e.innerText:e.text;
		        var img=this.dcsEvt(evt,"IMG");
		        if (img.alt){
			        ttl=img.alt;
		        }
		        else if (text){
			        ttl=text;
		        }
		        else if (e.innerHTML){
			        ttl=e.innerHTML;
		        }
		        this.dcsMultiTrack("DCS.dcssip",hn,"DCS.dcsuri",pth,"DCS.dcsqry",e.search||"","WT.ti","Download:"+ttl,"WT.dl","20","WT.nv",this.dcsNavigation(evt));
		    }
		}
	}
}
// Code section for Track right clicks to download links.
WebTrends.prototype.dcsRightClick=function(evt){
	evt=evt||(window.event||"");
	if (evt){
		var btn=evt.which||evt.button;
		if ((btn!=1)||(navigator.userAgent.indexOf("Safari")!=-1)){
			var e=this.dcsEvt(evt,"A");
			if ((typeof(e.href)!="undefined")&&e.href){
				if ((typeof(e.protocol)!="undefined")&&e.protocol&&(e.protocol.indexOf("http")!=-1)){
					if ((typeof(e.pathname)!="undefined")&&this.dcsTypeMatch(e.pathname,this.downloadtypes)){
						var pth=e.pathname?((e.pathname.indexOf("/")!=0)?"/"+e.pathname:e.pathname):"/";
						var hn=e.hostname?(e.hostname.split(":")[0]):"";
						this.dcsMultiTrack("DCS.dcssip",hn,"DCS.dcsuri",pth,"DCS.dcsqry","","WT.ti","RightClick:"+pth,"WT.dl","25");
					}
				}
			}
		}
	}
}
// Code section for Track clicks to MailTo links.
WebTrends.prototype.dcsMailTo = function(evt) {
    evt = evt || (window.event || "");
    if (evt && ((typeof (evt.which) != "number") || (evt.which == 1))) {
        var e = this.dcsEvt(evt, "A");
        if (e.href && e.protocol) {
            var qry = e.search ? e.search.substring(e.search.indexOf("?") + 1, e.search.length) : "";
            if (e.protocol.toLowerCase() == "mailto:") {
                this.dcsMultiTrack("DCS.dcssip", window.location.hostname, "DCS.dcsuri", e.href, "WT.ti", "MailTo:" + e.innerHTML, "WT.dl", "23", "WT.nv", this.dcsNavigation(evt));
            }
        }
    }
}
// Code section for Track clicks to JavaScript links.
WebTrends.prototype.dcsJavaScript = function(evt) {
    evt = evt || (window.event || "");
    if (evt && ((typeof (evt.which) != "number") || (evt.which == 1))) {
        var e = this.dcsEvt(evt, "A");
        if (e.href && e.protocol) {
            var qry = e.search ? e.search.substring(e.search.indexOf("?") + 1, e.search.length) : "";
            if (e.protocol.toLowerCase() == "javascript:") {
                this.dcsMultiTrack("DCS.dcssip", window.location.hostname, "DCS.dcsuri", e.href, "WT.ti", "JavaScript:" + e.innerHTML, "WT.dl", "22", "WT.nv", this.dcsNavigation(evt));
            }
        }
    }
}
// Code section for Track form button clicks.
WebTrends.prototype.dcsFormButton=function(evt){
	evt=evt||(window.event||"");
	if (evt&&((typeof(evt.which)!="number")||(evt.which==1))){
		var tags=["INPUT","BUTTON"];
		for (var j=0;j<tags.length;j++){
			var e=this.dcsEvt(evt,tags[j]);
			var type=e.type||"";
			if (type&&((type=="submit")||(type=="image")||(type=="button")||(type=="reset"))||((type=="text")&&((evt.which||evt.keyCode)==13))){
				var uri="";
				var ttl="";
				var id=0;
				if (e.form){
					// begin: field capture
					// end: field capture
					uri=e.form.action||window.location.pathname;
					ttl=e.form.id||e.form.name||e.form.className||"Unknown";
					id=(e.form.method&&(e.form.method.toLowerCase()=="post"))?"27":"26";
				}
				else{
					uri=window.location.pathname;
					ttl=e.name||e.id||"Unknown";
					id=(tags[j].toLowerCase()=="input")?"28":"29";
				}
				if (uri&&ttl&&(evt.keyCode!=9)){
					this.dcsMultiTrack("DCS.dcsuri",uri,"WT.ti","FormButton:"+ttl,"WT.dl",id,"WT.nv",this.dcsNavigation(evt));
				}
				break;
			}
		}
	}
}
// Code section for Track clicks to links leading offsite.
WebTrends.prototype.dcsOffsite=function(evt){
	evt=evt||(window.event||"");
	if (evt&&((typeof(evt.which)!="number")||(evt.which==1))){
		var e=this.dcsEvt(evt,"A");
		if (e.href){
		    var hn=e.hostname?(e.hostname.split(":")[0]):"";
		    var pr=e.protocol||"";
		    if ((hn.length>0)&&(pr.indexOf("http")==0)&&!this.dcsIsOnsite(hn)){
			    var qry=e.search?e.search.substring(e.search.indexOf("?")+1,e.search.length):"";
			    var pth=e.pathname?((e.pathname.indexOf("/")!=0)?"/"+e.pathname:e.pathname):"/";
			    this.dcsMultiTrack("DCS.dcssip", hn, "DCS.dcsuri", pth, "DCS.dcsqry", this.trimoffsiteparams ? "" : qry, "DCS.dcsref", window.location, "WT.ti", "Offsite:" + hn + pth + (qry.length ? ("?" + qry) : ""), "WT.dl", "24", "WT.nv", this.dcsNavigation(evt));
		    }
		}
	}
}

// Code section for Track clicks to links that contain anchors.
WebTrends.prototype.dcsAnchor=function(evt){
	evt=evt||(window.event||"");
	if (evt&&((typeof(evt.which)!="number")||(evt.which==1))){
		var e=this.dcsEvt(evt,"A");
		if (e.href){
		    var hn=e.hostname?(e.hostname.split(":")[0]):"";
		    if (this.dcsIsOnsite(hn)&&e.hash&&(e.hash!="")&&(e.hash!="#")){
		        var qry=e.search?e.search.substring(e.search.indexOf("?")+1,e.search.length):"";
			    var pth=e.pathname?((e.pathname.indexOf("/")!=0)?"/"+e.pathname:e.pathname):"/";
			    this.dcsMultiTrack("DCS.dcssip",hn,"DCS.dcsuri",escape(pth+e.hash),"WT.ti","Anchor:"+e.hash,"WT.dl","21","WT.nv",this.dcsNavigation(evt));
		    }
		}
	}
}
// Code section for clicks to image maps.
WebTrends.prototype.dcsImageMap=function(evt){
	evt=evt||(window.event||"");
	if (evt){
		var e=this.dcsEvt(evt,"AREA");
		if (e.href){
		    var hn=e.hostname?(e.hostname.split(":")[0]):"";
		    if ((hn!="")&&e.protocol&&(e.protocol.indexOf("http")!=-1)){
			    var ttl="";
			    var map=this.dcsEvt(evt,"MAP");
			    if (map){
			        if (map.name){
				        ttl=map.name;
			        }
			        else if (map.id){
				        ttl=map.id;
			        }
			    }
			    var pth=e.pathname?((e.pathname.indexOf("/")!=0)?"/"+e.pathname:e.pathname):"/";
			    this.dcsMultiTrack("DCS.dcssip",hn,"DCS.dcsuri",pth,"DCS.dcsqry",e.search||"","WT.ti","ImageMap:"+ttl,"WT.dl","30","WT.nv",this.dcsNavigation(evt));
		    }			
		}			
	}
}
WebTrends.prototype.dcsAdv=function(){
	if (this.trackevents&&(typeof(this.dcsET)=="function")){
		if (window.addEventListener){
			window.addEventListener("load",this.dcsET.wtbind(this),false);
		}
		else if (window.attachEvent){
			window.attachEvent("onload",this.dcsET.wtbind(this));
		}
	}
	this.dcsFPC();
	this.dcsTP();
}
WebTrends.prototype.dcsVar=function(){
	var dCurrent=new Date();
	var WT=this.WT;
	var DCS=this.DCS;
	WT.tz=parseInt(dCurrent.getTimezoneOffset()/60*-1)||"0";
	WT.bh=dCurrent.getHours()||"0";
	WT.ul=navigator.appName=="Netscape"?navigator.language:navigator.userLanguage;
	if (typeof(screen)=="object"){
		WT.cd=navigator.appName=="Netscape"?screen.pixelDepth:screen.colorDepth;
		WT.sr=screen.width+"x"+screen.height;
	}
	if (typeof(navigator.javaEnabled())=="boolean"){
		WT.jo=navigator.javaEnabled()?"Yes":"No";
	}
	if (document.title){
		if (window.RegExp){
			var tire=new RegExp("^"+window.location.protocol+"//"+window.location.hostname+"\\s-\\s");
			WT.ti=document.title.replace(tire,"");
		}
		else{
			WT.ti=document.title;
		}
	}
	WT.js="Yes";
	WT.jv=(function(){
		var agt=navigator.userAgent.toLowerCase();
		var major=parseInt(navigator.appVersion);
		var mac=(agt.indexOf("mac")!=-1);
		var ff=(agt.indexOf("firefox")!=-1);
		var ff0=(agt.indexOf("firefox/0.")!=-1);
		var ff10=(agt.indexOf("firefox/1.0")!=-1);
		var ff15=(agt.indexOf("firefox/1.5")!=-1);
		var ff20=(agt.indexOf("firefox/2.0")!=-1);
		var ff3up=(ff&&!ff0&&!ff10&!ff15&!ff20);
		var nn=(!ff&&(agt.indexOf("mozilla")!=-1)&&(agt.indexOf("compatible")==-1));
		var nn4=(nn&&(major==4));
		var nn6up=(nn&&(major>=5));
		var ie=((agt.indexOf("msie")!=-1)&&(agt.indexOf("opera")==-1));
		var ie4=(ie&&(major==4)&&(agt.indexOf("msie 4")!=-1));
		var ie5up=(ie&&!ie4);
		var op=(agt.indexOf("opera")!=-1);
		var op5=(agt.indexOf("opera 5")!=-1||agt.indexOf("opera/5")!=-1);
		var op6=(agt.indexOf("opera 6")!=-1||agt.indexOf("opera/6")!=-1);
		var op7up=(op&&!op5&&!op6);
		var jv="1.1";
		if (ff3up){
			jv="1.8";
		}
		else if (ff20){
			jv="1.7";
		}
		else if (ff15){
			jv="1.6";
		}
		else if (ff0||ff10||nn6up||op7up){
			jv="1.5";
		}
		else if ((mac&&ie5up)||op6){
			jv="1.4";
		}
		else if (ie5up||nn4||op5){
			jv="1.3";
		}
		else if (ie4){
			jv="1.2";
		}
		return jv;
	})();
	WT.ct="unknown";
	if (document.body&&document.body.addBehavior){
		try{
			document.body.addBehavior("#default#clientCaps");
			WT.ct=document.body.connectionType||"unknown";
			document.body.addBehavior("#default#homePage");
			WT.hp=document.body.isHomePage(location.href)?"1":"0";
		}
		catch(e){
		}
	}
	if (document.all){
		WT.bs=document.body?document.body.offsetWidth+"x"+document.body.offsetHeight:"unknown";
	}
	else{
		WT.bs=window.innerWidth+"x"+window.innerHeight;
	}
	WT.fv=(function(){
		var i,flash;
		if (window.ActiveXObject){
			for(i=15;i>0;i--){
				try{
					flash=new ActiveXObject("ShockwaveFlash.ShockwaveFlash."+i);
					return i+".0";
				}
				catch(e){
				}
			}
		}
		else if (navigator.plugins&&navigator.plugins.length){
			for (i=0;i<navigator.plugins.length;i++){
				if (navigator.plugins[i].name.indexOf('Shockwave Flash')!=-1){
					return navigator.plugins[i].description.split(" ")[2];
				}
			}
		}
		return "Not enabled";
	})();
	WT.slv=(function(){
		var slv="Not enabled";
		try{     
			if (navigator.userAgent.indexOf('MSIE')!=-1){
				var sli = new ActiveXObject('AgControl.AgControl');
				if (sli){
					slv="Unknown";
				}
			}
			else if (navigator.plugins["Silverlight Plug-In"]){
				slv="Unknown";
			}
		}
		catch(e){
		}
		if (slv!="Not enabled"){
			var i,m,M,F;
			if ((typeof(Silverlight)=="object")&&(typeof(Silverlight.isInstalled)=="function")){
				for(i=9;i>0;i--){
					M=i;
					if (Silverlight.isInstalled(M+".0")){
							break;
					}
					if (slv==M){
						break;
					}
				}
				for (m=9;m>=0;m--){
					F=M+"."+m;
					if (Silverlight.isInstalled(F)){
						slv=F;
						break;
					}
					if (slv==F){
						break;
					}
				}
			}
		}
		return slv;
	})();
	if (this.i18n){
		if (typeof(document.defaultCharset)=="string"){
			WT.le=document.defaultCharset;
		} 
		else if (typeof(document.characterSet)=="string"){
			WT.le=document.characterSet;
		}
		else{
			WT.le="unknown";
		}
	}
	WT.tv="9.4.0";
	WT.sp=this.splitvalue;
	WT.dl="0";
	WT.ssl=(window.location.protocol.indexOf('https:')==0)?"1":"0";
	DCS.dcsdat=dCurrent.getTime();
	DCS.dcssip=window.location.hostname;
	DCS.dcsuri=window.location.pathname;
	WT.es=DCS.dcssip+DCS.dcsuri;
	if (window.location.search){
		DCS.dcsqry=window.location.search;
	}
	if (DCS.dcsqry){
		var dcsqry=DCS.dcsqry.toLowerCase();
		var params=this.paidsearchparams.length?this.paidsearchparams.toLowerCase().split(","):[];
		for (var i=0;i<params.length;i++){
			if (dcsqry.indexOf(params[i]+"=")!=-1){
				WT.srch="1";
				break;
			}
		}
	}
	if ((window.document.referrer!="")&&(window.document.referrer!="-")){
		if (!(navigator.appName=="Microsoft Internet Explorer"&&parseInt(navigator.appVersion)<4)){
			DCS.dcsref=window.document.referrer;
		}
	}
}
WebTrends.prototype.dcsEscape=function(S, REL){
	if (REL!=""){
		S=S.toString();
		for (var R in REL){
 			if (REL[R] instanceof RegExp){
				S=S.replace(REL[R],R);
 			}
		}
		return S;
	}
	else{
		return escape(S);
	}
}
WebTrends.prototype.dcsA=function(N,V){
	if (this.i18n&&(this.exre!="")&&!this.exre.test(N)){
		if (N=="dcsqry"){
			var newV="";
			var params=V.substring(1).split("&");
			for (var i=0;i<params.length;i++){
				var pair=params[i];
				var pos=pair.indexOf("=");
				if (pos!=-1){
					var key=pair.substring(0,pos);
					var val=pair.substring(pos+1);
					if (i!=0){
						newV+="&";
					}
					newV+=key+"="+this.dcsEncode(val);
				}
			}
			V=V.substring(0,1)+newV;
		}
		else{
			V=this.dcsEncode(V);
		}
	}
	return "&"+N+"="+this.dcsEscape(V, this.re);
}
WebTrends.prototype.dcsEncode=function(S){
	return (typeof(encodeURIComponent)=="function")?encodeURIComponent(S):escape(S);
}
WebTrends.prototype.dcsCreateImage=function(dcsSrc){
	if (document.images){
		this.images[this.index]=new Image();
		this.images[this.index].src=dcsSrc;
		this.index++;
	}
}
WebTrends.prototype.dcsMeta=function(){
	var elems;
	if (document.documentElement){
		elems=document.getElementsByTagName("meta");
	}
	else if (document.all){
		elems=document.all.tags("meta");
	}
	if (typeof(elems)!="undefined"){
		var length=elems.length;
		for (var i=0;i<length;i++){
			var name=elems.item(i).name;
			var content=elems.item(i).content;
			var equiv=elems.item(i).httpEquiv;
			if (name.length>0){
				if (name.toUpperCase().indexOf("WT.")==0){
					this.WT[name.substring(3)]=content;
				}
				else if (name.toUpperCase().indexOf("DCSEXT.")==0){
					this.DCSext[name.substring(7)]=content;
				}
				else if (name.toUpperCase().indexOf("DCS.")==0){
					this.DCS[name.substring(4)]=content;
				}
			}
		}
	}
}
WebTrends.prototype.dcsTag=function(){
	if (document.cookie.indexOf("WTLOPTOUT=")!=-1){
		return;
	}
	var WT=this.WT;
	var DCS=this.DCS;
	var DCSext=this.DCSext;
	var i18n=this.i18n;
	var P="http"+(window.location.protocol.indexOf('https:')==0?'s':'')+"://"+this.domain+(this.dcsid==""?'':'/'+this.dcsid)+"/dcs.gif?";
	if (i18n){
		WT.dep="";
	}
	for (var N in DCS){
 		if (DCS[N]&&(typeof DCS[N]!="function")){
			P+=this.dcsA(N,DCS[N]);
		}
	}
	for (N in WT){
		if (WT[N]&&(typeof WT[N]!="function")){
			P+=this.dcsA("WT."+N,WT[N]);
		}
	}
	for (N in DCSext){
		if (DCSext[N]&&(typeof DCSext[N]!="function")){
			if (i18n){
				WT.dep=(WT.dep.length==0)?N:(WT.dep+";"+N);
			}
			P+=this.dcsA(N,DCSext[N]);
		}
	}
	if (i18n&&(WT.dep.length>0)){
		P+=this.dcsA("WT.dep",WT.dep);
	}
	if (P.length>2048&&navigator.userAgent.indexOf('MSIE')>=0){
		P=P.substring(0,2040)+"&WT.tu=1";
	}
	this.dcsCreateImage(P);
	this.WT.ad="";
}
WebTrends.prototype.dcsDebug=function(){
	var t=this;
	var i=t.images[0].src;
	var q=i.indexOf("?");
	var r=i.substring(0,q).split("/");
	var m="<b>Protocol</b><br><code>"+r[0]+"<br></code>";
	m+="<b>Domain</b><br><code>"+r[2]+"<br></code>";
	m+="<b>Path</b><br><code>/"+r[3]+"/"+r[4]+"<br></code>";
	m+="<b>Query Params</b><code>"+i.substring(q+1).replace(/\&/g,"<br>")+"</code>";
	m+="<br><b>Cookies</b><br><code>"+document.cookie.replace(/\;/g,"<br>")+"</code>";
	if (t.w&&!t.w.closed){
		t.w.close();
	}
	t.w=window.open("","dcsDebug","width=500,height=650,scrollbars=yes,resizable=yes");
	t.w.document.write(m);
	t.w.focus();
}
WebTrends.prototype.dcsCollect=function(){
    if (this.enabled){
        this.dcsVar();
        this.dcsMeta();
        this.dcsAdv();
        if (typeof(this.dcsCustom)=="function"){
			this.dcsCustom();
        }
        this.dcsTag();
    }
}

function dcsMultiTrack(){
	if (typeof(_tag)!="undefined"){
		return(_tag.dcsMultiTrack());
	}
}

function dcsDebug(){
	if (typeof(_tag)!="undefined"){
		return(_tag.dcsDebug());
	}
}

Function.prototype.wtbind = function(obj){
	var method=this;
	var temp=function(){
		return method.apply(obj,arguments);
	};
	return temp;
};


/* ***************** Credit PROD/Dev  H 27.2 Code ********/
/* San Jose - Remote Code - H Version

	151014 - add fordcreditlink
	151120 - addition of logic for s_account, language
	151125 - change dev suite
	
*/

/************************ ADDITIONAL FEATURES ************************
     Universal Tag
     Plugins
     Cookie Migration
*/

var default_account="fmccreditfcdev"
//var rs="dev"	// For sending data to "DEV" report suite **/
var rs="prod"		// For Sending data to "PROD" report suite

var valid_suites=new Array();
valid_suites[0]="fmccreditfc"
valid_suites[1]="fmccreditln"
valid_suites[2]="fmccreditcanada"
valid_suites[3]="fmccreditprimus"
valid_suites[4]="fmccreditsuzuki"
valid_suites[5]="fmccreditdearborn"
valid_suites[6]="fmccreditmazda"
valid_suites[7]="fmccreditjaguar"
valid_suites[8]="fmccreditvolvo"
valid_suites[9]="fmccreditlandrover"
valid_suites[10]="fmccreditpr"
valid_suites[11]="fmccreditsubaru"
valid_suites[12]="fmccreditfairlane"
valid_suites[13]="fmccreditsecureemail"
valid_suites[14]="fmccreditlncanada"
valid_suites[15]="fmccreditfcmexico"
valid_suites[16]="fmccreditlnmexico"

/* if s_account is set on page */
/*************** Load Account  - Should be set on a page level *****************/
if (typeof s_account == "undefined" || s_account==null || s_account==''){
	var s_account=default_account
}else{
	for (i=0;i<valid_suites.length;i++){
		if(valid_suites[i]==s_account){
			s_account=s_account+rs;
		}
	}
}

/* default s_account */
if(!s_account){
	s_account=default_account
}

var s=s_gi(s_account,1)
/************************** CONFIG SECTION **************************/
/* You may add or alter any code config here. */ 
/* E-commerce Config */
s.currencyCode="USD"
/* Link Tracking Config */
s.trackDownloadLinks=false
s.trackExternalLinks=false
s.trackInlineStats=true
s.linkDownloadFileTypes="exe,zip,wav,mp3,mov,mpg,avi,wmv,doc,pdf,xls"
s.linkInternalFilters="javascript:,credit.lincoln.com,credit.ford.com,fordmotorcredit.com,fordmotorcreditcompany.com,securedcontact.com,fordcredit.ca,mazdacredit.com,jaguarcredit.com,AmericanSuzukiAutomotiveCredit.com,subarucredit.com,primuscredit.com,fairlanecredit.com,fordcreditpr.com,dearborncapitalcorp.com,landrovercredit.com,volvocarfinance.com,acctaccess.com,fordfinancial.com,onlinevehiclefinancing.com,fordcomsearch.ford.com,credito.ford.com,credito.lincoln.com,credit.ford.ca,fordcredit.ca,lincolncanada.ca,lincolncanada.ford.com,ford.mx/ford-credit/,fordcreditlink.com"
s.linkLeaveQueryString=false
s.linkTrackVars="None"
s.linkTrackEvents="None"

/* Plugin Config */
s.usePlugins=true
function s_doPlugins(s) {
/* Add calls to plugins here */
		 
/* Force pageName to Lowercase all sites*/
	if(s.pageName)
		s.pageName=s.pageName.toLowerCase();
		
/* External Campaign Tracking */
	if(!s.campaign){
		if(s.getQueryParam('bannerid'))s.campaign=s.getQueryParam('bannerid')
		s.campaign=s.getCustomValOnce(s.campaign,"cmp_getval",0)
	}

	if(s.campaign){
		s.events=s.apl(s.events,"event53",",",2)
	}
	
	s.prop17=s.getAndPersistValue(s.campaign,'s_p17_pers',90);
  	s.eVar26 = s.prop26 = s.getQueryParam('searchid','');
	s.eVar26=s.getCustomValOnce(s.eVar26,"eVar26_getval",0)
	if(s.eVar26)s.events=s.apl(s.events,"event54",",",2)
	
/* Adobe Social Integration */
	if (!s.eVar60) s.eVar60=s.getQueryParam('scmp');
	s.socialPlatforms();
	
/* Set global campaign ID*/
	if(s.getQueryParam('fmccmp'))s.eVar30=s.getQueryParam('fmccmp');
	s.eVar30=s.getCustomValOnce(s.eVar30,"eVar30_getval",0)
	s.prop30=s.getAndPersistValue(s.eVar30,'s_p30_pers',90);	
        
/* Campaign Path Tracking */
	s.prop19=s.pageName;
	if(s.campaign)
		s.prop19=s.campaign+': '+s.pageName;
	else if(s.eVar30)
		s.prop19=s.eVar30+': '+s.pageName;               

/* Internal Campaign Tracking */
	if(!s.eVar13)
	s.eVar13=s.getQueryParam('intcmp'); 
	s.eVar13=s.getCustomValOnce(s.eVar13,"int_getval",0)
	s.prop13=s.getAndPersistValue(s.eVar13,'s_p13_pers',0);
	
/* Referrer Overide */
	if(s.getQueryParam('referrer'))
		s.referrer=s.getQueryParam('referrer');        

/* Email Campaign Tracking */
	s.eVar33=s.getQueryParam('emailid');
	s.prop33=s.getAndPersistValue(s.eVar33,'s_cp_pers',90);
	s.eVar31=s.getQueryParam('cks');
	s.eVar31=s.getCustomValOnce(s.eVar31,"eVar31_getval",0)

/* TnT Tracking */
	s.prop35=s.pageName;
	if(s.prop32)
		s.prop35=s.prop32 + ': ' + s.pageName;

/* Visit Start Logic */	

	var tempSuite="nosuite"
	if(!s.c_r("s_suite")){s.setSuite(s_account,"s_suite",0);}else{tempSuite=s.c_r("s_suite");}

	if(!s.c_r('v_starting')){
		s_visIdFloodlight('690327','fvflup','adobesvi','u2',1);	
		
		if((!tempSuite.match(s_account))&& tempSuite!=""){
			if(!isInternal()||document.referrer==''){
				s.prop48=s.prop49=s.eVar8=trafficsource();s.prop8=s.getAndPersistValue(s.eVar8,'s_p_s_prop8',0);
				s.eVar36 = s.getCustomValOnce(dt,'ev_36_getval',0);s.events = s.apl(s.events,'event17,event52',',',2);
				var dt=popDT();
			}
		} 
	}
	var expTime=new Date;expTime.setTime(expTime.getTime()+1800000);
	s.c_w('v_starting','nfp',expTime);
		
	if(!tempSuite.match(s_account)){s.setSuite(tempSuite+s_account,"s_suite",0);tempSuite=s.c_r("s_suite");}

 
/* Source of data, must be after traffic source*/ 
	var sod = s.getQueryParam('SourceOfData'); 
	if (sod != '') { 
    	s.prop49 = s.eVar49 = sod; 
    }    
    
	if(s.linkTrackVars=='None'){
		//s.linkTrackVars="prop37,prop39,pageName,eVar52,prop52"
	}else{
		s.linkTrackVars=s.linkTrackVars+",prop37,prop39,pageName,eVar52,prop52"
	}	
	
	if((s.linkTrackVars!='None'&& s.linkTrackVars!='')||s.linkTrackVars.match('prop')||s.linkTrackVars.match('eVar')||s.linkTrackVars.match('evar')||s.linkTrackVars.match('events')){
	
	}
	
   	s.prop37="151125"
   	if(!s.prop39 && s.pageName)s.prop39=s.pageName;
	s.eVar52=s.prop52=document.URL
	s.prop51=s.eVar51="D=UserAgent"
	   
	
/* Language setting	*/ 
	if (document.location.href.indexOf("credito.ford.com")>-1||document.location.href.indexOf("credito.lincoln.com")>-1||document.location.href.indexOf("ford.mx")>-1||document.location.href.indexOf("lincoln.mx")>-1) {
	    s.prop4=s.eVar4='esp';
	}else if (document.location.href.indexOf("fordcredit.ca/fr") >-1 || document.location.href.indexOf("fr.credit.ford.ca")>-1 || s.getQueryParam('lang') == 'FR'){
		s.prop4=s.eVar4='fre';
	}else{
		s.prop4=s.eVar4='eng';
	}
	
	/************************ TNT Integration *************************/
	
	//EVARS
	if (s.eVar2) updateCookie('fc_v1_v10','v2',s.eVar2,365);
	if (s.eVar3){
		updateCookie('fc_v1_v10','v3',s.eVar3,365);
		
		if (s.eVar3.indexOf('registered:') != -1){
			var curr_site='ford';
			if(document.location.hostname.indexOf('lincoln') != -1) curr_site='lincoln';
			updateCookie('cust_owner','v3',curr_site,365);
		}
	}
	
	if (s.eVar9) updateCookie('fc_v1_v10','v9',s.eVar9,365);
	
	if (s.eVar48){
		if (s.eVar48.indexOf('flmc payment estimator') != -1) updateCookie('fc_payest','v48','true',365);
		
		if(s.eVar48.indexOf('test run') != -1){
			if (s.eVar49.indexOf('start') != -1){
				s.events = s.apl(s.events, 'event39', ',', 2);}
			else if (s.eVar49.indexOf('complete') != -1){
				s.events = s.apl(s.events, 'event40', ',', 2);}
		}
	}
	
	//EVENTS
	if (s.events){
	
		if (s.events.match("event39")) updateCookie('fc_ev31_ev40','ev39','none',365);
		if (s.events.match("event40")) updateCookie('fc_ev31_ev40','ev40','none',365);
		
		if (s.events.match("event41")) updateCookie('fc_ev41_ev50','ev41','none',365);
		if (s.events.match("event42")) updateCookie('fc_ev41_ev50','ev42','none',365);

		
		//SPECIAL CASES
		if (s.events.match("event17")) updateCookie('fc_entpg','entpg',s.pageName,365);
		if (s.events.match("event17") && document.referrer != ""){
			var refArray=new Array();refArray = document.referrer.split('/');
			var trimmedRefDom = refArray[2];
			updateCookie('fc_refdom','refdom',trimmedRefDom,365);
		}
	}
	
} //end doPlugins

/*************************************CUSTOM COMMON SITE FUNCTIONS*****************************/

function padFrontZero(val) {
	if (val < 10) return '0'+val; else return val.toString();
}

function popDT() {
	var dte = new Date();
	return dte.getFullYear()+padFrontZero(dte.getMonth()+1)+padFrontZero(dte.getDate())+' '+padFrontZero(dte.getHours());
}


function trafficsource() {

	 var fs = new Array('fmc:ford.com|corporate.ford.com','fmc:fordvehicles.com|www.ford.com|fordenespanol.com','fmc:lincoln.com|lincoln.com|lincolnmercury.com',
      'fmc:mercuryvehicles.com|mercuryvehicles.com','fmc:flmowner.com|flmowner.com','fmc:motocraft.com|motocraft.com','fmc:fordracing.com|fordracing.com',
      'fmc:fordaccessories.com|fordaccessoriesstore.com|fordaccessories.com','fmc:lincolnaccessories.com|lincolnaccessories.com',
      'fmc:mercuryaccessories.com|mercuryaccessories.com','fmc:genuineservice.com|genuineservice.com|genuineflmservice.com|genuinefordservice.com|genuinemercuryservice.com|genuinelincolnservice.com|fordautoclub.com|genuineflmservice.com',
      'fmc:syncmyride.com|syncmyride.com','fmc:fordaxz.com|fordaxz.com','fmc:fordurban.com|fordurban.com',
      'fmc:quicklane.com|quicklane.com|quicklaneservice.com','fmc:dealerconnection.com|.dealerconnection.com',
      'fmc:owneradvantage.com|owneradvantage.com','fmc:fordworksolutions.com|fordworksolutions.com|fordworkssolutions.com',
      'fmc:fordcredit.com|fordcredit.com|acctaccess.com|onlinevehiclefinancing.com|billerweb.com','fmc:fordcpo.com|fordcpo.com','fmc:fordpartsonline.com|fordparts.com|fordpartsonline.com');


	if(s.getQueryParam('referrer')) var ref=s.getQueryParam('referrer') 
	else var ref = document.referrer; 
    
    for (i=0;i<fs.length;i++) {
    var fss = fs[i].split('|');
    	for (j=1;j<fss.length;j++) {
        	if (ref.indexOf(fss[j])>-1){
        		if(refSearch(ref)){ return camp();}else return fss[0];		   
        	}
      	}
    }
  	return camp()
}

function camp(){

	if(s.getQueryParam('referrer')) var ref=s.getQueryParam('referrer') 
	else var ref = document.referrer; 
	
	var fordCamp = s.getQueryParam('fmccmp');
	 
	if(s.getQueryParam('bannerid')) return 'banner';
	else if(s.getQueryParam('emailid')) return 'email';
    else if(s.getQueryParam('searchid')) {s.eVar50 = s.prop50 = "paid:" + s.prop50; return 'search-paid';}
    else if(s.getQueryParam('scmp')) return 'social-placement';
    else if(fordCamp){if (fordCamp.indexOf('t2-fdaf')>-1 || fordCamp.indexOf('t2-lda')>-1){return 'fmc:tier2';}else return 'fmc:other';}
    else if(ref=='') return 'typed-bookmarked';
    else if(refSearch(ref)) {s.eVar50 = s.prop50 = "natural:"+s.prop50; return 'search-natural';}
    else if(refSocial(ref)) return 'social';
    else return 'natural-referrer';
}


function refSearch(ref) {
   	var se = new Array('google.|q','yahoo.com|p','msn.com|q','ask.com|q','myway.com|searchfor','altavista.com|q','netscape.com|query','live.com|q','allthweb.com|q','lycos.com|query','.aol.|q','.aol.|query','suche.aolsvc.de|query','suche.aolsvc.de|q','bing.com|q','ask.jp|q','ask.co|ask','ask.jp|ask','ask.co|q','search.mywebsearch.com|searchfor');

    for (i = 0; i < se.length; i++) {
        var tmp = se[i].split('|');
        var keyword = s.getQueryParam(tmp[1], '', ref);
        if (ref.indexOf(tmp[0]) > -1) {
	        if(keyword == '' && typeof keyword != "undefined")keyword="no keyword"
	   		s.eVar50 = s.prop50 = keyword;
            if (tmp[0] == 'google.') {
                var rnk1 = s.getQueryParam('resnum', '', ref);
                var rnk2 = s.getQueryParam('cd', '', ref);
    
                if (rnk1||rnk2) {
                    s.events = s.apl(s.events, "event50", ",", 1);
                    s.events = s.apl(s.events, "event51", ",", 1);
                   
                    if(rnk1)s.products = s.apl(s.products, ";;;;" + "event50=" + rnk1, ",", 1);
                    if(rnk2)s.products = s.apl(s.products, ";;;;" + "event50=" + rnk2, ",", 1);
                	}
            	}
        
            return true;
        }
    }

    return false;
}

function refSocial(ref) {
   	var socialSites = new Array('12seconds.tv','4travel.jp','advogato.org','ameba.jp','anobii.com','asmallworld.net','backtype.com','badoo.com','bebo.com','bigadda.com','bigtent.com','biip.no','blackplanet.com','blog.seesaa.jp','blogspot.com','blogster.com','blomotion.jp','bolt.com','brightkite.com','buzznet.com','cafemom.com','care2.com','classmates.com','cloob.com','collegeblender.com','cyworld.co.kr','cyworld.com.cn','dailymotion.com','delicious.com','deviantart.com','digg.com','diigo.com','disqus.com','draugiem.lv','facebook.com','faceparty.com','fc2.com','flickr.com','flixster.com','fotolog.com','foursquare.com','friendfeed.com','friendsreunited.com','friendster.com','fubar.com','gaiaonline.com','geni.com','goodreads.com','grono.net','habbo.com','hatena.ne.jp','hi5.com','hotnews.infoseek.co.jp','hyves.nl','ibibo.com','identi.ca','imeem.com','intensedebate.com','irc-galleria.net','iwiw.hu','jaiku.com','jp.myspace.com','kaixin001.com','kaixin002.com','kakaku.com','kanshin.com','kozocom.com','last.fm','linkedin.com','livejournal.com','me2day.net','meetup.com','mister-wong.com','mixi.jp','mixx.com','mouthshut.com','multiply.com','myheritage.com','mylife.com','myspace.com','myyearbook.com','nasza-klasa.pl','netlog.com','nettby.no','netvibes.com','nicovideo.jp','ning.com','odnoklassniki.ru','orkut.com','pakila.jp','photobucket.com','pinterest.com','plaxo.com','plurk.com','plus.google.com','reddit.com','renren.com','skyrock.com','slideshare.net','smcb.jp','smugmug.com','sonico.com','studivz.net','stumbleupon.com','t.163.com','t.co','t.hexun.com','t.ifeng.com','t.people.com.cn','t.qq.com','t.sohu.com','tabelog.com','tagged.com','taringa.net','tripit.com','trombi.com','trytrend.jp','tuenti.com','tumblr.com','twine.com','twitter.com','uhuru.jp','viadeo.com','vimeo.com','vkontakte.ru','vox.com','wayn.com','weibo.com','weourfamily.com','wer-kennt-wen.de','wordpress.com','xanga.com','xing.com','yaplog.jp','yelp.com','youtube.com','yozm.daum.net','yuku.com','zooomr.com');
	
    for (i = 0; i < socialSites.length; i++) {
        if (ref.indexOf(socialSites[i]) > -1) {return true;}
    }
    return false;
}

/* ---------- TNT integration start	-------------*/ 

//tnt cookieRead - reads the cookie, returns the value in that cookie
function cookieRead(cookieName){

	var cvalue =document.cookie
	var carray=cvalue.split(';')
	for (i=0;i<carray.length;i++){
		if(carray[i].indexOf(cookieName)>-1) {
			var cresult=carray[i].split("=")		
			return(cresult[1]);
		}
	}
}
	
//tnt setCookie - sets the cookie. Only used within the updateCookie function
function setCookie(c_name,value,exdays)
{
var temp = location.host.split('.').reverse();
var root_domain = '.' + temp[1] + '.' + temp[0];

var exdate=new Date();
exdate.setDate(exdate.getDate() + exdays);
var c_value=value + ((exdays==null) ? "" : "; expires="+exdate.toUTCString());
document.cookie=c_name + "=" + c_value + "; domain=" + root_domain + "; path=/";
}

//tnt updateCookie - main cookie function to update cookies and values
//note: valueN=the variable name
//note: if value exists, it updates the value. if it does not exist, it appends it to the list
function updateCookie(c_name,valueN,value,exdays)
{
	var cValue=cookieRead(c_name);
	if (value=="" || value==undefined)value='none';
	if(value!=""&& value!=undefined){
	if(cValue== undefined)
	{
		value=valueN+"|"+value
		setCookie(c_name,value,exdays);
		}
	else{
		var exVar=finCookieVal(c_name,valueN)
		if(exVar=="not in the cookie")
			{
	
			value=valueN+"|"+value
			cValue=cValue+","+value
			setCookie(c_name,cValue,exdays);
			}
		else
			{
			cValue=cValue.replace(exVar,value);
			setCookie(c_name,cValue,exdays);
			}
		
		}
	}
		
}

//tnt finCookieVal - returns the value of the individual variable >> it will give me the VALUE of eVarX, not 'eVarX'
function finCookieVal(cookieN,varn){
	var cval= cookieRead(cookieN);
	if(cval==undefined){return "undefined"}
	else{
		if(cval.indexOf(varn)>-1)
		{
		var ar1=cval.split(',')
		for(var i=0;i<ar1.length;i++)
			{
				var ar2=ar1[i].split('|')
				if(ar2[0]==varn)
				return ar2[1];
			}
		}
		else return "not in the cookie"
	}	
}

/* ---------- TNT integration finish -------------*/ 

// function isInternal returns true if the referrer is internal, returns false if it is external
function isInternal(){
	var ref=document.referrer;
	if(ref!=''){
		if(ref.indexOf('www.')>-1)ref=ref.replace('www.','')
		if(ref.indexOf('https://')>-1)ref=ref.replace('https://','')
		if(ref.indexOf('http://')>-1)ref=ref.replace('http://','')	
		var ref1=ref.split('/');
		var refdom=ref1[0];
		
		var filter = s.linkInternalFilters.split(',')
		for(i=0;i<filter.length;i++){
			if(refdom.indexOf(filter[i])>-1)return true	;
		}
	}	

		return false;
}

function omtr_ovf_unload() {

  var metrsec = ['','','',''];
  var viewonly = true;
  var prop48=prop49=apptype='';

  function checkval(fv,sec,fld) {
    if (fv=="") {
      metrsec[sec-1]+=','+fld;
    } else {
      viewonly = false;
    }
  }

	var f = document.dataEntry;
		
	checkval(f.prFirstName.value,1,'a');
	checkval(f.prLastName.value,1,'b');
	checkval(f.prStreet.value,1,'c');
	checkval(f.prCity.value,1,'d');
	checkval(f.prState.value,1,'e');
	checkval(f.prZipCode.value,1,'f');
	checkval(f.prHomeMonthlyPayment.value,1,'g');
	checkval(f.prYearsAtAddress.value+f.prMonthAtAddress.value,1,'h');
	checkval(f.prEmail.value,1,'i');
	checkval(f.prConfirmEmail.value,1,'j');
	checkval(f.prPhNumber1.value+f.prPhNumber2.value+f.prPhNumber3.value,1,'k');
	checkval(f.prSSN1.value+f.prSSN2.value+f.prSSN3.value,1,'l');
	checkval(f.prDOBMM.value+f.prDOBDD.value+f.prDOBYY.value,1,'m');	
	checkval(f.prGrossAnnualIncome.value,2,'a');
	if (f.prRetiredFlag[1].checked) {
    checkval(f.prOccupation.value,2,'b');
    checkval(f.prEmployerName.value,2,'c');
    checkval(f.prYearsOnJob.value+f.prMonthsOnJob.value,2,'d');
    checkval(f.prWorkPh1.value+f.prWorkPh2.value+f.prWorkPh3.value,2,'e');
  }
	
	if (f.applicationType[1].checked) {
    prop48 = 'ovf app detail - joint';
    apptype = 'ovfj-';
    checkval(f.coFirstName.value,3,'a');
    checkval(f.coLastName.value,3,'b');
    checkval(f.coStreet.value,3,'c');
    checkval(f.coCity.value,3,'d');
    checkval(f.coState.value,3,'e');
    checkval(f.coZipCode.value,3,'f');
    checkval(f.coHomeMonthlyPayment.value,3,'g');
    checkval(f.coYearsAtAddress.value+f.coMonthAtAddress.value,3,'h');
    checkval(f.coEmail.value,3,'i');
    checkval(f.coConfirmEmail.value,3,'j');
    checkval(f.coPhNumber1.value+f.coPhNumber2.value+f.coPhNumber3.value,3,'k');
    checkval(f.coSSN1.value+f.coSSN2.value+f.coSSN3.value,3,'l');
    checkval(f.coDOBMM.value+f.coDOBDD.value+f.coDOBYY.value,3,'m');
	if (f.relationshipCode.options[0].selected==true)
		checkval('',3,'n');
    checkval(f.coGrossAnnualIncome.value,4,'a');
    if (f.coRetiredFlag[1].checked) {
      checkval(f.coOccupation.value,4,'b');
      checkval(f.coEmployerName.value,4,'c');
      checkval(f.coYearsOnJob.value+f.coMonthsOnJob.value,4,'d');
      checkval(f.coWorkPh1.value+f.coWorkPh2.value+f.coWorkPh3.value,4,'e');
      }
	} else 
	{
    prop48 = 'ovf app detail - individual';
    apptype = 'ovfi-';
	}
	
	if (viewonly) {
   prop49 = 'zero data';
	} else {
    var i;
    for (i=0;i<4;i++)
    {
      if (metrsec[i].length>1) {
        metrsec[i] = metrsec[i].substring(1);
       prop49+=(i+1)+':'+metrsec[i]+';';
       }
    }
	}
	
	if (prop49!='') {
    var scf = s_gi(s_account);
    scf.linkTrackVars = "prop48,prop49";
    scf.prop48 = prop48;
    scf.prop49 = apptype+prop49;
    scf.tl(this,"o","Credit Form Analysis");
  }

}


s.doPlugins=s_doPlugins
/************************** PLUGINS SECTION *************************/
/* You may insert any plugins you wish to use here.                 */

/* Floodlight Tag Generation Plugin v0.1 */
s_visIdFloodlight = function (ds, dt, dc, dn, ep) {

    if (!ep || ep != 1) {
        var isFirstPage = s.getVisitStart('s_visit');
    }
    if (ep == 1 || isFirstPage == 1) {
        var dviCookie = s.c_r('s_fid');
        var visRegExp = /[0-9A-F]+-[0-9A-F]+/g;
        var dvi = dviCookie.match(visRegExp);
        var pr = location.protocol;
        var du = pr + '//fls.doubleclick.net/activityi;src=' + ds + ';type=' + dt + ';cat=' + dc + ';' + dn + '=';
        if (dvi) {
            s_dfaCall(du, dvi);
        } else {
            setTimeout('s_dfaCall(\'' + du + '\')', 4000);
        }
    }
}
s_dfaCall = function (du, dvi) {
      s.prop60 = s.c_r('s_fid');
      if(!dvi) {
		var dviCookie = s.c_r('s_fid');
		var visRegExp = /[0-9A-F]+-[0-9A-F]+/g;
		var dvi = dviCookie.match(visRegExp);
      }
      var axel = Math.random() + '';
      var a = axel * 10000000000000;
      dfaUrl = du + dvi + ';ord=' + a + '?';
      var createIframe = document.createElement('iframe');
      createIframe.setAttribute('src', dfaUrl);
      createIframe.setAttribute('width', '1');
      createIframe.setAttribute('height', '1');
      createIframe.setAttribute('frameborder', '0');
      createIframe.setAttribute('style', 'display:none');
      document.getElementsByTagName('body')[0].appendChild(createIframe);
}

/*
 * Plugin Utility: Replace v1.0
 */
s.repl=new Function("x","o","n",""
+"var i=x.indexOf(o),l=n.length;while(x&&i>=0){x=x.substring(0,i)+n+x."
+"substring(i+o.length);i=x.indexOf(o,i+l)}return x");

/*
 * Plugin: socialPlatforms v1.1
 */
s.socialPlatforms=new Function("a",""
+"var s=this,g,K,D,E,F,i;g=s.referrer?s.referrer:document.referrer;g=g."
+"toLowerCase();K=s.split(s.socPlatList,'|');for(i=0;i<K.length;i++){"
+"D=s.split(K[i],'>');if(g.indexOf(D[0])!=-1){s.contextData['a.socialcontentprovider']=D[1];}}");
 
s.socPlatList="facebook.com>Facebook|twitter.com>Twitter|t.co/>Twitter|youtube.com>Youtube|clipmarks.com>Clipmarks|dailymotion.com>Dailymotion|delicious.com>Delicious|digg.com>Digg|diigo.com>Diigo|flickr.com>Flickr|flixster.com>Flixster|fotolog.com>Fotolog|friendfeed.com>FriendFeed|google.com/buzz>Google Buzz|buzz.googleapis.com>Google Buzz|plus.google.com>Google+|hulu.com>Hulu|identi.ca>identi.ca|ilike.com>iLike|intensedebate.com>IntenseDebate|myspace.com>MySpace|newsgator.com>Newsgator|photobucket.com>Photobucket|plurk.com>Plurk|slideshare.net>SlideShare|smugmug.com>SmugMug|stumbleupon.com>StumbleUpon|tumblr.com>Tumblr|vimeo.com>Vimeo|wordpress.com>WordPress|xanga.com>Xanga|metacafe.com>Metacafe|pinterest.com>Pinterest";

/*  
 * socialAuthors v1.5.2
 */
s.socialAuthors=new Function("",""
+"var s=this,g;g=s.referrer?s.referrer:document.referrer;if(g.indexOf"
+"('http://t.co/')===0||g.indexOf('https://t.co/')===0||g.indexOf('pi"
+"nterest.com/pin')!==-1||g.indexOf('tumblr.com')!==-1||g.indexOf('yo"
+"utube.com')!==-1){s.Integrate.add('SocialAuthor');s.Integrate.Socia"
+"lAuthor.tEvar='reserved';s.Integrate.SocialAuthor.get('http://sa-se"
+"rvices.social.omniture.com/author/name?var=[VAR]&callback=s.socialA"
+"uthorSearch&rs='+encodeURIComponent(s_account)+'&q='+encodeURICompo"
+"nent(g));s.Integrate.SocialAuthor.delay();s.Integrate.SocialAuthor."
+"setVars=function(s,p){if(p.tEvar==='reserved'){s.contextData['a.soc"
+"ialauthor']=s.user;}else{s[p.tEvar]=s.user;}}}");
s.socialAuthorSearch=new Function("obj",""
+"var s=this;if(typeof obj==='undefined'||typeof obj.author==='undefi"
+"ned'){s.user='Not Found';}else{s.user=obj.author;}s.Integrate.Socia"
+"lAuthor.ready();");

/*
* Plugin Utility: apl v1.1
*/
s.apl = new Function("l", "v", "d", "u", ""
+ "var s=this,m=0;if(!l)l='';if(u){var i,n,a=s.split(l,d);for(i=0;i<a."
+ "length;i++){n=a[i];m=m||(u==1?(n==v):(n.toLowerCase()==v.toLowerCas"
+ "e()));}}if(!m)l=l?l+d+v:v;return l");

/*
* Utility Function: split v1.5 (JS 1.0 compatible)
*/
s.split = new Function("l", "d", ""
+ "var i,x=0,a=new Array;while(l){i=l.indexOf(d);i=i>-1?i:l.length;a[x"
+ "++]=l.substring(0,i);l=l.substring(i+d.length);}return a");


/*
 * Plugin: Set Suite
 */
s.setSuite=new Function("v","c","e",""
+"var s=this,k=s.c_r(c),a=new Date;e=e?e:0;if(v){a.setTime(a.getTime("
+")+1800000);s.c_w(c,v,a);}else{v='novalue';a.setTime(a.getTime()+1800000);s.c_w(c,v,a);}");

/*
 * Plugin: getQueryParam 2.3
 */
s.getQueryParam=new Function("p","d","u",""
+"var s=this,v='',i,t;d=d?d:'';u=u?u:(s.pageURL?s.pageURL:s.wd.locati"
+"on);if(u=='f')u=s.gtfs().location;while(p){i=p.indexOf(',');i=i<0?p"
+".length:i;t=s.p_gpv(p.substring(0,i),u+'');if(t){t=t.indexOf('#')>-"
+"1?t.substring(0,t.indexOf('#')):t;}if(t)v+=v?d+t:t;p=p.substring(i="
+"=p.length?i:i+1)}return v");
s.p_gpv=new Function("k","u",""
+"var s=this,v='',i=u.indexOf('?'),q;if(k&&i>-1){q=u.substring(i+1);v"
+"=s.pt(q,'&','p_gvf',k)}return v");
s.p_gvf=new Function("t","k",""
+"if(t){var s=this,i=t.indexOf('='),p=i<0?t:t.substring(0,i),v=i<0?'T"
+"rue':t.substring(i+1);if(p.toLowerCase()==k.toLowerCase())return s."
+"epa(v)}return ''");
/*
 * Plugin: getCustomValOnce 
 */
s.getCustomValOnce=new Function("v","c","e",""
+"var s=this,k=s.c_r(c),a=new Date;e=e?e:0;if(v){a.setTime(a.getTime("
+")+1800000);if(!s.c_w(c,v,a))s.c_w(c,v,0);}else{a.setTime(a.getTime()+1800000);v=s.c_r(c);if(!s.c_w(c,v,a))s.c_w(c,v,a);}return v==k?'':v");

/*
 * Plugin: getAndPersistValue 0.3 - get a value on every page
 */
s.getAndPersistValue=new Function("v","c","e",""
+"var s=this,a=new Date;e=e?e:0;a.setTime(a.getTime()+e*86400000);if("
+"v)s.c_w(c,v,e?a:0);return s.c_r(c);");

s.join = new Function("v","p",""
+"var s = this;var f,b,d,w;if(p){f=p.front?p.front:'';b=p.back?p.back"
+":'';d=p.delim?p.delim:'';w=p.wrap?p.wrap:'';}var str='';for(var x=0"
+";x<v.length;x++){if(typeof(v[x])=='object' )str+=s.join( v[x],p);el"
+"se str+=w+v[x]+w;if(x<v.length-1)str+=d;}return f+str+b;");

/*
 * Plugin: getVisitStart v2.0 - returns 1 on first page of visit
 * otherwise 0
 */
s.getVisitStart=new Function("c",""
+"var s=this,v=1,t=new Date;t.setTime(t.getTime()+1800000);if(s.c_r(c"
+")){v=0}if(!s.c_w(c,1,t)){s.c_w(c,1,0)}if(!s.c_r(c)){v=0}return v;"); 

/* Configure Modules and Plugins */

s.maxDelay='3000';
s.loadModule("Integrate")
s.Integrate.onLoad=function(s,m){
	s.socialAuthors();
	//add other integration module dependent functions here
 };

/* WARNING: Changing any of the below variables will cause drastic
changes to how your visitor data is collected.  Changes should only be
made when instructed to do so by your account manager.*/
s.visitorNamespace="ford"
s.trackingServer="metrics.ford.com"
s.trackingServerSecure="smetrics.ford.com"
s.dc="112"
s.vmk="4A43B06B"

/* Configure Modules and Plugins */

s.loadModule("Media")
s.Media.autoTrack=false
s.Media.trackVars="None"
s.Media.trackEvents="None"

/****************************** MODULES *****************************/
/* Module: Media */
s.m_Media_c="(`OWhilePlaying~='s_media_'+m._in+'_~unc^D(~;`E~m.ae(mn,l,\"'+p+'\",~){var m=this~o;w.percent=((w.off^e+1)/w`X)*100;w.percent=w.percent>1~o.'+f~=new ~o.Get~:Math.floor(w.percent);w.timeP"
+"layed=i.t~}`x p');p=tcf(o)~Time~x,x!=2?p:-1,o)}~if(~m.monitor)m.monitor(m.s,w)}~m.s.d.getElementsByTagName~ersionInfo~'^N_c_il['+m._in+'],~'o','var e,p=~else~i.to~=Math.floor(~}catch(e){p=~m.track~"
+"s.wd.addEventListener~.name~m.s.rep(~layState~||^8~Object~m.s.wd[f1]~^A+=i.t+d+i.s+d+~.length~parseInt(~Player '+~s.wd.attachEvent~'a','b',c~Media~pe='m~;o[f1]~m.s.isie~.current~);i.~p<p2||p-p2>5)~"
+".event=~m.close~i.lo~vo.linkTrack~=v+',n,~.open~){w.off^e=~;n=m.cn(n);~){this.e(n,~v=e='None';~Quick~MovieName()~);o[f~out(\"'+v+';~return~1000~i.lx~m.ol~o.controls~m.s.ape(i.~load',m.as~)}};m.~scr"
+"ipt';x.~,t;try{t=~Version()~n==~'--**--',~pev3~o.id~i.ts~tion~){mn=~1;o[f7]=~();~(x==~){p='~&&m.l~l[n])~:'')+i.e~':'E')+o~var m=s~!p){tcf~xc=m.s.~Title()~()/~7+'~+1)/i.l~;i.e=''~3,p,o);~m.l[n]=~Dat"
+"e~5000~;if~i.lt~';c2='~tm.get~Events~set~Change~)};m~',f~(x!=~4+'=n;~~^N.m_i('`c');m.cn=f`2n`5;`x `Rm.s.rep(`Rn,\"\\n\",''),\"\\r\",''),^9''^g`o=f`2n,l,p,b`5,i`8`U,tm`8^X,a='',x`ql=`Yl)`3!l)l=1`3n&"
+"&p){`E!m.l)m.l`8`U`3m.^K`k(n)`3b&&b.id)a=b.id;for (x in m.l)`Em.l[x]^J[x].a==a)`k(m.l[x].n`hn=n;i.l=l;i.p=m.cn(p`ha=a;i.t=0;^C=0;i.s`M^c`C^R`y`hlx=0;^a=i.s;`l=0^U;`L=-1;^Wi}};`k=f`2n`r0,-1^g.play=f"
+"`2n,o`5,i;i=m.e(n,1,o`hm`8F`2`Ii`3m.l){i=m.l[\"'+`Ri.n,'\"','\\\\\"')+'\"]`3i){`E`z==1)m.e(i.n,3,-1`hmt=^e`Cout(i.m,^Y)}}'`hm(^g.stop=f`2n,o`r2,o)};`O=f`2n`5^Z `0) {m.e(n,4,-1^4e=f`2n,x,o`5,i,tm`8^"
+"X,ts`M^c`C^R`y),ti=`OSeconds,tp=`OMilestones,z`8Array,j,d=^9t=1,b,v=`OVars,e=`O^d,`dedia',^A,w`8`U,vo`8`U`qi=n^J&&m.l[n]?m.l[n]:0`3i){w`Q=n;w`X=i.l;w.playerName=i.p`3`L<0)w`j\"OPEN\";`K w`j^H1?\"PL"
+"AY\":^H2?\"STOP\":^H3?\"MONITOR\":\"CLOSE\")));w`o`C`8^X^Gw`o`C.^e`C(i.s*`y)`3x>2||^i`z&&^i2||`z==1))) {b=\"`c.\"+name;^A = ^2n)+d+i.l+d+^2p)+d`3x){`Eo<0&&^a>0){o=(ts-^a)+`l;o=o<i.l?o:i.l-1}o`Mo)`3"
+"x>=2&&`l<o){i.t+=o-`l;^C+=o-`l;}`Ex<=2){i.e+=^H1?'S^M;`z=x;}`K `E`z!=1)m.e(n,1,o`hlt=ts;`l=o;`W`0&&`L>=0?'L'+`L^L+^i2?`0?'L^M:'')^Z`0){b=0;`d_o'`3x!=4`p`600?100`A`3`F`E`L<0)`d_s';`K `Ex==4)`d_i';`K"
+"{t=0;`sti=ti?`Yti):0;z=tp?m.s.sp(tp,','):0`3ti&&^C>=ti)t=1;`K `Ez){`Eo<`L)`L=o;`K{for(j=0;j<z`X;j++){ti=z[j]?`Yz[j]):0`3ti&&((`L^T<ti/100)&&((o^T>=ti/100)){t=1;j=z`X}}}}}}}`K{m.e(n,2,-1)^Z`0`pi.l`6"
+"00?100`A`3`F^W0`3i.e){`W`0&&`L>=0?'L'+`L^L^Z`0){`s`d_o'}`K{t=0;m.s.fbr(b)}}`K t=0;b=0}`Et){`mVars=v;`m^d=e;vo.pe=pe;vo.^A=^A;m.s.t(vo,b)^Z`0){^C=0;`L=o^U}}}}`x i};m.ae=f`2n,l,p,x,o,b){`En&&p`5`3!m."
+"l||!m.^Km`o(n,l,p,b);m.e(n,x,o^4a=f`2o,t`5,i=^B?^B:o`Q,n=o`Q,p=0,v,c,c1,c2,^Ph,x,e,f1,f2`1oc^h3`1t^h4`1s^h5`1l^h6`1m^h7`1c',tcf,w`3!i){`E!m.c)m.c=0;i`1'+m.c;m.c++}`E!^B)^B=i`3!o`Q)o`Q=n=i`3!^0)^0`8"
+"`U`3^0[i])`x;^0[i]=o`3!xc)^Pb;tcf`8F`2`J0;try{`Eo.v`H&&o`g`c&&^1)p=1`N0`B`3^O`8F`2`J0^6`9`t`C^7`3t)p=2`N0`B`3^O`8F`2`J0^6`9V`H()`3t)p=3`N0`B}}v=\"^N_c_il[\"+m._in+\"],o=^0['\"+i+\"']\"`3p==1^IWindo"
+"ws `c `Zo.v`H;c1`np,l,x=-1,cm,c,mn`3o){cm=o`g`c;c=^1`3cm&&c^Ecm`Q?cm`Q:c.URL;l=cm.dura^D;p=c`gPosi^D;n=o.p`S`3n){`E^88)x=0`3^83)x=1`3^81`T2`T4`T5`T6)x=2;}^b`Ex>=0)`4`D}';c=c1+c2`3`f&&xc){x=m.s.d.cr"
+"eateElement('script');x.language='j^5type='text/java^5htmlFor=i;x`j'P`S^f(NewState)';x.defer=true;x.text=c;xc.appendChild(x`v6]`8F`2c1+'`E^83){x=3;'+c2+'}^e`Cout(`76+',^Y)'`v6]()}}`Ep==2^I`t`C `Z(`"
+"9Is`t`CRegistered()?'Pro ':'')+`9`t`C^7;f1=f2;c`nx,t,l,p,p2,mn`3o^E`9`u?`9`u:`9URL^Gn=`9Rate^Gt=`9`CScale^Gl=`9Dura^D^Rt;p=`9`C^Rt;p2=`75+'`3n!=`74+'||`i{x=2`3n!=0)x=1;`K `Ep>=l)x=0`3`i`42,p2,o);`4"
+"`D`En>0&&`7^S>=10){`4^V`7^S=0}`7^S++;`7^j`75+'=p;^e`C`w`72+'(0,0)\",500)}'`e`8F`2`b`v4]=-^F0`e(0,0)}`Ep==3^IReal`Z`9V`H^Gf1=n+'_OnP`S^f';c1`nx=-1,l,p,mn`3o^E`9^Q?`9^Q:`9Source^Gn=`9P`S^Gl=`9Length^"
+"R`y;p=`9Posi^D^R`y`3n!=`74+'){`E^83)x=1`3^80`T2`T4`T5)x=2`3^80&&(p>=l||p==0))x=0`3x>=0)`4`D`E^83&&(`7^S>=10||!`73+')){`4^V`7^S=0}`7^S++;`7^j^b`E`72+')`72+'(o,n)}'`3`V)o[f2]=`V;`V`8F`2`b1+c2)`e`8F`2"
+"`b1+'^e`C`w`71+'(0,0)\",`73+'?500:^Y);'+c2`v4]=-1`3`f)o[f3]=^F0`e(0,0^4as`8F`2'e',`Il,n`3m.autoTrack&&`G){l=`G(`f?\"OBJECT\":\"EMBED\")`3l)for(n=0;n<l`X;n++)m.a(^K;}')`3`a)`a('on^3);`K `E`P)`P('^3,"
+"false)";
s.m_i("Media");

/* Module: Integrate */
s.m_Integrate_c="var m=s.m_i('Integrate');m.add=function(n,o){var m=this,p;if(!o)o='s_Integrate_'+n;if(!m.s.wd[o])m.s.wd[o]=new Object;m[n]=new Object;p=m[n];p._n=n;p._m=m;p._c=0;p._d=0;p.disable=0;p"
+".get=m.get;p.delay=m.delay;p.ready=m.ready;p.beacon=m.beacon;p.script=m.script;m.l[m.l.length]=n};m._g=function(t){var m=this,s=m.s,i,p,f=(t?'use':'set')+'Vars',tcf;for(i=0;i<m.l.length;i++){p=m[m."
+"l[i]];if(p&&!p.disable&&p[f]){if(s.apv>=5&&(!s.isopera||s.apv>=7)){tcf=new Function('s','p','f','var e;try{p[f](s,p)}catch(e){}');tcf(s,p,f)}else p[f](s,p)}}};m._t=function(){this._g(1)};m._fu=func"
+"tion(p,u){var m=this,s=m.s,v,x,y,z,tm=new Date;if(u.toLowerCase().substring(0,4) != 'http')u='http://'+u;if(s.ssl)u=s.rep(u,'http:','https:');p.RAND=Math&&Math.random?Math.floor(Math.random()*10000"
+"000000000):tm.getTime();p.RAND+=Math.floor(tm.getTime()/10800000)%10;x=0;while(x>=0){x=u.indexOf('[',x);if(x>=0){y=u.indexOf(']',x);if(y>x){z=u.substring(x+1,y);if(z.length>2&&z.substring(0,2)=='s."
+"'){v=s[z.substring(2)];if(!v)v=''}else{v=''+p[z];if(!(v==p[z]||parseFloat(v)==p[z]))z=0}if(z) {u=u.substring(0,x)+s.rep(escape(v),'+','%2B')+u.substring(y+1);x=y-(z.length-v.length+1)} else {x=y}}}"
+"}return u};m.get=function(u,v){var p=this,m=p._m;if(!p.disable){if(!v)v='s_'+m._in+'_Integrate_'+p._n+'_get_'+p._c;p._c++;p.VAR=v;p._d++;m.s.loadModule('Integrate:'+v,m._fu(p,u),0,1,p._n)}};m.delay"
+"=function(){var p=this;if(p._d<=0)p._d=1};m.ready=function(){var p=this,m=p._m;p._d=0;if(!p.disable)m.s.dlt()};m._d=function(){var m=this,i,p;for(i=0;i<m.l.length;i++){p=m[m.l[i]];if(p&&!p.disable&"
+"&p._d>0)return 1}return 0};m._x=function(d,n){var p=this[n],x;if(!p.disable){for(x in d)if(x&&(!Object||!Object.prototype||!Object.prototype[x]))p[x]=d[x];p._d--}};m.beacon=function(u){var p=this,m"
+"=p._m,s=m.s,imn='s_i_'+m._in+'_Integrate_'+p._n+'_'+p._c,im;if(!p.disable&&s.d.images&&s.apv>=3&&(!s.isopera||s.apv>=7)&&(s.ns6<0||s.apv>=6.1)){p._c++;im=s.wd[imn]=new Image;im.src=m._fu(p,u)}};m.s"
+"cript=function(u){var p=this,m=p._m;if(!p.disable)m.s.loadModule(0,m._fu(p,u),0,1)};m.l=new Array;if(m.onLoad)m.onLoad(s,m)";
s.m_i("Integrate");

/************* DO NOT ALTER ANYTHING BELOW THIS LINE ! **************/
var s_code='',s_objectID;function s_gi(un,pg,ss){var c="s.version='H.27.2';s.an=s_an;s.logDebug=function(m){var s=this,tcf=new Function('var e;try{console.log(\"'+s.rep(s.rep(s.rep(m,\"\\\\\",\"\\\\"
+"\\\\\"),\"\\n\",\"\\\\n\"),\"\\\"\",\"\\\\\\\"\")+'\");}catch(e){}');tcf()};s.cls=function(x,c){var i,y='';if(!c)c=this.an;for(i=0;i<x.length;i++){n=x.substring(i,i+1);if(c.indexOf(n)>=0)y+=n}retur"
+"n y};s.fl=function(x,l){return x?(''+x).substring(0,l):x};s.co=function(o){return o};s.num=function(x){x=''+x;for(var p=0;p<x.length;p++)if(('0123456789').indexOf(x.substring(p,p+1))<0)return 0;ret"
+"urn 1};s.rep=s_rep;s.sp=s_sp;s.jn=s_jn;s.ape=function(x){var s=this,h='0123456789ABCDEF',f=\"+~!*()'\",i,c=s.charSet,n,l,e,y='';c=c?c.toUpperCase():'';if(x){x=''+x;if(s.em==3){x=encodeURIComponent("
+"x);for(i=0;i<f.length;i++) {n=f.substring(i,i+1);if(x.indexOf(n)>=0)x=s.rep(x,n,\"%\"+n.charCodeAt(0).toString(16).toUpperCase())}}else if(c=='AUTO'&&('').charCodeAt){for(i=0;i<x.length;i++){c=x.su"
+"bstring(i,i+1);n=x.charCodeAt(i);if(n>127){l=0;e='';while(n||l<4){e=h.substring(n%16,n%16+1)+e;n=(n-n%16)/16;l++}y+='%u'+e}else if(c=='+')y+='%2B';else y+=escape(c)}x=y}else x=s.rep(escape(''+x),'+"
+"','%2B');if(c&&c!='AUTO'&&s.em==1&&x.indexOf('%u')<0&&x.indexOf('%U')<0){i=x.indexOf('%');while(i>=0){i++;if(h.substring(8).indexOf(x.substring(i,i+1).toUpperCase())>=0)return x.substring(0,i)+'u00"
+"'+x.substring(i);i=x.indexOf('%',i)}}}return x};s.epa=function(x){var s=this,y,tcf;if(x){x=s.rep(''+x,'+',' ');if(s.em==3){tcf=new Function('x','var y,e;try{y=decodeURIComponent(x)}catch(e){y=unesc"
+"ape(x)}return y');return tcf(x)}else return unescape(x)}return y};s.pt=function(x,d,f,a){var s=this,t=x,z=0,y,r;while(t){y=t.indexOf(d);y=y<0?t.length:y;t=t.substring(0,y);r=s[f](t,a);if(r)return r"
+";z+=y+d.length;t=x.substring(z,x.length);t=z<x.length?t:''}return ''};s.isf=function(t,a){var c=a.indexOf(':');if(c>=0)a=a.substring(0,c);c=a.indexOf('=');if(c>=0)a=a.substring(0,c);if(t.substring("
+"0,2)=='s_')t=t.substring(2);return (t!=''&&t==a)};s.fsf=function(t,a){var s=this;if(s.pt(a,',','isf',t))s.fsg+=(s.fsg!=''?',':'')+t;return 0};s.fs=function(x,f){var s=this;s.fsg='';s.pt(x,',','fsf'"
+",f);return s.fsg};s.mpc=function(m,a){var s=this,c,l,n,v;v=s.d.visibilityState;if(!v)v=s.d.webkitVisibilityState;if(v&&v=='prerender'){if(!s.mpq){s.mpq=new Array;l=s.sp('webkitvisibilitychange,visi"
+"bilitychange',',');for(n=0;n<l.length;n++){s.d.addEventListener(l[n],new Function('var s=s_c_il['+s._in+'],c,v;v=s.d.visibilityState;if(!v)v=s.d.webkitVisibilityState;if(s.mpq&&v==\"visible\"){whil"
+"e(s.mpq.length>0){c=s.mpq.shift();s[c.m].apply(s,c.a)}s.mpq=0}'),false)}}c=new Object;c.m=m;c.a=a;s.mpq.push(c);return 1}return 0};s.si=function(){var s=this,i,k,v,c=s_gi+'var s=s_gi(\"'+s.oun+'\")"
+";s.sa(\"'+s.un+'\");';for(i=0;i<s.va_g.length;i++){k=s.va_g[i];v=s[k];if(v!=undefined){if(typeof(v)!='number')c+='s.'+k+'=\"'+s_fe(v)+'\";';else c+='s.'+k+'='+v+';'}}c+=\"s.lnk=s.eo=s.linkName=s.li"
+"nkType=s.wd.s_objectID=s.ppu=s.pe=s.pev1=s.pev2=s.pev3='';\";return c};s.c_d='';s.c_gdf=function(t,a){var s=this;if(!s.num(t))return 1;return 0};s.c_gd=function(){var s=this,d=s.wd.location.hostnam"
+"e,n=s.fpCookieDomainPeriods,p;if(!n)n=s.cookieDomainPeriods;if(d&&!s.c_d){n=n?parseInt(n):2;n=n>2?n:2;p=d.lastIndexOf('.');if(p>=0){while(p>=0&&n>1){p=d.lastIndexOf('.',p-1);n--}s.c_d=p>0&&s.pt(d,'"
+".','c_gdf',0)?d.substring(p):d}}return s.c_d};s.c_r=function(k){var s=this;k=s.ape(k);var c=' '+s.d.cookie,i=c.indexOf(' '+k+'='),e=i<0?i:c.indexOf(';',i),v=i<0?'':s.epa(c.substring(i+2+k.length,e<"
+"0?c.length:e));return v!='[[B]]'?v:''};s.c_w=function(k,v,e){var s=this,d=s.c_gd(),l=s.cookieLifetime,t;v=''+v;l=l?(''+l).toUpperCase():'';if(e&&l!='SESSION'&&l!='NONE'){t=(v!=''?parseInt(l?l:0):-6"
+"0);if(t){e=new Date;e.setTime(e.getTime()+(t*1000))}}if(k&&l!='NONE'){s.d.cookie=k+'='+s.ape(v!=''?v:'[[B]]')+'; path=/;'+(e&&l!='SESSION'?' expires='+e.toGMTString()+';':'')+(d?' domain='+d+';':''"
+");return s.c_r(k)==v}return 0};s.eh=function(o,e,r,f){var s=this,b='s_'+e+'_'+s._in,n=-1,l,i,x;if(!s.ehl)s.ehl=new Array;l=s.ehl;for(i=0;i<l.length&&n<0;i++){if(l[i].o==o&&l[i].e==e)n=i}if(n<0){n=i"
+";l[n]=new Object}x=l[n];x.o=o;x.e=e;f=r?x.b:f;if(r||f){x.b=r?0:o[e];x.o[e]=f}if(x.b){x.o[b]=x.b;return b}return 0};s.cet=function(f,a,t,o,b){var s=this,r,tcf;if(s.apv>=5&&(!s.isopera||s.apv>=7)){tc"
+"f=new Function('s','f','a','t','var e,r;try{r=s[f](a)}catch(e){r=s[t](e)}return r');r=tcf(s,f,a,t)}else{if(s.ismac&&s.u.indexOf('MSIE 4')>=0)r=s[b](a);else{s.eh(s.wd,'onerror',0,o);r=s[f](a);s.eh(s"
+".wd,'onerror',1)}}return r};s.gtfset=function(e){var s=this;return s.tfs};s.gtfsoe=new Function('e','var s=s_c_il['+s._in+'],c;s.eh(window,\"onerror\",1);s.etfs=1;c=s.t();if(c)s.d.write(c);s.etfs=0"
+";return true');s.gtfsfb=function(a){return window};s.gtfsf=function(w){var s=this,p=w.parent,l=w.location;s.tfs=w;if(p&&p.location!=l&&p.location.host==l.host){s.tfs=p;return s.gtfsf(s.tfs)}return "
+"s.tfs};s.gtfs=function(){var s=this;if(!s.tfs){s.tfs=s.wd;if(!s.etfs)s.tfs=s.cet('gtfsf',s.tfs,'gtfset',s.gtfsoe,'gtfsfb')}return s.tfs};s.mrq=function(u){var s=this,l=s.rl[u],n,r;s.rl[u]=0;if(l)fo"
+"r(n=0;n<l.length;n++){r=l[n];s.mr(0,0,r.r,r.t,r.u)}};s.flushBufferedRequests=function(){};s.mr=function(sess,q,rs,ta,u){var s=this,dc=s.dc,t1=s.trackingServer,t2=s.trackingServerSecure,tb=s.trackin"
+"gServerBase,p='.sc',ns=s.visitorNamespace,un=s.cls(u?u:(ns?ns:s.fun)),r=new Object,l,imn='s_i_'+s._in+'_'+un,im,b,e;if(!rs){if(t1){if(t2&&s.ssl)t1=t2}else{if(!tb)tb='2o7.net';if(dc)dc=(''+dc).toLow"
+"erCase();else dc='d1';if(tb=='2o7.net'){if(dc=='d1')dc='112';else if(dc=='d2')dc='122';p=''}t1=un+'.'+dc+'.'+p+tb}rs='http'+(s.ssl?'s':'')+'://'+t1+'/b/ss/'+s.un+'/'+(s.mobile?'5.1':'1')+'/'+s.vers"
+"ion+(s.tcn?'T':'')+'/'+sess+'?AQB=1&ndh=1'+(q?q:'')+'&AQE=1';if(s.isie&&!s.ismac)rs=s.fl(rs,2047)}if(s.d.images&&s.apv>=3&&(!s.isopera||s.apv>=7)&&(s.ns6<0||s.apv>=6.1)){if(!s.rc)s.rc=new Object;if"
+"(!s.rc[un]){s.rc[un]=1;if(!s.rl)s.rl=new Object;s.rl[un]=new Array;setTimeout('if(window.s_c_il)window.s_c_il['+s._in+'].mrq(\"'+un+'\")',750)}else{l=s.rl[un];if(l){r.t=ta;r.u=un;r.r=rs;l[l.length]"
+"=r;return ''}imn+='_'+s.rc[un];s.rc[un]++}if(s.debugTracking){var d='AppMeasurement Debug: '+rs,dl=s.sp(rs,'&'),dln;for(dln=0;dln<dl.length;dln++)d+=\"\\n\\t\"+s.epa(dl[dln]);s.logDebug(d)}im=s.wd["
+"imn];if(!im)im=s.wd[imn]=new Image;im.alt=\"\";im.s_l=0;im.onload=im.onerror=new Function('e','this.s_l=1;var wd=window,s;if(wd.s_c_il){s=wd.s_c_il['+s._in+'];s.bcr();s.mrq(\"'+un+'\");s.nrs--;if(!"
+"s.nrs)s.m_m(\"rr\")}');if(!s.nrs){s.nrs=1;s.m_m('rs')}else s.nrs++;im.src=rs;if(s.useForcedLinkTracking||s.bcf){if(!s.forcedLinkTrackingTimeout)s.forcedLinkTrackingTimeout=250;setTimeout('if(window"
+".s_c_il)window.s_c_il['+s._in+'].bcr()',s.forcedLinkTrackingTimeout);}else if((s.lnk||s.eo)&&(!ta||ta=='_self'||ta=='_top'||ta=='_parent'||(s.wd.name&&ta==s.wd.name))){b=e=new Date;while(!im.s_l&&e"
+".getTime()-b.getTime()<500)e=new Date}return ''}return '<im'+'g sr'+'c=\"'+rs+'\" width=1 height=1 border=0 alt=\"\">'};s.gg=function(v){var s=this;if(!s.wd['s_'+v])s.wd['s_'+v]='';return s.wd['s_'"
+"+v]};s.glf=function(t,a){if(t.substring(0,2)=='s_')t=t.substring(2);var s=this,v=s.gg(t);if(v)s[t]=v};s.gl=function(v){var s=this;if(s.pg)s.pt(v,',','glf',0)};s.rf=function(x){var s=this,y,i,j,h,p,"
+"l=0,q,a,b='',c='',t;if(x&&x.length>255){y=''+x;i=y.indexOf('?');if(i>0){q=y.substring(i+1);y=y.substring(0,i);h=y.toLowerCase();j=0;if(h.substring(0,7)=='http://')j+=7;else if(h.substring(0,8)=='ht"
+"tps://')j+=8;i=h.indexOf(\"/\",j);if(i>0){h=h.substring(j,i);p=y.substring(i);y=y.substring(0,i);if(h.indexOf('google')>=0)l=',q,ie,start,search_key,word,kw,cd,';else if(h.indexOf('yahoo.co')>=0)l="
+"',p,ei,';if(l&&q){a=s.sp(q,'&');if(a&&a.length>1){for(j=0;j<a.length;j++){t=a[j];i=t.indexOf('=');if(i>0&&l.indexOf(','+t.substring(0,i)+',')>=0)b+=(b?'&':'')+t;else c+=(c?'&':'')+t}if(b&&c)q=b+'&'"
+"+c;else c=''}i=253-(q.length-c.length)-y.length;x=y+(i>0?p.substring(0,i):'')+'?'+q}}}}return x};s.s2q=function(k,v,vf,vfp,f){var s=this,qs='',sk,sv,sp,ss,nke,nk,nf,nfl=0,nfn,nfm;if(k==\"contextDat"
+"a\")k=\"c\";if(v){for(sk in v)if((!f||sk.substring(0,f.length)==f)&&v[sk]&&(!vf||vf.indexOf(','+(vfp?vfp+'.':'')+sk+',')>=0)&&(!Object||!Object.prototype||!Object.prototype[sk])){nfm=0;if(nfl)for(n"
+"fn=0;nfn<nfl.length;nfn++)if(sk.substring(0,nfl[nfn].length)==nfl[nfn])nfm=1;if(!nfm){if(qs=='')qs+='&'+k+'.';sv=v[sk];if(f)sk=sk.substring(f.length);if(sk.length>0){nke=sk.indexOf('.');if(nke>0){n"
+"k=sk.substring(0,nke);nf=(f?f:'')+nk+'.';if(!nfl)nfl=new Array;nfl[nfl.length]=nf;qs+=s.s2q(nk,v,vf,vfp,nf)}else{if(typeof(sv)=='boolean'){if(sv)sv='true';else sv='false'}if(sv){if(vfp=='retrieveLi"
+"ghtData'&&f.indexOf('.contextData.')<0){sp=sk.substring(0,4);ss=sk.substring(4);if(sk=='transactionID')sk='xact';else if(sk=='channel')sk='ch';else if(sk=='campaign')sk='v0';else if(s.num(ss)){if(s"
+"p=='prop')sk='c'+ss;else if(sp=='eVar')sk='v'+ss;else if(sp=='list')sk='l'+ss;else if(sp=='hier'){sk='h'+ss;sv=sv.substring(0,255)}}}qs+='&'+s.ape(sk)+'='+s.ape(sv)}}}}}if(qs!='')qs+='&.'+k}return "
+"qs};s.hav=function(){var s=this,qs='',l,fv='',fe='',mn,i,e;if(s.lightProfileID){l=s.va_m;fv=s.lightTrackVars;if(fv)fv=','+fv+','+s.vl_mr+','}else{l=s.va_t;if(s.pe||s.linkType){fv=s.linkTrackVars;fe"
+"=s.linkTrackEvents;if(s.pe){mn=s.pe.substring(0,1).toUpperCase()+s.pe.substring(1);if(s[mn]){fv=s[mn].trackVars;fe=s[mn].trackEvents}}}if(fv)fv=','+fv+','+s.vl_l+','+s.vl_l2;if(fe){fe=','+fe+',';if"
+"(fv)fv+=',events,'}if (s.events2)e=(e?',':'')+s.events2}for(i=0;i<l.length;i++){var k=l[i],v=s[k],b=k.substring(0,4),x=k.substring(4),n=parseInt(x),q=k;if(!v)if(k=='events'&&e){v=e;e=''}if(v&&(!fv|"
+"|fv.indexOf(','+k+',')>=0)&&k!='linkName'&&k!='linkType'){if(k=='supplementalDataID')q='sdid';else if(k=='timestamp')q='ts';else if(k=='dynamicVariablePrefix')q='D';else if(k=='visitorID')q='vid';e"
+"lse if(k=='marketingCloudVisitorID')q='mid';else if(k=='analyticsVisitorID')q='aid';else if(k=='audienceManagerLocationHint')q='aamlh';else if(k=='audienceManagerBlob')q='aamb';else if(k=='pageURL'"
+"){q='g';if(v.length>255){s.pageURLRest=v.substring(255);v=v.substring(0,255);}}else if(k=='pageURLRest')q='-g';else if(k=='referrer'){q='r';v=s.fl(s.rf(v),255)}else if(k=='vmk'||k=='visitorMigratio"
+"nKey')q='vmt';else if(k=='visitorMigrationServer'){q='vmf';if(s.ssl&&s.visitorMigrationServerSecure)v=''}else if(k=='visitorMigrationServerSecure'){q='vmf';if(!s.ssl&&s.visitorMigrationServer)v=''}"
+"else if(k=='charSet'){q='ce';if(v.toUpperCase()=='AUTO')v='ISO8859-1';else if(s.em==2||s.em==3)v='UTF-8'}else if(k=='visitorNamespace')q='ns';else if(k=='cookieDomainPeriods')q='cdp';else if(k=='co"
+"okieLifetime')q='cl';else if(k=='variableProvider')q='vvp';else if(k=='currencyCode')q='cc';else if(k=='channel')q='ch';else if(k=='transactionID')q='xact';else if(k=='campaign')q='v0';else if(k=='"
+"resolution')q='s';else if(k=='colorDepth')q='c';else if(k=='javascriptVersion')q='j';else if(k=='javaEnabled')q='v';else if(k=='cookiesEnabled')q='k';else if(k=='browserWidth')q='bw';else if(k=='br"
+"owserHeight')q='bh';else if(k=='connectionType')q='ct';else if(k=='homepage')q='hp';else if(k=='plugins')q='p';else if(k=='events'){if(e)v+=(v?',':'')+e;if(fe)v=s.fs(v,fe)}else if(k=='events2')v=''"
+";else if(k=='contextData'){qs+=s.s2q('c',s[k],fv,k,0);v=''}else if(k=='lightProfileID')q='mtp';else if(k=='lightStoreForSeconds'){q='mtss';if(!s.lightProfileID)v=''}else if(k=='lightIncrementBy'){q"
+"='mti';if(!s.lightProfileID)v=''}else if(k=='retrieveLightProfiles')q='mtsr';else if(k=='deleteLightProfiles')q='mtsd';else if(k=='retrieveLightData'){if(s.retrieveLightProfiles)qs+=s.s2q('mts',s[k"
+"],fv,k,0);v=''}else if(s.num(x)){if(b=='prop')q='c'+n;else if(b=='eVar')q='v'+n;else if(b=='list')q='l'+n;else if(b=='hier'){q='h'+n;v=s.fl(v,255)}}if(v)qs+='&'+s.ape(q)+'='+(k.substring(0,3)!='pev"
+"'?s.ape(v):v)}}return qs};s.ltdf=function(t,h){t=t?t.toLowerCase():'';h=h?h.toLowerCase():'';var qi=h.indexOf('?'),hi=h.indexOf('#');if(qi>=0){if(hi>=0&&hi<qi)qi=hi;}else qi=hi;h=qi>=0?h.substring("
+"0,qi):h;if(t&&h.substring(h.length-(t.length+1))=='.'+t)return 1;return 0};s.ltef=function(t,h){t=t?t.toLowerCase():'';h=h?h.toLowerCase():'';if(t&&h.indexOf(t)>=0)return 1;return 0};s.lt=function("
+"h){var s=this,lft=s.linkDownloadFileTypes,lef=s.linkExternalFilters,lif=s.linkInternalFilters;lif=lif?lif:s.wd.location.hostname;h=h.toLowerCase();if(s.trackDownloadLinks&&lft&&s.pt(lft,',','ltdf',"
+"h))return 'd';if(s.trackExternalLinks&&h.indexOf('#')!=0&&h.indexOf('about:')!=0&&h.indexOf('javascript:')!=0&&(lef||lif)&&(!lef||s.pt(lef,',','ltef',h))&&(!lif||!s.pt(lif,',','ltef',h)))return 'e'"
+";return ''};s.lc=new Function('e','var s=s_c_il['+s._in+'],b=s.eh(this,\"onclick\");s.lnk=this;s.t();s.lnk=0;if(b)return this[b](e);return true');s.bcr=function(){var s=this;if(s.bct&&s.bce)s.bct.d"
+"ispatchEvent(s.bce);if(s.bcf){if(typeof(s.bcf)=='function')s.bcf();else if(s.bct&&s.bct.href)s.d.location=s.bct.href}s.bct=s.bce=s.bcf=0};s.bc=new Function('e','if(e&&e.s_fe)return;var s=s_c_il['+s"
+"._in+'],f,tcf,t,n,nrs,a,h;if(s.d&&s.d.all&&s.d.all.cppXYctnr)return;if(!s.bbc)s.useForcedLinkTracking=0;else if(!s.useForcedLinkTracking){s.b.removeEventListener(\"click\",s.bc,true);s.bbc=s.useFor"
+"cedLinkTracking=0;return}else s.b.removeEventListener(\"click\",s.bc,false);s.eo=e.srcElement?e.srcElement:e.target;nrs=s.nrs;s.t();s.eo=0;if(s.nrs>nrs&&s.useForcedLinkTracking&&e.target){a=e.targe"
+"t;while(a&&a!=s.b&&a.tagName.toUpperCase()!=\"A\"&&a.tagName.toUpperCase()!=\"AREA\")a=a.parentNode;if(a){h=a.href;if(h.indexOf(\"#\")==0||h.indexOf(\"about:\")==0||h.indexOf(\"javascript:\")==0)h="
+"0;t=a.target;if(e.target.dispatchEvent&&h&&(!t||t==\"_self\"||t==\"_top\"||t==\"_parent\"||(s.wd.name&&t==s.wd.name))){tcf=new Function(\"s\",\"var x;try{n=s.d.createEvent(\\\\\"MouseEvents\\\\\")}"
+"catch(x){n=new MouseEvent}return n\");n=tcf(s);if(n){tcf=new Function(\"n\",\"e\",\"var x;try{n.initMouseEvent(\\\\\"click\\\\\",e.bubbles,e.cancelable,e.view,e.detail,e.screenX,e.screenY,e.clientX"
+",e.clientY,e.ctrlKey,e.altKey,e.shiftKey,e.metaKey,e.button,e.relatedTarget)}catch(x){n=0}return n\");n=tcf(n,e);if(n){n.s_fe=1;e.stopPropagation();if (e.stopImmediatePropagation) {e.stopImmediateP"
+"ropagation();}e.preventDefault();s.bct=e.target;s.bce=n}}}}}');s.oh=function(o){var s=this,l=s.wd.location,h=o.href?o.href:'',i,j,k,p;i=h.indexOf(':');j=h.indexOf('?');k=h.indexOf('/');if(h&&(i<0||"
+"(j>=0&&i>j)||(k>=0&&i>k))){p=o.protocol&&o.protocol.length>1?o.protocol:(l.protocol?l.protocol:'');i=l.pathname.lastIndexOf('/');h=(p?p+'//':'')+(o.host?o.host:(l.host?l.host:''))+(h.substring(0,1)"
+"!='/'?l.pathname.substring(0,i<0?0:i)+'/':'')+h}return h};s.ot=function(o){var t=o.tagName;if(o.tagUrn||(o.scopeName&&o.scopeName.toUpperCase()!='HTML'))return '';t=t&&t.toUpperCase?t.toUpperCase()"
+":'';if(t=='SHAPE')t='';if(t){if((t=='INPUT'||t=='BUTTON')&&o.type&&o.type.toUpperCase)t=o.type.toUpperCase();else if(!t&&o.href)t='A';}return t};s.oid=function(o){var s=this,t=s.ot(o),p,c,n='',x=0;"
+"if(t&&!o.s_oid){p=o.protocol;c=o.onclick;if(o.href&&(t=='A'||t=='AREA')&&(!c||!p||p.toLowerCase().indexOf('javascript')<0))n=s.oh(o);else if(c){n=s.rep(s.rep(s.rep(s.rep(''+c,\"\\r\",''),\"\\n\",''"
+"),\"\\t\",''),' ','');x=2}else if(t=='INPUT'||t=='SUBMIT'){if(o.value)n=o.value;else if(o.innerText)n=o.innerText;else if(o.textContent)n=o.textContent;x=3}else if(o.src&&t=='IMAGE')n=o.src;if(n){o"
+".s_oid=s.fl(n,100);o.s_oidt=x}}return o.s_oid};s.rqf=function(t,un){var s=this,e=t.indexOf('='),u=e>=0?t.substring(0,e):'',q=e>=0?s.epa(t.substring(e+1)):'';if(u&&q&&(','+u+',').indexOf(','+un+',')"
+">=0){if(u!=s.un&&s.un.indexOf(',')>=0)q='&u='+u+q+'&u=0';return q}return ''};s.rq=function(un){if(!un)un=this.un;var s=this,c=un.indexOf(','),v=s.c_r('s_sq'),q='';if(c<0)return s.pt(v,'&','rqf',un)"
+";return s.pt(un,',','rq',0)};s.sqp=function(t,a){var s=this,e=t.indexOf('='),q=e<0?'':s.epa(t.substring(e+1));s.sqq[q]='';if(e>=0)s.pt(t.substring(0,e),',','sqs',q);return 0};s.sqs=function(un,q){v"
+"ar s=this;s.squ[un]=q;return 0};s.sq=function(q){var s=this,k='s_sq',v=s.c_r(k),x,c=0;s.sqq=new Object;s.squ=new Object;s.sqq[q]='';s.pt(v,'&','sqp',0);s.pt(s.un,',','sqs',q);v='';for(x in s.squ)if"
+"(x&&(!Object||!Object.prototype||!Object.prototype[x]))s.sqq[s.squ[x]]+=(s.sqq[s.squ[x]]?',':'')+x;for(x in s.sqq)if(x&&(!Object||!Object.prototype||!Object.prototype[x])&&s.sqq[x]&&(x==q||c<2)){v+"
+"=(v?'&':'')+s.sqq[x]+'='+s.ape(x);c++}return s.c_w(k,v,0)};s.wdl=new Function('e','var s=s_c_il['+s._in+'],r=true,b=s.eh(s.wd,\"onload\"),i,o,oc;if(b)r=this[b](e);for(i=0;i<s.d.links.length;i++){o="
+"s.d.links[i];oc=o.onclick?\"\"+o.onclick:\"\";if((oc.indexOf(\"s_gs(\")<0||oc.indexOf(\".s_oc(\")>=0)&&oc.indexOf(\".tl(\")<0)s.eh(o,\"onclick\",0,s.lc);}return r');s.wds=function(){var s=this;if(s"
+".apv>3&&(!s.isie||!s.ismac||s.apv>=5)){if(s.b&&s.b.attachEvent)s.b.attachEvent('onclick',s.bc);else if(s.b&&s.b.addEventListener){if(s.n&&((s.n.userAgent.indexOf('WebKit')>=0&&s.d.createEvent)||(s."
+"n.userAgent.indexOf('Firefox/2')>=0&&s.wd.MouseEvent))){s.bbc=1;s.useForcedLinkTracking=1;s.b.addEventListener('click',s.bc,true)}s.b.addEventListener('click',s.bc,false)}else s.eh(s.wd,'onload',0,"
+"s.wdl)}};s.vs=function(x){var s=this,v=s.visitorSampling,g=s.visitorSamplingGroup,k='s_vsn_'+s.un+(g?'_'+g:''),n=s.c_r(k),e=new Date,y=e.getYear();e.setYear(y+10+(y<1900?1900:0));if(v){v*=100;if(!n"
+"){if(!s.c_w(k,x,e))return 0;n=x}if(n%10000>v)return 0}return 1};s.dyasmf=function(t,m){if(t&&m&&m.indexOf(t)>=0)return 1;return 0};s.dyasf=function(t,m){var s=this,i=t?t.indexOf('='):-1,n,x;if(i>=0"
+"&&m){var n=t.substring(0,i),x=t.substring(i+1);if(s.pt(x,',','dyasmf',m))return n}return 0};s.uns=function(){var s=this,x=s.dynamicAccountSelection,l=s.dynamicAccountList,m=s.dynamicAccountMatch,n,"
+"i;s.un=s.un.toLowerCase();if(x&&l){if(!m)m=s.wd.location.host;if(!m.toLowerCase)m=''+m;l=l.toLowerCase();m=m.toLowerCase();n=s.pt(l,';','dyasf',m);if(n)s.un=n}i=s.un.indexOf(',');s.fun=i<0?s.un:s.u"
+"n.substring(0,i)};s.sa=function(un){var s=this;if(s.un&&s.mpc('sa',arguments))return;s.un=un;if(!s.oun)s.oun=un;else if((','+s.oun+',').indexOf(','+un+',')<0)s.oun+=','+un;s.uns()};s.m_i=function(n"
+",a){var s=this,m,f=n.substring(0,1),r,l,i;if(!s.m_l)s.m_l=new Object;if(!s.m_nl)s.m_nl=new Array;m=s.m_l[n];if(!a&&m&&m._e&&!m._i)s.m_a(n);if(!m){m=new Object,m._c='s_m';m._in=s.wd.s_c_in;m._il=s._"
+"il;m._il[m._in]=m;s.wd.s_c_in++;m.s=s;m._n=n;m._l=new Array('_c','_in','_il','_i','_e','_d','_dl','s','n','_r','_g','_g1','_t','_t1','_x','_x1','_rs','_rr','_l');s.m_l[n]=m;s.m_nl[s.m_nl.length]=n}"
+"else if(m._r&&!m._m){r=m._r;r._m=m;l=m._l;for(i=0;i<l.length;i++)if(m[l[i]])r[l[i]]=m[l[i]];r._il[r._in]=r;m=s.m_l[n]=r}if(f==f.toUpperCase())s[n]=m;return m};s.m_a=new Function('n','g','e','if(!g)"
+"g=\"m_\"+n;var s=s_c_il['+s._in+'],c=s[g+\"_c\"],m,x,f=0;if(s.mpc(\"m_a\",arguments))return;if(!c)c=s.wd[\"s_\"+g+\"_c\"];if(c&&s_d)s[g]=new Function(\"s\",s_ft(s_d(c)));x=s[g];if(!x)x=s.wd[\\'s_\\"
+"'+g];if(!x)x=s.wd[g];m=s.m_i(n,1);if(x&&(!m._i||g!=\"m_\"+n)){m._i=f=1;if((\"\"+x).indexOf(\"function\")>=0)x(s);else s.m_m(\"x\",n,x,e)}m=s.m_i(n,1);if(m._dl)m._dl=m._d=0;s.dlt();return f');s.m_m="
+"function(t,n,d,e){t='_'+t;var s=this,i,x,m,f='_'+t,r=0,u;if(s.m_l&&s.m_nl)for(i=0;i<s.m_nl.length;i++){x=s.m_nl[i];if(!n||x==n){m=s.m_i(x);u=m[t];if(u){if((''+u).indexOf('function')>=0){if(d&&e)u=m"
+"[t](d,e);else if(d)u=m[t](d);else u=m[t]()}}if(u)r=1;u=m[t+1];if(u&&!m[f]){if((''+u).indexOf('function')>=0){if(d&&e)u=m[t+1](d,e);else if(d)u=m[t+1](d);else u=m[t+1]()}}m[f]=1;if(u)r=1}}return r};"
+"s.m_ll=function(){var s=this,g=s.m_dl,i,o;if(g)for(i=0;i<g.length;i++){o=g[i];if(o)s.loadModule(o.n,o.u,o.d,o.l,o.e,1);g[i]=0}};s.loadModule=function(n,u,d,l,e,ln){var s=this,m=0,i,g,o=0,f1,f2,c=s."
+"h?s.h:s.b,b,tcf;if(n){i=n.indexOf(':');if(i>=0){g=n.substring(i+1);n=n.substring(0,i)}else g=\"m_\"+n;m=s.m_i(n)}if((l||(n&&!s.m_a(n,g)))&&u&&s.d&&c&&s.d.createElement){if(d){m._d=1;m._dl=1}if(ln){"
+"if(s.ssl)u=s.rep(u,'http:','https:');i='s_s:'+s._in+':'+n+':'+g;b='var s=s_c_il['+s._in+'],o=s.d.getElementById(\"'+i+'\");if(s&&o){if(!o.l&&s.wd.'+g+'){o.l=1;if(o.i)clearTimeout(o.i);o.i=0;s.m_a("
+"\"'+n+'\",\"'+g+'\"'+(e?',\"'+e+'\"':'')+')}';f2=b+'o.c++;if(!s.maxDelay)s.maxDelay=250;if(!o.l&&o.c<(s.maxDelay*2)/100)o.i=setTimeout(o.f2,100)}';f1=new Function('e',b+'}');tcf=new Function('s','c"
+"','i','u','f1','f2','var e,o=0;try{o=s.d.createElement(\"script\");if(o){o.type=\"text/javascript\";'+(n?'o.id=i;o.defer=true;o.onload=o.onreadystatechange=f1;o.f2=f2;o.l=0;':'')+'o.src=u;c.appendC"
+"hild(o);'+(n?'o.c=0;o.i=setTimeout(f2,100)':'')+'}}catch(e){o=0}return o');o=tcf(s,c,i,u,f1,f2)}else{o=new Object;o.n=n+':'+g;o.u=u;o.d=d;o.l=l;o.e=e;g=s.m_dl;if(!g)g=s.m_dl=new Array;i=0;while(i<g"
+".length&&g[i])i++;g[i]=o}}else if(n){m=s.m_i(n);m._e=1}return m};s.voa=function(vo,r){var s=this,l=s.va_g,i,k,v,x;for(i=0;i<l.length;i++){k=l[i];v=vo[k];if(v||vo['!'+k]){if(!r&&(k==\"contextData\"|"
+"|k==\"retrieveLightData\")&&s[k])for(x in s[k])if(!v[x])v[x]=s[k][x];s[k]=v}}};s.vob=function(vo,onlySet){var s=this,l=s.va_g,i,k;for(i=0;i<l.length;i++){k=l[i];vo[k]=s[k];if(!onlySet&&!vo[k])vo['!"
+"'+k]=1}};s.dlt=new Function('var s=s_c_il['+s._in+'],d=new Date,i,vo,f=0;if(s.dll)for(i=0;i<s.dll.length;i++){vo=s.dll[i];if(vo){if(!s.m_m(\"d\")||d.getTime()-vo._t>=s.maxDelay){s.dll[i]=0;s.t(vo)}"
+"else f=1}}if(s.dli)clearTimeout(s.dli);s.dli=0;if(f){if(!s.dli)s.dli=setTimeout(s.dlt,s.maxDelay)}else s.dll=0');s.dl=function(vo){var s=this,d=new Date;if(!vo)vo=new Object;s.vob(vo);vo._t=d.getTi"
+"me();if(!s.dll)s.dll=new Array;s.dll[s.dll.length]=vo;if(!s.maxDelay)s.maxDelay=250;s.dlt()};s._waitingForMarketingCloudVisitorID = false;s._doneWaitingForMarketingCloudVisitorID = false;s._marketi"
+"ngCloudVisitorIDCallback=function(marketingCloudVisitorID) {var s=this;s.marketingCloudVisitorID = marketingCloudVisitorID;s._doneWaitingForMarketingCloudVisitorID = true;s._callbackWhenReadyToTrac"
+"kCheck();};s._waitingForAnalyticsVisitorID = false;s._doneWaitingForAnalyticsVisitorID = false;s._analyticsVisitorIDCallback=function(analyticsVisitorID) {var s=this;s.analyticsVisitorID = analytic"
+"sVisitorID;s._doneWaitingForAnalyticsVisitorID = true;s._callbackWhenReadyToTrackCheck();};s._waitingForAudienceManagerLocationHint = false;s._doneWaitingForAudienceManagerLocationHint = false;s._a"
+"udienceManagerLocationHintCallback=function(audienceManagerLocationHint) {var s=this;s.audienceManagerLocationHint = audienceManagerLocationHint;s._doneWaitingForAudienceManagerLocationHint = true;"
+"s._callbackWhenReadyToTrackCheck();};s._waitingForAudienceManagerBlob = false;s._doneWaitingForAudienceManagerBlob = false;s._audienceManagerBlobCallback=function(audienceManagerBlob) {var s=this;s"
+".audienceManagerBlob = audienceManagerBlob;s._doneWaitingForAudienceManagerBlob = true;s._callbackWhenReadyToTrackCheck();};s.isReadyToTrack=function() {var s=this,readyToTrack = true,visitor = s.v"
+"isitor;if ((visitor) && (visitor.isAllowed())) {if ((!s._waitingForMarketingCloudVisitorID) && (!s.marketingCloudVisitorID) && (visitor.getMarketingCloudVisitorID)) {s._waitingForMarketingCloudVisi"
+"torID = true;s.marketingCloudVisitorID = visitor.getMarketingCloudVisitorID([s,s._marketingCloudVisitorIDCallback]);if (s.marketingCloudVisitorID) {s._doneWaitingForMarketingCloudVisitorID = true;}"
+"}if ((!s._waitingForAnalyticsVisitorID) && (!s.analyticsVisitorID) && (visitor.getAnalyticsVisitorID)) {s._waitingForAnalyticsVisitorID = true;s.analyticsVisitorID = visitor.getAnalyticsVisitorID(["
+"s,s._analyticsVisitorIDCallback]);if (s.analyticsVisitorID) {s._doneWaitingForAnalyticsVisitorID = true;}}if ((!s._waitingForAudienceManagerLocationHint) && (!s.audienceManagerLocationHint) && (vis"
+"itor.getAudienceManagerLocationHint)) {s._waitingForAudienceManagerLocationHint = true;s.audienceManagerLocationHint = visitor.getAudienceManagerLocationHint([s,s._audienceManagerLocationHintCallba"
+"ck]);if (s.audienceManagerLocationHint) {s._doneWaitingForAudienceManagerLocationHint = true;}}if ((!s._waitingForAudienceManagerBlob) && (!s.audienceManagerBlob) && (visitor.getAudienceManagerBlob"
+")) {s._waitingForAudienceManagerBlob = true;s.audienceManagerBlob = visitor.getAudienceManagerBlob([s,s._audienceManagerBlobCallback]);if (s.audienceManagerBlob) {s._doneWaitingForAudienceManagerBl"
+"ob = true;}}if (((s._waitingForMarketingCloudVisitorID)     && (!s._doneWaitingForMarketingCloudVisitorID)     && (!s.marketingCloudVisitorID)) ||((s._waitingForAnalyticsVisitorID)          && (!s."
+"_doneWaitingForAnalyticsVisitorID)          && (!s.analyticsVisitorID)) ||((s._waitingForAudienceManagerLocationHint) && (!s._doneWaitingForAudienceManagerLocationHint) && (!s.audienceManagerLocati"
+"onHint)) ||((s._waitingForAudienceManagerBlob)         && (!s._doneWaitingForAudienceManagerBlob)         && (!s.audienceManagerBlob))) {readyToTrack = false;}}return readyToTrack;};s._callbackWhen"
+"ReadyToTrackQueue = null;s._callbackWhenReadyToTrackInterval = 0;s.callbackWhenReadyToTrack=function(callbackThis,callback,args) {var s=this,callbackInfo;callbackInfo = {};callbackInfo.callbackThis"
+" = callbackThis;callbackInfo.callback     = callback;callbackInfo.args         = args;if (s._callbackWhenReadyToTrackQueue == null) {s._callbackWhenReadyToTrackQueue = [];}s._callbackWhenReadyToTra"
+"ckQueue.push(callbackInfo);if (s._callbackWhenReadyToTrackInterval == 0) {s._callbackWhenReadyToTrackInterval = setInterval(s._callbackWhenReadyToTrackCheck,100);}};s._callbackWhenReadyToTrackCheck"
+"=new Function('var s=s_c_il['+s._in+'],callbackNum,callbackInfo;if (s.isReadyToTrack()) {if (s._callbackWhenReadyToTrackInterval) {clearInterval(s._callbackWhenReadyToTrackInterval);s._callbackWhen"
+"ReadyToTrackInterval = 0;}if (s._callbackWhenReadyToTrackQueue != null) {while (s._callbackWhenReadyToTrackQueue.length > 0) {callbackInfo = s._callbackWhenReadyToTrackQueue.shift();callbackInfo.ca"
+"llback.apply(callbackInfo.callbackThis,callbackInfo.args);}}}');s._handleNotReadyToTrack=function(variableOverrides) {var s=this,args,varKey,variableOverridesCopy = null,setVariables = null;if (!s."
+"isReadyToTrack()) {args = [];if (variableOverrides != null) {variableOverridesCopy = {};for (varKey in variableOverrides) {variableOverridesCopy[varKey] = variableOverrides[varKey];}}setVariables ="
+" {};s.vob(setVariables,true);args.push(variableOverridesCopy);args.push(setVariables);s.callbackWhenReadyToTrack(s,s.track,args);return true;}return false;};s.gfid=function(){var s=this,d='01234567"
+"89ABCDEF',k='s_fid',fid=s.c_r(k),h='',l='',i,j,m=8,n=4,e=new Date,y;if(!fid||fid.indexOf('-')<0){for(i=0;i<16;i++){j=Math.floor(Math.random()*m);h+=d.substring(j,j+1);j=Math.floor(Math.random()*n);"
+"l+=d.substring(j,j+1);m=n=16}fid=h+'-'+l;}y=e.getYear();e.setYear(y+2+(y<1900?1900:0));if(!s.c_w(k,fid,e))fid=0;return fid};s.track=s.t=function(vo,setVariables){var s=this,notReadyToTrack,trk=1,tm"
+"=new Date,sed=Math&&Math.random?Math.floor(Math.random()*10000000000000):tm.getTime(),sess='s'+Math.floor(tm.getTime()/10800000)%10+sed,y=tm.getYear(),vt=tm.getDate()+'/'+tm.getMonth()+'/'+(y<1900?"
+"y+1900:y)+' '+tm.getHours()+':'+tm.getMinutes()+':'+tm.getSeconds()+' '+tm.getDay()+' '+tm.getTimezoneOffset(),tcf,tfs=s.gtfs(),ta=-1,q='',qs='',code='',vb=new Object;if ((!s.supplementalDataID) &&"
+" (s.visitor) && (s.visitor.getSupplementalDataID)) {s.supplementalDataID = s.visitor.getSupplementalDataID(\"AppMeasurement:\" + s._in,(s.expectSupplementalData ? false : true));}if(s.mpc('t',argum"
+"ents))return;s.gl(s.vl_g);s.uns();s.m_ll();notReadyToTrack = s._handleNotReadyToTrack(vo);if (!notReadyToTrack) {if (setVariables) {s.voa(setVariables);}if(!s.td){var tl=tfs.location,a,o,i,x='',c='"
+"',v='',p='',bw='',bh='',j='1.0',k=s.c_w('s_cc','true',0)?'Y':'N',hp='',ct='',pn=0,ps;if(String&&String.prototype){j='1.1';if(j.match){j='1.2';if(tm.setUTCDate){j='1.3';if(s.isie&&s.ismac&&s.apv>=5)"
+"j='1.4';if(pn.toPrecision){j='1.5';a=new Array;if(a.forEach){j='1.6';i=0;o=new Object;tcf=new Function('o','var e,i=0;try{i=new Iterator(o)}catch(e){}return i');i=tcf(o);if(i&&i.next){j='1.7';if(a."
+"reduce){j='1.8';if(j.trim){j='1.8.1';if(Date.parse){j='1.8.2';if(Object.create)j='1.8.5'}}}}}}}}}if(s.apv>=4)x=screen.width+'x'+screen.height;if(s.isns||s.isopera){if(s.apv>=3){v=s.n.javaEnabled()?"
+"'Y':'N';if(s.apv>=4){c=screen.pixelDepth;bw=s.wd.innerWidth;bh=s.wd.innerHeight}}s.pl=s.n.plugins}else if(s.isie){if(s.apv>=4){v=s.n.javaEnabled()?'Y':'N';c=screen.colorDepth;if(s.apv>=5){bw=s.d.do"
+"cumentElement.offsetWidth;bh=s.d.documentElement.offsetHeight;if(!s.ismac&&s.b){tcf=new Function('s','tl','var e,hp=0;try{s.b.addBehavior(\"#default#homePage\");hp=s.b.isHomePage(tl)?\"Y\":\"N\"}ca"
+"tch(e){}return hp');hp=tcf(s,tl);tcf=new Function('s','var e,ct=0;try{s.b.addBehavior(\"#default#clientCaps\");ct=s.b.connectionType}catch(e){}return ct');ct=tcf(s)}}}else r=''}if(s.pl)while(pn<s.p"
+"l.length&&pn<30){ps=s.fl(s.pl[pn].name,100)+';';if(p.indexOf(ps)<0)p+=ps;pn++}s.resolution=x;s.colorDepth=c;s.javascriptVersion=j;s.javaEnabled=v;s.cookiesEnabled=k;s.browserWidth=bw;s.browserHeigh"
+"t=bh;s.connectionType=ct;s.homepage=hp;s.plugins=p;s.td=1}if(vo){s.vob(vb);s.voa(vo)}if(!s.analyticsVisitorID&&!s.marketingCloudVisitorID)s.fid=s.gfid();if((vo&&vo._t)||!s.m_m('d')){if(s.usePlugins"
+")s.doPlugins(s);if(!s.abort){var l=s.wd.location,r=tfs.document.referrer;if(!s.pageURL)s.pageURL=l.href?l.href:l;if(!s.referrer&&!s._1_referrer){s.referrer=r;s._1_referrer=1}s.m_m('g');if(s.lnk||s."
+"eo){var o=s.eo?s.eo:s.lnk,p=s.pageName,w=1,t=s.ot(o),n=s.oid(o),x=o.s_oidt,h,l,i,oc;if(s.eo&&o==s.eo){while(o&&!n&&t!='BODY'){o=o.parentElement?o.parentElement:o.parentNode;if(o){t=s.ot(o);n=s.oid("
+"o);x=o.s_oidt}}if(!n||t=='BODY')o='';if(o){oc=o.onclick?''+o.onclick:'';if((oc.indexOf('s_gs(')>=0&&oc.indexOf('.s_oc(')<0)||oc.indexOf('.tl(')>=0)o=0}}if(o){if(n)ta=o.target;h=s.oh(o);i=h.indexOf("
+"'?');h=s.linkLeaveQueryString||i<0?h:h.substring(0,i);l=s.linkName;t=s.linkType?s.linkType.toLowerCase():s.lt(h);if(t&&(h||l)){s.pe='lnk_'+(t=='d'||t=='e'?t:'o');s.pev1=(h?s.ape(h):'');s.pev2=(l?s."
+"ape(l):'')}else trk=0;if(s.trackInlineStats){if(!p){p=s.pageURL;w=0}t=s.ot(o);i=o.sourceIndex;if(o.dataset&&o.dataset.sObjectId){s.wd.s_objectID=o.dataset.sObjectId;}else if(o.getAttribute&&o.getAt"
+"tribute('data-s-object-id')){s.wd.s_objectID=o.getAttribute('data-s-object-id');}else if(s.useForcedLinkTracking){s.wd.s_objectID='';oc=o.onclick?''+o.onclick:'';if(oc){var ocb=oc.indexOf('s_object"
+"ID'),oce,ocq,ocx;if(ocb>=0){ocb+=10;while(ocb<oc.length&&(\"= \\t\\r\\n\").indexOf(oc.charAt(ocb))>=0)ocb++;if(ocb<oc.length){oce=ocb;ocq=ocx=0;while(oce<oc.length&&(oc.charAt(oce)!=';'||ocq)){if(o"
+"cq){if(oc.charAt(oce)==ocq&&!ocx)ocq=0;else if(oc.charAt(oce)==\"\\\\\")ocx=!ocx;else ocx=0;}else{ocq=oc.charAt(oce);if(ocq!='\"'&&ocq!=\"'\")ocq=0}oce++;}oc=oc.substring(ocb,oce);if(oc){o.s_soid=n"
+"ew Function('s','var e;try{s.wd.s_objectID='+oc+'}catch(e){}');o.s_soid(s)}}}}}if(s.gg('objectID')){n=s.gg('objectID');x=1;i=1}if(p&&n&&t)qs='&pid='+s.ape(s.fl(p,255))+(w?'&pidt='+w:'')+'&oid='+s.a"
+"pe(s.fl(n,100))+(x?'&oidt='+x:'')+'&ot='+s.ape(t)+(i?'&oi='+i:'')}}else trk=0}if(trk||qs){s.sampled=s.vs(sed);if(trk){if(s.sampled)code=s.mr(sess,(vt?'&t='+s.ape(vt):'')+s.hav()+q+(qs?qs:s.rq()),0,"
+"ta);qs='';s.m_m('t');if(s.p_r)s.p_r();s.referrer=s.lightProfileID=s.retrieveLightProfiles=s.deleteLightProfiles=''}s.sq(qs)}}}else s.dl(vo);if(vo)s.voa(vb,1);}s.abort=0;s.supplementalDataID=s.pageU"
+"RLRest=s.lnk=s.eo=s.linkName=s.linkType=s.wd.s_objectID=s.ppu=s.pe=s.pev1=s.pev2=s.pev3='';if(s.pg)s.wd.s_lnk=s.wd.s_eo=s.wd.s_linkName=s.wd.s_linkType='';return code};s.trackLink=s.tl=function(o,t"
+",n,vo,f){var s=this;s.lnk=o;s.linkType=t;s.linkName=n;if(f){s.bct=o;s.bcf=f}s.t(vo)};s.trackLight=function(p,ss,i,vo){var s=this;s.lightProfileID=p;s.lightStoreForSeconds=ss;s.lightIncrementBy=i;s."
+"t(vo)};s.setTagContainer=function(n){var s=this,l=s.wd.s_c_il,i,t,x,y;s.tcn=n;if(l)for(i=0;i<l.length;i++){t=l[i];if(t&&t._c=='s_l'&&t.tagContainerName==n){s.voa(t);if(t.lmq)for(i=0;i<t.lmq.length;"
+"i++){x=t.lmq[i];y='m_'+x.n;if(!s[y]&&!s[y+'_c']){s[y]=t[y];s[y+'_c']=t[y+'_c']}s.loadModule(x.n,x.u,x.d)}if(t.ml)for(x in t.ml)if(s[x]){y=s[x];x=t.ml[x];for(i in x)if(!Object.prototype[i]){if(typeo"
+"f(x[i])!='function'||(''+x[i]).indexOf('s_c_il')<0)y[i]=x[i]}}if(t.mmq)for(i=0;i<t.mmq.length;i++){x=t.mmq[i];if(s[x.m]){y=s[x.m];if(y[x.f]&&typeof(y[x.f])=='function'){if(x.a)y[x.f].apply(y,x.a);e"
+"lse y[x.f].apply(y)}}}if(t.tq)for(i=0;i<t.tq.length;i++)s.t(t.tq[i]);t.s=s;return}}};s.wd=window;s.ssl=(s.wd.location.protocol.toLowerCase().indexOf('https')>=0);s.d=document;s.b=s.d.body;if(s.d.ge"
+"tElementsByTagName){s.h=s.d.getElementsByTagName('HEAD');if(s.h)s.h=s.h[0]}s.n=navigator;s.u=s.n.userAgent;s.ns6=s.u.indexOf('Netscape6/');var apn=s.n.appName,v=s.n.appVersion,ie=v.indexOf('MSIE ')"
+",o=s.u.indexOf('Opera '),i;if(v.indexOf('Opera')>=0||o>0)apn='Opera';s.isie=(apn=='Microsoft Internet Explorer');s.isns=(apn=='Netscape');s.isopera=(apn=='Opera');s.ismac=(s.u.indexOf('Mac')>=0);if"
+"(o>0)s.apv=parseFloat(s.u.substring(o+6));else if(ie>0){s.apv=parseInt(i=v.substring(ie+5));if(s.apv>3)s.apv=parseFloat(i)}else if(s.ns6>0)s.apv=parseFloat(s.u.substring(s.ns6+10));else s.apv=parse"
+"Float(v);s.em=0;if(s.em.toPrecision)s.em=3;else if(String.fromCharCode){i=escape(String.fromCharCode(256)).toUpperCase();s.em=(i=='%C4%80'?2:(i=='%U0100'?1:0))}if(s.oun)s.sa(s.oun);s.sa(un);s.vl_l="
+"'supplementalDataID,timestamp,dynamicVariablePrefix,visitorID,marketingCloudVisitorID,analyticsVisitorID,audienceManagerLocationHint,fid,vmk,visitorMigrationKey,visitorMigrationServer,visitorMigrat"
+"ionServerSecure,ppu,charSet,visitorNamespace,cookieDomainPeriods,cookieLifetime,pageName,pageURL,referrer,contextData,currencyCode,lightProfileID,lightStoreForSeconds,lightIncrementBy,retrieveLight"
+"Profiles,deleteLightProfiles,retrieveLightData';s.va_l=s.sp(s.vl_l,',');s.vl_mr=s.vl_m='timestamp,charSet,visitorNamespace,cookieDomainPeriods,cookieLifetime,contextData,lightProfileID,lightStoreFo"
+"rSeconds,lightIncrementBy';s.vl_t=s.vl_l+',variableProvider,channel,server,pageType,transactionID,purchaseID,campaign,state,zip,events,events2,products,audienceManagerBlob,linkName,linkType';var n;"
+"for(n=1;n<=75;n++){s.vl_t+=',prop'+n+',eVar'+n;s.vl_m+=',prop'+n+',eVar'+n}for(n=1;n<=5;n++)s.vl_t+=',hier'+n;for(n=1;n<=3;n++)s.vl_t+=',list'+n;s.va_m=s.sp(s.vl_m,',');s.vl_l2=',tnt,pe,pev1,pev2,p"
+"ev3,resolution,colorDepth,javascriptVersion,javaEnabled,cookiesEnabled,browserWidth,browserHeight,connectionType,homepage,pageURLRest,plugins';s.vl_t+=s.vl_l2;s.va_t=s.sp(s.vl_t,',');s.vl_g=s.vl_t+"
+"',trackingServer,trackingServerSecure,trackingServerBase,fpCookieDomainPeriods,disableBufferedRequests,mobile,visitorSampling,visitorSamplingGroup,dynamicAccountSelection,dynamicAccountList,dynamic"
+"AccountMatch,trackDownloadLinks,trackExternalLinks,trackInlineStats,linkLeaveQueryString,linkDownloadFileTypes,linkExternalFilters,linkInternalFilters,linkTrackVars,linkTrackEvents,linkNames,lnk,eo"
+",lightTrackVars,_1_referrer,un';s.va_g=s.sp(s.vl_g,',');s.pg=pg;s.gl(s.vl_g);s.contextData=new Object;s.retrieveLightData=new Object;if(!ss)s.wds();if(pg){s.wd.s_co=function(o){return o};s.wd.s_gs="
+"function(un){s_gi(un,1,1).t()};s.wd.s_dc=function(un){s_gi(un,1).t()}}",
w=window,l=w.s_c_il,n=navigator,u=n.userAgent,v=n.appVersion,e=v.indexOf('MSIE '),m=u.indexOf('Netscape6/'),a,i,j,x,s;if(un){un=un.toLowerCase();if(l)for(j=0;j<2;j++)for(i=0;i<l.length;i++){s=l[i];x=s._c;if((!x||x=='s_c'||(j>0&&x=='s_l'))&&(s.oun==un||(s.fs&&s.sa&&s.fs(s.oun,un)))){if(s.sa)s.sa(un);if(x=='s_c')return s}else s=0}}w.s_an='0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
w.s_sp=new Function("x","d","var a=new Array,i=0,j;if(x){if(x.split)a=x.split(d);else if(!d)for(i=0;i<x.length;i++)a[a.length]=x.substring(i,i+1);else while(i>=0){j=x.indexOf(d,i);a[a.length]=x.subst"
+"ring(i,j<0?x.length:j);i=j;if(i>=0)i+=d.length}}return a");
w.s_jn=new Function("a","d","var x='',i,j=a.length;if(a&&j>0){x=a[0];if(j>1){if(a.join)x=a.join(d);else for(i=1;i<j;i++)x+=d+a[i]}}return x");
w.s_rep=new Function("x","o","n","return s_jn(s_sp(x,o),n)");
w.s_d=new Function("x","var t='`^@$#',l=s_an,l2=new Object,x2,d,b=0,k,i=x.lastIndexOf('~~'),j,v,w;if(i>0){d=x.substring(0,i);x=x.substring(i+2);l=s_sp(l,'');for(i=0;i<62;i++)l2[l[i]]=i;t=s_sp(t,'');d"
+"=s_sp(d,'~');i=0;while(i<5){v=0;if(x.indexOf(t[i])>=0) {x2=s_sp(x,t[i]);for(j=1;j<x2.length;j++){k=x2[j].substring(0,1);w=t[i]+k;if(k!=' '){v=1;w=d[b+l2[k]]}x2[j]=w+x2[j].substring(1)}}if(v)x=s_jn("
+"x2,'');else{w=t[i]+' ';if(x.indexOf(w)>=0)x=s_rep(x,w,t[i]);i++;b+=62}}}return x");
w.s_fe=new Function("c","return s_rep(s_rep(s_rep(c,'\\\\','\\\\\\\\'),'\"','\\\\\"'),\"\\n\",\"\\\\n\")");
w.s_fa=new Function("f","var s=f.indexOf('(')+1,e=f.indexOf(')'),a='',c;while(s>=0&&s<e){c=f.substring(s,s+1);if(c==',')a+='\",\"';else if((\"\\n\\r\\t \").indexOf(c)<0)a+=c;s++}return a?'\"'+a+'\"':"
+"a");
w.s_ft=new Function("c","c+='';var s,e,o,a,d,q,f,h,x;s=c.indexOf('=function(');while(s>=0){s++;d=1;q='';x=0;f=c.substring(s);a=s_fa(f);e=o=c.indexOf('{',s);e++;while(d>0){h=c.substring(e,e+1);if(q){i"
+"f(h==q&&!x)q='';if(h=='\\\\')x=x?0:1;else x=0}else{if(h=='\"'||h==\"'\")q=h;if(h=='{')d++;if(h=='}')d--}if(d>0)e++}c=c.substring(0,s)+'new Function('+(a?a+',':'')+'\"'+s_fe(c.substring(o+1,e))+'\")"
+"'+c.substring(e+1);s=c.indexOf('=function(')}return c;");
c=s_d(c);if(e>0){a=parseInt(i=v.substring(e+5));if(a>3)a=parseFloat(i)}else if(m>0)a=parseFloat(u.substring(m+10));else a=parseFloat(v);if(a<5||v.indexOf('Opera')>=0||u.indexOf('Opera')>=0)c=s_ft(c);if(!s){s=new Object;if(!w.s_c_in){w.s_c_il=new Array;w.s_c_in=0}s._il=w.s_c_il;s._in=w.s_c_in;s._il[s._in]=s;w.s_c_in++;}s._c='s_c';(new Function("s","un","pg","ss",c))(s,un,pg,ss);return s}

/************* Audience Manager ***********************/
"function"!=typeof DIL&&(DIL=function(a,b){var d=[],c,e;a!==Object(a)&&(a={});var f,h,m,u,s,v,w,q,x,H,I;f=a.partner;h=a.containerNSID;m=a.iframeAttachmentDelay;u=!!a.disableDestinationPublishingIframe;s=a.iframeAkamaiHTTPS;v=a.mappings;w=a.uuidCookie;q=!0===a.enableErrorReporting;x=a.visitorService;H=a.declaredId;I=!0===a.removeFinishedScriptsAndCallbacks;var J,K,E,C;J=!0===a.disableScriptAttachment;K=!0===a.disableDefaultRequest;E=a.afterResultForDefaultRequest;C=a.dpIframeSrc;q&&DIL.errorModule.activate();
var L=!0===window._dil_unit_tests;(c=b)&&d.push(c+"");if(!f||"string"!=typeof f)return c="DIL partner is invalid or not specified in initConfig",DIL.errorModule.handleError({name:"error",message:c,filename:"dil.js"}),Error(c);c="DIL containerNSID is invalid or not specified in initConfig, setting to default of 0";if(h||"number"==typeof h)h=parseInt(h,10),!isNaN(h)&&0<=h&&(c="");c&&(h=0,d.push(c),c="");e=DIL.getDil(f,h);if(e instanceof DIL&&e.api.getPartner()==f&&e.api.getContainerNSID()==h)return e;
if(this instanceof DIL)DIL.registerDil(this,f,h);else return new DIL(a,"DIL was not instantiated with the 'new' operator, returning a valid instance with partner = "+f+" and containerNSID = "+h);var y={IS_HTTPS:"https:"==document.location.protocol,POST_MESSAGE_ENABLED:!!window.postMessage,COOKIE_MAX_EXPIRATION_DATE:"Tue, 19 Jan 2038 03:14:07 UTC"},F={stuffed:{}},n={},p={firingQueue:[],fired:[],firing:!1,sent:[],errored:[],reservedKeys:{sids:!0,pdata:!0,logdata:!0,callback:!0,postCallbackFn:!0,useImageRequest:!0},
callbackPrefix:"demdexRequestCallback",firstRequestHasFired:!1,useJSONP:!0,abortRequests:!1,num_of_jsonp_responses:0,num_of_jsonp_errors:0,num_of_img_responses:0,num_of_img_errors:0,toRemove:[],removed:[],readyToRemove:!1,platformParams:{d_nsid:h+"",d_rtbd:"json",d_jsonv:DIL.jsonVersion+"",d_dst:"1"},nonModStatsParams:{d_rtbd:!0,d_dst:!0,d_cts:!0,d_rs:!0},modStatsParams:null,adms:{TIME_TO_CATCH_ALL_REQUESTS_RELEASE:2E3,calledBack:!1,uuid:null,noVisitorAPI:!1,instance:null,releaseType:"no VisitorAPI",
admsProcessingStarted:!1,process:function(g){try{if(!this.admsProcessingStarted){var a=this,l,k,c,b,d;if("function"==typeof g&&"function"==typeof g.getInstance){if(x===Object(x)&&(l=x.namespace)&&"string"==typeof l)k=g.getInstance(l);else{this.releaseType="no namespace";this.releaseRequests();return}if(k===Object(k)&&"function"==typeof k.isAllowed&&"function"==typeof k.getGlobalVisitorID){if(!k.isAllowed()){this.releaseType="VisitorAPI not allowed";this.releaseRequests();return}this.instance=k;this.admsProcessingStarted=
!0;c=function(g){"VisitorAPI"!=a.releaseType&&(a.uuid=g,a.releaseType="VisitorAPI",a.releaseRequests())};L&&(b=x.server)&&"string"==typeof b&&(k.server=b);d=k.getGlobalVisitorID(c);if("string"==typeof d&&d.length){c(d);return}setTimeout(function(){"VisitorAPI"!=a.releaseType&&(a.releaseType="timeout",a.releaseRequests())},this.TIME_TO_CATCH_ALL_REQUESTS_RELEASE);return}this.releaseType="invalid instance"}else this.noVisitorAPI=!0;this.releaseRequests()}}catch(f){this.releaseRequests()}},releaseRequests:function(){this.calledBack=
!0;p.registerRequest()},getGlobalVisitorID:function(){return this.instance?this.instance.getGlobalVisitorID():null}},declaredId:{uuid:null,declaredId:{init:null,request:null},declaredIdCombos:{},dIdAlwaysOn:!1,dIdInRequest:!1,setDeclaredId:function(g,a){var l=t.isPopulatedString,k=encodeURIComponent;if(g===Object(g)&&l(a)){var c=g.dpid,d=g.dpuuid,b=null;if(l(c)&&l(d)){b=k(c)+"$"+k(d);if(!0===this.declaredIdCombos[b])return"setDeclaredId: combo exists for type '"+a+"'";this.declaredIdCombos[b]=!0;
this.declaredId[a]={dpid:c,dpuuid:d};"init"==a?this.dIdAlwaysOn=!0:"request"==a&&(this.dIdInRequest=!0);return"setDeclaredId: succeeded for type '"+a+"'"}}return"setDeclaredId: failed for type '"+a+"'"},getDeclaredIdQueryString:function(){var g=this.declaredId.request,a=this.declaredId.init,l="";null!==g?l="&d_dpid="+g.dpid+"&d_dpuuid="+g.dpuuid:null!==a&&(l="&d_dpid="+a.dpid+"&d_dpuuid="+a.dpuuid);return l},getUUIDQueryString:function(){var g=p.adms,a=t.isPopulatedString,l=!1,k=p.adms.getGlobalVisitorID();
a(this.uuid)?a(k)&&this.uuid!=k&&(this.uuid=k):this.uuid=k||g.uuid;if(this.dIdAlwaysOn||this.dIdInRequest)l=!0,this.dIdInRequest=!1;return a(this.uuid)&&l?"d_uuid="+this.uuid+"&":""}},registerRequest:function(g){var a=this.firingQueue;g===Object(g)&&a.push(g);!this.firing&&a.length&&(this.adms.calledBack?(g=a.shift(),g.src=g.src.replace(/demdex.net\/event\?d_nsid=/,"demdex.net/event?"+this.declaredId.getUUIDQueryString()+"d_nsid="),z.fireRequest(g),this.firstRequestHasFired||"script"!=g.tag||(this.firstRequestHasFired=
!0)):this.processVisitorAPI())},processVisitorAPI:function(){this.adms.process(window.Visitor)},requestRemoval:function(g){if(!I)return"removeFinishedScriptsAndCallbacks is not boolean true";var a=this.toRemove,l,k;g===Object(g)&&(l=g.script,k=g.callbackName,(l===Object(l)&&"SCRIPT"==l.nodeName||"no script created"==l)&&"string"==typeof k&&k.length&&a.push(g));if(this.readyToRemove&&a.length){k=a.shift();l=k.script;k=k.callbackName;"no script created"!=l?(g=l.src,l.parentNode.removeChild(l)):g=l;
window[k]=null;try{delete window[k]}catch(c){}this.removed.push({scriptSrc:g,callbackName:k});DIL.variables.scriptsRemoved.push(g);DIL.variables.callbacksRemoved.push(k);return this.requestRemoval()}return"requestRemoval() processed"}};e=function(){var g="http://fast.",a="?d_nsid="+h+"#"+encodeURIComponent(document.location.href);if("string"===typeof C&&C.length)return C+a;y.IS_HTTPS&&(g=!0===s?"https://fast.":"https://");return g+f+".demdex.net/dest4.html"+a};var A={THROTTLE_START:3E4,throttleTimerSet:!1,
id:"destination_publishing_iframe_"+f+"_"+h,url:e(),iframe:null,iframeHasLoaded:!1,sendingMessages:!1,messages:[],messagesPosted:[],messageSendingInterval:y.POST_MESSAGE_ENABLED?15:100,jsonProcessed:[],attachIframe:function(){var g=this,a=document.createElement("iframe");a.id=this.id;a.style.cssText="display: none; width: 0; height: 0;";a.src=this.url;r.addListener(a,"load",function(){g.iframeHasLoaded=!0;g.requestToProcess()});document.body.appendChild(a);this.iframe=a},requestToProcess:function(g,
a){var l=this;g&&!t.isEmptyObject(g)&&this.process(g,a);this.iframeHasLoaded&&this.messages.length&&!this.sendingMessages&&(this.throttleTimerSet||(this.throttleTimerSet=!0,setTimeout(function(){l.messageSendingInterval=y.POST_MESSAGE_ENABLED?15:150},this.THROTTLE_START)),this.sendingMessages=!0,this.sendMessages())},process:function(g,a){var l=encodeURIComponent,k,c,d,b,f,e;a===Object(a)&&(e=r.encodeAndBuildRequest([p.declaredId.uuid||"",a.dpid||"",a.dpuuid||""],","));if((k=g.dests)&&k instanceof
Array&&(c=k.length))for(d=0;d<c;d++)b=k[d],b=[l("dests"),l(b.id||""),l(b.y||""),l(b.c||"")],this.addMessage(b.join("|"));if((k=g.ibs)&&k instanceof Array&&(c=k.length))for(d=0;d<c;d++)b=k[d],b=[l("ibs"),l(b.id||""),l(b.tag||""),r.encodeAndBuildRequest(b.url||[],","),l(b.ttl||""),"",e],this.addMessage(b.join("|"));if((k=g.dpcalls)&&k instanceof Array&&(c=k.length))for(d=0;d<c;d++)b=k[d],f=b.callback||{},f=[f.obj||"",f.fn||"",f.key||"",f.tag||"",f.url||""],b=[l("dpm"),l(b.id||""),l(b.tag||""),r.encodeAndBuildRequest(b.url||
[],","),l(b.ttl||""),r.encodeAndBuildRequest(f,","),e],this.addMessage(b.join("|"));this.jsonProcessed.push(g)},addMessage:function(g){var a=encodeURIComponent,a=q?a("---destpub-debug---"):a("---destpub---");this.messages.push(a+g)},sendMessages:function(){var g=this,a;this.messages.length?(a=this.messages.shift(),DIL.xd.postMessage(a,this.url,this.iframe.contentWindow),this.messagesPosted.push(a),setTimeout(function(){g.sendMessages()},this.messageSendingInterval)):this.sendingMessages=!1}},G={traits:function(g){t.isValidPdata(g)&&
(n.sids instanceof Array||(n.sids=[]),r.extendArray(n.sids,g));return this},pixels:function(g){t.isValidPdata(g)&&(n.pdata instanceof Array||(n.pdata=[]),r.extendArray(n.pdata,g));return this},logs:function(g){t.isValidLogdata(g)&&(n.logdata!==Object(n.logdata)&&(n.logdata={}),r.extendObject(n.logdata,g));return this},customQueryParams:function(g){t.isEmptyObject(g)||r.extendObject(n,g,p.reservedKeys);return this},signals:function(g,a){var b,d=g;if(!t.isEmptyObject(d)){if(a&&"string"==typeof a)for(b in d=
{},g)g.hasOwnProperty(b)&&(d[a+b]=g[b]);r.extendObject(n,d,p.reservedKeys)}return this},declaredId:function(g){p.declaredId.setDeclaredId(g,"request");return this},result:function(g){"function"==typeof g&&(n.callback=g);return this},afterResult:function(g){"function"==typeof g&&(n.postCallbackFn=g);return this},useImageRequest:function(){n.useImageRequest=!0;return this},clearData:function(){n={};return this},submit:function(){z.submitRequest(n);n={};return this},getPartner:function(){return f},getContainerNSID:function(){return h},
getEventLog:function(){return d},getState:function(){var g={},a={};r.extendObject(g,p,{callbackPrefix:!0,useJSONP:!0,registerRequest:!0});r.extendObject(a,A,{attachIframe:!0,requestToProcess:!0,process:!0,sendMessages:!0});return{pendingRequest:n,otherRequestInfo:g,destinationPublishingInfo:a}},idSync:function(g){if(g!==Object(g)||"string"!=typeof g.dpid||!g.dpid.length)return"Error: config or config.dpid is empty";if("string"!=typeof g.url||!g.url.length)return"Error: config.url is empty";var a=
g.url,b=g.minutesToLive,d=encodeURIComponent,c=p.declaredId,a=a.replace(/^https:/,"").replace(/^http:/,"");if("undefined"==typeof b)b=20160;else if(b=parseInt(b,10),isNaN(b)||0>=b)return"Error: config.minutesToLive needs to be a positive number";c=r.encodeAndBuildRequest([p.adms.getGlobalVisitorID()||c.uuid||"",g.dpid,g.dpuuid||""],",");g=["ibs",d(g.dpid),"img",d(a),b,"",c];A.addMessage(g.join("|"));p.firstRequestHasFired&&A.requestToProcess();return"Successfully queued"},aamIdSync:function(a){if(a!==
Object(a)||"string"!=typeof a.dpuuid||!a.dpuuid.length)return"Error: config or config.dpuuid is empty";a.url="//dpm.demdex.net/ibs:dpid="+a.dpid+"&dpuuid="+a.dpuuid;return this.idSync(a)},passData:function(a){if(t.isEmptyObject(a))return"Error: json is empty or not an object";z.defaultCallback(a);return"json submitted for processing"},getPlatformParams:function(){return p.platformParams},getEventCallConfigParams:function(){var a=p,b=a.modStatsParams,d=a.platformParams,c;if(!b){b={};for(c in d)d.hasOwnProperty(c)&&
!a.nonModStatsParams[c]&&(b[c.replace(/^d_/,"")]=d[c]);a.modStatsParams=b}return b}},z={submitRequest:function(a){p.registerRequest(z.createQueuedRequest(a));return!0},createQueuedRequest:function(a){var b=p,d,c=a.callback,e="img";if(!t.isEmptyObject(v)){var B,q,s;for(B in v)v.hasOwnProperty(B)&&(q=v[B],null!=q&&""!==q&&B in a&&!(q in a||q in p.reservedKeys)&&(s=a[B],null!=s&&""!==s&&(a[q]=s)))}t.isValidPdata(a.sids)||(a.sids=[]);t.isValidPdata(a.pdata)||(a.pdata=[]);t.isValidLogdata(a.logdata)||
(a.logdata={});a.logdataArray=r.convertObjectToKeyValuePairs(a.logdata,"=",!0);a.logdataArray.push("_ts="+(new Date).getTime());"function"!=typeof c&&(c=this.defaultCallback);if(b.useJSONP=!a.useImageRequest||"boolean"!=typeof a.useImageRequest)e="script",d=b.callbackPrefix+"_"+f+"_"+h+"_"+(new Date).getTime();return{tag:e,src:z.makeRequestSrc(a,d),internalCallbackName:d,callbackFn:c,postCallbackFn:a.postCallbackFn,useImageRequest:a.useImageRequest,requestData:a}},defaultCallback:function(a,b){var d,
c,f,e,h,q,s,v,m;if((d=a.stuff)&&d instanceof Array&&(c=d.length))for(f=0;f<c;f++)if((e=d[f])&&e===Object(e)){h=e.cn;q=e.cv;s=e.ttl;if("undefined"==typeof s||""===s)s=Math.floor(r.getMaxCookieExpiresInMinutes()/60/24);v=e.dmn||"."+document.domain.replace(/^www\./,"");m=e.type;h&&(q||"number"==typeof q)&&("var"!=m&&(s=parseInt(s,10))&&!isNaN(s)&&r.setCookie(h,q,1440*s,"/",v,!1),F.stuffed[h]=q)}d=a.uuid;c=p.declaredId;f=t.isPopulatedString;f(d)&&(f(c.uuid)||(c.uuid=d),t.isEmptyObject(w)||(c=w.path,"string"==
typeof c&&c.length||(c="/"),f=parseInt(w.days,10),isNaN(f)&&(f=100),r.setCookie(w.name||"aam_did",d,1440*f,c,w.domain||"."+document.domain.replace(/^www\./,""),!0===w.secure)));u||p.abortRequests||A.requestToProcess(a,b)},makeRequestSrc:function(a,b){a.sids=t.removeEmptyArrayValues(a.sids||[]);a.pdata=t.removeEmptyArrayValues(a.pdata||[]);var d=p,c=d.platformParams,e=r.encodeAndBuildRequest(a.sids,","),h=r.encodeAndBuildRequest(a.pdata,","),q=(a.logdataArray||[]).join("&");delete a.logdataArray;var s=
y.IS_HTTPS?"https://":"http://",v=d.declaredId.getDeclaredIdQueryString(),m;m=[];var n,w,x,u;for(n in a)if(!(n in d.reservedKeys)&&a.hasOwnProperty(n))if(w=a[n],n=encodeURIComponent(n),w instanceof Array)for(x=0,u=w.length;x<u;x++)m.push(n+"="+encodeURIComponent(w[x]));else m.push(n+"="+encodeURIComponent(w));m=m.length?"&"+m.join("&"):"";return s+f+".demdex.net/event?d_nsid="+c.d_nsid+v+(e.length?"&d_sid="+e:"")+(h.length?"&d_px="+h:"")+(q.length?"&d_ld="+encodeURIComponent(q):"")+m+(d.useJSONP?
"&d_rtbd="+c.d_rtbd+"&d_jsonv="+c.d_jsonv+"&d_dst="+c.d_dst+"&d_cb="+(b||""):"")},fireRequest:function(a){if("img"==a.tag)this.fireImage(a);else if("script"==a.tag){var b=p.declaredId,b=b.declaredId.request||b.declaredId.init||{};this.fireScript(a,{dpid:b.dpid||"",dpuuid:b.dpuuid||""})}},fireImage:function(a){var b=p,f,e;b.abortRequests||(b.firing=!0,f=new Image(0,0),b.sent.push(a),f.onload=function(){b.firing=!1;b.fired.push(a);b.num_of_img_responses++;b.registerRequest()},e=function(f){c="imgAbortOrErrorHandler received the event of type "+
f.type;d.push(c);b.abortRequests=!0;b.firing=!1;b.errored.push(a);b.num_of_img_errors++;b.registerRequest()},f.addEventListener?(f.addEventListener("error",e,!1),f.addEventListener("abort",e,!1)):f.attachEvent&&(f.attachEvent("onerror",e),f.attachEvent("onabort",e)),f.src=a.src)},fireScript:function(a,b){var e=this,k=p,h,q,s=a.src,m=a.postCallbackFn,v="function"==typeof m,n=a.internalCallbackName;k.abortRequests||(k.firing=!0,window[n]=function(e){try{e!==Object(e)&&(e={});var l=a.callbackFn;k.firing=
!1;k.fired.push(a);k.num_of_jsonp_responses++;l(e,b);v&&m(e,b)}catch(h){h.message="DIL jsonp callback caught error with message "+h.message;c=h.message;d.push(c);h.filename=h.filename||"dil.js";h.partner=f;DIL.errorModule.handleError(h);try{l({error:h.name+"|"+h.message}),v&&m({error:h.name+"|"+h.message})}catch(s){}}finally{k.requestRemoval({script:q,callbackName:n}),k.registerRequest()}},J?(k.firing=!1,k.requestRemoval({script:"no script created",callbackName:n})):(q=document.createElement("script"),
q.addEventListener&&q.addEventListener("error",function(b){k.requestRemoval({script:q,callbackName:n});c="jsonp script tag error listener received the event of type "+b.type+" with src "+s;e.handleScriptError(c,a)},!1),q.type="text/javascript",q.src=s,h=DIL.variables.scriptNodeList[0],h.parentNode.insertBefore(q,h)),k.sent.push(a),k.declaredId.declaredId.request=null)},handleScriptError:function(a,b){var c=p;d.push(a);c.abortRequests=!0;c.firing=!1;c.errored.push(b);c.num_of_jsonp_errors++;c.registerRequest()}},
t={isValidPdata:function(a){return a instanceof Array&&this.removeEmptyArrayValues(a).length?!0:!1},isValidLogdata:function(a){return!this.isEmptyObject(a)},isEmptyObject:function(a){if(a!==Object(a))return!0;for(var b in a)if(a.hasOwnProperty(b))return!1;return!0},removeEmptyArrayValues:function(a){for(var b=0,c=a.length,d,f=[],b=0;b<c;b++)d=a[b],"undefined"!=typeof d&&null!=d&&f.push(d);return f},isPopulatedString:function(a){return"string"==typeof a&&a.length}},r={addListener:function(){if(document.addEventListener)return function(a,
b,d){a.addEventListener(b,function(a){"function"==typeof d&&d(a)},!1)};if(document.attachEvent)return function(a,b,d){a.attachEvent("on"+b,function(a){"function"==typeof d&&d(a)})}}(),convertObjectToKeyValuePairs:function(a,b,d){var c=[];b=b||"=";var f,e;for(f in a)e=a[f],"undefined"!=typeof e&&null!=e&&c.push(f+b+(d?encodeURIComponent(e):e));return c},encodeAndBuildRequest:function(a,b){return this.map(a,function(a){return encodeURIComponent(a)}).join(b)},map:function(a,b){if(Array.prototype.map)return a.map(b);
if(void 0===a||null===a)throw new TypeError;var d=Object(a),c=d.length>>>0;if("function"!==typeof b)throw new TypeError;for(var f=Array(c),e=0;e<c;e++)e in d&&(f[e]=b.call(b,d[e],e,d));return f},filter:function(a,b){if(!Array.prototype.filter){if(void 0===a||null===a)throw new TypeError;var d=Object(a),c=d.length>>>0;if("function"!==typeof b)throw new TypeError;for(var f=[],e=0;e<c;e++)if(e in d){var h=d[e];b.call(b,h,e,d)&&f.push(h)}return f}return a.filter(b)},getCookie:function(a){a+="=";var b=
document.cookie.split(";"),d,c,e;d=0;for(c=b.length;d<c;d++){for(e=b[d];" "==e.charAt(0);)e=e.substring(1,e.length);if(0==e.indexOf(a))return decodeURIComponent(e.substring(a.length,e.length))}return null},setCookie:function(a,b,d,c,e,f){var h=new Date;d&&(d*=6E4);document.cookie=a+"="+encodeURIComponent(b)+(d?";expires="+(new Date(h.getTime()+d)).toUTCString():"")+(c?";path="+c:"")+(e?";domain="+e:"")+(f?";secure":"")},extendArray:function(a,b){return a instanceof Array&&b instanceof Array?(Array.prototype.push.apply(a,
b),!0):!1},extendObject:function(a,b,d){var c;if(a===Object(a)&&b===Object(b)){for(c in b)!b.hasOwnProperty(c)||!t.isEmptyObject(d)&&c in d||(a[c]=b[c]);return!0}return!1},getMaxCookieExpiresInMinutes:function(){return((new Date(y.COOKIE_MAX_EXPIRATION_DATE)).getTime()-(new Date).getTime())/1E3/60}};"error"==f&&0==h&&r.addListener(window,"load",function(){DIL.windowLoaded=!0});var D=function(){N();u||p.abortRequests||A.attachIframe();p.readyToRemove=!0;p.requestRemoval()},N=function(){u||setTimeout(function(){K||
p.firstRequestHasFired||p.adms.admsProcessingStarted||p.adms.calledBack||("function"==typeof E?G.afterResult(E).submit():G.submit())},DIL.constants.TIME_TO_DEFAULT_REQUEST)},M=document;"error"!=f&&(DIL.windowLoaded?D():"complete"!=M.readyState&&"loaded"!=M.readyState?r.addListener(window,"load",D):DIL.isAddedPostWindowLoadWasCalled?r.addListener(window,"load",D):(m="number"==typeof m?parseInt(m,10):0,0>m&&(m=0),setTimeout(D,m||DIL.constants.TIME_TO_CATCH_ALL_DP_IFRAME_ATTACHMENT)));p.declaredId.setDeclaredId(H,
"init");this.api=G;this.getStuffedVariable=function(a){var b=F.stuffed[a];b||"number"==typeof b||(b=r.getCookie(a))||"number"==typeof b||(b="");return b};this.validators=t;this.helpers=r;this.constants=y;this.log=d;L&&(this.pendingRequest=n,this.requestController=p,this.setDestinationPublishingUrl=e,this.destinationPublishing=A,this.requestProcs=z,this.variables=F)},function(){var a=document,b;null==a.readyState&&a.addEventListener&&(a.readyState="loading",a.addEventListener("DOMContentLoaded",b=
function(){a.removeEventListener("DOMContentLoaded",b,!1);a.readyState="complete"},!1))}(),DIL.extendStaticPropertiesAndMethods=function(a){var b;if(a===Object(a))for(b in a)a.hasOwnProperty(b)&&(this[b]=a[b])},DIL.extendStaticPropertiesAndMethods({version:"4.8",jsonVersion:1,constants:{TIME_TO_DEFAULT_REQUEST:50,TIME_TO_CATCH_ALL_DP_IFRAME_ATTACHMENT:500},variables:{scriptNodeList:document.getElementsByTagName("script"),scriptsRemoved:[],callbacksRemoved:[]},windowLoaded:!1,dils:{},isAddedPostWindowLoadWasCalled:!1,
isAddedPostWindowLoad:function(a){this.isAddedPostWindowLoadWasCalled=!0;this.windowLoaded="function"==typeof a?!!a():"boolean"==typeof a?a:!0},create:function(a){try{return new DIL(a)}catch(b){return(new Image(0,0)).src="http://error.demdex.net/event?d_nsid=0&d_px=14137&d_ld=name%3Derror%26filename%3Ddil.js%26partner%3Dno_partner%26message%3DError%2520in%2520attempt%2520to%2520create%2520DIL%2520instance%2520with%2520DIL.create()%26_ts%3D"+(new Date).getTime(),Error("Error in attempt to create DIL instance with DIL.create()")}},
registerDil:function(a,b,d){b=b+"$"+d;b in this.dils||(this.dils[b]=a)},getDil:function(a,b){var d;"string"!=typeof a&&(a="");b||(b=0);d=a+"$"+b;return d in this.dils?this.dils[d]:Error("The DIL instance with partner = "+a+" and containerNSID = "+b+" was not found")},dexGetQSVars:function(a,b,d){b=this.getDil(b,d);return b instanceof this?b.getStuffedVariable(a):""},xd:{postMessage:function(a,b,d){var c=1;b&&(window.postMessage?d.postMessage(a,b.replace(/([^:]+:\/\/[^\/]+).*/,"$1")):b&&(d.location=
b.replace(/#.*$/,"")+"#"+ +new Date+c++ +"&"+a))}}}),DIL.errorModule=function(){var a=DIL.create({partner:"error",containerNSID:0,disableDestinationPublishingIframe:!0}),b={harvestererror:14138,destpuberror:14139,dpmerror:14140,generalerror:14137,error:14137,noerrortypedefined:15021,evalerror:15016,rangeerror:15017,referenceerror:15018,typeerror:15019,urierror:15020},d=!1;return{activate:function(){d=!0},handleError:function(c){if(!d)return"DIL error module has not been activated";c!==Object(c)&&
(c={});var e=c.name?(new String(c.name)).toLowerCase():"",f=[];c={name:e,filename:c.filename?c.filename+"":"",partner:c.partner?c.partner+"":"no_partner",site:c.site?c.site+"":document.location.href,message:c.message?c.message+"":""};f.push(e in b?b[e]:b.noerrortypedefined);a.api.pixels(f).logs(c).useImageRequest().submit();return"DIL error report sent"},pixelMap:b}}(),DIL.tools={},DIL.modules={helpers:{handleModuleError:function(a,b,d){var c="";b=b||"Error caught in DIL module/submodule: ";a===Object(a)?
c=b+(a.message||"err has no message"):(c=b+"err is not a valid object",a={});a.message=c;d instanceof DIL&&(a.partner=d.api.getPartner());DIL.errorModule.handleError(a);return this.errorMessage=c}}});
DIL.tools.getSearchReferrer=function(a,b){var d=DIL.getDil("error"),c=DIL.tools.decomposeURI(a||document.referrer),e="",f="",h={queryParam:"q"};return(e=d.helpers.filter([b===Object(b)?b:{},{hostPattern:/aol\./},{hostPattern:/ask\./},{hostPattern:/bing\./},{hostPattern:/google\./},{hostPattern:/yahoo\./,queryParam:"p"}],function(a){return!(!a.hasOwnProperty("hostPattern")||!c.hostname.match(a.hostPattern))}).shift())?{valid:!0,name:c.hostname,keywords:(d.helpers.extendObject(h,e),f=h.queryPattern?
(e=(""+c.search).match(h.queryPattern))?e[1]:"":c.uriParams[h.queryParam],decodeURIComponent(f||"").replace(/\+|%20/g," "))}:{valid:!1,name:"",keywords:""}};
DIL.tools.decomposeURI=function(a){var b=DIL.getDil("error"),d=document.createElement("a");d.href=a||document.referrer;return{hash:d.hash,host:d.host.split(":").shift(),hostname:d.hostname,href:d.href,pathname:d.pathname.replace(/^\//,""),protocol:d.protocol,search:d.search,uriParams:function(a,d){b.helpers.map(d.split("&"),function(b){b=b.split("=");a[b.shift()]=b.shift()});return a}({},d.search.replace(/^(\/|\?)?|\/$/g,""))}};
DIL.tools.getMetaTags=function(){var a={},b=document.getElementsByTagName("meta"),d,c,e,f,h;d=0;for(e=arguments.length;d<e;d++)if(f=arguments[d],null!==f)for(c=0;c<b.length;c++)if(h=b[c],h.name==f){a[f]=h.content;break}return a};
DIL.modules.siteCatalyst={dil:null,handle:DIL.modules.helpers.handleModuleError,init:function(a,b,d){try{var c=this,e={name:"DIL Site Catalyst Module Error"},f=function(a){e.message=a;DIL.errorModule.handleError(e);return a};this.dil=null;if(b instanceof DIL)this.dil=b;else return f("dilInstance is not a valid instance of DIL");e.partner=b.api.getPartner();if(a!==Object(a))return f("siteCatalystReportingSuite is not an object");window.AppMeasurement_Module_DIL=a.m_DIL=function(a){var b="function"===
typeof a.m_i?a.m_i("DIL"):this;if(b!==Object(b))return f("m is not an object");b.trackVars=c.constructTrackVars(d);b.d=0;b.s=a;b._t=function(){var a,b,d=","+this.trackVars+",",c=this.s,e,h=[];e=[];var m={},u=!1;if(c!==Object(c))return f("Error in m._t function: s is not an object");if(this.d){if("function"==typeof c.foreachVar)c.foreachVar(function(a,b){m[a]=b;u=!0},this.trackVars);else{if(!(c.va_t instanceof Array))return f("Error in m._t function: s.va_t is not an array");if(c.lightProfileID)(a=
c.lightTrackVars)&&(a=","+a+","+c.vl_mr+",");else if(c.pe||c.linkType)a=c.linkTrackVars,c.pe&&(b=c.pe.substring(0,1).toUpperCase()+c.pe.substring(1),c[b]&&(a=c[b].trackVars)),a&&(a=","+a+","+c.vl_l+","+c.vl_l2+",");if(a){b=0;for(h=a.split(",");b<h.length;b++)0<=d.indexOf(","+h[b]+",")&&e.push(h[b]);e.length&&(d=","+e.join(",")+",")}e=0;for(b=c.va_t.length;e<b;e++)a=c.va_t[e],0<=d.indexOf(","+a+",")&&null!=c[a]&&""!==c[a]&&(m[a]=c[a],u=!0)}u&&this.d.api.signals(m,"c_").submit()}}};a.loadModule("DIL");
a.DIL.d=b;return e.message?e.message:"DIL.modules.siteCatalyst.init() completed with no errors"}catch(h){return this.handle(h,"DIL.modules.siteCatalyst.init() caught error with message ",this.dil)}},constructTrackVars:function(a){var b=[],d,c,e,f,h;if(a===Object(a)){d=a.names;if(d instanceof Array&&(e=d.length))for(c=0;c<e;c++)f=d[c],"string"==typeof f&&f.length&&b.push(f);a=a.iteratedNames;if(a instanceof Array&&(e=a.length))for(c=0;c<e;c++)if(d=a[c],d===Object(d)&&(f=d.name,h=parseInt(d.maxIndex,
10),"string"==typeof f&&f.length&&!isNaN(h)&&0<=h))for(d=0;d<=h;d++)b.push(f+d);if(b.length)return b.join(",")}return this.constructTrackVars({names:"pageName channel campaign products events pe pev1 pev2 pev3".split(" "),iteratedNames:[{name:"prop",maxIndex:75},{name:"eVar",maxIndex:75}]})}};
DIL.modules.GA={dil:null,arr:null,tv:null,errorMessage:"",defaultTrackVars:["_setAccount","_setCustomVar","_addItem","_addTrans","_trackSocial"],defaultTrackVarsObj:null,signals:{},hasSignals:!1,handle:DIL.modules.helpers.handleModuleError,init:function(a,b,d){try{this.tv=this.arr=this.dil=null;this.errorMessage="";this.signals={};this.hasSignals=!1;var c={name:"DIL GA Module Error"},e="";b instanceof DIL?(this.dil=b,c.partner=this.dil.api.getPartner()):(e="dilInstance is not a valid instance of DIL",
c.message=e,DIL.errorModule.handleError(c));a instanceof Array&&a.length?this.arr=a:(e="gaArray is not an array or is empty",c.message=e,DIL.errorModule.handleError(c));this.tv=this.constructTrackVars(d);this.errorMessage=e}catch(f){this.handle(f,"DIL.modules.GA.init() caught error with message ",this.dil)}finally{return this}},constructTrackVars:function(a){var b=[],d,c,e,f;if(this.defaultTrackVarsObj!==Object(this.defaultTrackVarsObj)){e=this.defaultTrackVars;f={};d=0;for(c=e.length;d<c;d++)f[e[d]]=
!0;this.defaultTrackVarsObj=f}else f=this.defaultTrackVarsObj;if(a===Object(a)){a=a.names;if(a instanceof Array&&(c=a.length))for(d=0;d<c;d++)e=a[d],"string"==typeof e&&e.length&&e in f&&b.push(e);if(b.length)return b}return this.defaultTrackVars},constructGAObj:function(a){var b={};a=a instanceof Array?a:this.arr;var d,c,e,f;d=0;for(c=a.length;d<c;d++)e=a[d],e instanceof Array&&e.length&&(e=[],f=a[d],e instanceof Array&&f instanceof Array&&Array.prototype.push.apply(e,f),f=e.shift(),"string"==typeof f&&
f.length&&(b[f]instanceof Array||(b[f]=[]),b[f].push(e)));return b},addToSignals:function(a,b){if("string"!=typeof a||""===a||null==b||""===b)return!1;this.signals[a]instanceof Array||(this.signals[a]=[]);this.signals[a].push(b);return this.hasSignals=!0},constructSignals:function(){var a=this.constructGAObj(),b={_setAccount:function(a){this.addToSignals("c_accountId",a)},_setCustomVar:function(a,b,c,d){"string"==typeof b&&b.length&&this.addToSignals("c_"+b,c)},_addItem:function(a,b,c,d,e,f){this.addToSignals("c_itemOrderId",
a);this.addToSignals("c_itemSku",b);this.addToSignals("c_itemName",c);this.addToSignals("c_itemCategory",d);this.addToSignals("c_itemPrice",e);this.addToSignals("c_itemQuantity",f)},_addTrans:function(a,b,c,d,e,f,h,m){this.addToSignals("c_transOrderId",a);this.addToSignals("c_transAffiliation",b);this.addToSignals("c_transTotal",c);this.addToSignals("c_transTax",d);this.addToSignals("c_transShipping",e);this.addToSignals("c_transCity",f);this.addToSignals("c_transState",h);this.addToSignals("c_transCountry",
m)},_trackSocial:function(a,b,c,d){this.addToSignals("c_socialNetwork",a);this.addToSignals("c_socialAction",b);this.addToSignals("c_socialTarget",c);this.addToSignals("c_socialPagePath",d)}},d=this.tv,c,e,f,h,m,u;c=0;for(e=d.length;c<e;c++)if(f=d[c],a.hasOwnProperty(f)&&b.hasOwnProperty(f)&&(u=a[f],u instanceof Array))for(h=0,m=u.length;h<m;h++)b[f].apply(this,u[h])},submit:function(){try{if(""!==this.errorMessage)return this.errorMessage;this.constructSignals();return this.hasSignals?(this.dil.api.signals(this.signals).submit(),
"Signals sent: "+this.dil.helpers.convertObjectToKeyValuePairs(this.signals,"=",!0)+this.dil.log):"No signals present"}catch(a){return this.handle(a,"DIL.modules.GA.submit() caught error with message ",this.dil)}},Stuffer:{LIMIT:5,dil:null,cookieName:null,delimiter:null,errorMessage:"",handle:DIL.modules.helpers.handleModuleError,callback:null,v:function(){return!1},init:function(a,b,d){try{this.callback=this.dil=null,this.errorMessage="",a instanceof DIL?(this.dil=a,this.v=this.dil.validators.isPopulatedString,
this.cookieName=this.v(b)?b:"aam_ga",this.delimiter=this.v(d)?d:"|"):this.handle({message:"dilInstance is not a valid instance of DIL"},"DIL.modules.GA.Stuffer.init() error: ")}catch(c){this.handle(c,"DIL.modules.GA.Stuffer.init() caught error with message ",this.dil)}finally{return this}},process:function(a){var b,d,c,e,f,h;h=!1;var m=1;if(a===Object(a)&&(b=a.stuff)&&b instanceof Array&&(d=b.length))for(a=0;a<d;a++)if((c=b[a])&&c===Object(c)&&(e=c.cn,f=c.cv,e==this.cookieName&&this.v(f))){h=!0;break}if(h){b=
f.split(this.delimiter);"undefined"==typeof window._gaq&&(window._gaq=[]);c=window._gaq;a=0;for(d=b.length;a<d&&!(h=b[a].split("="),f=h[0],h=h[1],this.v(f)&&this.v(h)&&c.push(["_setCustomVar",m++,f,h,1]),m>this.LIMIT);a++);this.errorMessage=1<m?"No errors - stuffing successful":"No valid values to stuff"}else this.errorMessage="Cookie name and value not found in json";if("function"==typeof this.callback)return this.callback()},submit:function(){try{var a=this;if(""!==this.errorMessage)return this.errorMessage;
this.dil.api.afterResult(function(b){a.process(b)}).submit();return"DIL.modules.GA.Stuffer.submit() successful"}catch(b){return this.handle(b,"DIL.modules.GA.Stuffer.submit() caught error with message ",this.dil)}}}};
DIL.modules.Peer39={aid:"",dil:null,optionals:null,errorMessage:"",calledBack:!1,script:null,scriptsSent:[],returnedData:[],handle:DIL.modules.helpers.handleModuleError,init:function(a,b,d){try{this.dil=null;this.errorMessage="";this.calledBack=!1;this.optionals=d===Object(d)?d:{};d={name:"DIL Peer39 Module Error"};var c=[],e="";this.isSecurePageButNotEnabled(document.location.protocol)&&(e="Module has not been enabled for a secure page",c.push(e),d.message=e,DIL.errorModule.handleError(d));b instanceof
DIL?(this.dil=b,d.partner=this.dil.api.getPartner()):(e="dilInstance is not a valid instance of DIL",c.push(e),d.message=e,DIL.errorModule.handleError(d));"string"==typeof a&&a.length?this.aid=a:(e="aid is not a string or is empty",c.push(e),d.message=e,DIL.errorModule.handleError(d));this.errorMessage=c.join("\n")}catch(f){this.handle(f,"DIL.modules.Peer39.init() caught error with message ",this.dil)}finally{return this}},isSecurePageButNotEnabled:function(a){return"https:"==a&&!0!==this.optionals.enableHTTPS?
!0:!1},constructSignals:function(){var a=this,b=this.constructScript(),d=DIL.variables.scriptNodeList[0];window["afterFinished_"+this.aid]=function(){try{var b=a.processData(p39_KVP_Short("c_p","|").split("|"));b.hasSignals&&a.dil.api.signals(b.signals).submit()}catch(d){}finally{a.calledBack=!0,"function"==typeof a.optionals.afterResult&&a.optionals.afterResult()}};d.parentNode.insertBefore(b,d);this.scriptsSent.push(b);return"Request sent to Peer39"},processData:function(a){var b,d,c,e,f={},h=!1;
this.returnedData.push(a);if(a instanceof Array)for(b=0,d=a.length;b<d;b++)c=a[b].split("="),e=c[0],c=c[1],e&&isFinite(c)&&!isNaN(parseInt(c,10))&&(f[e]instanceof Array||(f[e]=[]),f[e].push(c),h=!0);return{hasSignals:h,signals:f}},constructScript:function(){var a=document.createElement("script"),b=this.optionals,d=b.scriptId,c=b.scriptSrc,b=b.scriptParams;a.id="string"==typeof d&&d.length?d:"peer39ScriptLoader";a.type="text/javascript";"string"==typeof c&&c.length?a.src=c:(a.src=(this.dil.constants.IS_HTTPS?
"https:":"http:")+"//stags.peer39.net/"+this.aid+"/trg_"+this.aid+".js","string"==typeof b&&b.length&&(a.src+="?"+b));return a},submit:function(){try{return""!==this.errorMessage?this.errorMessage:this.constructSignals()}catch(a){return this.handle(a,"DIL.modules.Peer39.submit() caught error with message ",this.dil)}}};
var fDil = DIL.create({
			partner: "ford",
			uuidCookie:{
				name:'aam_uuid',
				days:30
				}
			});
var _scDilObj = s_gi(s_account);
DIL.modules.siteCatalyst.init(_scDilObj, fDil, {
	names: ['pageName', 'channel', 'campaign', 'products', 'events', 'pe', 'referrer', 'server', 'purchaseID', 'zip', 'state'],
	iteratedNames: [{
		name: 'eVar',
		maxIndex: 75
		}, {
		name: 'prop',
		maxIndex: 75
		}, {
		name: 'pev',
		maxIndex: 3
		}, {
		name: 'hier',
		maxIndex: 4
		}, {
		name: "list",
		maxIndex: 3
		}]
	});
	
	
function objIsEmpty(obj) { 
    for(var prop in obj) { 
        if(obj.hasOwnProperty(prop) && prop !== "") 
                return false; 
    }; 
        return true; 
    };

var uriData = DIL.tools.decomposeURI(document.URL);
delete uriData.hash;
delete uriData.search;
delete uriData.href;
if(! objIsEmpty(uriData.uriParams)){ 
	fDil.api.signals(uriData.uriParams, 'c_');
};
if(objIsEmpty(uriData.pathname)){ 
	delete uriData.pathname;
};
delete uriData.uriParams;

fDil.api.signals(uriData, 'c_').submit();

var b = fDil.helpers.getCookie("s_vi");
if(b){
	b = b.split("|")[1].split("[")[0];
	fDil.api.aamIdSync({
		dpid: '1308',
		dpuuid: b,
		minutesToLive: 20160
	});
};

if(typeof fDil != 'undefined' && typeof s.eVar31 != 'undefined' && s.eVar31 /*&& s.eVar31 != <ADD NOT LOGGED IN VALUE HERE>*/)
{
	var cksId = s.eVar31;
	fDil.api.aamIdSync({
		dpid: '1307',
		dpuuid: cksId,
		minutesToLive: 20160
	});
};



//Ford chooses to use jQuery Touchwipe and all associated files under the MIT license.
/**
 * Copyright (c) 2010 Matt Bryson* Dual licensed under the MIT or GPL Version 2 licenses.
 *
 * jQuery Plugin to obtain touch gestures from iPhone, iPod Touch and iPad, should also work with Android mobile phones (not tested yet!)
 * Common usage: wipe images (left and right to show the previous or next image)
 * 
 * @author Andreas Waltl, netCU Internetagentur (http://www.netcu.de)
 * @version 1.1.1 (9th December 2010) - fix bug (older IE's had problems)
 * @version 1.1 (1st September 2010) - support wipe up and wipe down
 * @version 1.0 (15th July 2010)
 */
 (function($) { 
   $.fn.touchwipe = function(settings) {
     var config = {
    		min_move_x: 20,
    		min_move_y: 20,
 			wipeLeft: function() { },
 			wipeRight: function() { },
 			wipeUp: function() { },
 			wipeDown: function() { },
			preventDefaultEvents: true
	 };
     
     if (settings) $.extend(config, settings);
 
     this.each(function() {
    	 var startX;
    	 var startY;
		 var isMoving = false;

    	 function cancelTouch() {
    		 this.removeEventListener('touchmove', onTouchMove);
    		 startX = null;
    		 isMoving = false;
    	 }	
    	 
    	 function onTouchMove(e) {
    		 if(config.preventDefaultEvents) {
    			 e.preventDefault();
    		 }
    		 if(isMoving) {
	    		 var x = e.touches[0].pageX;
	    		 var y = e.touches[0].pageY;
	    		 var dx = startX - x;
	    		 var dy = startY - y;
	    		 if(Math.abs(dx) >= config.min_move_x) {
	    			cancelTouch();
	    			if(dx > 0) {
	    				config.wipeLeft();
	    			}
	    			else {
	    				config.wipeRight();
	    			}
	    		 }
	    		 else if(Math.abs(dy) >= config.min_move_y) {
		    			cancelTouch();
		    			if(dy > 0) {
		    				config.wipeDown();
		    			}
		    			else {
		    				config.wipeUp();
		    			}
		    		 }
    		 }
    	 }
    	 
    	 function onTouchStart(e)
    	 {
    		 if (e.touches.length == 1) {
    			 startX = e.touches[0].pageX;
    			 startY = e.touches[0].pageY;
    			 isMoving = true;
    			 this.addEventListener('touchmove', onTouchMove, false);
    		 }
    	 }    	 
    	 if ('ontouchstart' in document.documentElement) {
    		 this.addEventListener('touchstart', onTouchStart, false);
    	 }
     });
 
     return this;
   };
 
 })(jQuery);


/*
Author: 		Brett Chaney
Description: 	Accordion taken from global.js in FTD2010 JS folder and added to ND namespace.
				Amends made to extend functionality for title links.
				Also add "single-open" class to "accordion-panel" DIV so only a single panel will open at any one time and prev/back buttons.
*/

ND = window.ND = window.ND || {};

(function($){

	ND.accordionMod = {
		init:function() {

			var curStep 	= $(".accordion-panel ul li").index($("li.active")) + 1,
				nextStep 	= curStep + 1,
				prevStep 	= curStep - 1;


			if(!$(".accordion-active").size()) {return;}
			
			$("div.accordion-active > UL > LI > DIV.dropdown").hide();
			$("div.accordion-active > UL > LI.active > DIV.dropdown").show();

			$("div.accordion-active > UL > LI > DIV.tab-area a").click(function(e) {
				e.stopPropagation();
			});

			$("div.accordion-active > UL > LI > DIV.tab-area").each(function() {

				if (!$(this).next().hasClass('dropdown')) {
					$(this).addClass('no-dropdown');
				}

			});

			$("div.accordion-active > UL > LI > DIV.tab-area").click(function(){

				var $this 		= $(this);

				// Add "single-open" class to "accordion-panel" DIV if you require only one panel to be open at any one time
				if ($(".accordion-panel.single-open")[0]) { 
				
					if($this.parent("li").hasClass("active")) {
						return;
					}
					$this.parents(".accordion-panel").find(".dropdown").slideUp(200).parent("li").removeClass("active");

					setTimeout(function() {
						$('html, body').animate({
					        scrollTop: $this.offset().top
					    },150);

					    // Show all dropdowns in Personalisation section
					    if ($(".panel").length) {
					    	$("div.accordion-active .panel .dropdown").show();
					    }
						
					},250);
					
				}

				if ($this.next().hasClass('dropdown')) {
					
					if(!$this.parent("li").hasClass("active")){
						$this.next("div.dropdown").slideDown(200);
						$this.parent("li").addClass("active");
					} else {
						$this.next("div.dropdown").slideUp(200);
						$this.parent("li").removeClass("active");
					}

					if ($(".single-open")[0]) { 
						nextStep = $(".accordion-panel > ul > li").index($("li.active")) + 2;
						prevStep = $(".accordion-panel > ul > li").index($("li.active"));
					}

				} else {

					var currLink = $this.find('a').attr('href');
					location.href = currLink;
				}
				
			});


			if ($(".accordion-panel.single-open")[0]) { 

				$(".accordion-next").on("click", function(e) {
					e.preventDefault();
					$("div.single-open > ul > li:nth-child(" + nextStep + ") > DIV.tab-area").trigger('click');
				});

				$(".accordion-prev").on("click", function(e) {
					if($(this).hasClass("islink")){
						return;
					}
					e.preventDefault();
					$("div.single-open > ul > li:nth-child(" + prevStep + ") > DIV.tab-area").trigger('click');
				});

			}

		}
	};

	$(function(){
		ND.accordionMod.init();
	});

})(jQuery);


//uuid.js
(function() {
  var _global = this;

  
  var _rng;

 
  if (typeof(require) == 'function') {
    try {
      var _rb = require('crypto').randomBytes;
      _rng = _rb && function() {return _rb(16);};
    } catch(e) {}
  }

  if (!_rng && _global.crypto && crypto.getRandomValues) {
    
    var _rnds8 = new Uint8Array(16);
    _rng = function whatwgRNG() {
      crypto.getRandomValues(_rnds8);
      return _rnds8;
    };
  }

  if (!_rng) {
    
    var  _rnds = new Array(16);
    _rng = function() {
      for (var i = 0, r; i < 16; i++) {
        if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
        _rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
      }

      return _rnds;
    };
  }

  var BufferClass = typeof(Buffer) == 'function' ? Buffer : Array;

  var _byteToHex = [];
  var _hexToByte = {};
  for (var i = 0; i < 256; i++) {
    _byteToHex[i] = (i + 0x100).toString(16).substr(1);
    _hexToByte[_byteToHex[i]] = i;
  }

  function parse(s, buf, offset) {
    var i = (buf && offset) || 0, ii = 0;

    buf = buf || [];
    s.toLowerCase().replace(/[0-9a-f]{2}/g, function(oct) {
      if (ii < 16) { // Don't overflow!
        buf[i + ii++] = _hexToByte[oct];
      }
    });

    while (ii < 16) {
      buf[i + ii++] = 0;
    }

    return buf;
  }

  function unparse(buf, offset) {
    var i = offset || 0, bth = _byteToHex;
    return  bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] + '-' +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]] +
            bth[buf[i++]] + bth[buf[i++]];
  }

  
  var _seedBytes = _rng();

  var _nodeId = [
    _seedBytes[0] | 0x01,
    _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
  ];

  var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

  var _lastMSecs = 0, _lastNSecs = 0;

  function v1(options, buf, offset) {
    var i = buf && offset || 0;
    var b = buf || [];

    options = options || {};

    var clockseq = options.clockseq != null ? options.clockseq : _clockseq;

    
    var msecs = options.msecs != null ? options.msecs : new Date().getTime();

    
    var nsecs = options.nsecs != null ? options.nsecs : _lastNSecs + 1;

    var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

    if (dt < 0 && options.clockseq == null) {
      clockseq = clockseq + 1 & 0x3fff;
    }

   
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs == null) {
      nsecs = 0;
    }

    if (nsecs >= 10000) {
      throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
    }

    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq;

    msecs += 12219292800000;

    var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff;

    var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff;

    b[i++] = tmh >>> 24 & 0xf | 0x10; 
    b[i++] = tmh >>> 16 & 0xff;

    b[i++] = clockseq >>> 8 | 0x80;

    b[i++] = clockseq & 0xff;

    var node = options.node || _nodeId;
    for (var n = 0; n < 6; n++) {
      b[i + n] = node[n];
    }

    return buf ? buf : unparse(b);
  }


  function v4(options, buf, offset) {
    var i = buf && offset || 0;

    if (typeof(options) == 'string') {
      buf = options == 'binary' ? new BufferClass(16) : null;
      options = null;
    }
    options = options || {};

    var rnds = options.random || (options.rng || _rng)();

    rnds[6] = (rnds[6] & 0x0f) | 0x40;
    rnds[8] = (rnds[8] & 0x3f) | 0x80;

    if (buf) {
      for (var ii = 0; ii < 16; ii++) {
        buf[i + ii] = rnds[ii];
      }
    }

    return buf || unparse(rnds);
  }

  var uuid = v4;
  uuid.v1 = v1;
  uuid.v4 = v4;
  uuid.parse = parse;
  uuid.unparse = unparse;
  uuid.BufferClass = BufferClass;

  if (typeof define === 'function' && define.amd) {
    define(function() {return uuid;});
  } else if (typeof(module) != 'undefined' && module.exports) {
    module.exports = uuid;
  } else {
    var _previousRoot = _global.uuid;

    uuid.noConflict = function() {
      _global.uuid = _previousRoot;
      return uuid;
    };

    _global.uuid = uuid;
  }
}).call(this);


/*
 * Foundation Responsive Library
 * http://foundation.zurb.com
 * Copyright 2014, ZURB
 * Free to use under the MIT license.
 * http://www.opensource.org/licenses/mit-license.php
*/

(function ($, window, document, undefined) {
  'use strict';

  var header_helpers = function (class_array) {
    var i = class_array.length;
    var head = $('head');

    while (i--) {
      if(head.has('.' + class_array[i]).length === 0) {
        head.append('<meta class="' + class_array[i] + '" />');
      }
    }
  };

  header_helpers([
    'foundation-mq-small',
    'foundation-mq-medium',
    'foundation-mq-large',
    'foundation-mq-xlarge',
    'foundation-mq-xxlarge',
    'foundation-data-attribute-namespace']);

  // Enable FastClick if present

  $(function() {
    if (typeof FastClick !== 'undefined') {
      // Don't attach to body if undefined
      if (typeof document.body !== 'undefined') {
        FastClick.attach(document.body);
      }
    }
  });

  // private Fast Selector wrapper,
  // returns jQuery object. Only use where
  // getElementById is not available.
  var S = function (selector, context) {
    if (typeof selector === 'string') {
      if (context) {
        var cont;
        if (context.jquery) {
          cont = context[0];
          if (!cont) return context;
        } else {
          cont = context;
        }
        return $(cont.querySelectorAll(selector));
      }

      return $(document.querySelectorAll(selector));
    }

    return $(selector, context);
  };

  // Namespace functions.

  var attr_name = function (init) {
    var arr = [];
    if (!init) arr.push('data');
    if (this.namespace.length > 0) arr.push(this.namespace);
    arr.push(this.name);

    return arr.join('-');
  };

  var add_namespace = function (str) {
    var parts = str.split('-'),
        i = parts.length,
        arr = [];

    while (i--) {
      if (i !== 0) {
        arr.push(parts[i]);
      } else {
        if (this.namespace.length > 0) {
          arr.push(this.namespace, parts[i]);
        } else {
          arr.push(parts[i]);
        }
      }
    }

    return arr.reverse().join('-');
  };

  // Event binding and data-options updating.

  var bindings = function (method, options) {
    var self = this,
        should_bind_events = !S(this).data(this.attr_name(true));

    if (typeof method === 'string') {
      return this[method].call(this, options);
    }

    if (S(this.scope).is('[' + this.attr_name() +']')) {
      S(this.scope).data(this.attr_name(true) + '-init', $.extend({}, this.settings, (options || method), this.data_options(S(this.scope))));

      if (should_bind_events) {
        this.events(this.scope);
      }

    } else {
      S('[' + this.attr_name() +']', this.scope).each(function () {
        var should_bind_events = !S(this).data(self.attr_name(true) + '-init');
        S(this).data(self.attr_name(true) + '-init', $.extend({}, self.settings, (options || method), self.data_options(S(this))));

        if (should_bind_events) {
          self.events(this);
        }
      });
    }
  };

  var single_image_loaded = function (image, callback) {
    function loaded () {
      callback(image[0]);
    }

    function bindLoad () {
      this.one('load', loaded);

      if (/MSIE (\d+\.\d+);/.test(navigator.userAgent)) {
        var src = this.attr( 'src' ),
            param = src.match( /\?/ ) ? '&' : '?';

        param += 'random=' + (new Date()).getTime();
        this.attr('src', src + param);
      }
    }

    if (!image.attr('src')) {
      loaded();
      return;
    }

    if (image[0].complete || image[0].readyState === 4) {
      loaded();
    } else {
      bindLoad.call(image);
    }
  };

  /*
    https://github.com/paulirish/matchMedia.js
  */

  window.matchMedia = window.matchMedia || (function( doc ) {

    "use strict";

    var bool,
        docElem = doc.documentElement,
        refNode = docElem.firstElementChild || docElem.firstChild,
        // fakeBody required for <FF4 when executed in <head>
        fakeBody = doc.createElement( "body" ),
        div = doc.createElement( "div" );

    div.id = "mq-test-1";
    div.style.cssText = "position:absolute;top:-100em";
    fakeBody.style.background = "none";
    fakeBody.appendChild(div);

    return function (q) {

      div.innerHTML = "&shy;<style media=\"" + q + "\"> #mq-test-1 { width: 42px; }</style>";

      docElem.insertBefore( fakeBody, refNode );
      bool = div.offsetWidth === 42;
      docElem.removeChild( fakeBody );

      return {
        matches: bool,
        media: q
      };

    };

  }( document ));

  /*
   * jquery.requestAnimationFrame
   * https://github.com/gnarf37/jquery-requestAnimationFrame
   * Requires jQuery 1.8+
   *
   * Copyright (c) 2012 Corey Frang
   * Licensed under the MIT license.
   */

  (function($) {

  // requestAnimationFrame polyfill adapted from Erik M??ller
  // fixes from Paul Irish and Tino Zijdel
  // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
  // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

  var animating,
      lastTime = 0,
      vendors = ['webkit', 'moz'],
      requestAnimationFrame = window.requestAnimationFrame,
      cancelAnimationFrame = window.cancelAnimationFrame,
      jqueryFxAvailable = 'undefined' !== typeof jQuery.fx;

  for (; lastTime < vendors.length && !requestAnimationFrame; lastTime++) {
    requestAnimationFrame = window[ vendors[lastTime] + "RequestAnimationFrame" ];
    cancelAnimationFrame = cancelAnimationFrame ||
      window[ vendors[lastTime] + "CancelAnimationFrame" ] ||
      window[ vendors[lastTime] + "CancelRequestAnimationFrame" ];
  }

  function raf() {
    if (animating) {
      requestAnimationFrame(raf);

      if (jqueryFxAvailable) {
        jQuery.fx.tick();
      }
    }
  }

  if (requestAnimationFrame) {
    // use rAF
    window.requestAnimationFrame = requestAnimationFrame;
    window.cancelAnimationFrame = cancelAnimationFrame;

    if (jqueryFxAvailable) {
      jQuery.fx.timer = function (timer) {
        if (timer() && jQuery.timers.push(timer) && !animating) {
          animating = true;
          raf();
        }
      };

      jQuery.fx.stop = function () {
        animating = false;
      };
    }
  } else {
    // polyfill
    window.requestAnimationFrame = function (callback) {
      var currTime = new Date().getTime(),
        timeToCall = Math.max(0, 16 - (currTime - lastTime)),
        id = window.setTimeout(function () {
          callback(currTime + timeToCall);
        }, timeToCall);
      lastTime = currTime + timeToCall;
      return id;
    };

    window.cancelAnimationFrame = function (id) {
      clearTimeout(id);
    };

  }

  }( jQuery ));


  function removeQuotes (string) {
    if (typeof string === 'string' || string instanceof String) {
      string = string.replace(/^['\\/"]+|(;\s?})+|['\\/"]+$/g, '');
    }

    return string;
  }

  window.Foundation = {
    name : 'Foundation',

    version : '5.2.3',

    media_queries : {
      small : S('.foundation-mq-small').css('font-family').replace(/^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g, ''),
      medium : S('.foundation-mq-medium').css('font-family').replace(/^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g, ''),
      large : S('.foundation-mq-large').css('font-family').replace(/^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g, ''),
      xlarge: S('.foundation-mq-xlarge').css('font-family').replace(/^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g, ''),
      xxlarge: S('.foundation-mq-xxlarge').css('font-family').replace(/^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g, '')
    },

    stylesheet : $('<style></style>').appendTo('head')[0].sheet,

    global: {
      namespace: undefined
    },

    init : function (scope, libraries, method, options, response) {
      var args = [scope, method, options, response],
          responses = [];

      // check RTL
      this.rtl = /rtl/i.test(S('html').attr('dir'));

      // set foundation global scope
      this.scope = scope || this.scope;

      this.set_namespace();

      if (libraries && typeof libraries === 'string' && !/reflow/i.test(libraries)) {
        if (this.libs.hasOwnProperty(libraries)) {
          responses.push(this.init_lib(libraries, args));
        }
      } else {
        for (var lib in this.libs) {
          responses.push(this.init_lib(lib, libraries));
        }
      }

      return scope;
    },

    init_lib : function (lib, args) {
      if (this.libs.hasOwnProperty(lib)) {
        this.patch(this.libs[lib]);

        if (args && args.hasOwnProperty(lib)) {
            if (typeof this.libs[lib].settings !== 'undefined') {
                $.extend(true, this.libs[lib].settings, args[lib]);
            }
            else if (typeof this.libs[lib].defaults !== 'undefined') {
                $.extend(true, this.libs[lib].defaults, args[lib]);
            }
          return this.libs[lib].init.apply(this.libs[lib], [this.scope, args[lib]]);
        }

        args = args instanceof Array ? args : new Array(args);    // PATCH: added this line
        return this.libs[lib].init.apply(this.libs[lib], args);
      }

      return function () {};
    },

    patch : function (lib) {
      lib.scope = this.scope;
      lib.namespace = this.global.namespace;
      lib.rtl = this.rtl;
      lib['data_options'] = this.utils.data_options;
      lib['attr_name'] = attr_name;
      lib['add_namespace'] = add_namespace;
      lib['bindings'] = bindings;
      lib['S'] = this.utils.S;
    },

    inherit : function (scope, methods) {
      var methods_arr = methods.split(' '),
          i = methods_arr.length;

      while (i--) {
        if (this.utils.hasOwnProperty(methods_arr[i])) {
          scope[methods_arr[i]] = this.utils[methods_arr[i]];
        }
      }
    },

    set_namespace: function () {

      // Description:
      //    Don't bother reading the namespace out of the meta tag
      //    if the namespace has been set globally in javascript
      //
      // Example:
      //    Foundation.global.namespace = 'my-namespace';
      // or make it an empty string:
      //    Foundation.global.namespace = '';
      //
      //

      // If the namespace has not been set (is undefined), try to read it out of the meta element.
      // Otherwise use the globally defined namespace, even if it's empty ('')
      var namespace = ( this.global.namespace === undefined ) ? $('.foundation-data-attribute-namespace').css('font-family') : this.global.namespace;

      // Finally, if the namsepace is either undefined or false, set it to an empty string.
      // Otherwise use the namespace value.
      this.global.namespace = ( namespace === undefined || /false/i.test(namespace) ) ? '' : namespace;
    },

    libs : {},

    // methods that can be inherited in libraries
    utils : {

      // Description:
      //    Fast Selector wrapper returns jQuery object. Only use where getElementById
      //    is not available.
      //
      // Arguments:
      //    Selector (String): CSS selector describing the element(s) to be
      //    returned as a jQuery object.
      //
      //    Scope (String): CSS selector describing the area to be searched. Default
      //    is document.
      //
      // Returns:
      //    Element (jQuery Object): jQuery object containing elements matching the
      //    selector within the scope.
      S : S,

      // Description:
      //    Executes a function a max of once every n milliseconds
      //
      // Arguments:
      //    Func (Function): Function to be throttled.
      //
      //    Delay (Integer): Function execution threshold in milliseconds.
      //
      // Returns:
      //    Lazy_function (Function): Function with throttling applied.
      throttle : function (func, delay) {
        var timer = null;

        return function () {
          var context = this, args = arguments;

          if (timer == null) {
            timer = setTimeout(function () {
              func.apply(context, args);
              timer = null;
            }, delay);
          }
        };
      },

      // Description:
      //    Executes a function when it stops being invoked for n seconds
      //    Modified version of _.debounce() http://underscorejs.org
      //
      // Arguments:
      //    Func (Function): Function to be debounced.
      //
      //    Delay (Integer): Function execution threshold in milliseconds.
      //
      //    Immediate (Bool): Whether the function should be called at the beginning
      //    of the delay instead of the end. Default is false.
      //
      // Returns:
      //    Lazy_function (Function): Function with debouncing applied.
      debounce : function (func, delay, immediate) {
        var timeout, result;
        return function () {
          var context = this, args = arguments;
          var later = function () {
            timeout = null;
            if (!immediate) result = func.apply(context, args);
          };
          var callNow = immediate && !timeout;
          clearTimeout(timeout);
          timeout = setTimeout(later, delay);
          if (callNow) result = func.apply(context, args);
          return result;
        };
      },

      // Description:
      //    Parses data-options attribute
      //
      // Arguments:
      //    El (jQuery Object): Element to be parsed.
      //
      // Returns:
      //    Options (Javascript Object): Contents of the element's data-options
      //    attribute.
      data_options : function (el, data_attr_name) {
        data_attr_name = data_attr_name || 'options';
        var opts = {}, ii, p, opts_arr,
            data_options = function (el) {
              var namespace = Foundation.global.namespace;

              if (namespace.length > 0) {
                return el.data(namespace + '-' + data_attr_name);
              }

              return el.data(data_attr_name);
            };

        var cached_options = data_options(el);

        if (typeof cached_options === 'object') {
          return cached_options;
        }

        opts_arr = (cached_options || ':').split(';');
        ii = opts_arr.length;

        function isNumber (o) {
          return ! isNaN (o-0) && o !== null && o !== "" && o !== false && o !== true;
        }

        function trim (str) {
          if (typeof str === 'string') return $.trim(str);
          return str;
        }

        while (ii--) {
          p = opts_arr[ii].split(':');
          p = [p[0], p.slice(1).join(':')];

          if (/true/i.test(p[1])) p[1] = true;
          if (/false/i.test(p[1])) p[1] = false;
          if (isNumber(p[1])) {
            if (p[1].indexOf('.') === -1) {
              p[1] = parseInt(p[1], 10);
            } else {
              p[1] = parseFloat(p[1]);
            }
          }

          if (p.length === 2 && p[0].length > 0) {
            opts[trim(p[0])] = trim(p[1]);
          }
        }

        return opts;
      },

      // Description:
      //    Adds JS-recognizable media queries
      //
      // Arguments:
      //    Media (String): Key string for the media query to be stored as in
      //    Foundation.media_queries
      //
      //    Class (String): Class name for the generated <meta> tag
      register_media : function (media, media_class) {
        if(Foundation.media_queries[media] === undefined) {
          $('head').append('<meta class="' + media_class + '">');
          Foundation.media_queries[media] = removeQuotes($('.' + media_class).css('font-family'));
        }
      },

      // Description:
      //    Add custom CSS within a JS-defined media query
      //
      // Arguments:
      //    Rule (String): CSS rule to be appended to the document.
      //
      //    Media (String): Optional media query string for the CSS rule to be
      //    nested under.
      add_custom_rule : function (rule, media) {
        if (media === undefined && Foundation.stylesheet) {
          Foundation.stylesheet.insertRule(rule, Foundation.stylesheet.cssRules.length);
        } else {
          var query = Foundation.media_queries[media];

          if (query !== undefined) {
            Foundation.stylesheet.insertRule('@media ' +
              Foundation.media_queries[media] + '{ ' + rule + ' }');
          }
        }
      },

      // Description:
      //    Performs a callback function when an image is fully loaded
      //
      // Arguments:
      //    Image (jQuery Object): Image(s) to check if loaded.
      //
      //    Callback (Function): Function to execute when image is fully loaded.
      image_loaded : function (images, callback) {
        var self = this,
            unloaded = images.length;

        if (unloaded === 0) {
          callback(images);
        }

        images.each(function () {
          single_image_loaded(self.S(this), function () {
            unloaded -= 1;
            if (unloaded === 0) {
              callback(images);
            }
          });
        });
      },

      // Description:
      //    Returns a random, alphanumeric string
      //
      // Arguments:
      //    Length (Integer): Length of string to be generated. Defaults to random
      //    integer.
      //
      // Returns:
      //    Rand (String): Pseudo-random, alphanumeric string.
      random_str : function () {
        if (!this.fidx) this.fidx = 0;
        this.prefix = this.prefix || [(this.name || 'F'), (+new Date).toString(36)].join('-');

        return this.prefix + (this.fidx++).toString(36);
      }
    }
  };

  $.fn.foundation = function () {
    var args = Array.prototype.slice.call(arguments, 0);

    return this.each(function () {
      Foundation.init.apply(Foundation, [this].concat(args));
      return this;
    });
  };

}(jQuery, window, window.document));


;(function ($, window, document, undefined) {
  'use strict';

  Foundation.libs.equalizer = {
    name : 'equalizer',

    version : '5.2.3',

    settings : {
      use_tallest: true,
      before_height_change: $.noop,
      after_height_change: $.noop,
      equalize_on_stack: false
    },

    init : function (scope, method, options) {
      Foundation.inherit(this, 'image_loaded');
      this.bindings(method, options);
      this.reflow();
    },

    events : function () {
      this.S(window).off('.equalizer').on('resize.fndtn.equalizer', function(e){
        this.reflow();
      }.bind(this));
    },

    equalize: function(equalizer) {
      var isStacked = false,
          vals = equalizer.find('[' + this.attr_name() + '-watch]:visible'),
          settings = equalizer.data(this.attr_name(true)+'-init');

      if (vals.length === 0) return;
      var firstTopOffset = vals.first().offset().top;
      settings.before_height_change();
      equalizer.trigger('before-height-change');
      vals.height('inherit');
      vals.each(function(){
        var el = $(this);
        if (el.offset().top !== firstTopOffset) {
          isStacked = true;
        }
      });

      if (settings.equalize_on_stack === false) {
        if (isStacked) return;
      };

      var heights = vals.map(function(){ return $(this).outerHeight(false) }).get();

      if (settings.use_tallest) {
        var max = Math.max.apply(null, heights);
        vals.css('height', max);
      } else {
        var min = Math.min.apply(null, heights);
        vals.css('height', min);
      }
      settings.after_height_change();
      equalizer.trigger('after-height-change');
    },

    reflow : function () {
      var self = this;

      this.S('[' + this.attr_name() + ']', this.scope).each(function(){
        var $eq_target = $(this);
        self.image_loaded(self.S('img', this), function(){
          self.equalize($eq_target)
        });
      });
    }
  };
})(jQuery, window, window.document);



;(function ($, window, document, undefined) {
  'use strict';

  Foundation.libs.accordion = {
    name : 'accordion',

    version : '5.2.3',

    settings : {
      active_class: 'active',
      multi_expand: false,
      toggleable: true,
      callback : function () {}
    },

    init : function (scope, method, options) {
      this.bindings(method, options);
    },

    events : function () {
      var self = this;
      var S = this.S;
      S(this.scope)
      .off('.fndtn.accordion')
      .on('click.fndtn.accordion', '[' + this.attr_name() + '] > dd > a', function (e) {
        var accordion = S(this).closest('[' + self.attr_name() + ']'),
            target = S('#' + this.href.split('#')[1]),
            siblings = S('dd > .content', accordion),
            aunts = $('dd', accordion),
            groupSelector = self.attr_name() + '=' + accordion.attr(self.attr_name()),
            settings = accordion.data(self.attr_name(true) + '-init'),
            active_content = S('dd > .content.' + settings.active_class, accordion);
        e.preventDefault();

        if (accordion.attr(self.attr_name())) {
          siblings = siblings.add('[' + groupSelector + '] dd > .content');
          aunts = aunts.add('[' + groupSelector + '] dd');
        }

        if (settings.toggleable && target.is(active_content)) {
          target.parent('dd').toggleClass(settings.active_class, false);
          return target.toggleClass(settings.active_class, false);
        }

        if (!settings.multi_expand) {
          siblings.removeClass(settings.active_class);
          aunts.removeClass(settings.active_class);
        }

        target.addClass(settings.active_class).parent().addClass(settings.active_class);
        settings.callback(target);
      });
    },

    off : function () {},

    reflow : function () {}
  };
}(jQuery, window, window.document));


;(function ($, window, document, undefined) {
  'use strict';

  Foundation.libs.reveal = {
    name : 'reveal',

    version : '5.2.3',

    locked : false,

    settings : {
      animation: 'fadeAndPop',
      animation_speed: 250,
      close_on_background_click: true,
      close_on_esc: true,
      dismiss_modal_class: 'close-reveal-modal',
      bg_class: 'reveal-modal-bg',
      open: function(){},
      opened: function(){},
      close: function(){},
      closed: function(){},
      bg : $('.reveal-modal-bg'),
      css : {
        open : {
          'opacity': 0,
          'visibility': 'visible',
          'display' : 'block'
        },
        close : {
          'opacity': 1,
          'visibility': 'hidden',
          'display': 'none'
        }
      }
    },

    init : function (scope, method, options) {
      $.extend(true, this.settings, method, options);
      this.bindings(method, options);
    },

    events : function (scope) {
      var self = this,
          S = self.S;

      S(this.scope)
        .off('.reveal')
        .on('click.fndtn.reveal', '[' + this.add_namespace('data-reveal-id') + ']', function (e) {
          e.preventDefault();

          if (!self.locked) {
            var element = S(this),
                ajax = element.data(self.data_attr('reveal-ajax'));

            self.locked = true;

            if (typeof ajax === 'undefined') {
              self.open.call(self, element);
            } else {
              var url = ajax === true ? element.attr('href') : ajax;

              self.open.call(self, element, {url: url});
            }
          }
        });

      S(document)
        .on('touchend.fndtn.reveal click.fndtn.reveal', this.close_targets(), function (e) {

          e.preventDefault();

          if (!self.locked) {
            var settings = S('[' + self.attr_name() + '].open').data(self.attr_name(true) + '-init'),
                bg_clicked = S(e.target)[0] === S('.' + settings.bg_class)[0];

            if (bg_clicked) {
              if (settings.close_on_background_click) {
                e.stopPropagation();
              } else {
                return;
              }
            }

            self.locked = true;
            self.close.call(self, bg_clicked ? S('[' + self.attr_name() + '].open') : S(this).closest('[' + self.attr_name() + ']'));
          }
        });

      if(S('[' + self.attr_name() + ']', this.scope).length > 0) {
        S(this.scope)
          // .off('.reveal')
          .on('open.fndtn.reveal', this.settings.open)
          .on('opened.fndtn.reveal', this.settings.opened)
          .on('opened.fndtn.reveal', this.open_video)
          .on('close.fndtn.reveal', this.settings.close)
          .on('closed.fndtn.reveal', this.settings.closed)
          .on('closed.fndtn.reveal', this.close_video);
      } else {
        S(this.scope)
          // .off('.reveal')
          .on('open.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.open)
          .on('opened.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.opened)
          .on('opened.fndtn.reveal', '[' + self.attr_name() + ']', this.open_video)
          .on('close.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.close)
          .on('closed.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.closed)
          .on('closed.fndtn.reveal', '[' + self.attr_name() + ']', this.close_video);
      }

      return true;
    },

    // PATCH #3: turning on key up capture only when a reveal window is open
    key_up_on : function (scope) {
      var self = this;

      // PATCH #1: fixing multiple keyup event trigger from single key press
      self.S('body').off('keyup.fndtn.reveal').on('keyup.fndtn.reveal', function ( event ) {
        var open_modal = self.S('[' + self.attr_name() + '].open'),
            settings = open_modal.data(self.attr_name(true) + '-init');
        // PATCH #2: making sure that the close event can be called only while unlocked,
        //           so that multiple keyup.fndtn.reveal events don't prevent clean closing of the reveal window.
        if ( settings && event.which === 27  && settings.close_on_esc && !self.locked) { // 27 is the keycode for the Escape key
          self.close.call(self, open_modal);
        }
      });

      return true;
    },

    // PATCH #3: turning on key up capture only when a reveal window is open
    key_up_off : function (scope) {
      this.S('body').off('keyup.fndtn.reveal');
      return true;
    },

    open : function (target, ajax_settings) {
      var self = this,
          modal;

      if (target) {
        if (typeof target.selector !== 'undefined') {
          // Find the named node; only use the first one found, since the rest of the code assumes there's only one node
          modal = self.S('#' + target.data(self.data_attr('reveal-id'))).first();
        } else {
          modal = self.S(this.scope);

          ajax_settings = target;
        }
      } else {
        modal = self.S(this.scope);
      }

      var settings = modal.data(self.attr_name(true) + '-init');
      settings = settings || this.settings;

      if (!modal.hasClass('open')) {
        var open_modal = self.S('[' + self.attr_name() + '].open');

        if (typeof modal.data('css-top') === 'undefined') {
          modal.data('css-top', parseInt(modal.css('top'), 10))
            .data('offset', this.cache_offset(modal));
        }

        this.key_up_on(modal);    // PATCH #3: turning on key up capture only when a reveal window is open
        modal.trigger('open');

        if (open_modal.length < 1) {
          this.toggle_bg(modal, true);
        }

        if (typeof ajax_settings === 'string') {
          ajax_settings = {
            url: ajax_settings
          };
        }

        if (typeof ajax_settings === 'undefined' || !ajax_settings.url) {
          if (open_modal.length > 0) {
            this.hide(open_modal, settings.css.close);
          }

          this.show(modal, settings.css.open);
        } else {
          var old_success = typeof ajax_settings.success !== 'undefined' ? ajax_settings.success : null;

          $.extend(ajax_settings, {
            success: function (data, textStatus, jqXHR) {
              if ( $.isFunction(old_success) ) {
                old_success(data, textStatus, jqXHR);
              }

              modal.html(data);
              self.S(modal).foundation('section', 'reflow');
              self.S(modal).children().foundation();

              if (open_modal.length > 0) {
                self.hide(open_modal, settings.css.close);
              }
              self.show(modal, settings.css.open);
            }
          });

          $.ajax(ajax_settings);
        }
      }
    },

    close : function (modal) {
      var modal = modal && modal.length ? modal : this.S(this.scope),
          open_modals = this.S('[' + this.attr_name() + '].open'),
          settings = modal.data(this.attr_name(true) + '-init') || this.settings;

      if (open_modals.length > 0) {
        this.locked = true;
        this.key_up_off(modal);   // PATCH #3: turning on key up capture only when a reveal window is open
        modal.trigger('close');
        this.toggle_bg(modal, false);
        this.hide(open_modals, settings.css.close, settings);
      }
    },

    close_targets : function () {
      var base = '.' + this.settings.dismiss_modal_class;

      if (this.settings.close_on_background_click) {
        return base + ', .' + this.settings.bg_class;
      }

      return base;
    },

    toggle_bg : function (modal, state) {
      if (this.S('.' + this.settings.bg_class).length === 0) {
        this.settings.bg = $('<div />', {'class': this.settings.bg_class})
          .appendTo('body').hide();
      }

      var visible = this.settings.bg.filter(':visible').length > 0;
      if ( state != visible ) {
        if ( state == undefined ? visible : !state ) {
          this.hide(this.settings.bg);
        } else {
          this.show(this.settings.bg);
        }
      }
    },

    show : function (el, css) {
      // is modal
      if (css) {
        var settings = el.data(this.attr_name(true) + '-init');
        settings = settings || this.settings;

        if (el.parent('body').length === 0) {
          var placeholder = el.wrap('<div style="display: none;" />').parent(),
              rootElement = this.settings.rootElement || 'body';

          el.on('closed.fndtn.reveal.wrapped', function() {
            el.detach().appendTo(placeholder);
            el.unwrap().unbind('closed.fndtn.reveal.wrapped');
          });

          el.detach().appendTo(rootElement);
        }

        var animData = getAnimationData(settings.animation);
        if (!animData.animate) {
          this.locked = false;
        }
        if (animData.pop) {
          css.top = $(window).scrollTop() - el.data('offset') + 'px';
          var end_css = {
            top: $(window).scrollTop() + el.data('css-top') + 'px',
            opacity: 1
          };

          return setTimeout(function () {
            return el
              .css(css)
              .animate(end_css, settings.animation_speed, 'linear', function () {
                this.locked = false;
                el.trigger('opened');
              }.bind(this))
              .addClass('open');
          }.bind(this), settings.animation_speed / 2);
        }

        if (animData.fade) {
          css.top = $(window).scrollTop() + el.data('css-top') + 'px';
          var end_css = {opacity: 1};

          return setTimeout(function () {
            return el
              .css(css)
              .animate(end_css, settings.animation_speed, 'linear', function () {
                this.locked = false;
                el.trigger('opened');
              }.bind(this))
              .addClass('open');
          }.bind(this), settings.animation_speed / 2);
        }

        return el.css(css).show().css({opacity: 1}).addClass('open').trigger('opened');
      }

      var settings = this.settings;

      // should we animate the background?
      if (getAnimationData(settings.animation).fade) {
        return el.fadeIn(settings.animation_speed / 2);
      }

      this.locked = false;

      return el.show();
    },

    hide : function (el, css) {
      // is modal
      if (css) {
        var settings = el.data(this.attr_name(true) + '-init');
        settings = settings || this.settings;

        var animData = getAnimationData(settings.animation);
        if (!animData.animate) {
          this.locked = false;
        }
        if (animData.pop) {
          var end_css = {
            top: - $(window).scrollTop() - el.data('offset') + 'px',
            opacity: 0
          };

          return setTimeout(function () {
            return el
              .animate(end_css, settings.animation_speed, 'linear', function () {
                this.locked = false;
                el.css(css).trigger('closed');
              }.bind(this))
              .removeClass('open');
          }.bind(this), settings.animation_speed / 2);
        }

        if (animData.fade) {
          var end_css = {opacity: 0};

          return setTimeout(function () {
            return el
              .animate(end_css, settings.animation_speed, 'linear', function () {
                this.locked = false;
                el.css(css).trigger('closed');
              }.bind(this))
              .removeClass('open');
          }.bind(this), settings.animation_speed / 2);
        }

        return el.hide().css(css).removeClass('open').trigger('closed');
      }

      var settings = this.settings;

      // should we animate the background?
      if (getAnimationData(settings.animation).fade) {
        return el.fadeOut(settings.animation_speed / 2);
      }

      return el.hide();
    },

    close_video : function (e) {
      var video = $('.flex-video', e.target),
          iframe = $('iframe', video);

      if (iframe.length > 0) {
        iframe.attr('data-src', iframe[0].src);
        iframe.attr('src', 'about:blank');
        video.hide();
      }
    },

    open_video : function (e) {
      var video = $('.flex-video', e.target),
          iframe = video.find('iframe');

      if (iframe.length > 0) {
        var data_src = iframe.attr('data-src');
        if (typeof data_src === 'string') {
          iframe[0].src = iframe.attr('data-src');
        } else {
          var src = iframe[0].src;
          iframe[0].src = undefined;
          iframe[0].src = src;
        }
        video.show();
      }
    },

    data_attr: function (str) {
      if (this.namespace.length > 0) {
        return this.namespace + '-' + str;
      }

      return str;
    },

    cache_offset : function (modal) {
      var offset = modal.show().height() + parseInt(modal.css('top'), 10);

      modal.hide();

      return offset;
    },

    off : function () {
      $(this.scope).off('.fndtn.reveal');
    },

    reflow : function () {}
  };

  /*
   * getAnimationData('popAndFade') // {animate: true,  pop: true,  fade: true}
   * getAnimationData('fade')       // {animate: true,  pop: false, fade: true}
   * getAnimationData('pop')        // {animate: true,  pop: true,  fade: false}
   * getAnimationData('foo')        // {animate: false, pop: false, fade: false}
   * getAnimationData(null)         // {animate: false, pop: false, fade: false}
   */
  function getAnimationData(str) {
    var fade = /fade/i.test(str);
    var pop = /pop/i.test(str);
    return {
      animate: fade || pop,
      pop: pop,
      fade: fade
    };
  }
}(jQuery, window, window.document));


;(function ($, window, document, undefined) {
  'use strict';

  Foundation.libs.dropdown = {
    name : 'dropdown',

    version : '5.2.3',

    settings : {
      active_class: 'open',
      align: 'bottom',
      is_hover: false,
      opened: function(){},
      closed: function(){}
    },

    init : function (scope, method, options) {
      Foundation.inherit(this, 'throttle');

      this.bindings(method, options);
    },

    events : function (scope) {
      var self = this,
          S = self.S;

      S(this.scope)
        .off('.dropdown')
        .on('click.fndtn.dropdown', '[' + this.attr_name() + ']', function (e) {
          var settings = S(this).data(self.attr_name(true) + '-init') || self.settings;
          if (!settings.is_hover || Modernizr.touch) {
            e.preventDefault();
            self.toggle($(this));
          }
        })
        .on('mouseenter.fndtn.dropdown', '[' + this.attr_name() + '], [' + this.attr_name() + '-content]', function (e) {
          var $this = S(this),
              dropdown,
              target;

          clearTimeout(self.timeout);

          if ($this.data(self.data_attr())) {
            dropdown = S('#' + $this.data(self.data_attr()));
            target = $this;
          } else {
            dropdown = $this;
            target = S("[" + self.attr_name() + "='" + dropdown.attr('id') + "']");
          }

          var settings = target.data(self.attr_name(true) + '-init') || self.settings;
          
          if(S(e.target).data(self.data_attr()) && settings.is_hover) {
            self.closeall.call(self);
          }
          
          if (settings.is_hover) self.open.apply(self, [dropdown, target]);
        })
        .on('mouseleave.fndtn.dropdown', '[' + this.attr_name() + '], [' + this.attr_name() + '-content]', function (e) {
          var $this = S(this);
          self.timeout = setTimeout(function () {
            if ($this.data(self.data_attr())) {
              var settings = $this.data(self.data_attr(true) + '-init') || self.settings;
              if (settings.is_hover) self.close.call(self, S('#' + $this.data(self.data_attr())));
            } else {
              var target = S('[' + self.attr_name() + '="' + S(this).attr('id') + '"]'),
                  settings = target.data(self.attr_name(true) + '-init') || self.settings;
              if (settings.is_hover) self.close.call(self, $this);
            }
          }.bind(this), 150);
        })
        .on('click.fndtn.dropdown', function (e) {
          var parent = S(e.target).closest('[' + self.attr_name() + '-content]');

          if (S(e.target).data(self.data_attr()) || S(e.target).parent().data(self.data_attr())) {
            return;
          }
          if (!(S(e.target).data('revealId')) && 
            (parent.length > 0 && (S(e.target).is('[' + self.attr_name() + '-content]') || 
              $.contains(parent.first()[0], e.target)))) {
            e.stopPropagation();
            return;
          }

          self.close.call(self, S('[' + self.attr_name() + '-content]'));
        })
        .on('opened.fndtn.dropdown', '[' + self.attr_name() + '-content]', function () {
            self.settings.opened.call(this);
        })
        .on('closed.fndtn.dropdown', '[' + self.attr_name() + '-content]', function () {
            self.settings.closed.call(this);
        });

      S(window)
        .off('.dropdown')
        .on('resize.fndtn.dropdown', self.throttle(function () {
          self.resize.call(self);
        }, 50));

      this.resize();
    },

    close: function (dropdown) {
      var self = this;
      dropdown.each(function () {
        if (self.S(this).hasClass(self.settings.active_class)) {
          self.S(this)
            .css(Foundation.rtl ? 'right':'left', '-99999px')
            .removeClass(self.settings.active_class)
            .prev('[' + self.attr_name() + ']')
            .removeClass(self.settings.active_class)
            .removeData('target');

          self.S(this).trigger('closed', [dropdown]);
        }
      });
    },

    closeall: function() {
      var self = this;
      $.each(self.S('[' + this.attr_name() + '-content]'), function() {
        self.close.call(self, self.S(this))
      });
    },

    open: function (dropdown, target) {
        this
          .css(dropdown
            .addClass(this.settings.active_class), target);
        dropdown.prev('[' + this.attr_name() + ']').addClass(this.settings.active_class);
        dropdown.data('target', target.get(0)).trigger('opened', [dropdown, target]);
    },

    data_attr: function () {
      if (this.namespace.length > 0) {
        return this.namespace + '-' + this.name;
      }

      return this.name;
    },

    toggle : function (target) {
      var dropdown = this.S('#' + target.data(this.data_attr()));
      if (dropdown.length === 0) {
        // No dropdown found, not continuing
        return;
      }

      this.close.call(this, this.S('[' + this.attr_name() + '-content]').not(dropdown));

      if (dropdown.hasClass(this.settings.active_class)) {
        this.close.call(this, dropdown);
        if (dropdown.data('target') !== target.get(0))
          this.open.call(this, dropdown, target);
      } else {
        this.open.call(this, dropdown, target);
      }
    },

    resize : function () {
      var dropdown = this.S('[' + this.attr_name() + '-content].open'),
          target = this.S("[" + this.attr_name() + "='" + dropdown.attr('id') + "']");

      if (dropdown.length && target.length) {
        this.css(dropdown, target);
      }
    },

    css : function (dropdown, target) {
      this.clear_idx();

      if (this.small()) {
        var p = this.dirs.bottom.call(dropdown, target);

        dropdown.attr('style', '').removeClass('drop-left drop-right drop-top').css({
          position : 'absolute',
          width: '95%',
          'max-width': 'none',
          top: p.top
        });

        dropdown.css(Foundation.rtl ? 'right':'left', '2.5%');
      } else {
        var settings = target.data(this.attr_name(true) + '-init') || this.settings;

        this.style(dropdown, target, settings);
      }

      return dropdown;
    },

    style : function (dropdown, target, settings) {
      var css = $.extend({position: 'absolute'}, 
        this.dirs[settings.align].call(dropdown, target, settings));

      dropdown.attr('style', '').css(css);
    },

    // return CSS property object
    // `this` is the dropdown
    dirs : {
      // Calculate target offset
      _base : function (t) {
        var o_p = this.offsetParent(),
            o = o_p.offset(),
            p = t.offset();

        p.top -= o.top;
        p.left -= o.left;

        return p;
      },
      top: function (t, s) {
        var self = Foundation.libs.dropdown,
            p = self.dirs._base.call(this, t),
            pip_offset_base = (t.outerWidth() / 2) - 8;

        this.addClass('drop-top');

        if (t.outerWidth() < this.outerWidth() || self.small()) {
          self.adjust_pip(pip_offset_base, p);
        }

        if (Foundation.rtl) {
          return {left: p.left - this.outerWidth() + t.outerWidth(), 
            top: p.top - this.outerHeight()};
        }

        return {left: p.left, top: p.top - this.outerHeight()};
      },
      bottom: function (t, s) {
        var self = Foundation.libs.dropdown,
            p = self.dirs._base.call(this, t),
            pip_offset_base = (t.outerWidth() / 2) - 8;

        if (t.outerWidth() < this.outerWidth() || self.small()) {
          self.adjust_pip(pip_offset_base, p);
        }

        if (self.rtl) {
          return {left: p.left - this.outerWidth() + t.outerWidth(), top: p.top + t.outerHeight()};
        }

        return {left: p.left, top: p.top + t.outerHeight()};
      },
      left: function (t, s) {
        var p = Foundation.libs.dropdown.dirs._base.call(this, t);

        this.addClass('drop-left');

        return {left: p.left - this.outerWidth(), top: p.top};
      },
      right: function (t, s) {
        var p = Foundation.libs.dropdown.dirs._base.call(this, t);

        this.addClass('drop-right');

        return {left: p.left + t.outerWidth(), top: p.top};
      }
    },

    // Insert rule to style psuedo elements
    adjust_pip : function (pip_offset_base, p) {
      var sheet = Foundation.stylesheet;

      if (this.small()) {
        pip_offset_base += p.left - 8;
      }

      this.rule_idx = sheet.cssRules.length;

      var sel_before = '.f-dropdown.open:before',
          sel_after  = '.f-dropdown.open:after',
          css_before = 'left: ' + pip_offset_base + 'px;',
          css_after  = 'left: ' + (pip_offset_base - 1) + 'px;';

      if (sheet.insertRule) {
        sheet.insertRule([sel_before, '{', css_before, '}'].join(' '), this.rule_idx);
        sheet.insertRule([sel_after, '{', css_after, '}'].join(' '), this.rule_idx + 1);
      } else {
        sheet.addRule(sel_before, css_before, this.rule_idx);
        sheet.addRule(sel_after, css_after, this.rule_idx + 1);
      }
    },

    // Remove old dropdown rule index
    clear_idx : function () {
      var sheet = Foundation.stylesheet;

      if (this.rule_idx) {
        sheet.deleteRule(this.rule_idx);
        sheet.deleteRule(this.rule_idx);
        delete this.rule_idx;
      }
    },

    small : function () {
      return matchMedia(Foundation.media_queries.small).matches &&
        !matchMedia(Foundation.media_queries.medium).matches;
    },

    off: function () {
      this.S(this.scope).off('.fndtn.dropdown');
      this.S('html, body').off('.fndtn.dropdown');
      this.S(window).off('.fndtn.dropdown');
      this.S('[data-dropdown-content]').off('.fndtn.dropdown');
    },

    reflow : function () {}
  };
}(jQuery, window, window.document));


/*
Author: Gianfranco S. del Mundo
File name: consoleFix.js
Description:
 * Protect window.console method calls, e.g. console is not defined on IE
 * unless dev tools are open, and IE doesn't define console.debug
 * 
 * Chrome 41.0.2272.118: debug,error,info,log,warn,dir,dirxml,table,trace,assert,count,markTimeline,profile,profileEnd,time,timeEnd,timeStamp,timeline,timelineEnd,group,groupCollapsed,groupEnd,clear
 * Firefox 37.0.1: log,info,warn,error,exception,debug,table,trace,dir,group,groupCollapsed,groupEnd,time,timeEnd,profile,profileEnd,assert,count
 * Internet Explorer 11: select,log,info,warn,error,debug,assert,time,timeEnd,timeStamp,group,groupCollapsed,groupEnd,trace,clear,dir,dirxml,count,countReset,cd
 * Safari 6.2.4: debug,error,log,info,warn,clear,dir,dirxml,table,trace,assert,count,profile,profileEnd,time,timeEnd,timeStamp,group,groupCollapsed,groupEnd
 * Opera 28.0.1750.48: debug,error,info,log,warn,dir,dirxml,table,trace,assert,count,markTimeline,profile,profileEnd,time,timeEnd,timeStamp,timeline,timelineEnd,group,groupCollapsed,groupEnd,clear

Dependencies: none
*/
(function() {
  // Union of Chrome, Firefox, IE, Opera, and Safari console methods
  var methods = ["assert", "assert", "cd", "clear", "count", "countReset",
    "debug", "dir", "dirxml", "dirxml", "dirxml", "error", "error", "exception",
    "group", "group", "groupCollapsed", "groupCollapsed", "groupEnd", "info",
    "info", "log", "log", "markTimeline", "profile", "profileEnd", "profileEnd",
    "select", "table", "table", "time", "time", "timeEnd", "timeEnd", "timeEnd",
    "timeEnd", "timeEnd", "timeStamp", "timeline", "timelineEnd", "trace",
    "trace", "trace", "trace", "trace", "warn"];
  var length = methods.length;
  var console = (window.console = window.console || {});
  var method;
  var noOperation = function() {};
  while (length--) {
    method = methods[length];
    // define undefined methods as noops to prevent errors
    if (!console[method])
      console[method] = noOperation;
  }
})();


/*
Author: 		Randell Quitain
File name: 		tools.js
Description: 	Global tools
Dependencies: 	jQuery
Usage: 			// encode a url string - param: url/string
				guxApp.tools.encode(uri);

				// decode a url string - param: url/string
				guxApp.tools.decode(uri);
				
				// get specifically the #rest-services data
				guxApp.tools.restServicesData();
				
				// get specifically the #common-config data
				guxApp.tools.commonConfigData();
				
				// get a custom x-json script data - param: x-json script id
				guxApp.tools.getEmbeddedData(id);
				
				// get object length - param: object
				guxApp.tools.getObjectLength(obj);

				// check if object is empty - param: object
				guxApp.tools.isEmpty(obj);

				// check if browser currently used is IE, returns boolean - param: IE version, comparison
				// is it IE8?
				guxApp.tools.isIE(8);

				// is it less than or equal to IE 6?
				guxApp.tools.isIE(7, 'lte');
				
				// cleans a object data that is not grouped based on its index suffix (billboard rest returns this kind of json structure), so for example;

				// if your data return is like this:

				var data = {
					"title_0": "Title 0",
					"desc_0": "Desc 0",
					"title_1": "Title 1",
					"desc_1": "Desc 1",
					"title_2": "Title 2",
					"desc_2": "Desc 2"
				}
				
				guxApp.tools.cleanData(data);

				// returns:

				{
					0: {
						"title_0": "Title 0",
						"desc_0": "Desc 0"
					},
					1: {
						"title_1": "Title 1",
						"desc_1": "Desc 1"
					},
					2: {
						"title_2": "Title 2",
						"desc_2": "Desc 2"
					}
				}

				// check if iOS browser, returns true if iOS
				Example: guxApp.tools.isIOS()?true:false;
				guxApp.tools.isIOS();

				//check if device is mobile [or not]
				guxApp.tools.isMobile();

				// Check if Site is Right To Left; Returns true if RTL
				guxApp.tools.isRTL();
				
				// Check if IE Browser, returns version number if yes and false if not/
				guxApp.tools.detectIE();

*/

var guxApp = guxApp || {};

(function($){
	guxApp.tools = {

		encode: function (uri) {
			if (!uri) { return null; }
			return encodeURIComponent(uri) || null;
		},
		decode: function (uri) {
			if (!uri) { return null; }
			return decodeURIComponent(uri) || null;
		},
		restServicesData: function() {
			if ($('#rest-services').length){
				return $('#rest-services').embeddedData();
			} else {
				return null;
			}
		},
		commonConfigData: function() {
			if ($('#common-config').length){
				return $('#common-config').embeddedData();
			} else {
				return null;
			}
		},
		getEmbeddedData: function(id) {
			if ($(id).length){
				return $(id).embeddedData();
			} else {
				return null;
			}
		},
		getObjectLength: function(obj) {
			var getLength = 0;
			for(var prop in obj) {
				(obj.hasOwnProperty(prop)) ? getLength++ : getLength;
			}
			return getLength;
		},
		isEmpty: function(obj) {
			for(var prop in obj) {
				if(obj.hasOwnProperty(prop))
					return false;
			}
			return true;
		},
		cleanData: function(data) {
			var cleaned = [];
			for(var key in data){
				var suffix = key.match(/\d/);
				// the following will create the new "group" in the master cleaned variable if it doesn't exist
				if(!cleaned[suffix]){cleaned[suffix] = {};}
				cleaned[suffix][key] = data[key];
			}
			return cleaned;
		},
		slugify: function(string) {
			/*
			 * this function converts a normal string to a slug format - lowercased, hyphened and sanitized
			 * ie. from: ABCD - (EFgh)
			 *       to: abcd-efgh
			 */

			// sanitize
			string = $.trim(string.replace(/([~!@#$%^&*()_-]+)(\s)?/g, ''));
			
			return string.toLowerCase().replace(/\s/g, "-");
		},
		isIE: function(version, comparison) {
			var cc = 'IE',
				b = document.createElement('B'),
				docElem = document.documentElement,
				isIE;

			if(version){
				cc += ' ' + version;
				if(comparison){ cc = comparison + ' ' + cc; }
			}

			b.innerHTML = '<!--[if '+ cc +']><b id="iecctest"></b><![endif]-->';
			docElem.appendChild(b);
			isIE = !!document.getElementById('iecctest');
			docElem.removeChild(b);
			return isIE;
		},
		detectIE: function(){
			var ua = window.navigator.userAgent;

		    var msie = ua.indexOf('MSIE ');
		    if (msie > 0) {
		        // IE 10 or older => return version number
		        return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);
		    }

		    var trident = ua.indexOf('Trident/');
		    if (trident > 0) {
		        // IE 11 => return version number
		        var rv = ua.indexOf('rv:');
		        return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);
		    }

		    var edge = ua.indexOf('Edge/');
		    if (edge > 0) {
		       // IE 12 (aka Edge) => return version number
		       return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);
		    }

		    // other browser
		    return false;
		},
		loader: function(element) {
			element.prev('.loading').remove();
			element.removeClass('module-loader');
		},
		imageLoader: function(element, callback) {
			var imgLoad = imagesLoaded( element );
			imgLoad.on( 'always', function( instance ) {
				// show carousel nav
				if(guxApp.viewport.view !== "mobile" && $('.flex-direction-nav', element).length > 0) { $('.flex-direction-nav', element).show(); }
				if(typeof callback === "function") { callback(); }
			}).promise().done(function(){
				guxApp.billboardCarousel.init();
			});
		},
		isBingMap: function(){
			if(typeof (Microsoft) != "undefined" && typeof (Microsoft.Maps) != "undefined"){
				return true;
			}
			return false;
		},
		isAutoNaviMap: function(){
			if(typeof (AMap) != "undefined" && typeof (AMap.Map) != "undefined"){
				return true;
			}
			return false;
		},
		isIOS: function(){
			return navigator.userAgent.match(/iPhone|iPad|iPod/i);
		},
		getMonth: function() {

			// return current month in a number i.e. 6 (for July) and then add one to make 7 for July
			var d = new Date();
			return d.getMonth() + 1;
		},
		getYear: function() {

			// return current year in a four digit number i.e. 2015
			var d = new Date();
			return d.getFullYear();
		},
		numberCommas: function(num) {

			// convert a number to a string with commas
			num = num.toString().replace(/,/g, '');
			return num.replace(/\B(?=(\d{3})+(?!\d))/g, ',');
		},

		removeCommas: function(str) {

			// remove commas from a string and then convert to a number
			var removeCommas = str.replace(/,/g,'');
	    	return parseFloat(removeCommas, 10);
		},

		equalHeight: function(){
			var elem = arguments,
				maxHeight = 0;

			$(elem).each(function(){
				var self = $(this);

				if (self.outerHeight(true) > maxHeight){
					maxHeight = self.outerHeight(true);
				}
			});

			return maxHeight;
		},

		isMobile: function(){
			var isMobile = navigator.userAgent.match(/(iPhone|iPod|iPad|Android|BlackBerry)/);
			return isMobile;
		},

		isRTL: function(){
			var rtl = $('body').hasClass('rtl');
			return rtl;
		}


	
	}

})(jQuery);


/*
Author: 		Randell Quitain
File name: 		cookie.js
Description: 	Create, Retrieve & Delete cookie
Dependencies: 	jQuery
Usage: 			
				Create a cookie 
				guxApp.cookie.set('name', 'value', expiration, secured);

				name ??? cookie name
				value ??? cookie value
				expiration ??? cookie expiration (can be String || Number || Date) *optional*
				secured ??? Boolean (default: false) *optional*

				Retrieve a cookie as object
				guxApp.cookie.get('name');

				Delete a cookie
				guxApp.cookie.del('name');

*/
var guxApp = guxApp || {};

(function($){
	guxApp.cookie = {
		/**
		 * get cookie string or specific item value from cookie string
		 * example to get "pc" from dfy.u cookie:
		 * dfy.u="{"fn":"TestOwner3","pc":"ST158BG"}"
		 * @param cookieName
		 * @param keyName, String, the key of the value (fn,country_code)
		 * @param seperator, String, use to split the string ("#",",")
		 * @return value, result Object, {"pc":"ST158BG"}
		 * @return cookieStr, cookie string "{"fn":"TestOwner3","pc":"ST158BG"}"
		 *
		 */
		get: function (cookieName,keyName,seperator) {
			
			// check if cookie exist
			if (!cookieName) { return null; }
			
			var self = this,
				cookieStr = guxApp.tools.decode(document.cookie.replace(new RegExp("(?:(?:^|.*;)\\s*" + guxApp.tools.encode(cookieName).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=\\s*([^;]*).*$)|^.*$"), "$1")) || null;
			
			if(cookieStr&&keyName&&seperator){
				return self.getCookieVal(cookieStr,keyName,seperator);
			}else{
				return cookieStr;
			}
		},
		set: function (cookieName, cookieValue, cookieExp, cookieSecure) {

			// check if cookieNmae set and if same cookie is already set
			if (!cookieName || /^(?:expires|max\-age|path|domain|secure)$/i.test(cookieName)) { return false; }

			var configInfo = (typeof $('#common-config') != 'undefined' && $('#common-config').length > 0) ? $('#common-config').embeddedData() : null,
				expiration = '',
				cookiePath = '/', // set cookie path
				cookieDomain = '';

			// set cookie expiration
			if (cookieExp) {
				switch (cookieExp.constructor) {
					case Number:
					expiration = cookieExp === Infinity ? '; expires=Fri, 31 Dec 9999 23:59:59 GMT' : '; max-age=' + cookieExp;
					break;
					case String:
					expiration = '; expires=' + cookieExp;
					break;
					case Date:
					expiration = '; expires=' + cookieExp.toUTCString();
					break;
				}
			}

			// set cookie domain
			if(configInfo != null && configInfo.cookieDomain) {
				cookieDomain = configInfo.cookieDomain;
			}

			document.cookie = guxApp.tools.encode(cookieName) + '=' + guxApp.tools.encode(cookieValue) + expiration + (cookieDomain ? '; domain=' + cookieDomain : '') + (cookiePath ? '; path=' + cookiePath : '') + (cookieSecure ? '; secure' : '');
			
			return true;

		},
		del: function (cookieName) {

			// check if cookie doesn't exist
			if (!this.hasItem(cookieName)) { return false; }

			var configInfo = (typeof $('#common-config') != 'undefined' && $('#common-config').length > 0) ? $('#common-config').embeddedData() : null,
				cookiePath = '/', // set cookie path
				cookieDomain = '';

			// set cookie domain
			if(configInfo != null && configInfo.cookieDomain) {
				cookieDomain = configInfo.cookieDomain;
			}

			document.cookie = guxApp.tools.encode(cookieName) + '=; expires=Thu, 01 Jan 1970 00:00:00 GMT' + (cookieDomain ? '; domain=' + cookieDomain : '') + (cookiePath ? '; path=' + cookiePath : '');
			
			return true;
		},
		hasItem: function (cookieName) {
			if (!cookieName) { return false; }
			return (new RegExp("(?:^|;\\s*)" + guxApp.tools.encode(cookieName).replace(/[\-\.\+\*]/g, "\\$&") + "\\s*\\=")).test(document.cookie);
		},
		/**
		 * check whether the string is a Json String
		 * example string '{"fn":"TestOwner3","pc":"ST158BG"}'
		 * @param str, string
		 * @return boolean.
		 */
		isJsonStr : function(str) {
			try {
				$.parseJSON(str);
			} catch (e) {
				return false;
			}
			return true;
		},
		/**
		 * get specific item value from cookie
		 * example to get "pc" from dfy.u cookie:
		 * dfy.u="{"fn":"TestOwner3","pc":"ST158BG"}"
		 * @param cookieStr, JSON string ("{"fn":"TestOwner3","pc":"ST158BG"}"), or normal string ("userInfo=country_code=CN#region_code=SH#city=SHANGHAI")
		 * @param valName, String, the key of the value (fn,country_code)
		 * @param seperator, String, use to split the string ("#",",")
		 * @return value, result Object, {"pc":"ST158BG"}
		 *
		 */
		getCookieVal : function(cookieStr, valName, seperator) {
			var self = this, value = {}, valNameLen = valName.length;
			if (self.isJsonStr(cookieStr)) {
				var cookieObj = $.parseJSON(cookieStr);
				for (var i in cookieObj) {
					for (var j = 0; j < valNameLen; j++) {
						if (i == valName[j]) {
							value[valName[j]] = cookieObj[i];
						}
					}
				}
			} else {
				var cookieArr = cookieStr.split(seperator), cookieLen = cookieArr.length;
				for (var i = 0; i < cookieLen; i++) {
					for (var j = 0; j < valNameLen; j++) {
						if (cookieArr[i].indexOf(valName[j]) != -1) {//if value name exist in current cookieArr
							value[valName[j]] = cookieArr[i].substring(valName[j].length + 1, cookieArr[i].length);
						}
					}
				}
			}
			return value;
		}
	}

})(jQuery);


/*
Author: Ruiwen Qin
File name: foundationInit.js
Description: Initiate foundation JS
Dependencies: lib/foundation/foundation.js
*/
(function($){
	var foundationModules = {
		init: function(){
			$(document).foundation({
				reveal: {
	                animation: 'fade',
	                animation_speed: 400,
	                close_on_esc: false,
	                dismiss_modal_class: 'close-reveal-modal',
	                css: {
	                    open: {
	                        'opacity': 0,
	                        'visibility': 'visible',
	                        'display': 'block'
	                    },
	                    close: {
	                        'opacity': 1,
	                        'visibility': 'hidden',
	                        'display': 'none'
	                    }
	                }
	            }
			});
		}
	};

	$(function(){
		foundationModules.init();
	});

})(jQuery);


/*
Author: 		
File name: 		embeddedData.js
Description: 	Read JSON data
Dependencies: 	jQuery
Usage: 			<script id="price-urls" type="text/x-json">
 				{
  					"xhr-calcprice-data":"GetPrices.js",
 					"xhr-calcprice-form":"overlay-calculateprice.html?v2"
  				}
  				</script>

  				var mydata = $("price-urls").embeddedData();
*/
(function($){
	$.fn.embeddedData = function(prop){
		var xJson = this.data('x-json');
		
		if( !xJson && this.attr('type') === 'text/x-json' ) {
			xJson = $.parseJSON( this.html() );
			this.data( 'x-json', xJson );
		}	
		
		if( prop ) {
			return xJson[prop] || null;
		} else {
			return xJson || {};
		}
	};
})(jQuery);


/*
Author: 		Ruiwen Qin - created based on ftd/js/priceformatter.js
File name: 		priceformatter.js
Description: 	Format the price numbers
Dependencies: 	jQuery
Usage: 			 * true,0 -> true means use delimiter or not. , means use comma as delimitor for prices, 0 means how many decimal places should be displayed
				 * 
				 * for example if we have true,0 
				 * 
				 * input 2000.00 -> output 2,000
				 *
				 * if we have false,2
				 * 
				 * input 2000 -> output 2000.00
				 * input 2000.999 -> output 2000.99
				 * 
				 * if we have true/2
				 * 
				 * input 2000 -> output 2/000.00
				 * input 2000.999 -> output 2/000.99
				 * 
				 * $ %1
				 * 
				 * 
				 * Internal methods for priceFormatter, shamelessly borrowed from jquery.priceformat.js version 1.7 <http://jquerypriceformat.com>
				 * Originally created By Eduardo Cuducos cuducos [at] gmail [dot] com, and maintained by Flavio Silveira flavio [at] gmail [dot] com
				 * 
				 * guxApp.priceFormatter.initialise({
			     *       formatString: "$%1",
			     *       thousandsSeparator: ','
			     *   });

			     * var price = guxApp.priceFormatter.format("2000");
*/
var guxApp = guxApp || {};

(function($){
	guxApp.priceFormatter = {
		
		initialise: function(options) {
			var defaults =
			{
				data: 'true,0',
				formatString: '', //currency symbol
				prefix: '',
	            suffix: '',
				centsSeparator: '.', //monetary decimal separator
				thousandsSeparator: '', //grouping separator
				limit: false,
				centsLimit: 0,
				clearPrefix: false,
	            clearSufix: false,
				allowNegative: false,
				forceDecimal: false
			};
			
			guxApp.priceFormatter.options = $.extend({},defaults, options);
			// Deals with parsing the data options passed to the constructor
			var s = guxApp.priceFormatter.options.data.match(/\W+/g);
			var d = guxApp.priceFormatter.options.data.split(s);
			if (d[0] === "true") {
				guxApp.priceFormatter.options.thousandsSeparator = guxApp.priceFormatter.options.thousandsSeparator;
			} else {
				guxApp.priceFormatter.options.thousandsSeparator = defaults.thousandsSeparator;
			}
			if (parseInt(d[1]) > 0) {
				guxApp.priceFormatter.options.forceDecimal = true;
				guxApp.priceFormatter.options.centsLimit = parseInt(d[1]);
			} 
		},

		// pre defined options
		internalFormatter: function(value) {
			var obj = value;
			var is_number = /[0-9]/;
	
			// load the pluggings settings
			var prefix = guxApp.priceFormatter.options.prefix;
	        var suffix = guxApp.priceFormatter.options.suffix;
			var centsSeparator = guxApp.priceFormatter.options.centsSeparator;
			var thousandsSeparator = guxApp.priceFormatter.options.thousandsSeparator;
			var limit = guxApp.priceFormatter.options.limit;
			var centsLimit = guxApp.priceFormatter.options.centsLimit;
			var clearPrefix = guxApp.priceFormatter.options.clearPrefix;
	        var clearSuffix = guxApp.priceFormatter.options.clearSuffix;
			var allowNegative = guxApp.priceFormatter.options.allowNegative;
	
			// skip everything that isn't a number
			// and also skip the left zeroes
			function to_numbers (str)
			{
				var formatted = '';
				for (var i=0;i<(str.length);i++)
				{
					char_ = str.charAt(i);
					if (formatted.length==0 && char_==0) char_ = false;
	
					if (char_ && char_.match(is_number))
					{
						if (limit)
						{
							if (formatted.length < limit) formatted = formatted+char_;
						}
						else
						{
							formatted = formatted+char_;
						}
					}
				}
	
				return formatted;
			}
	
			// format to fill with zeros to complete cents chars
			function fill_with_zeroes (str)
			{
				while (str.length<(centsLimit+1)) str = '0'+str;
				return str;
			}
	
			// format as price
			function price_format (str)
			{
				// formatting settings
				var formatted = fill_with_zeroes(to_numbers(str));
				var thousandsFormatted = '';
				var thousandsCount = 0;
	
				// split integer from cents
				var centsVal = formatted.substr(formatted.length-centsLimit,centsLimit);
				var integerVal = formatted.substr(0,formatted.length-centsLimit);
	
				// apply cents pontuation
				formatted = integerVal+centsSeparator+centsVal;
	
				// apply thousands pontuation
				if (thousandsSeparator)
				{
					for (var j=integerVal.length;j>0;j--)
					{
						char_ = integerVal.substr(j-1,1);
						thousandsCount++;
						if (thousandsCount%3==0) char_ = thousandsSeparator+char_;
						thousandsFormatted = char_+thousandsFormatted;
					}
					if (thousandsFormatted.substr(0,1)==thousandsSeparator) thousandsFormatted = thousandsFormatted.substring(1,thousandsFormatted.length);
					formatted = thousandsFormatted+centsSeparator+centsVal;
				}
	
				// if the string contains a dash, it is negative - add it to the begining (except for zero)
				if (allowNegative && str.indexOf('-') != -1 && (integerVal != 0 || centsVal != 0)) formatted = '-' + formatted;
	
				// apply the prefix
				if (prefix) formatted = prefix+formatted;
	            
	            // apply the suffix
				if (suffix) formatted = formatted+suffix;
	
				return formatted;
			}
	
			// filter what user type (only numbers and functional keys)
			function key_check (e)
			{
				var code = (e.keyCode ? e.keyCode : e.which);
				var typed = String.fromCharCode(code);
				var functional = false;
				var str = obj;
				var newValue = price_format(str+typed);
	
				// allow key numbers, 0 to 9
				if((code >= 48 && code <= 57) || (code >= 96 && code <= 105)) functional = true;
	
				// check Backspace, Tab, Enter, Delete, and left/right arrows
				if (code ==  8) functional = true;
				if (code ==  9) functional = true;
				if (code == 13) functional = true;
				if (code == 46) functional = true;
				if (code == 37) functional = true;
				if (code == 39) functional = true;
				if (allowNegative && (code == 189 || code == 109)) functional = true; // dash as well
	
				if (!functional)
				{
					e.preventDefault();
					e.stopPropagation();
					if (str!=newValue) obj = newValue;
				}
	
			}
	
			// inster formatted price as a value of an input field
			function price_it ()
			{
				var str = obj;
				var price = price_format(str);
				if (str != price) obj = price;
			}
	
			// Add prefix on focus
			function add_prefix()
			{
				var val = obj;
				obj = prefix + val;
			}
	        
	        function add_suffix()
			{
				var val = obj;
				obj = val + suffix;
			}
	
			// Clear prefix on blur if is set to true
			function clear_prefix()
			{
				if($.trim(prefix) != '' && clearPrefix)
				{
					var array = obj.split(prefix);
					obj = array[1];
				}
			}
	        
	        // Clear suffix on blur if is set to true
			function clear_suffix()
			{
				if($.trim(suffix) != '' && clearSuffix)
				{
					var array = obj.split(suffix);
					obj = array[0];
				}
			}
			
			price_it();
			return obj;
		},

		// Pad with leading zeros
		pad : function(num, size) {
		    var s = num+"";
		    while (s.length < size) s = "0" + s;
		    return s;
		},
		
		format: function(value) {
			var result = value = value.toString();
			try {
				if (guxApp.priceFormatter.options === undefined) {
					throw 'Priceformatter not initialized';
				}
				
				//first replace the . coming from the server with centsSeperator
				value = value.replace('.', guxApp.priceFormatter.options.centsSeparator);
				
//					console.log('value before : ' + value);
				
			    var length = 0;
			    var centsLimit = guxApp.priceFormatter.options.centsLimit;
			    var decimalIdx = value.indexOf(guxApp.priceFormatter.options.centsSeparator);
			    //if centsLimit is greater than zero but value has no decimal for instance if we have 500 but 
			    //centLimit = 3 then this line will convert 500 to 500.000
				if (centsLimit > 0 && decimalIdx === -1) {
					value += guxApp.priceFormatter.options.centsSeparator + guxApp.priceFormatter.pad("0", centsLimit);
					
//						console.log('value += guxApp.priceFormatter.options.centsSeparator + guxApp.priceFormatter.pad("0", centsLimit) : ' + value);
					
				} else if (decimalIdx > 0 && ((length = value.substring(decimalIdx + 1, value.length).length) < centsLimit)) {
					
//						console.log('value.substring(decimalIdx + 1, value.length): ' + value.substring(decimalIdx + 1, value.length));
					
					value += guxApp.priceFormatter.pad("0", centsLimit - length);
					
//						console.log('value += guxApp.priceFormatter.pad("0",  - length) : ' + value);
					
				} else if (length > centsLimit) { //value = 100.00000  but cent limit is 2 
					 value = value.substring(0, decimalIdx + 1 + centsLimit);
					 
//						 console.log('value = value.substring(0, decimalIdx + 1 + centsLimit): ' + value);
				}
				var output = guxApp.priceFormatter.internalFormatter(value);
				if (!guxApp.priceFormatter.options.forceDecimal) {
//						console.log('index of ' + guxApp.priceFormatter.options.centsSeparator + ' in ' + output + ' is (output.indexOf(guxApp.priceFormatter.options.centsSeparator)): ' + output.indexOf(guxApp.priceFormatter.options.centsSeparator));
					output = output.substring(0,output.indexOf(guxApp.priceFormatter.options.centsSeparator));
					
//						console.log('output = output.substring(0,output.indexOf(guxApp.priceFormatter.options.centsSeparator)); ' + output);
				}
				result = guxApp.priceFormatter.options.formatString.replace("%1", output);
				
//					console.log('result: ' + result);
				
			} catch(e) {
				throw e;
			}
			
			return result;
		}
	}

})(jQuery);


/*
Author: 		Ruiwen Qin
File name: 		priceformatInit.js
Description: 	
Dependencies: 	jQuery
Usage: 			
*/

var guxApp = guxApp || {};

(function($){

	guxApp.priceformatInit = {

		// each component requires an init function 
		init: function(element) {
			var priceFormatOptions;

			if ($('#mpz-config').length){
				priceFormatOptions = $('#mpz-config').embeddedData();

				guxApp.priceFormatter.initialise({
					data: priceFormatOptions.priceFormat,
		            formatString: priceFormatOptions.currencySymbol,
		            centsSeparator: priceFormatOptions.monetaryDecimalSeparator,
		            thousandsSeparator: priceFormatOptions.groupingSeparator
		        });
			}
			
			// console.log(guxApp.priceFormatter.format("2000"));
		
		}

	};

	$(function(){
		guxApp.priceformatInit.init();

	});

})(jQuery);


/*
Author: 		Ray Huang
File name: 		uniform.js
Description: 	bind uniform UI to specified element
Dependencies: 	jQuery, jquery.uniform.min.js
Usage: 			
*/

var guxApp = guxApp || {};

(function($){
	var uniform = {
		/**
		 * bind uniform UI for existing dom element goes here.
		 * for those delegated elements, please use "bindTo" function
		 */
		init: function(){
			var self = this;
				//to exclude those non custom uniform elements
				wrapper = ".uniform",
				elementObj = {
					//type 	:  element
					"select" : "select",
					"checkbox" : "input[type=checkbox]",
					"radio-round" : "input[type=radio].round",
					"radio-square" : "input[type=radio].square"
				}
			
			for (var i in elementObj){
				self.bindTo($(wrapper + " " + elementObj[i]),i);
			}
			
			$.subscribe("uniform", function(ev, obj, c, d) {
				self.bindTo(obj.el, obj.el_type);
			});
			
		},
		/**
		 * bind uniform UI to specified element,
		 * @param el, jquery Object, the specified element
		 * @param type, string, the type to define what option should be passed to uniform UI
		 */
		bindTo: function(el, type) {

			var self = this,
				option = {};
			
			switch (type)
			{
				case "select" :
					option.selectAutoWidth = false;
					option.selectClass = "dropdown";
					break;
				case "radio-square" :
					option.radioClass = "radio square";
					break;
				/* custom option example:
				case "checkbox" :
					option.checkboxClass = "checkbox";
					option.checkedClass = "selected";
					break;
				*/
			}
				
			el.uniform(self.isEmptyObject(option)?null:option);
		},
		/*
		* check whether the object is empty
		* @param obj, object need to be checked
		*/
		isEmptyObject: function(obj) {
			for (var n in obj) {
				return false
			}
			return true;
		}	
	}

	$(function(){
		uniform.init();
	});

})(jQuery);


/*
 * jQuery way to fix placeholder not work on older browsers. for example IE8
 * author : Ray
 * dependencies: jquery, Modernizr
 */

(function($) {
	var placeholder = {
		init : function() {
			if(!Modernizr.input.placeholder){
				$('[placeholder]').focus(function() {
					var input = $(this);
					if (input.val() == input.attr('placeholder-value')) {
						input.val('');
						input.removeClass('placeholder');
					}
				}).blur(function() {
					var input = $(this);
					//page load, store placeholder value to new attribute
					if(!input.attr('placeholder-value')){input.attr('placeholder-value',input.attr('placeholder'));}
					if (input.val() == '' || input.val() == input.attr('placeholder-value')) {
						input.addClass('placeholder');
						input.val(input.attr('placeholder-value'));
					}
				}).blur();
				
				// prevent placeholder value from submit
				$('[placeholder]').parents('form').submit(function() {
					$(this).find('.placeholder').each(function() {
						var input = $(this);
						if (input.val() == input.attr('placeholder-value')) {
							input.val('');
						}
					})
				});
			}
		}
	}

	$(function() {
		placeholder.init();
	});
})(jQuery);


/*
Author: 		Ray Huang
File name: 		innerPopup.js
Description: 	open as tooltip
Dependencies: 	jQuery

html, strcuture:
	<a class="citation">
		<sup data-disclosure="1">1</sup>
		<sup data-disclosure="6">6</sup>
	</a>

	other

	<a class="citation">
		<span data-disclosure="1">1</span>
	</a>
	
JS template: 
	<script id="inner-popup" type="text/template">
		<div class="inner-popup">
			<a class="close-popup" href="#"></a>
				<div class="header">
					<h5>Disclosure</h5>
				</div>
			<div class="content"></div>
		</div>
	</script>

JS, Call innerPopup:
	$(function(){
		guxApp.innerPopup.init({
			container : ".my-example",
			triggerEvent : "hover",
			fillByDisclosure : false,
			hideOnLeave : false
		});
	});
	
*/

var guxApp = guxApp || {};

(function($){
	guxApp.innerPopup = {
		
		init: function(option) {
			
			var self = this;
				var defaultOpt = {
					container : "#page-wrapper",//wrapper contains inner popUp elements
					ngView	:  ".ng-scope",//for ng-view container
					triggerBy : ".citation",//bind trigger event to this element
					triggerEvent : "click",//event will be used to bind
					popup : ".inner-popup",//popUp container
					popupClose : ".close-popup",//close button in the popUp container
					hideOnLeave : true,//true to bind "mouseleave" event to popUp. This will hide the popUp when lose mouse focus on it.
					sectionContainer : "section" 
				};

				
			self.setting = $.extend({},defaultOpt,option);
			
			self.container = $(self.setting.container);
			self.ngView = $(self.setting.ndView);
			self.sectionContainer = $(self.setting.sectionContainer);
			self.triggerBy = $(self.setting.triggerBy,self.container);
			self.closBtn = $(self.setting.popupClose,self.container);
			
			self.appendPopupTmpl();
			if(self.popUp.length == 0){return;}
			self.open();
			self.close();
		},
		/*
		 * if inner popup not exist
		 * add inner popup from template
		 */
		appendPopupTmpl: function() {
			var self = this,
				innerPopup = $('#inner-popup'),
				showroomPopup = $('#showroom-popup');
			if(self.container.find(self.setting.popup).length  == 0 && innerPopup.length > 0){
				self.container.append(_.template(innerPopup.html()));
			}

			if(self.container.find(self.setting.popup).length  == 0 && showroomPopup.length > 0){
				self.container.append(_.template(showroomPopup.html()));
			}
			//re-define self.popup
			self.popUp = $(self.setting.popup,self.container);
			//self.title = self.popUp.find(".header h5").text();
		},
		/*
		 *	open inner popup,
		 *	inner popup opens with related "disclosure" filled in
		 */
		open: function() {
			var self = this;
			
			if(self.triggerBy.length==0){return;}
			
			self.sectionContainer.on(self.setting.triggerEvent,self.setting.triggerBy,function(e){
				e.preventDefault();
				var citation = $(this),
					curPopup = citation.closest(self.setting.container).children(self.setting.popup);
				
				self.fillContent(this,curPopup);
				$.publish('popup-opened');
			});
			
			//if(self.setting.hideOnLeave){self.hover();}
		},
		/*
		 *	close inner popup
		 */
		close: function() {
			var self = this;
			$(document).on("click",self.setting.popupClose,function(e){
				e.preventDefault();
				//"this" - close-popup button
				var parentInnerPopup = $(this).closest(self.setting.popup);
				if(parentInnerPopup.hasClass("clone")){
					//remove body class only when no other full overlay opened
					if(parentInnerPopup.siblings(".vehicle-container.clone").length == 0){
						$("body").removeClass("no-scroll has-scroll");
					}
					parentInnerPopup.remove();
				}else{
					parentInnerPopup.removeClass("active");
				}
			});
		},
		/*
		 *	set hideOnLeave : true, to enable the function.
		 * 	popUp will be hided when lose mouse focus
		 */
		hover: function(){
			var self = this;
			
			if(self.popUp.length==0){return;}
			
			self.popUp.on("mouseleave",function(){
				$(this).removeClass("active");
			});
			
			//remove "vehicle-container" hover state in showroom
			self.popUp.hover(function(){
				var vechileCon = $(".vehicle-container");
				if (vechileCon.length > 0){
					vechileCon.addClass("no-hover");
				}
			},function(){
				$(this).removeClass("active");
				var vechileCon = $(".vehicle-container");
				if (vechileCon.length > 0){
					vechileCon.removeClass("no-hover");
				}
			});
			
			//simulate hover state for touch device
			$(document).on("touchstart",function(){
				self.popUp.removeClass("active");
			});
			self.popUp.on("touchstart",function(e){
				e.stopPropagation();
			});
			self.closBtn.on("touchstart",function(e){
				$(this).closest(self.setting.popup).removeClass("active");
			});
		},
		/**
		 * 	fill the content of popup by related disclosure list.
		 * 	@param curEl, the "citation" user clicked
		 *  @param curPopup, "citation" related innerPopup
		 **/
		fillContent: function(curEl,curPopup) {
			var	self = this,
				citation = $(curEl),
				title = citation.attr("data-title");
				data = "",
				targetDataList = $(".disclaimer .disclaimer-text li"),
				curDataList = citation.find("sup, span"),
				insertTo = citation.closest(self.setting.sectionContainer),
				clonedInnerPopup = insertTo.children(self.setting.popup);
			
			//fill title
			if(!title || title.length == 0){
				title = self.title;
			}

			curPopup.find(".header h5").text(title);
			//fill content
			if(citation.hasClass("fill-by-text")){//fill by paragrah
				data = citation.find(".text").html();
				curPopup.find(".content").html(data);
				//display inner popup
				curPopup.addClass("active");
			}else{//fill by disclosure
				if(targetDataList.length == 0 || curDataList.length == 0){return;}			
				//preFill discliaimer to inner-popUp	
				curDataList.each(function(){
					var curDataKey = $(this).attr("data-disclosure");
					targetDataList.each(function(){
						var thisTargetData = $(this),
							targetDataKey = thisTargetData.attr("data-disclosure");
						if(curDataKey == targetDataKey){
							data = data + '<li>'+thisTargetData.html()+'</li>';
							return false;
						}
					});
				});
				if(data.length > 0){
					curPopup.find(".content").html('<ul>'+data+'</ul>');
				}
			}
			
			//remove all other "displayed" inner-popUp before show the current one
			self.popUp.removeClass("active");
			clonedInnerPopup.remove();
			$("body").removeClass("no-scroll has-scroll");
			
			if($(window).width() > 751){
				setTimeout(function(){
					var curElPos = citation.offset();
					var top;//1px top, to cover the citation
									

					// if the citation is inside the reveal modal
					if(citation.parents(".reveal-modal").length){
						var revealDistance = $(".reveal-modal").offset().left;
						top = (curElPos.top - citation.parents(".reveal-modal").offset().top - 10);
						if(citation.closest('.right').length){
							//var left = citation.offset().left - revealDistance;
							var left = ($(".reveal-modal").outerWidth() / 2) + 10;
						}else{
							var left = ($(".reveal-modal").outerWidth() / 2) - (curPopup.outerWidth() + 10);
							//var left = (citation.offset().left - revealDistance) - curPopup.outerWidth() + citation.outerWidth();
						}
						curPopup.css({
							"top" : top,
							"left" : left
						});
					}else{
						top = curElPos.top-1;
						//with "align-to-container" class, citation popup will align with it's parent container
						if(citation.hasClass("align-to-container")){
							var alignTo = citation.closest("div");
							curElPos.left = alignTo.offset().left+alignTo.width()/2; //get center of container
						}
		
						var left = curElPos.left-curPopup.outerWidth()/2;
						curPopup.css({
							"top" : top,
							"left" : left
						});
					}
					
					curPopup.addClass("active");					
					
				},500);

			} else {
				//show "inner-popUp" as fullScreen overlay on mobile view
				$("body").addClass("no-scroll has-scroll");
				curPopup.clone().addClass("clone hide-for-large-up").css({"top":0,"left":0}).appendTo(insertTo);
			}
		}
	}

})(jQuery);

$(function(){
	guxApp.innerPopup.init();
});


/*
 Author: 		Ray Huang
 File name: 		locationAware.js
 Description: 	auto detect user location by:
 address detection(dfy.u)->postCode detection(dfy.p)->IP detection(userInfo)
 Dependencies: 	jQuery, jquery.uniform.min.js, cookie.js
 Usage:
 */

var guxApp = guxApp || {};

(function($) {
	guxApp.locationAware = {
		/**
		 * detect location by :
		 * address detection(dfy.u)->IP detection(userInfo)
		 * @param callback, can be used if address detected
		 */
		locationDetection : function(callback) {
			//mocked cookie & sessionStorage for local testing
			//document.cookie=" dfy.u=%7B%22fn%22%3A%22TestOwner3%22%2C%22now%22%3A%22Mustang%22%2C%22s%22%3A%22OW%22%2C%22authid%22%3A%22311942%22%2C%22authby%22%3A%22005%3D%3D%3D%3D%3D%3D%3D%22%2C%22pcode%22%3A%22MUSTANG%22%2C%22pc%22%3A%223000%22%7D";
			//document.cookie=" dfy.u=%7B%22fn%22%3A%22TestOwner3%22%2C%22now%22%3A%22Mustang%22%2C%22s%22%3A%22OW%22%2C%22authid%22%3A%22311942%22%2C%22authby%22%3A%22005%3D%3D%3D%3D%3D%3D%3D%22%2C%22pcode%22%3A%22MUSTANG%22%2C%22pc%22%3A%22%22%7D";
			//document.cookie=" dfy.p=%7B%22fn%22%3A%22TestOwner3%22%2C%22pc%22%3A%22ggg%22%7D";
			//document.cookie=" dfy.p=%7B%22fn%22%3A%22TestOwner3%22%2C%22pc%22%3A%22%22%7D";
			//sessionStorage.setItem("dfy.p",'{"authState":"OW","pc":"2220"}');
			//sessionStorage.setItem("dfy.p",'{"authState":"OW","pc":""}');
			//document.cookie="userInfo=country_code=AU#region_code=SH#city=SHANGHAI#county=#zip=#latitude=-33.86#longitude=151.20";
			//document.cookie='userInfo=""';
			var self = this,
				mapController = guxApp.googleMapController,
				searchInput = $(".search-panel .input-panel input[type=text]"),
				searchKeyObj = {
					"dfy.u" : {
						"key" : ["pc"]
					},
					"userInfo" : {
						"key" : ["country_code", "latitude", "longitude"],
						"seperator" : "#"
					}
				};
			//switch between maps	
			/* if(guxApp.tools.isBingMap()){
				mapController = guxApp.bingMapController;
			}
			else  */if(guxApp.tools.isAutoNaviMap()) {
				mapController = guxApp.autonaviMapController;
			}
			//loadMap called before "mapController.init" callback, wait untill "mapController.init" has been loaded.
			var waitMap = setInterval(function() {
				if (mapController.mapAPI) {
					clearInterval(waitMap);
					var valueObj = {};
					//address detection(dfy.u)->postCode detection(dfy.p)->IP detection(userInfo)

					for (var i in searchKeyObj) {
						//address detection
						if (guxApp.cookie.get(i)) {
							valueObj = guxApp.cookie.getCookieVal(guxApp.cookie.get(i), searchKeyObj[i].key, searchKeyObj[i].seperator);
						} else {//if not in cookie, try search in sessionStorage
							if ( typeof sessionStorage != "undefined" && sessionStorage.getItem(i) != null) {
								valueObj = guxApp.cookie.getCookieVal(sessionStorage.getItem(i), searchKeyObj[i].key, searchKeyObj[i].seperator);
							}
						}

						if (searchKeyObj[i].key.length == 1) {
							var addressInfo = valueObj[searchKeyObj[i].key[0]];
						} else {
							var countryCode = $("#common-config").embeddedData().iso2country;
							if ((i == "userInfo") && valueObj.country_code && countryCode && (valueObj.country_code == countryCode)) {
								//var addressInfo = valueObj.latitude + "," + valueObj.longitude;
								var addressInfo = {
									lat : valueObj.latitude,
									lng : valueObj.longitude
								}
								searchInput.addClass("isIpDetection");
							}
						}
						
						//if location detected, jump out of the loop
						if (addressInfo) {break;}
					}
					//return address information in callback
					if(callback){callback(addressInfo,true);}
				}
			}, 1000);
		}
	}

})(jQuery); 


/*
Author: 		Ruiwen Qin
File name: 		viewport.js
Description: 	Find out the viewport width
Dependencies: 	jQuery 
Usage: 			Use guxApp.viewport.view for your condition. The value of guxApp.viewport is either mobile or tablet.
*/
var guxApp = guxApp || {};

(function($){
	guxApp.viewport = {
		view:'',
		init: function(){
			if ($(window).width() < 768){
				guxApp.viewport.view = "mobile";
			}
			else {
				guxApp.viewport.view = "tablet";
			}
			this.resize();
		},
		resize: function(){
			$(window).on("resize", function() {
				if ($(window).width() < 768){
					guxApp.viewport.view = "mobile";
				}
				else {
					guxApp.viewport.view = "tablet";
				}
			});
		}	
	}

	$(function(){
		guxApp.viewport.init();
	});

})(jQuery);


/*
Author: Ruiwen Qin / Randell Quitain
File name: carousel.js
Description: This file holds the carousels on pages.
			 1. Go through all the elements have flexslider class names
			 2. By adding "carousel-mobile-only" class, directionNave will not be generated, such as showcase carousel on homepage return
			 3. By adding "controls-container" class, you can specify the element as the container of controls
			 4. By adding "carousel-main" class, you can specify a main carousel to sync the closest .carousel-fader carousel
			 5. By adding "data-slide-width", to specify item width
			 	ex: data-slide-width="640"
			 6. By adding "data-slide-margin", to specify item margin
			 	ex: data-slide-margin="10"
			 7. By adding "carousel-limit" class, you can specify item min/max items per slide/breakpoint
			 	You also need to add "data-item-limit" attribute to set number of items per breakpoint
			 	ex: data-item-limit='{"small":"1", "medium":"1", "large":"1", "xlarge":"2"}'
             8. By adding "rotating" class, you can add a slideshow/auto-rotate feature to the slider
                You also need to add "data-rotate-on" attribute to set what breakpoint should the slider only auto-rotate
                // tablet - tablet and up view
                // mobile - mobile view only
                ex: data-rotate-on="tablet"

            // Resetting of options
            setOpts(slider, options), use for updating a specific slider opts

            e.g:
            guxApp.billboardCarousel.setOpts(slider.data('flexslider'), {
                minItems: gridSize,
                maxItems: gridSize
            });

Dependencies: lib/jquery.flexslider.js
*/
var guxApp = guxApp || {};

(function($){
    guxApp.billboardCarousel = {
        init: function(element){
            if (!$(".flexslider", element).length) {return;}

            var sliders = $(".flexslider", element),
                controls = "",
                isRTL = $('body').hasClass('rtl');

            sliders.each(function(i, e){

                var slider = $(e),
                    options = {
                        slideshow: (slider.hasClass("rotating")) ? guxApp.billboardCarousel.autoRotate(slider) : false,
                        animation: (slider.hasClass("carousel-fader")) ? "fade" : "slide",
                        animationLoop: (slider.hasClass("noloop")) ? false : true,
                        directionNav: (slider.hasClass("carousel-mobile-only")) ? false : true,
                        sync: (slider.hasClass("carousel-main")) ? guxApp.billboardCarousel.getSyncedCarousel(slider) : "",
                        itemWidth: guxApp.billboardCarousel.getSlideWidth(slider),
                        itemMargin: guxApp.billboardCarousel.getSlideMargin(slider),
                        minItems: (slider.hasClass("carousel-limit")) ? guxApp.billboardCarousel.getGridSize(slider) : 1,
                        maxItems: (slider.hasClass("carousel-limit")) ? guxApp.billboardCarousel.getGridSize(slider) : 0,
                        controlsContainer: "",
                        touch: (slider.hasClass("carousel-fader") || slider.hasClass('no-touch') ) ? false : true,
                        allowOneSlide: true,
                        move: (slider.hasClass("one-slide")) ? 1 : 0,
                        reverse: isRTL,
                        start: function(slider) {
                            slider.resize();
                            //Publishes flex-complete if the carousel is loaded.
                            $.publish('flex-complete');
                            $('.smob-controls .prev-smob').click(function(){
                                if(slider.currentSlide == 0){
                                    $(this).hide();
                                } else {
                                    $(this).show();    
                                }
                            });
                        },
                        end: function(){
                            if(guxApp.viewport.view == "mobile"){
                                if(slider.hasClass("smob-hide")){
                                    $('.smob-controls .next-smob').hide();
                                }
                            }
                        }
                    };

                //change the default container of carousel controls 
                if (slider.parents(".controls-container").length > 0){
                    options.controlsContainer = slider.parents(".controls-container");
                }

                // initialize slideshow feature
                if(slider.hasClass("rotating")) {
                    options.pauseOnHover = true;
                    options.slideshowSpeed = 5000;
                }

                // initialize flexslider
                slider.flexslider(options);

                // update flexslider on resize
                $(window).on('resize', function() {

                    // change flexslider options on resize
                    if(typeof slider.data('flexslider') != 'undefined') {

                        // add slideshow feature on specific breakpoint
                        if(slider.hasClass("rotating")) {
                            var rotateOn = slider.data('rotate-on');
                            if(guxApp.viewport.view == rotateOn) {
                                guxApp.billboardCarousel.setOpts(slider.data('flexslider'), {
                                    slideshow: true
                                });
                            } else {
                                guxApp.billboardCarousel.setOpts(slider.data('flexslider'), {
                                    slideshow: false
                                });
                            }
                        }

                        // update gridSize for carousel-limit with 2 item count and up only
                        if(slider.hasClass("carousel-limit")) {
                            // update slider min/max items
                            var gridSize = guxApp.billboardCarousel.getGridSize(slider);
                            if(typeof gridSize != 'undefined') {
                                // update min/max flexslider property
                                guxApp.billboardCarousel.setOpts(slider.data('flexslider'), {
                                    minItems: gridSize,
                                    maxItems: gridSize
                                });
                            }
                        }

                    }

                });

            });

            $(document).on('scroll',function(){    
                //guxApp.billboardCarousel.flexSliderResize();
            });
            guxApp.billboardCarousel.flexSliderResize();
            isRTL ? guxApp.billboardCarousel.rtlSupport() : false;
         },
        setOpts: function(slider, opts) {
            for (var opt in opts) {
                slider.vars[opt] = opts[opt];
            }
            slider.setup();
        },
        getGridSize: function(slider) {
            if (!slider.data('item-limit') || $('.slides li', slider).length === 1) {return;}
            var itemLimit = slider.data('item-limit'),
                wWidth = $(window).width(),
                smallRange = 480,
                mediumRange = 768,
                largeRange = 991,
                smallRangeItemCount = itemLimit.small,
                mediumRangeItemCount = itemLimit.medium,
                largeRangeItemCount = itemLimit.large,
                xLargeRangeItemCount = itemLimit.xlarge;

            // check if slide item is less than carousel-limit highest breakpoint
            $('.flex-direction-nav', slider).css('visibility', '');

            if($('.slides li', slider).length <= xLargeRangeItemCount) {
                $('.flex-direction-nav', slider).css('visibility', 'hidden');
            }

            return (wWidth < smallRange) ? smallRangeItemCount : (wWidth < mediumRange) ? mediumRangeItemCount : (wWidth < largeRange) ? largeRangeItemCount : xLargeRangeItemCount;
        },
        getSlideWidth: function(slider) {
            if (!slider.data('slide-width')) {return 0;}
            return slider.data('slide-width');
        }, 
        getSlideMargin: function(slider) {
            if (!slider.data('slide-margin')) {return 0;}
            return slider.data('slide-margin');
        },
        getSyncedCarousel: function(slider) {
            return slider.parent().find('.carousel-fader');
        },
        autoRotate: function(slider) {
            if (!slider.data('rotate-on') || $('.slides li', slider).length === 1) {return false;}
            var rotateOn = slider.data('rotate-on');
            if(guxApp.viewport.view == rotateOn) {
                return true;
            } else {
                return false;
            }
        },
        flexSliderResize: function(){
            if (!$(".flexslider").length) {return;}
            $(window).trigger('resize');
            
        },

        setToFirstSlide: function(){
            var container = $('.flexslider');
            if (!container.length) {return;}

            $('.flex-control-nav li',container).each(function(i,e){
                var slide = $(e);
                slide.first().find('a').triggerHandler('click');
            });

        },

        rtlSupport: function(){
            var flexslider = $(".flexslider")
            flexslider.each(function(){
                var list = $(this).find(".flex-control-nav"),
                listItems = list.children('li');
                list.append(listItems.get().reverse());
            });
        }
    };

    $(function(){
        guxApp.billboardCarousel.init();
    });

})(jQuery);


/*
Author: 		Brett Chaney
File name: 		revealer.js
Description: 	Reveals hidden panel via a sliding transition.
Dependencies: 	jQuery

Example HTML: 	<div class="large-12 columns">
					<div class="revealer">
						<div class="revealer-one">
							...content here...
							<a href="#" class="revealer-open">open</a>
						</div>
						<div class="revealer-two">
							...content here...
							<a href="#" class="revealer-close">close</a>
						</div>
					</div>
				</div>
*/

var guxApp = guxApp || {};

(function($){
	guxApp.revealer = {

		init: function(){
			if (!$(".revealer").length) {return;}

			// declare common variables/settings
			var $container 		= $(".revealer"),
				$openBtn 		= $(".revealer-open"),
				$closeBtn 		= $(".revealer-close"),
				$revealerOne 	= $(".revealer-one"),
				$revealerTwo 	= $(".revealer-two"),
				currElem 		= null,
				itemW 			= $("#page-wrapper").width(),
				containerW 		= $container.width(),
				tabSliderSpeed 	= 600,					// change slider speed here
				mobSliderSpeed 	= tabSliderSpeed / 1.5,
				isRTL 			= $("body").hasClass("rtl");

			// functions
			var sliderSpeed = function() {
				// slow the slider speed value if mobile screen size detected
				if (guxApp.viewport.view === "tablet") {
					return tabSliderSpeed;
				} else {
					return mobSliderSpeed;
				}
			};

			var open = function(currElem) {
				itemW = $("#page-wrapper").width();

				currElem.parents(".revealer-one")
					.add(currElem.parents(".revealer-one").next())
					.animate({"left": -itemW}, sliderSpeed())
					.parent().addClass("revealer-open");
			};

			var close = function(currElem) {
				currElem.parents(".revealer-two")
					.add(currElem.parents(".revealer-two").prev())
					.animate({"left": 0}, sliderSpeed())
					.parent().removeClass("revealer-open");
			};

			var updateWidths = function() {
				itemW 		= $("#page-wrapper").width();
				containerW 	= itemW * 2;

				$container.css("width", containerW);
				$revealerOne
					.add($revealerTwo)
					.css("width", itemW);
			};

			if (isRTL) {
				$container.parent().css("direction","ltr");
			}

			setTimeout(function() {

				// timeout is to ensure correct width of each item
				updateWidths();
				$container.parent().css("overflow","hidden");
				$revealerOne.css("float", "left");
				$revealerTwo.css({"float": "left", "left": 0});

			},250);

			$(window).on("resize", function() {
				updateWidths();

				$container.each(function() {
					if ($(this).hasClass("revealer-open")) {
						$(this).children(".revealer-one")
							.add($(this).children(".revealer-two"))
							.css("left", -itemW);
					}
				});
			});

			$openBtn.on("click", function(e) {
			 	e.preventDefault();
			 	
			 	currElem = $(this);
			 	open(currElem);
			});

			$closeBtn.on("click", function(e) {
			 	e.preventDefault();

			 	currElem = $(this);
			 	close(currElem);
			});
			
		}
	};

	$(function() {
		// initiate revealer module
		guxApp.revealer.init();
	});

})(jQuery);


/*
Author: 		Ruiwen Qin
File name: 		brandgallery.js
Description: 	Toggle showing elements on mobile view
Dependencies: 	jQuery 
Usage: 			
*/


(function($){
	var brandgallery = {
		init: function(){
			if (!$(".brand-gallery").length) {return;}

			var gallery = $(".brand-gallery");

			brandgallery.toggleElements(gallery);

		},
		toggleElements: function(gallery){
			var items = $(".show-for-large-up",gallery).not(".hero"),
				expandbar = $(".expandbar",gallery),
				btnAll = $(".viewall",expandbar),
				btnLess = $(".viewless",expandbar),
				btnIcon = $(".icon",expandbar);
	
			expandbar.click(function(){
				if (btnAll.is(":visible")){
					btnAll.hide();
					btnLess.show();
					btnIcon.addClass("icon-minus");
					items.removeClass("show-for-large-up");
				}
				else {
					btnAll.show();
					btnLess.hide();
					btnIcon.removeClass("icon-minus");
					items.addClass("show-for-large-up");
				}
			});
		}
	
	}

	$(function(){
		brandgallery.init();
	});

})(jQuery);


/*
Author: 		Ruiwen Qin
File name: 		revealerVertical.js
Description: 	Vertical revealer
Dependencies: 	jQuery 
Usage: 			<div class="large-12 columns">
					<div class="revealer-vertical">
						<div class="hide">...</div> // add hide class onto the element you want to hide initially
					</div>
				</div>
*/

var guxApp = guxApp || {};

(function($){
	guxApp.revealerVertical = {
		init: function(){
			if (!$(".revealer-vertical").length){return;}

			var container = null,
				items = $(".revealer-vertical .hide");

			$(".revealer-vertical .revealer-open").click(function(e){

				var btnOpen = $(this);

				if (btnOpen.is('.trackable') && !e.originalEvent) { return false; } // temporary solution to prevent multiple trigger
				
				container = btnOpen.parents(".revealer-vertical");
				items = $(".hide",container);

				btnOpen.toggleClass("active");
				items.slideToggle("normal",function(){
					var item = $(this);
					//for maps only
					// if(item.hasClass("map")&&item.is(":visible")&&guxApp.googleMapController.map){
					// 	google.maps.event.trigger(guxApp.googleMapController.map.map,'resize');//resize hidden map
					// }
				});
			});

			$(window).resize(function(){
				if ($(window).width() < 768){
					items.show();
				}
			});

		}
	
	}

	$(function(){
		guxApp.revealerVertical.init();
	});

})(jQuery);


/*
Author: Ruiwen Qin
File name: moduleLoader.js
Description: 1. Go through .module-loader elements on the page.
			 2. Wait until images are loaded, then remove the loading circle
Dependencies: jQuery, tools.js
*/
var guxApp = guxApp || {};

(function($){
	guxApp.moduleLoader = {
		init: function(){
			if (!$(".module-loader").length) {return;}

			var modules = $(".module-loader");

			modules.each(function(){
				var module = $(this);

				guxApp.moduleLoader.imageLoader(module, function(){
					guxApp.moduleLoader.loader(module);
				});
			});

			//Trigger Resize when Carousel is visible. IE8 Fix for lazy loading and carousel conflict.
			$.subscribe('flex-complete',function(){
				guxApp.billboardCarousel.flexSliderResize();
				guxApp.billboardCarousel.setToFirstSlide();
			});

		},
		imageLoader: function(element, callback) {
			var imgLoad = imagesLoaded( element );
			imgLoad.on( 'always', function( instance ) {
				// show carousel nav
				if(guxApp.viewport.view !== "mobile" && $('.flex-direction-nav', element).length > 0) { $('.flex-direction-nav', element).show(); }
				if(typeof callback === "function") { callback(); }
			});
		},
		loader: function(element) {
			element.children().unwrap();
		}
	};

	$(function(){
		guxApp.moduleLoader.init();
	});

})(jQuery);


/*
Author:         Brett Chaney
File name:      gux-locale.js
Description:    GUX localisation select overlay and code for FTD template backwards compatibility
Dependencies:   jQuery, bootstrap.modal.js, jquery.uniform, overlay.js, jquery.tinypubsub.js
*/
var guxApp = guxApp || {};

(function($) {

guxApp.locale = {

	init: function() {
		if (!$('#locale-data').length){return;}
		var self = this,
			json = $('#locale-data').embeddedData(),
			commonConfig = $("#common-config").embeddedData();
			
		guxApp.locale.url = json['locale-overlay'];
		guxApp.locale.domain = json.domain;
		guxApp.locale.fromLink = false;
		guxApp.locale.isGUX = $("#gux-footer").length;
		guxApp.locale.cookieDomain = commonConfig.cookieDomain;
		guxApp.locale.locale = commonConfig.locale;

		// set ND.rtl to true if RTL page
		// a condition that needs to be set for overlay.js when opening an overlay on FTD template RTL pages
		ND.rtl = $('body').hasClass('rtl');

		// attach the on click event that launches the locale overlay
		self.launchOverlayEvent();

		self.checkLocale();

		// check locale cookie on page load
		// this is to decide if the locale overlay needs to be launched if no region is confirmed
		if (!guxApp.locale.isGUX) {
			self.checkCookie();
			self.initMenu();
		}
	},

	checkLocale: function(){
		var self = this;
		var url = window.location.href;
		var locale = [];

		if ($.cookie(self.COOKIEKEY)){
			locale = $.cookie(self.COOKIEKEY).split('-');

			if (url.indexOf(locale[1]) < 0){
				self.clearFPSinfo();
				
				self.setGTUID();
			}
			
			if (url.indexOf(locale[2]) === "1"){
				// true: locale confirmed
				self.updateCookie(url,true);
			}
			else {
				self.updateCookie(url,false);
			}
			
		}
		else {
			// false: locale not confirmed
			self.updateCookie(url,false);
		}

	},

	launchOverlayEvent: function() {

		var self = this;

		$('.locale-select').on('click', function(e) {
			e.preventDefault();
			$('body').addClass('modal-open');
			guxApp.locale.fromLink = true;
			self.commonLocaleOverlay();
			self.removeBodyClass();
			self.launchOverlay();
		});

	},

	removeBodyClass:function(){
		$('.close-reveal-modal', '.reveal-modal').on('click',function(e){
			e.preventDefault();
			$('body').removeClass('modal-open');
		})
	},

	launchOverlay: function() {

		var self = this;

		// // launch Bootstrap modal
		// $('#modalWrap').addClass('locale-modal').modal({
		// 	"backdrop" : false,
		// 	"keyboard" : false
		// });

		// inject HTML from cache if previously loaded
		if (self.cache) {
			$('.locale-modal .modal-body').html(self.cache);
			self.commonLocaleOverlay();
		} else {

			$.get(self.url, function( data ) {

				// inject content into modal
				$('.locale-modal .modal-body').html(data);

			  	self.cache = data;
				self.closeOverlayEvent();

				self.commonLocaleOverlay();

			});

		}

	},

	commonLocaleOverlay: function() {

		// the following are functions/methods that are run
		// each time the GUX locale overlay is launched
		
		var self = this;

		// enable uniform js ui styles
		// subscribe on the on-success publish in revealmodal.js
		$.subscribe('foundation-reveal-modal-open', function(){
			if($('.reveal-modal .uniform')){
        		$('.uniform select', '.reveal-modal').uniform({selectClass: 'dropdown', selectAutoWidth: false});
			}
			self.reinitInnerPopup();
		});

		// self.reinitInnerPopup();

		// $('.locale-wrap').on('click', '.close-popup', function() {
		// 	// re-init inner popup
		// 	self.reinitInnerPopup();
		// });

		// self.realignInnerPopup();
		
		if (guxApp.locale.fromLink) {
			// this is run when the user clicks the overlay from the link in the footer
			self.checkCookie();
		}

		self.bindOverlay();

	},

	localeArr: [],

	COUNTRY: 1,
	
	CONFIRMED: 2,

	COOKIEKEY: "dfy.fme.locale",

	checkCookie: function() {
		var self = this,
			cookieVal = $.cookie(self.COOKIEKEY);
		
		if (cookieVal) {
			self.localeArr = cookieVal.split('-');
		}
		//if the locale is confirmed, will not popup overlay.
		if(self.localeArr[self.CONFIRMED] == '1'){
			return;
		}

		if (guxApp.locale.url && !guxApp.locale.fromLink) {
			// this is run when the cookie on page load is not confirmed
			if (guxApp.locale.isGUX) {
				self.launchOverlay();
			} else {
				window.setTimeout(function(){
					$.publish('overlay.launch', {
						url: guxApp.locale.url,
						success: function() {
							self.bindOverlay();
						}
					});
				}, 1000);
			}

		}

	},

	bindOverlay: function() {

		// bind event to overlay, force redirection and
		// change cookie when user submits the form
		var self = this;

		if ($('#overlay .controls').length){
			$('#overlay .controls').hide();
		}

		$('.country-overlay select').on('change', function() {
			$(this).parents('form').attr({'action': $(this).val()});
		}).trigger('change');	// trigger change event when overlay first launches

		$('.country-overlay form').submit(function(e){

			var $this = $(this),
				value = $('select', $this).val();

			if ($this.attr('action')) {
				$this.attr({'action': value});
			}

			if (value.indexOf(guxApp.locale.locale) < 0){
				self.clearFPSinfo();
			}

			// if current submit data match the current current URL
			// cancel the submit redirection and hide the overlay
			if (!self.updateCookie(value,true)) {
				e.preventDefault();

				if (guxApp.locale.isGUX) {
					self.closeOverlay();
				} else {
					$.publish("overlay.hide");
				}
				
				return false;
			}

		});
		
		var country = self.localeArr[self.COUNTRY];
		if (country) {
			$('.country-overlay select option').each(function() {
				var $options = $(this),
					val = $options.attr('value');

				if (val && val.indexOf(country) > 0) {
					$options.attr({'selected' : 'selected'});
				}
			});
		}

		// re-init uniform selects
		if (guxApp.locale.isGUX) {
			$('.locale-modal select').uniform();
		}

	},

	initMenu: function() {

		var $current = $('.countrytab .current'),
			$anchors = $('.country li a'),
			self = this;

		// update Menu text
		if(self.localeArr[self.CONFIRMED] == '1'){
			// convert ["bh", "ar", "1"] => "bh/ar"
			var key = self.localeArr.slice(0,2).join('/');

			$anchors.each(function(){
				var $this = $(this), 
					href = $this.attr('href');

				if(href.indexOf(key) >-1 ){
					$current.text($this.text());
				}
			});
		}

		// bind event to top menu update cookie when click on the anchors
		$anchors.click(function(e){
			var value = $(this).attr('href');
			
			if (value.indexOf(guxApp.locale.locale) < 0){
				self.clearFPSinfo();
			}

			if(!self.updateCookie(value,true)){
				e.preventDefault();
			}
		});

	},

	updateCookie: function(value,confirmed) {

		// update locale cookie: convert url "/en/irq/homeXXX#**" => en-irq-1
		// return 0 means selected locale match the current url
		var self = this;

		if (value) {

			// remove the host name, get the relative path, etc "/en/irq/xxx"
			var host = location.host, i = value.indexOf(host);
			value = i > 0 ? value.substr(i + host.length) : value;
			// remove the first '/' if nessary.
			value = value.charAt(0) == '/' ? value.substr(1) : value;

			// get the locale array, like [ "en", "irq", "0" ]
			var localeArr = value.split('/').slice(0,2);

			if (confirmed){
				localeArr[self.CONFIRMED] = '1';
			}
			else {
				localeArr[self.CONFIRMED] = '0';
			}
			

			$.cookie(self.COOKIEKEY, localeArr.join('-'), {
				expires: 365,
				path: '/'
			});

			

			// whether current URL contains something like "/en/irq/"?
			if (location.href.indexOf('/' + localeArr.slice(0,2).join('/')) > 0) {
				return 0;
			}

		}

		return 1;

	},

	reinitInnerPopup: function() {
		// re-init inner popup
		guxApp.innerPopup.init({
			container : ".reveal-modal"
		});
	},

	realignInnerPopup: function() {

		// align popups correctly for GUX locale overlay
		$('.reveal-modal a.citation').on('click', function() {
			$('.reveal-modal > .inner-popup').removeClass('right-popup');
		});

		$('.reveal-modal .right a.citation').on('click', function() {
			$('.reveal-modal > .inner-popup').addClass('right-popup');
		});

	},

	closeOverlayEvent: function() {

		var self = this;

		// close overlay when clicking on close 'X'
		$('#modalWrap.locale-modal').off('click').on('click', '.icon-close', function(e) {
			e.preventDefault();
			self.closeOverlay();
		});

		$(document).keydown(function(e) {

			// close overlay when ESC key is pressed
			if (e.keyCode == 27) {
				self.closeOverlay();
			}
		});

	},

	closeOverlay: function () {

		// hide modal and then remove content
		$('#modalWrap').modal('hide').removeClass('polk-modal').find('.modal-body').html('');

		guxApp.innerPopup.init();
	},

	clearFPSinfo: function(){
	
		if($.cookie('dfy.uuid')){
			$.removeCookie('dfy.uuid', {path:'/', domain:guxApp.locale.cookieDomain});
		}

		if($.cookie('gt_uid')){
			var dmArray = [];
			dmArray = guxApp.locale.cookieDomain.split('.');

			var dmStr = "." + dmArray[dmArray.length - 2] + "." + dmArray[dmArray.length - 1];
			$.removeCookie('gt_uid', {path:'/', domain:dmStr});
		}

		if($.cookie('dfy.p')){
			$.removeCookie('dfy.p', {path:'/', domain:guxApp.locale.cookieDomain});
		}

		if(sessionStorage.getItem("dfy.p") !== null){
			sessionStorage.removeItem("dfy.p");
		}

		// $.publish('FPS-reset');
	},
	setGTUID: function(){
		//gt_uid is the cookie used by FPS to check user status
		var setCookie = function (sKey, sValue, vEnd, sPath, sDomain, bSecure) {
	        if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) { return false; }
	        var sExpires = "";
	        if (vEnd) {
	            switch (vEnd.constructor) {
	                case Number:
	                    sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
	                    break;
	                case String:
	                    sExpires = "; expires=" + vEnd;
	                    break;
	                case Date:
	                    sExpires = "; expires=" + vEnd.toUTCString();
	                    break;
	            }
	        }
	        document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
	        return true;
	    };
	    var readCookie = function (name) {
	        var nameEQ = name + "=";
	        var ca = document.cookie.split(';');
	        for (var i = 0; i < ca.length; i++) {
	            var c = ca[i];
	            while (c.charAt(0) == ' ') c = c.substring(1, c.length);
	            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
	        }
	        return null;
	    }
		var UUIDV4 = function b(a) { return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, b) };
	    var uid = readCookie('gt_uid') || UUIDV4();

	    var now = new Date();
	    var domain = (function () {
	        var i = 0, domain = document.domain, p = domain.split('.'), s = '_gd' + now.getTime();
	        while (i < (p.length - 1) && document.cookie.indexOf(s + '=' + s) == -1) {
	            domain = p.slice(-1 - (++i)).join('.');
	            document.cookie = s + "=" + s + ";domain=" + domain + ";";
	        }
	        document.cookie = s + "=;expires=Thu, 01 Jan 1970 00:00:01 GMT;domain=" + domain + ";";
	        return domain;
	    })();
	    setCookie('gt_uid', uid, new Date(now.getTime() + (365 * 86400000)), '/', domain);
	}

};

$(function() {
	// if ($('#locale-data').length) {
	// 	window.setTimeout(function(){
	// 		guxApp.locale.init();
	// 	}, 1000);
	// }
	guxApp.locale.init();
});

})(jQuery);


/*
Author: 		Doris Zhang
File name: 		commonMapController.js
Description: 	common method of mapcontroller
Dependencies: 	jQuery 
Usage: 			
*/


var guxApp = guxApp || {};

(function($) {

	guxApp.commonMapController = {
		
		searchDealersByKeyword: function(keyword, container, callback, errmessage) {

			var self = this,
				map = this.map,
				is_postcode = /^\d/.test(keyword),
				is_invalidAd = /[@#$%^*()_+]+/.test(keyword),
				moduleContainer = $('dealer-locator,mini-dealer');

			if (is_postcode) {

				self.searchDealersByLocation(keyword, container, null, null, callback, errmessage);

			} else {
				
				if(is_invalidAd){keyword="@";}
				self.searchDealersByProperties( {}, { DealerNameSearch: keyword.toLowerCase() }, function(dealer) {
					if (!dealer.length) {
						//search by property of country if address is country level 
						map.geocodeLocation(keyword, function(locations) {
							var currLocation = locations[0];
							if (currLocation&&_.contains(currLocation.types,'country')) {
								self.searchDealersByProperties({}, {Country:currLocation.description}, function(dealer) {
									if(!dealer.length){
										setTimeout(function() {
											self.searchDealersByLocation(keyword, container, null, null, callback, errmessage);
										}, 1000);
										return;
									} 
									else {
										callback(dealer);											
									}						
								});
							}
							else {
								setTimeout(function() {
											self.searchDealersByLocation(keyword, container, null, null, callback, errmessage);
										}, 1000);
										return;
							}
						});
						
					}
					else {
						callback(dealer);
					}
				});
			}	

		},
		makeDealerURL: function(dealer) {
			
			var params = dealer.DealerID,
				domain = this.config.lad_url || location.href,
				has_query_string = _.contains(domain, '?'),
				has_dealer_param = /(\?|\&)+(dealer)+\=/.test(domain);
			var dealerTrans = $("#dealer-translations").embeddedData();
			var pathRootUrl = dealerTrans.pathRootUrl;
			//if usePathUrl exist and true
			if (dealerTrans.usePathUrl && dealerTrans.usePathUrl == "true"){
				//console.log("usePathUrl is true");
				if (guxApp.tools.isAutoNaviMap()) {
				params = guxApp.tools.slugify(dealer._name) + "-" + params;
				params = ((dealer._address)? guxApp.tools.slugify(dealer._address)+"/":"") + params;
				params = ((dealer.Province)? guxApp.tools.slugify(dealer.Province)+"/":"") + params;
				
				}
				else {
				params = guxApp.tools.slugify(dealer.DealerName) + "-" + params; 
				params = ((dealer.Locality)? guxApp.tools.slugify(dealer.Locality)+"/":"") + params;
				params = ((dealer.AdministrativeArea)? guxApp.tools.slugify(dealer.AdministrativeArea)+"/":"") + params;
				
				}

				// if the domain has query string, this will insert the dealer param (<dealer code>/<dealer city>/<dealer name>)  between domain and query string 
				if (has_query_string) {
					var domainArr = domain.split("?");					
					return domainArr[0]  + "/" + params + "?" + domainArr[1];		
				};
			
				return domain  + "/" + params;
			}else {
				
				//console.log("usePathUrl is false");
				if (guxApp.tools.isAutoNaviMap()) {
				params = guxApp.tools.slugify(dealer._name) + "-" + params;
				params = ((dealer._address)? guxApp.tools.slugify(dealer._address)+"-":"") + params;
				params = ((dealer.Province)? guxApp.tools.slugify(dealer.Province)+"-":"") + params;

				}
				else {
				params = guxApp.tools.slugify(dealer.DealerName) + "-" + params;
				params = ((dealer.Locality)? guxApp.tools.slugify(dealer.Locality)+"-":"") + params;
				params = ((dealer.AdministrativeArea)? guxApp.tools.slugify(dealer.AdministrativeArea)+"-":"") + params;

				}
				if (has_query_string && has_dealer_param) {
					domain = domain.split(/(\?|\&)+(dealer)+\=/)[0];
					has_query_string=_.contains(domain, '?');
				};
				//repalce ominiture data
				if(_da&&_da.module&&_da.module.template&&domain.indexOf("intcmp")!=-1){
					if(domain.indexOf("STATUS")!=-1){
						domain = domain.replace(/STATUS/,_da.module.template);
					}
				}
				return domain + (has_query_string?"&":"?") + "dealer=" + params;
			}
			

			// dealership_url = location.href.split('?')[0]+"?dealer=";

		},

		makeDealerAddress: function(dealer, format) {

			var self = this,
				address = (format || "a l L A C p").split(/\s/),
				address_obj = {
					"a": _.reduce([
						dealer.AddressLine1,
						dealer.AddressLine2,
						dealer.AddressLine3
					], function(memo, a) { return memo + ((a)?" "+a:""); }),
					"l": (dealer.SubLocality?dealer.SubLocality:""),
					"L": (dealer.Locality?dealer.Locality:""),
					"A": (dealer.AdministrativeArea?dealer.AdministrativeArea:""),
					"C": (dealer.Country?dealer.Country: ""),
					"p": (dealer.PostCode?dealer.PostCode:"")
				};

			_.each(address, function(value, i) {

				var key_name = value.replace(/\W/g, ''),
					key_value = address_obj[key_name];

				if (!key_value) {
					address.splice(i, 1, " ");
					return;
				}
				//seperate each address info by ","   except the last address info
				if(i < address.length-1){
					key_value = key_value + ","
				}
				//as required country name such as "New Zealand" should not be displayed
				if(self.config.display_country && self.config.display_country == "N" && key_name == "C" ) {
					key_value = "";
				}
				
				value = value.replace(key_name.toString(), key_value);
				address.splice(i, 1, value);

			});

			return address.join(" ");

		},
        		
		open_dept: function(dept_hours) {
			
			var open_dept = false;

			for (key in dept_hours) {
				open_dept = dept_hours[key];
				break;
			}

			return open_dept;

		},

		capitalize: function(string) {
			if (string){
				return string.charAt(0).toUpperCase()+string.slice(1);
			}
		},

		is_dealerOpen: function(dealer, day) {
			var self = this,
				is_open = false,
				now = new Date();

			if (dealer.hours) {
				
				var dept = self.open_dept(dealer.hours),
					dept_name = self.capitalize(dept.key);
				
				if (!!parseInt(dealer[dept_name+day+"Open"]) || dealer[dept_name+day+"Open"] === "Y") {
					var dealer_time = self.strTotime(dealer[dept_name+day+"CloseTime"], true);
					is_open = Date.parse(now) <= Date.parse(dealer_time);
				}
			}

			return is_open;

		},

		filterData: function(obj, filter) {
			/*
			 * filter objects with specified filter pattern
			 * return: object of filtered objects
			 */

			var filtered_objects = false;

			for (var key in obj) {
				if (filter.test(key) && obj[key] != "") {
					
					if (!filtered_objects) filtered_objects = {};

					filtered_objects[key] = obj[key];

				}
			}

			return filtered_objects;

		},

		getDeptSchedule: function (obj, mapController) {

			var self = this,
				dept = {
					"sales": {
						pattern: /^Sales+\w+(Time|Open|Comments)$/,
						keys: ["HasSalesDepartmentPV", "HasSalesDepartmentCV","Used","ApprovedUsed"]
					},
					"service": {
						pattern: /^Service+\w+(Time|Open|Comments)$/,
						keys: ["HasServiceDepartmentPV", "HasServiceDepartmentCV"]
					},
					"parts": {
						pattern: /^Parts+\w+(Time|Open|Comments)$/,
						keys: ["HasPartsDepartment"]
					}
				},
				hours = false,
				displayHours = false;

			//this code is easy for tester to use mock api data to test
			if($("#mocked-api").length == 1){
				obj = $("#mocked-api").embeddedData();
			}	
			
			for (var key in dept) {

				displayHours = false;
				$.each(dept[key].keys,function(i,value) {
					displayHours = (obj[value]=="Y"||obj[value]=="1")? true:displayHours;
				})
				if (!displayHours) continue;

				// if (obj[dept[key].keys[0]] === "N" || obj[dept[key].keys[0]] === "0" || !obj[dept[key].keys[0]]) continue;

				
				var deptHours = self.filterData(obj, dept[key].pattern);

				if (!hours) hours = {};
				for (var deptDay in deptHours) {
					if (!hours.hasOwnProperty(key)) {
						hours[key] = {
							"name": self.config.translation[key],
							"key": key
						};
					}

					hours[key][deptDay] = (deptDay.indexOf("OpenTime")!=-1||deptDay.indexOf("CloseTime")!=-1)&&(/^\d{4}$/.test(deptHours[deptDay]) || /\d{2}\:\d{2}/.test(deptHours[deptDay]))? mapController.strTotime(deptHours[deptDay]) : deptHours[deptDay];
				}

			}

			return hours;
		},

		strTotime: function(timeStr, return_time_obj) {

			if (!timeStr) return;

			timeStr = timeStr.replace(':','');

			var self = this,
				date = new Date(),
				hours = parseInt(timeStr,10)/100,
				minutes = parseInt(timeStr,10)%100
				time = null;

			time = new Date(date.getFullYear(), date.getMonth(), date.getDate(), hours, minutes, 00, 00);

			if (return_time_obj) return time;

			hours = time.getHours();
			minutes = time.getMinutes().toString();

			return ((hours>12)?hours-12:((hours==0)?12:hours))+":"+((minutes.length<=1)?"0"+minutes:minutes)+((hours>=12)? self.config.translation.evening_suffix: self.config.translation.morning_suffix);

		},

		getCloseTime: function (dealer, day) {
			var self = this,
				closeTime = false;

			if (dealer.hours) {
				var dept = self.open_dept(dealer.hours);
				closeTime = self.strTotime( dealer[ self.capitalize(dept.key) +day+"CloseTime"])
			}

			return closeTime;
		},

		getNextOpenTime: function (dealer) {

			var self = this,
				day = (new Date()).getDay(),
				next_open = "";

			if (dealer.hours) {
				var dept = self.open_dept(dealer.hours),
					dept_name = self.capitalize(dept.key);

				for (var i = day+1, counter=0; counter < 7; counter++) {
					if (!!parseInt(dealer[dept_name+dealer.day_str[i]+"Open"]) || dealer[dept_name+dealer.day_str[i]+"Open"] === "Y") {
						next_open = dealer.day_str_translated[i] + " " + self.strTotime(dealer[dept_name+dealer.day_str[i]+"OpenTime"]);
						break;
					}
					i = (i >= 6)?0:i+1;
				};
			}

			return next_open;
		},

		scheduleString: function(dealer, hours, day) {

			var self = this,
				date = new Date(),
				curTime = parseInt(date.getHours().toString()+date.getMinutes().toString()),
				scheduleString = {
					type : "",
					description: self.config.translation.closed_str
				};

			if (dealer.hours) {
				
				var dept = self.open_dept(hours),
					dept_name = self.capitalize(dept.key),
					dept_val = self.capitalize(dept.name),
					closeTime = dealer[dept_name+day+"CloseTime"]?parseInt(dealer[dept_name+day+"CloseTime"],10):2459;


				if ((!!parseInt(dealer[dept_name+day+"Open"]) || dealer[dept_name+day+"Open"] === "Y") && (curTime < closeTime)) {

					if (!dealer.closeTime) {
						scheduleString.description = "";
					} else {
						scheduleString.type = dept_val + " ";
						scheduleString.description = self.config.translation.open_until + dealer.closeTime;
					}
				} else if (dealer.nextOpenTime) {
					scheduleString.type = dept_val + " ";
					scheduleString.description = self.config.translation.reopen_on + dealer.nextOpenTime;
				}
				
			}


			return scheduleString;
		}

	};

	

})(jQuery);


/*
Author: 		Jay Gauten
File name: 		googleMapController.js
Description: 	load google map
Dependencies: 	jQuery 
Usage: 			
*/


var guxApp = guxApp || {};

(function($) {

	guxApp.googleMapController = {
		init: function() {

			var self = this,
				APIconfig = {
					language : self.config.localisation,
					countryCode : self.config.country_code,
					countryCodes : self.config.country_code,
					imagePath : self.config.marker_image_path,
					countryBounds: self.config.country_bounds,
					autocompleteCallbackName: "googleAutocompleteCallbackName",
					dealerTableURL: self.config.dealer_table
				};
  			
  			self.mapAPI = new googleMapsApi(APIconfig);
			
			if ($('.dealer-locator').length) {
				self.mapContainer = $('.dealer-map-field')[0];
			} else if ($('.mini-dealer').length) {
				self.mapContainer = $('#map-container')[0];
			}

			if (!self.map && !!self.mapContainer) self.loadMap(self.mapContainer);

			$.publish('api-done');

		},
		loadMap: function(mapContainer) {

			var self = this;

			// initialize map
			var map = new self.mapAPI.map(mapContainer, {
				center: {
					lat: self.config.currentLat,
					lng: self.config.currentLong
				},
				scrollwheel: false,
				mapTypeControl: true,
			    mapTypeControlOptions: {
			        style: google.maps.MapTypeControlStyle.DROPDOWN_MENU,
			        position: google.maps.ControlPosition.RIGHT_BOTTOM
			    },
			    panControl: true,
			    panControlOptions: {
			        position: google.maps.ControlPosition.TOP_RIGHT
			    },
			    zoomControl: true,
			    zoomControlOptions: {
			        position: google.maps.ControlPosition.RIGHT_TOP
			    },
			    scaleControl: true, 
			    streetViewControl: false,
				supressInfoWindows: true,
				zoom: parseInt(self.config.zoom_level)
			});

			self.map = map;
			
			if ($('.map-default', $('.dealer-locator')).length) $('.map-default', $('.dealer-locator')).remove();

			$.publish('map-api-done');

		},

		getCoordsFromAddressString: function(address, callback) {
			this.map.geocodeLocation(address, callback);
		},

		getAddressStringFromCoord: function(coords, callback) {
			this.map.reverseGeocode(coords, callback);
		},

		searchDealersByKeyword: function(keyword, container, callback, errmessage) {

		    guxApp.commonMapController.searchDealersByKeyword.call(this, keyword, container, callback, errmessage);

		},

		searchDealersByProperties: function(matchParams, containsParams, callback, errmessage) {

			var _self = this,
				map = _self.map,
				matchParams = matchParams || {},
				containsParams = containsParams || null;

			_self.cleanMap();
			_self.currentLocationCoords = null;
			
			if(_self.config.langFilter){
				matchParams.Language = _self.config.langFilter;
			}
			// add brand filter
			if(_self.config.brandFilter){
				matchParams.Brand = _self.config.brandFilter;
			}
			// add country filter
			if(_self.config.countryCodeFilter){
				// matchParams.CountryCode = _self.config.countryCodeFilter;
			}
			
			map.searchDealersByProperties(_self.config.limit, function(response) {
				callback(response, errmessage);
			}, matchParams, containsParams);

		},

		searchDealersByLocation: function(address, searchField, matchParams, containParams, callback, errmessage, isAutoDetection) {

			// method for auto detection

			var self = this,
				map = this.map,
				response = null,
				matchParams = matchParams || {},
				containParams = containParams || null;

			self.currentLocationCoords = null;

			var search = function(address) {
				map.geocodeLocation(address, function(locations) {

					// locations = _.filter(locations, function(location) { return !_.contains(location.types, "country"); });
					
					var currLocation = locations[0];

					if (!currLocation) {
						callback(false, errmessage);
						return false;
					} else if (_.contains(currLocation.types, 'country') && currLocation.description.toLowerCase() != address.toLowerCase()) {
						callback(false, self.config.error_message.location_not_found);
						return false;
					}
					
					if(isAutoDetection){
						//auto detection will prefill search input box
						searchField.val(currLocation.description);
					}
					
					self.currentLocationCoords = {
						lat: currLocation.lat,
						lng: currLocation.lng
					}
					
					self.searchForDealers(currLocation, self.config.radius, self.config.limit, matchParams, containParams, callback, self.config.error_message.nearest_dealer_not_found);
	
				});
			}
			
			//search by lat/lng
			if(typeof address == "object"){
				//conver lat/lng to address first.
				map.reverseGeocode(address,function(location){
					//restore coverted address
					search(location.address);
				});
			}else{//search by address
				search(address);
			}
		},

		searchForDealers: function(origin, radius, resultLimit, matchParams, containParams, callback, errormessage) {

			var _self = this,
				map = _self.map,
				distance_interval = 50,
				search_interval = 1,
				matchParams = matchParams || {},
				containParams = containParams || null;
			
			_self.reiterate = null;
			_self.cleanMap();
			
			if(_self.config.langFilter){
				matchParams.Language = _self.config.langFilter;
			}
			// add brand filter
			if(_self.config.brandFilter){
				matchParams.Brand = _self.config.brandFilter;
			}
			// add country filter
			if(_self.config.countryCodeFilter){
				// matchParams.CountryCode = _self.config.countryCodeFilter;
			}

			map.searchDealersByDistance(origin, radius, resultLimit, function(results) {

				if (results.length) {
					
					callback(results);

				} else {

					// iterate search until distance limit is reached
					if (radius <= _self.config.max_radius) {
						// notify user
						_self.reiterate = setTimeout(function() {
							_self.searchForDealers(origin, radius+distance_interval, resultLimit, matchParams, containParams, callback, errormessage);
						}, search_interval*1000);

					} else {
						// show error
						callback(false, errormessage);
					}

				}

			}, matchParams, containParams);

		},

		makeMapURL: function(destination, origin) {
			
			var self = this,
				map = this.map;
			return map.getDirectionsURL(destination, origin);

		},

		makeDealerURL: function(dealer) {

		    return guxApp.commonMapController.makeDealerURL.call(this, dealer);

		},

		makeDealerAddress: function(dealer, format) {

		    return guxApp.commonMapController.makeDealerAddress.call(this, dealer, format);

		},

		displayMap: function() {
			google.maps.event.trigger(this.map.map, 'resize');
		},

		cleanMap: function() {

			var map = this.map;

			map.deselectMarkers();
			map.clearMarkers(map.markers);
			map.clearRoutes();
			map.clearDealers();

		},

		open_dept: function(dept_hours) {
			
		    return guxApp.commonMapController.open_dept.call(this, dept_hours);

		},

		capitalize: function (string) {

		    return guxApp.commonMapController.capitalize.call(this, string);

		},

		is_dealerOpen: function (dealer, day) {

		    return guxApp.commonMapController.is_dealerOpen.call(this, dealer, day);

		},

		filterData: function(obj, filter) {
			
		    return guxApp.commonMapController.filterData.call(this, obj, filter);

		},

		getDeptSchedule: function(obj) {

		    return guxApp.commonMapController.getDeptSchedule.call(this, obj, guxApp.googleMapController);

		},

		strTotime: function(timeStr, return_time_obj) {

		    return guxApp.commonMapController.strTotime.call(this, timeStr, return_time_obj);

		},

		getCloseTime: function(dealer, day) {
			
		    return guxApp.commonMapController.getCloseTime.call(this, dealer, day);

		},

		getNextOpenTime: function(dealer) {

		    return guxApp.commonMapController.getNextOpenTime.call(this, dealer);

		},

		scheduleString: function(dealer, hours, day) {

		    return guxApp.commonMapController.scheduleString.call(this, dealer, hours, day);

		}

	};

	$(function() {
		
		// if (($('.dealer-locator').length==0 && $('.mini-dealer').length==0) || guxApp.tools.isBingMap() || guxApp.tools.isAutoNaviMap()) {return;}
		if (($('.dealer-locator').length==0 && $('.mini-dealer').length==0) || guxApp.tools.isAutoNaviMap()) {return;}
		
		var locator_config = $('#locator-config').embeddedData(),
			common_config = $("#common-config").embeddedData(),
			mapController = guxApp.googleMapController;
		
		mapController.config = locator_config;
		if (common_config.multiLanguage == true && common_config.language){
			mapController.config.langFilter = common_config.language;
		}
		// add brand filter
		mapController.config.brandFilter = common_config.brand?common_config.brand:"Ford";
		// add country filter
		mapController.config.countryCodeFilter = common_config.iso2country;

		mapController.map_loaded = false;

		mapController.currentLocationCoords = null;

		// load google map api
		var script = document.createElement('script');
  		script.type = 'text/javascript';


  		var clientMode = (!common_config.apiClient) ? 'client_id' : common_config.apiClient;

  		script.src = 'https://maps.googleapis.com/maps/api/js?' + clientMode + '=gme-fordmotorcompany2&libraries=places&language=' + locator_config.localisation + '&callback=guxApp.googleMapController.init';
  		document.body.appendChild(script);

  		// for modern browsers
  		script.onerror = function(a,b,c,d) {
  			var google = google || undefined;
  			$('.error', $('.dealer-locator, .mini-dealer')).show().find('.text').text(locator_config.error_message.map_not_loaded);
  			return;
  		}

  		// for ie8
  		script.onreadystatechange = function(a,b,c,d) {
  			// this.readyState, 
  			if (this.readyState == "loaded") {
  				if (!window.google) {
  					$('.error', $('.dealer-locator, .mini-dealer')).show().find('.text').text(locator_config.error_message.map_not_loaded);
  					return;
  				}
  			}
  		}


	});

	

})(jQuery);


/*
Author: Ruiwen Qin
File name: video.js
Description: Initialize jwPlayer
Dependencies: jQuery, jwPlayer
*/
var guxApp = guxApp || {};

(function($){
	guxApp.video = {
		settings : {},
		defaults : {
	    	width : 593,
	    	height : 348,
	      	modes : [
	          {
	            type : 'html5',
	            config : {
	              // skin : "../../src/themes/ftd/skin/glow/glow.xml"
	              skin: "/themes/ftd/skin/glow/glow.xml"
	            }
	          }, 
	          {
	            type : 'flash',
	            // src : '../../src/themes/ftd/swf/player.swf',
	            src: "/themes/ftd/swf/player.swf",
	            config : {
	              // skin : "../../src/themes/ftd/skin/glow.zip"
	              skin: "/themes/ftd/skin/glow.zip"
	            }
	          } ],
	      	// Close tracking by default (begin, 25, 50, 75, finish)
	      	track : "00000",
	      	play : false
	    },

		init: function(){
			if (!$("#video-inner").length) {return;}
			
			//prepare setting options
			guxApp.video.dataSetup();
			guxApp.video.load("jwplayer-js", "/themes/ftd/js/lib/jwplayer.js");
		    $ready("jwplayer", guxApp.video.videoSetup);
			//video options setup and video initialize
			//guxApp.video.videoSetup();
			
		},
		//load script dynamicly
	    load: function(id, src){
	      if(document.getElementById(id)) return;

	      var js, fjs = document.getElementsByTagName("script")[0];
	      js = document.createElement("script");
	      js.id = id;
	      js.src = src;
	      fjs.parentNode.insertBefore(js, fjs);
	    },
		dataSetup: function(){
			if ($("#video-config").length > 0){
				var videoConfig = $("#video-config").embeddedData();
			}
			
			if (videoConfig !== undefined && !guxApp.tools.isEmpty(videoConfig)){
				guxApp.video.settings = $.extend({},guxApp.video.defaults,videoConfig);

				// customize skin for html5 video player
			    if (videoConfig.skin){
			    	// guxApp.video.settings.modes[0].config.skin = "../../src/themes/ftd/skin/" + guxApp.video.settings.skin + "/" + guxApp.video.settings.skin + ".xml";
			    	guxApp.video.settings.modes[0].config.skin = "/themes/ftd/skin/" + guxApp.video.settings.skin + "/" + guxApp.video.settings.skin + ".xml";
			    }
			}
		},
		videoSetup: function(){

			/*if (guxApp.viewport.view === "mobile") {
				guxApp.video.settings.play = false;
			} else {
				guxApp.video.settings.play = true;
			}*/

			var playerOptions = {
	        	image: guxApp.video.settings.image,
	        	modes: guxApp.video.settings.modes,
	        	levels : [ {
	          		type : 'video/mp4',
	          		file : guxApp.video.settings.file
	        	}],
	        	width: guxApp.video.settings.width,
	        	autostart:guxApp.video.settings.play,
	        	'plugins' : {}
	      	};

	      	if (guxApp.video.settings.controlbar) {
		    	playerOptions.controlbar = "none";
		    }

		    if (guxApp.video.settings.caption) {
        		playerOptions["plugins"]["captions-2"] = {
          			"file" : guxApp.video.settings.caption
        		};
      		}

      		//video initialize
      		jwplayer("video-inner").setup(playerOptions);
      		
      		jwplayer().onReady(function(){
      			var videoContainer = $("#modalWrap .modal-body"),
      				containerWidth = videoContainer.width(),
      				playerHeight,ratio;

      			//hide control bar until video starts to play
  				if (guxApp.video.settings.hideControls){
      				jwplayer().getPlugin("controlbar").hide();
      			}

      			//Don't hide control bar if using chrome.
      			console.log(guxApp.tools.isMobile());
      			if(!(guxApp.tools.isMobile() == "Android")){
      				jwplayer().getPlugin("controlbar").hide();
      			}

      			//set height of the player based on the ratio
      			if (guxApp.video.settings.ratio){
		      		var prop = guxApp.video.settings.ratio.split(":");
		      		ratio = prop[1] / prop[0];
		      		playerHeight = containerWidth * ratio;
		      		jwplayer().resize(containerWidth,playerHeight);
		      	}

      			//resize the dimension of the player along with window size
      			$(window).resize(function(){
		            containerWidth = videoContainer.width();
		            playerHeight = containerWidth * ratio;
		            jwplayer().resize(containerWidth,playerHeight);
      			});

      			// hide close button on fullscreen
      			$("#video-inner").on("click", "#video-inner_jwplayer_controlbar_fullscreenButton", function() {
		            $(".modal .icon-close").hide();
		        });
		        
				// show close button on fullscreen
		        $("#video-inner").on("click", "#video-inner_jwplayer_controlbar_normalscreenButton", function() {
		            $(".modal .icon-close").show();
		        });

      			jwplayer().play(guxApp.video.settings.play);

      			$(".modal-body").removeClass("loading-video");
  			});

  			jwplayer().onPlay(function(){
          		jwplayer().getPlugin("controlbar").show();
          		jwplayer().resize(jwplayer().getWidth(),jwplayer().getHeight());
        	});

        	// tracking impl
          	guxApp.video.settings.track != "00000" && guxApp.video.track(guxApp.video.settings);
	},
		// track video
	    track : function(settings) {
	      	// tracking flag
	      	var trackPos = { "0" : 1, "0.2" : 1, "0.5" : 1, "0.7" : 1, "0.8" : 1},
	          	ti = settings.title || "",
	          	dcsuri = settings.url || "",
	          	pname = settings.pname || "",
	          	hier = settings.hier|| "";
	      	jwplayer().onTime(function(e) {
	        	var percent = Math.round(e.position / e.duration * 10) / 10, action;
	        	var omTitle, omEvents, year, nameplate='none';	        	
	        	if (trackPos[percent]) {
	          		switch (percent) {
			            case 0:
			              if (settings.track.charAt(0) == "1") {
			                action = "Play";
			                omTitle = "video start";
			                omEvents = "event56";
			              }
			              break;
			            case 0.2:
			              if (settings.track.charAt(1) == "1") {
			                action = "Play 25";
			              }
			              break;
			            case 0.5:
			              if (settings.track.charAt(2) == "1") {
			                action = "Play 50";
			              }
			              break;
			            case 0.7:
			              if (settings.track.charAt(3) == "1") {
			                action = "Play 75";
			              }
			              break;
			            case 0.8:
			              if (settings.track.charAt(4) == "1") {
			                action = "Finish";
			                omTitle = "video finish";
			                omEvents = "event57";
			              }
			              break;
	          		}

	          		trackPos[percent] = 0;

		          	if (omTitle && omEvents) {
		        		if (window._da && window._da.om && ND && ND.omniture ) {
		        			var clip_n = settings.clip_n || ti;	
//		        			$.publish('/analytics/link',{
//		              			'link':true,
//		              	      	'onclicks':omTitle,
//		              			'events':omEvents,
//		              			'type':'o',
//		              			'content':clip_n,
//		              			'title':omTitle,
//		              			'nameplate':'none',
//		              			'pname':pname,
//		              			'hier1':hier
//		              		});
		        			if(_da.nameplate && _da.nameplate.year) year = _da.nameplate.year;
					    	if(_da.nameplate && _da.nameplate.name) nameplate = _da.nameplate.name;
					    	
		        			ND.omniture.trackLink({
		              			'link':true,
		              	      	'onclicks':omTitle,
		              			'events':omEvents,
		              			'type':'o',
		              			'content':clip_n,
		              			'title':omTitle,
		              			'nameplate':nameplate,
		    				    "titleNameplate":"none",
		              			'pname':pname,
		              			'hier1':hier,
		              			'year':year
		        			});
		    		  	}
		          	}          	          
//		          	if (action) {
//		            	var clip_n = settings.clip_n || (ti + (e.duration>>0)) ;
//		          
//			            // Tracking implementation
//			            ND.analytics._tag.dcsMultiTrack(
//			                "WT.ti", ti + action,
//			                "DCS.dcsuri", (dcsuri + action.replace(/ /g, '')).toLowerCase().replace(/ /g, '-'),
//			                "WT.clip_ev", action.replace(/ /g,''),
//			                "WT.clip_n", clip_n,
//			                "WT.dl", 7
//			            );
//		          	}
	        	}
	    	});

	      	// For replaying.
	      	jwplayer().onComplete(function(){
	        	trackPos = { "0" : 1, "0.2" : 1, "0.5" : 1, "0.7" : 1, "0.8" : 1};
	      	});
    	}
	};

})(jQuery);


/*
 * functionalities of dealerlocator
 * author : Ray
 * dependencies: jquery, underscorejs, uniformjs, googleMapController, lib/googleMaps, tinypubsub, cookie, jquery-cookie
 
 * History
 * 2015/12/11, Steven Xue, SMW - INC000015398018 - REQ #6689341 - Dragonfly Front end issue about dealer telephone number not display the sam, Line 706, remove .replace(/\s/g, '')
 */
var guxApp = guxApp || {};

(function($) {

	guxApp.dealerLocator = {
		
		init : function() {

			// check if component exists
			var dealerLocator = $('.dealer-locator');
			if (!dealerLocator.length || $('.dealer-unaware',dealerLocator).hasClass('search-panel')) return;

			// container
			var dealerLocatorContainer = $('.dealer-locator'),
				self = this;

			self.colorLengend = self.colorLengend || $();
			

			// utility apps
			var cookie = guxApp.cookie,
				locatorConfig = $("#locator-config").embeddedData();
			
			self.mapController = guxApp.googleMapController;
			/* if(guxApp.tools.isBingMap()){
				self.mapController = guxApp.bingMapController;
			}
			else  */if(guxApp.tools.isAutoNaviMap()) {
				self.mapController = guxApp.autonaviMapController;
			}
			
			// data holders
			self.filters = [];
			self.container = dealerLocatorContainer;
			self.mapContainer = $('.dealer-map-field', self.container);
			self.dealerResultHolder = $('.dealer-list', dealerLocatorContainer);
			self.config = self.mapController.config;
			self.is_mobile = guxApp.viewport.view == "mobile";
			self.is_autoDetection = false;
			self.is_selectLocation = false;
			self.hideDistanceByLocation = !!self.config.hideDistanceByLocation;
			self.errorContainer = $(".error", self.container);
			
			//will not show the landing img if it visited by SEO url directly
			if(self.config.dealerId.length==0){$('.dealer-map-landing').removeClass('hide');}
			
			$('.btn-search', dealerLocatorContainer).on('click', function(e) {
				if ($(this).is('.trackable') && !e.originalEvent) return false;
			});

			// filter button
			$('.filter-toggler', dealerLocatorContainer).on('click', function(e) {
				e.preventDefault();
				//$('.result-list').toggle();
				var	filterBar = $(this).closest(".dealer-filter-bar"),
					resultLists = filterBar.siblings(".result-list");
				if(filterBar.hasClass("active")){//hiding now
					if(self._LastHasCls){
						filterBar.siblings(".result-list.selected").show();
					}else{
						filterBar.siblings(".result-list.selected").siblings(".result-list").show();
					}
				}else{
					self._LastHasCls = filterBar.siblings(".result-list:visible").hasClass("selected")?true:false;
					resultLists.hide();
				}
				
				//gux omniture
				if($(".dealer-filter-bar").hasClass('active')){
					$(this).removeClass('trackable');
				}

				var view_saved_cta = $('.viewSaved', dealerLocatorContainer);
				if (self.getSavedDealer()) {
					view_saved_cta.show();
				} else {
					view_saved_cta.hide();
				}

				// popove launcher
				$('.view-details', dealerLocatorContainer).on('click', self.togglePopInfo);
				
				$(".dealer-filter-bar").toggleClass('active');

			});

			// filter group accordion
			$('.filter-accordion', dealerLocatorContainer).find('.control').on('click', self.toggleAccordion);
			
			// distance dropdown trigger
			$('.filter-distance', dealerLocatorContainer).find('dt a').on('click', self.showOptions);

			// // popove launcher

			// close popover
			$('.group-list', dealerLocatorContainer).on('click', '.close-info', self.closePopInfo);
					

			// remove selected filter
			$('.filter-clear', dealerLocatorContainer).on('click', function(e) {
				var groupList = $('.group-list', dealerLocatorContainer);
				groupList.find('input:checked').removeAttr('checked');
				groupList.find('span[class="checked"]').removeClass('checked');
			});

			$('.input-panel input[type=text]', dealerLocatorContainer).on('focus', function() {
				var elem = this,
					placeholder = $(elem).attr('placeholder'),
					value = $(elem).val();

				if ($(elem).attr('placeholder')) {
					$(elem).data('placeholder', placeholder);
					$(elem).removeAttr('placeholder');
				}

			});

			$('.input-panel input[type=text]', dealerLocatorContainer).on('blur', function(e) {
				var elem = this,
					placeholder = $(elem).attr('placeholder'),
					value = $(elem).val();

				if (!value) {
					$(elem).attr('placeholder', $(elem).data('placeholder'));
				}

			});

			$('.dealer-filter-bar', dealerLocatorContainer).on('submit', '.filter-accordion', function(e) {
				e.preventDefault();

				var form_data = $(this).serialize(),
					dealers = self.dealers || [],
					filters = {};
				
				self.filters = [];
				self.is_autoDetection = false;
				
				self.closeTabs();

				if (!!form_data) {
					
					form_data = form_data.split("&");

					$.each(form_data, function(i, filter) {
						var filter_obj = filter.split('=');

						self.filters.push(filter_obj[0]);

						filters[filter_obj[0]] = true;

					});

					dealers = _.where(self.dealers, filters);

					if (!dealers.length) {

						self.loadedDealers = [];
						self.mapController.cleanMap();

						$('.dealer-result-container .count .num').text("");
						$('.dealer-result-container .count .msg').text("");
						$('.result-list ul').empty()
							.append($('<li class="error" />').text(self.config.error_message.filtered_dealer_not_found));
						$('.result-list').not('.selected').find('.dealer-view-more').hide();
						return;
					}
					
					
				}
				
				self.loadedDealers = [];

				self.mapController.cleanMap();

				self.processResults(dealers, '', true);

				return false;

			});

			// show saved dealer on list
			$('.viewSaved', dealerLocatorContainer).on('click', function(e) {
				e.preventDefault();
				self.closeTabs();
				self.showSavedDealer();
			});

			$('.show-list', dealerLocatorContainer).on('click', function() {
				self.closeTabs();
			});

			$('.dealer-result-container', dealerLocatorContainer).on('click', '.view-all-dealers', function(e) {
				e.preventDefault();
				e.stopPropagation();
				var dealerTrans = $("#dealer-translations").embeddedData(); 
				var pathRootUrl = dealerTrans.pathRootUrl;
				if (window.history.pushState && !self.is_mobile) {
					var domain = location.href,
						has_query_string = _.contains(domain, '?'),
						has_dealer_param = /(\?|\&)+(dealer)+\=/.test(domain);

					if (has_dealer_param) {
						domain = domain.split(/(\?|\&)+(dealer)+\=/)[0];
					}else {
						//if usePathUrl  
						if (dealerTrans.usePathUrl && dealerTrans.usePathUrl == "true"){
							var newURI = domain;
							var parts = domain.split('/'); 
							var toRemove = parts[parts.length-3];
							if ($(".dealer-result-container").hasClass("detailed")) {
								domain = domain.split(toRemove)[0];
							}
						}
					}
					window.history.pushState("", "", domain);
				}

				$(this).parents('.dealer-result-container').removeClass('detailed');
				$(this).parents('.dealer-result-container').find(".filter-toggler").addClass('trackable');

				if ($('.dealer-filter-bar').is('.active')) $('.filter-toggler', self.container).triggerHandler('click');
				$('.result-list', dealerLocatorContainer).show().siblings('.selected').hide();

			});

			// get user location via current location
			$('.dealer-unaware .btn-current', dealerLocatorContainer).on('click', function(e) {
				e.preventDefault();
				e.stopPropagation();
				self.getDealersFromCurrentLocation();
				self.is_selectLocation = false;
			});

			$('.search-panel', dealerLocatorContainer).on('submit', function(e) {
				e.preventDefault();
				self.getDealersByKeyword($('.input-panel input[type=text]').val(), false);
				return false;
			});

			// search dealer
			$('.input-panel input[type=text]', dealerLocatorContainer).on('keyup', self.autoCompleteTrigger);			
			var self = this;
			/*$.urlParam = function(name){
			    var results = new RegExp('[\?&]' + name + '=([^&#]*)').exec(window.location.href);
			    if (results==null){
			       return null;
			    }
			    else{
			       return results[1] || 0;
			    }
			};
			var specialitiesID = !!$.urlParam('specialities')?decodeURI($.urlParam('specialities')):'';*/
			if (sessionStorage['dealers']) {
			    self.processResults(JSON.parse(sessionStorage['dealers']), sessionStorage['error_message']);


				if (sessionStorage['search_keyword']) {
					$('.input-panel input[type=text]', self.container).val(sessionStorage['search_keyword']).blur();
				}

				sessionStorage.removeItem('dealers');
				sessionStorage.removeItem('search_keyword');
				sessionStorage.removeItem('error_message');

			} else {
				//SEO dealer Search 1st
				if(locatorConfig.dealerId.length!=0){
					//var waitMap = setInterval(function() {
						//if(guxApp.googleMapController.map){//issue
							//clearInterval(waitMap);
							self.mapController.searchDealersByProperties({DealerID: locatorConfig.dealerId}, {}, function(dealers) {
								if (dealers.length) {
									self.processResults(dealers, null, null, true);
									
									$('.result-list.selected').show().siblings('.result-list').hide();
									$('.dealer-result-container').addClass('detailed').find(".filter-toggler").removeClass('trackable');
									self.showDealerCard($('.dealer-result-container li.dealer-result'), true);
									if (guxApp.tools.isAutoNaviMap()) self.mapController.map.panTo(dealers[0].location);									
								}
							});
						//}
					//},1000);
				}
				/*else if(guxApp.tools.isAutoNaviMap()&&specialitiesID.length!=0){
							self.mapController.searchDealersByProperties({}, {DealerNewVehicle:specialitiesID}, function(dealers) {
								if (dealers.length) {
									self.processResults(dealers);								
								}
							});
				}*/else{// location aware 2nd
					guxApp.locationAware.locationDetection(function(addressInfo,isAutoDetection){
						if(addressInfo){
	
							self.mapController.searchDealersByLocation(addressInfo, $('.input-panel input[type=text]', dealerLocatorContainer),{},{}, function(results, response) {
	
								// location not found
								if (!results) {
									// self.showError( (response)?response:self.config.error_message.location_not_found);
									return false;
								}
	
								self.is_autoDetection = isAutoDetection;
	
								self.processResults(results);
	
							},"",isAutoDetection);
							
						}
					});
				}
			}
		},
		showNotification: function(e) {
			
			var self = guxApp.dealerLocator,
				notification = $('.save-dealer', self.container);

			notification.stop().slideDown();

			setTimeout(function() {
				notification.stop().slideUp();
			}, 5000);

		},
		hideNotification: function(e) {
			var self = guxApp.dealerLocator,
				notification = $('.save-dealer', self.container);

			notification.stop().slideUp();
		},
		toggleAccordion: function(e) {
			e.preventDefault();
			
			if ($(this).is('.trackable') && !e.originalEvent) return false;

			var control = $(this);
			control.parent().toggleClass('active')
				.siblings().removeClass('active');

			//gux omniture
			$(":first-child", control).toggleClass('trackable');

		},

		showOptions: function(e) {
			e.preventDefault();
			$(this).parents('.values').toggleClass('active').siblings().removeClass('active');

		},

		togglePopInfo: function(e) {
			e.preventDefault();

			var btn = $(this),
				popover = btn.siblings('.popover');

			if (!btn.is('.active')) {
				$('.popover').hide();
				$('.view-details').removeClass('active');
			}

			btn.toggleClass('active');
			popover.toggle();
			
			// TODO position of popover

		},

		closePopInfo: function(e) {
			e.preventDefault();

			guxApp.dealerLocator.togglePopInfo(e);

		},

		getDealerServices: function(obj) {

			var services = $('#services-config').embeddedData(),
				fetched_services = [];

			$.each(services, function(service, info) {
				if (obj[service]) fetched_services.push(info);
			});
			
			//sort service list (service in detail tab) in order
			fetched_services.sort(function(a,b){
				return parseInt(a.order) - parseInt(b.order);
			});

			return (fetched_services.length)?fetched_services:false;
		},

		


		showSavedDealer: function() {

			var self = guxApp.dealerLocator,
				map = self.mapController.map,
				dealers = [];

			var dc = self.getSavedDealer();

			self.loadedDealers = [];
			self.mapController.cleanMap();

			if (_.contains(_.pluck(self.dealers, "DealerID"), dc)) {
				self.processResults(self.dealers,null, null, null,true);
			} else {
				self.mapController.searchDealersByProperties({DealerID: dc}, {}, function(dealers) {
					self.processResults(_.union(dealers,self.dealers),null, null, null,true);
				});
			}

			// self.closeTabs();

		},

		removeSavedDealer: function() {

			var self = guxApp.dealerLocator,
				map = self.mapController.map,
				dealers = [];

			var dc = self.getSavedDealer();

			self.loadedDealers = [];
			self.mapController.cleanMap();
			if (_.contains(_.pluck(self.dealers, "DealerID"), dc)) {
				self.dealers.splice(_.indexOf(self.dealer, dc), 1);
			}

			self.processResults(self.dealers,null, null, null,true);

			// self.closeTabs();
		},

		is_loggedin: function() {
			return guxPersonalisation.psn.profile.authState === "OW";
		},

		getSavedDealer: function() {

			var self = this,
				dc;

			if (self.is_loggedin()) {
				dc = guxApp.cookie.get('dfy.dl') || JSON.parse(sessionStorage['dfy.p']).dc;
			} else {
				dc = guxApp.cookie.get('dfy.dl');
			}

			return dc;
		},
		
		is_savedDealer: function(dealer) {
			return (dealer.DealerID == this.getSavedDealer());
		},
		showDealerCard: function(container, is_dealer) {	
			
			var self = this,
				dealer = $(container).data(),
				services = guxApp.dealerLocator.getDealerServices(dealer),
				personalisation = guxPersonalisation.psn,
				cookie = guxApp.cookie,
				is_favdealer = false,
				is_dealer = is_dealer || false;

			$.extend(dealer, {
				services: services
			});

			if (window.history.pushState && !self.is_mobile && !is_dealer) window.history.pushState(dealer, dealer.DealerName, dealer.dealershipURL);
			// if ($.bbq.pushState && !self.is_mobile && !is_dealer) 	$.bbq.pushState({dealer:decodeURIComponent(dealer.dealershipURL.split('?')[1]||'')});

			// show card template
			$('.result-list.selected .dealer-result').html(_.template($('#dealer-detail').html(), dealer)).data(dealer);
			if (self.is_selectLocation && self.hideDistanceByLocation) {
			    $('.distance', $('.result-list.selected .dealer-result')).hide();
			}
			
			// bind uniform event to customize select elements - uniform.js
			$.publish('uniform', {
				el: $('.select-dept', self.container),
				el_type: "select"
			});

			// check if the saved dealer
			if (self.is_savedDealer(dealer)) {
				$('.save-dealer-btn', $(".result-list.selected")).addClass('saved');
				is_favdealer = true;
			}

			$('.save-dealer-btn em', self.container).html( (is_favdealer)?self.config.translation.saved:self.config.translation.save);
			if(guxApp.tools.isAutoNaviMap()) $('.dealer-locator .dealer-result-container .result-list.selected .dealer-result .dealer-num').addClass(dealer['DealerAffiliation']);
			$('.dealer-accordion').find('.control').on('click', self.toggleAccordion);


			$('.save-dealer-btn').on('click', function(e) {

				e.preventDefault();
				//for omniture
				var omName = $(this).attr('data-name');
				var omType = $(this).attr('data-type');
				var freq = $(this).attr('data-freq');
				var omOnClick = "dealer info:save";
				//end for omniture
				var save_btn = this,
					view_all_btn = $('.view-all-dealers', self.container);

				var queued_event = function(e) {
					if (!$('.input-panel', self.container).is('.active')) view_all_btn.data('dealerEvent')();
					view_all_btn.unbind('click', queued_event);
				}

				view_all_btn.on('click', queued_event);

				// init personalisation
				personalisation_data = JSON.parse(sessionStorage['dfy.p']);

				// change state
				if ($(this).is('.saved')) {

					$(this).removeClass('saved');
					omOnClick = "dealer info:unsave";
					// remove dealer
					$.publish('/analytics/event/', {
						"type": "fav-dealer",
						"code": ""
					});

					// remove from cookie
					personalisation_data.dc = "";

					personalisation.profile = personalisation_data;
					sessionStorage['dfy.p'] = JSON.stringify(personalisation_data);

					if (cookie.hasItem('dfy.dl')) cookie.del('dfy.dl');

					$('.dealer-result.preferred').removeClass('preferred');

					$('em', save_btn).html(self.config.translation.save);
					self.hideNotification();

					view_all_btn.data('dealerEvent', self.removeSavedDealer);
					
					$.publish('/analytics/link/', { 
	        			title: omName,
	        			link: this,
	        			type: omType,
	        			onclicks: omOnClick,
	        			freq:freq
	        			
	        		});	
					return false;

				}

				// show notification
				self.showNotification();
				
				$.publish('/analytics/event/', {
					"type": "fav-dealer",
					"code": dealer.DealerID
				});

				if (self.is_loggedin()) {

					// halt to warn for overwrite
					personalisation_data.dc = dealer.DealerID;
					personalisation.profile = personalisation_data;
					sessionStorage['dfy.p'] = JSON.stringify(personalisation_data);
				}
				
				cookie.set('dfy.dl', dealer.DealerID, Infinity);
				$(save_btn).addClass('saved');
				$('em', save_btn).html(self.config.translation.saved);
				view_all_btn.data('dealerEvent', self.showSavedDealer);
				$.publish('/analytics/link/', { 
        			title: omName,
        			link: this,
        			type: omType,
        			onclicks: omOnClick,
        			freq:freq
        		});		
				
			});


			$('.save-dealer .view-details').on('click', function(e) {
				e.preventDefault();
				$(this).parent().find('.popover').toggle();
			});

			// change hours for specified dept
			$('.select-dept', self.container).on('change', function(e) {
				var key = $(this).val(),
					schedList = $(this).closest(".dropdown").siblings(".hours-wrap").children(".sched");
				
				schedList.each(function(){
					if($(this).hasClass(key)){
						$(this).show();
					}else{
						$(this).hide();
					}
				});
			});
			$('.result-list.selected', self.container).show().siblings('.result-list').hide();
			$('.dealer-result-container', self.container).addClass('detailed');
			$(".filter-toggler", self.container).removeClass('trackable');

		},

		scrollToDealer: function(i, marker, isIcon, isPin) {

			var self = this,
				index = i-1,
				container = $('.result-list').not('.selected'),
				dealer = $('li', container).eq(index),
				map = self.mapController.map,
				pos = {};

			// pan to
			if (guxApp.tools.isAutoNaviMap()) {
				map.panTo(marker.marker.getPosition());
			}
			else {
				map.panTo(marker.getPosition());
			}
			if (dealer.is('.active')) return;

			if(self.is_mobile){
				if(isIcon){
					$("html,body").animate({
						scrollTop: $('.dealer-locator .dealer-unaware').offset().top
					});
				}
				if(isPin&&!$('.dealer-result-container .result-list:visible').hasClass('selected')){
					$("html,body").animate({
						scrollTop: dealer.offset().top - parseInt(dealer.css("margin-top"))
					});
				}
			} else {
				$('.result-list').not('.selected').animate({
					scrollTop: dealer.position().top
				});
			}
			if (map.markers.length) {
				map.deselectMarkers();
			}

			if(!guxApp.tools.isAutoNaviMap()) marker.select(3000);
			if (!self.is_mobile) marker.showInfoWindow();
			
			if(!guxApp.tools.isAutoNaviMap()) dealer.addClass('active').siblings().removeClass('active');

			window.setTimeout(function () {
			    $('.alt-theme .info-window .dealer-name').off('click').on('click', function (e) {
			        e.preventDefault();
			        self.showDealerCard(dealer);
			    });
			}, 500);
			

		},
		addDealerToList: function(dealer, container, index, self, map, mapController, is_preferred) {
			
			//this code is easy for tester to use mocked api data to test
			/*if($("#mocked-api").length == 1){
				var mockedData = $("#mocked-api").embeddedData();
				for(var i in mockedData){
					if(dealer.hasOwnProperty(i)){
						dealer[i] = mockedData[i]
					}
				}
			}*/
			
			dealer['hours'] = mapController.getDeptSchedule(dealer);
			
			$.extend(dealer, {
				address: mapController.makeDealerAddress(dealer, self.config.addressFormat),
				dealershipURL: mapController.makeDealerURL(dealer),
				index: index,
				is_preferred: self.is_savedDealer(dealer),
				is_mobile: self.is_mobile,
				is_open: mapController.is_dealerOpen(dealer, self.day),//false
				closeTime: mapController.getCloseTime(dealer, self.day),//undefinded
				govtTaxIDName: self.config.govtTaxIdName,
				mapURL: mapController.makeMapURL(dealer.location, mapController.currentLocationCoords)
			});
			
			dealer['day_str'] = [];
			dealer['day_str_translated'] = [];
			for (var i in self.config.translation.day_str) {
				dealer['day_str'].push(i);
				dealer['day_str_translated'].push(self.config.translation.day_str[i])
			}
			
			dealer['nextOpenTime'] = mapController.getNextOpenTime(dealer);//""
			var schedule = mapController.scheduleString(dealer, dealer.hours, self.day);//"Closed"
			dealer['schedule'] = schedule.description;
			dealer['scheduleType'] = schedule.type;
			dealer['vehicleOffer'] = self.getVehiOffer(dealer);
			dealer['phoneNumbers'] = (dealer['PrimaryPhone'] && dealer['PrimaryPhone'].length) ? dealer['PrimaryPhone'].split(/[;,]/g) : [];
			dealer['DealerAffiliation'] = dealer['DealerAffiliation'] || '';
			dealer['entityText'] = getDealerEntityTextByCategory(dealer['DealerAffiliation']);
			dealer['dealerNewVehicle'] = (dealer['DealerNewVehicle'] && dealer['DealerNewVehicle'].length) ? dealer['DealerNewVehicle'].replace(/\s/g, '').split(/[;,]/g) : [];

			function getDealerEntityTextByCategory(category) {
			    var text = '';
			    if (category) {
			        if ($('.color-lengend .' + category).length) {
			            text = $('.color-lengend .' + category).parent().text();
			        }
			    }
			    return text;
			}

			// checking if url is properly formatted
			if (guxApp.tools.isAutoNaviMap()) {
				if ((dealer.dealershipURL != "") && (dealer.dealershipURL.indexOf("http://") != 0)) {
					dealer.dealershipURL = "http://" + dealer.dealershipURL;
				}
			}
			else {
				if ((dealer.PrimaryURL != "") && (dealer.PrimaryURL.indexOf("http://") != 0)) {
					dealer.PrimaryURL = "http://" + dealer.PrimaryURL;
				}
			}
			

			var dealerElem = $(_.template($('#dealer-results').html(), dealer)),
				markerImages = {};
			if(self.config.markerImages && self.config.markerImagesAttribute){
				markerImages = self.config.markerImages[dealer[self.config.markerImagesAttribute]];
			}
			// add marker to map
			var marker = map.addGuxMarker(dealer.location, dealer.index, _.template($('#infobox-template').html(), dealer).toString(), function(dealer) {
				return function() {	
				    self.scrollToDealer(index, marker, false, true);
				}
			}(dealer),markerImages);

			$(container).append(dealerElem);
			if (self.is_selectLocation && self.hideDistanceByLocation) {
			    $('.distance', dealerElem).hide();
			}

			// embed data to element
			dealerElem.data(dealer);

			// scroll to dealer
			$('.dealer-icon .dealer-num', dealerElem).on('click', function() {
				if ($(dealerElem).is('.active')) return;
				self.scrollToDealer(index, marker,$(this).hasClass('dealer-num')?true:false);
			});
			
			// show detailed
			$('.details, .dealer-heading a', dealerElem).on('click', function(e) {
				e.preventDefault();
				self.scrollToDealer(index, marker);
				self.showDealerCard(dealerElem);
			});

			//init select 1st dealer by default
			if (is_preferred) {
				var _event = 'idle';
				/* if(guxApp.tools.isBingMap()){
					_event = 'viewchangeend';
				} */
				if(guxApp.tools.isAutoNaviMap()){
					_event = 'moveend';
				} 
				var handler = map.addListener(map.map, _event, function() {
					// geolocation.getCurrentPosition();
					// geolocation.watchPosition();
					self.scrollToDealer(index, marker);
					map.removeListener(handler);
				});

				$('.save-dealer-btn.saved em', dealerElem).text(self.config.translation.saved);
			}			

		},
		loadDealers: function(dealers) {

			var self = this,
				map = self.mapController.map,
				dealer_list = $('.result-list').find("> ul"),
				loadedDealers = self.loadedDealers || [],
				loadedDealersCount = loadedDealers.length,
				cached_dealers = dealers.slice(loadedDealersCount,loadedDealersCount+5),
				origin = {
					lat: self.mapController.currentLat,
					lng: self.mapController.currentLong
				};

			loadedDealers = _.union(loadedDealers, cached_dealers);
			self.loadedDealers = loadedDealers;

			// map.displayDealers(dealers);
			$.each(cached_dealers, function(i, dealer) {
				
				var index = i+loadedDealersCount+1;
				self.addDealerToList(dealer, dealer_list, index, self, map, self.mapController, index==1);

			});

			// add to view
			$('.dealer-result-container').show();
			if (guxApp.tools.isAutoNaviMap()) {
				var dealerBonds = [];
				$.each(loadedDealers,function(i,value){dealerBonds[i]=value._location});
				map.setBounds(dealerBonds,1);
			}
			else {
				map.setBounds(loadedDealers, 1);
			}
			if(_.size(dealers) < 5){
				map.setZoom(10);
			}

			if (dealers.length > loadedDealers.length) {
				$('.result-list').not('.selected').find('.dealer-view-more').show();
			} else {
				$('.result-list').not('.selected').find('.dealer-view-more').hide();
			}
		},

		autoCompleteTrigger: function(e) {

			var self = guxApp.dealerLocator,
				map = self.mapController.map,
				searchKey = $(this).val(),
				strlen = searchKey.length,
				search_panel = $('.search-panel'),
				location_limit = self.config.auto_suggest_limit,
				user_intent_delay = null,
				key = !e.charCode ? e.which : e.charCode;

			var keys_regex = new RegExp("^[a-zA-Z0-9]+$");
		    var str = String.fromCharCode(key).valueOf();

		    // prevent trigger if ctrl/alt key is pressed
		    if (e.altKey || e.ctrlKey || key == 17 || key == 18) return false;


		    if (user_intent_delay) {
		    	clearTimeout(user_intent_delay);
		    	user_intent_delay = null;
		    }


		    // arrow keys
		    if (key == 38 || key == 40) {

		    	switch(key) {
		    		case 38:
		    			var direction = true;
		    			break;
		    		case 40:
		    			var direction = false;
		    			break;
		    	}

		    	if ($('.dealer-disambiguation', self.container).is(':visible')) self.selectSuggestion(this, direction);

		    	return;
		    } 

			// enable predictive search
			if (!!searchKey && (/[A-Z]{2,}/.test(searchKey) || strlen >= self.config.autocomplete_char_count)) {
				// keys_regex.test(str) &&	

				user_intent_delay = setTimeout(function() {

		    		if ($('.input-panel', self.container).is('.active')) return false;

					guxApp.googleMapController.map.autocomplete(searchKey, location_limit, function(results) {//issue

						var locations = results.locations,
							dealers = _.pluck(results.dealers, "DealerName");

						if (locations.length || dealers.length) {
							guxApp.dealerLocator.showSuggestions(_.union(dealers, locations), search_panel);
						}

					});

				}, 300);

			}
		},

		selectSuggestion: function(field, up) {

			var suggestion_holder = $('.search-panel .dealer-disambiguation'),
				current_selected = $('li.active', suggestion_holder),
				next = (current_selected.next().length)?current_selected.next():$('li', suggestion_holder).eq(0),
				prev = (current_selected.prev().length)?current_selected.prev():$('li', suggestion_holder).eq($('li', suggestion_holder).length-1);

			current_selected = next;

			if (up) {
				current_selected = prev
			}
			
			current_selected.addClass('active').siblings().removeClass('active');
			$(field).val($('a', current_selected).text());

		},

		showSuggestions: function(suggestions, container) {

			$('.search-panel .error').hide();
			$('.dealer-result-container').hide();

			if (suggestions.length) {

				$('.dealer-disambiguation', container).show();
				$(".dealer-disambiguation ul", container).html(_.template($("#dealer-disambiguation").html(), {suggestions:suggestions}));
				$('.dealer-disambiguation a', $(container)).on("click", function(e) {
					
					e.preventDefault();

					$(".input-panel input[type=text]", container).val($(this).text());
					$('.dealer-disambiguation', container).hide();
					$(container).trigger('submit');

				});
			} else {
				$('.dealer-disambiguation', container).hide();
			}
		},

		getDealersByKeyword: function(keyword, matchParams) {

			var self = this,
				map = self.mapController.map,
				errmessage = self.config.error_message.dealer_not_found,
				matchParams = matchParams || {},
				containsParams = {},
				origin = {
					lat: self.mapController.currentLat,
					lng: self.mapController.currentLong
				};


			self.is_autoDetection = false;
			self.filters = [];

			$('.error', self.container).hide();

			if (keyword == "" || !keyword) {
				self.showError(self.config.error_message.blank_field);
				return;
			}

			if ($('.input-panel', self.container).is('.active')) return false;
			$('.input-panel', self.container).addClass('active');

			clearTimeout(map.autocompleteTimeout);
			map.autocompleteTimeout = null;
			
			self.mapController.searchDealersByKeyword(keyword, $('.input-panel input[type=text]', self.container), self.processResults, errmessage)

			self.loadedDealers = [];

			$('.input-panel input[type=text]', self.container).blur();
			
			self.closeTabs();

		},

		showError: function(errorText) {
			this.closeTabs();
			$('.dealer-result-container').hide();
			this.errorContainer.addClass("active").show().find('.text').text(errorText);//issue
		},

		getDealersFromCurrentLocation: function() {
			var self = this,
				map = self.mapController.map || null,
				searchField = $('.input-panel input[type=text]', self.container),
				errmessage = self.config.error_message.nearest_dealer_not_found,
				geoLocationTimeout = null;

			self.is_autoDetection = false;
			self.filters = [];
			self.closeTabs();
			self.mapController.cleanMap();

			$('.error', self.container).hide();

			if ($('.input-panel', self.container).is('.active')) return false;
			$('.input-panel', self.container).addClass('active');

			geoLocationTimeout = setTimeout(function() {
				self.showError(self.config.error_message.geolocation_error_timeout);
				$('.input-panel', self.container).removeClass('active');	
			}, 10000);

			if (!!navigator.geolocation) {
				
				navigator.geolocation.getCurrentPosition(function(position) {
					
					var lat = position.coords.latitude,
						lng = position.coords.longitude;

					self.loadedDealers = [];

					clearTimeout(geoLocationTimeout);
					geoLocationTimeout = null;

					self.mapController.getAddressStringFromCoord({ "lat":lat, "lng":lng}, function(result, status) {
							searchField.val(result);
							self.mapController.searchDealersByLocation(result, searchField, {},{},self.processResults, self.config.error_message.location_not_found);					

					});
												
				}, function(err) {
					
					clearTimeout(geoLocationTimeout);
					geoLocationTimeout = null;

					switch (err.code) {
						case err.PERMISSION_DENIED:
							self.showError(self.config.error_message.geolocation_error_denied);
							break;
						case err.POSITION_UNAVAILABLE:
							self.showError(self.config.error_message.geolocation_error);
							break;
						case err.TIMEOUT:
							self.showError(self.config.error_message.geolocation_error_timeout);
							break;
					}

					$('.input-panel', self.container).removeClass('active');

				}, { timeout:7000 });

			} else {
				clearTimeout(geoLocationTimeout);
				geoLocationTimeout = null;
				
				self.showError(self.config.error_message.geolocation_error_denied);
				$('.input-panel', self.container).removeClass('active');
			}

		},
		// 23/11/2015 : added is_hideTrack, if save/remove prefer dealers, will not track
		processResults: function(dealers, errmessage, is_filtered_results, is_detailed,is_hideTrack) {
			var self = guxApp.dealerLocator,
				map = self.mapController.map,
				subOpts = $(".sub-options",self.searchContainer),
				filterBar = $(".dealer-result-container .filter-header"),
				origin = {
					lat: self.mapController.currentLat,
					lng: self.mapController.currentLong
				};
				
			//detect whether it is url opened dealer
			if(is_detailed){
				filterBar.hide();
			} else {
				filterBar.show();
			}

			$('.input-panel', self.container).removeClass('active');

			if (!dealers || !dealers.length) {
				self.hasResults = false;
				self.colorLengend.removeClass("active");
				//auto detection dont need error message
				if (!self.is_autoDetection) { self.showError(errmessage); }
				subOpts.show();
				return false;
			}
			if(subOpts.length > 0){
				self.hasResults = true;
				subOpts.hide();
				$(".wrap .title",self.container).removeClass("active");
				self.colorLengend.addClass("active");
				self.errorContainer.removeClass("active");
				self.resultsContainer.removeClass("detailed");
				self.selResContainer.hide();
			}
			$('.dealer-map-field').addClass("show");
			$('.dealer-map-landing').addClass("hide");
			self.mapController.displayMap();
			
			// map.setCenter({ lat: origin.lat, lng: origin.lng });
			_.each(dealers, function(dealer, i) {
				_.defaults(dealer, { "distance":"", "ABN":"" });
			});

			if ($('.result-list.selected', self.container).is(':hidden')) $('.result-list').not('.selected').show();
			$('.dealer-disambiguation').hide();
			$('.search-panel .error').hide();
			$('.result-list > ul').empty();

			// guxApp.dealerLocator.cachedDealers = _.sortBy(dealers, "distance"); /* refactor this part*/
			if(!is_filtered_results) self.dealers = _.sortBy(dealers, "distance");

			// make the fave dealer appear as the first item of the list
			var saved_dealer = _.find(dealers, function(dealer) { return self.is_savedDealer(dealer); });
			

			if (_.size(saved_dealer)) {
				new_dealers = _.reject(dealers, function(dealer) { return self.is_savedDealer(dealer); });
				dealers = _.union(saved_dealer, new_dealers);
			}
			
			var	dealer_count = "", 
				dealer_count_text = self.config.dealer_count_message.no_dealer;
			if(dealers.length == 1){
				dealer_count = dealers.length;
				dealer_count_text = " "+self.config.dealer_count_message.single_dealer;
			}else if (dealers.length > 1) {
				dealer_count = dealers.length;
				dealer_count_text = " "+self.config.dealer_count_message.multiple_dealer;
			}
			$('.dealer-result-container .count .num').text(dealer_count);
			$('.dealer-result-container .count .msg').text(dealer_count_text);
			
			self.loadDealers(dealers);
			//gux omniture
			is_hideTrack = is_hideTrack || false;
			if(!is_hideTrack){
				$.publish('dealers-done');
			}
			
			var services_config = $('#services-config').embeddedData(),
				filters = self.filters || [];

			if (!is_filtered_results) {
				self.services = {};
				$.each(dealers, function(i, dealer) {

					_.each(services_config, function(service, key) {

						if (!!parseInt(dealer[key]) || dealer[key] === "Y" || dealer[key] === true) {
							self.services[key] = service;
						}
					});
				});
			}
			
			//hide filter tab if no filter
			if(!guxApp.tools.isEmpty(self.services)){
				//convert to array
				var services = [];
				for (var i in self.services){
					services.push(self.services[i]);
					services[services.length-1].key = i;
				}
				//sort service list (service in filter tab) in order
				services.sort(function(a,b){
					return parseInt(a.order) - parseInt(b.order);
				});
	
				$('.filter-services .group-list').html(_.template($('#services-template').html(), {services:services, filters:filters}));
				if($('.filter-header .filter-toggler').is(':hidden')){
					$('.filter-header .filter-toggler').show();
				}
			}else{
				$('.filter-header .filter-toggler').hide();
			}
			
			$.publish('uniform', {
				el: $('.filter-services input:checkbox', self.container),
				el_type: "rounded-checkbox"
			});

			// load more dealers
			$('.dealer-view-more', $('.result-list', self.container).not('.selected')).unbind().on('click', '.button', function(e) {
				
				var existing_dealers = $('.dealer-result').length;

				e.preventDefault();
				self.loadDealers(dealers);

			});

			$('.input-panel', self.container).removeClass('active');

		},

		displayRouteToDealerTrigger: function(e) {
			// event handler

			e.preventDefault();

			var self = guxApp.dealerLocator,
				map = self.mapController.map,
				dealer = $(this).parents('.dealer-result').data();

			map.displayRouteToDealer({lat: self.mapController.currentLat, lng: self.mapController.currentLong}, dealer);

		},

		closeTabs: function() {
			var self = this;

			$('.view-all-dealers', self.container).trigger('click');
			if ($('.dealer-filter-bar').is('.active')) $('.filter-toggler', self.container).triggerHandler('click');
			$('.dealer-disambiguation', self.container).hide();
			$('.error', self.container).removeClass("active");

		}
	};

	$(function(){

		// check if component exists
		if (!$('.dealer-locator').length) return;
		
		guxApp.dealerLocator.loading = true;

		var date = new Date();
		guxApp.dealerLocator.date = date;
		guxApp.dealerLocator.day = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][date.getDay()];

		$.subscribe('api-done', function() {
			guxApp.dealerLocator.init();
		});

	});
	
	//jQuery mobile will add "ui-link" to "a" tag which cause style issue.
	$(document).on("pageinit", function() {
		if (!$('.dealer-locator').length) return;
		
		$('.dealer-locator .ui-link').removeClass('ui-link');
		
		var self = this;

		if (!guxApp.dealerLocator.loading) {
			
			if ($('.dealer-map-field').is(":hidden")) $('.dealer-map-field').show();
			$.subscribe('api-done', function() {
				guxApp.dealerLocator.init();
			});

			//self.mapController.map = null;
			//self.mapController.mapContainer = null;
			//self.mapController.currentLocationCoords = null;

		}
		
	});

	$(document).on('pageshow', function() {
		//if (!guxApp.dealerLocator.loading) guxApp.googleMapController.init();
		guxApp.dealerLocator.loading = false;
	});

}(jQuery));



/*
 * functionalities of dealerlocator Bing
 * author : Ray
 * dependencies: jquery, underscorejs, uniformjs, bingMapController, bingMaps
 */
(function($) {
	/**
	 * to filter dealers
	 * @param dealers, dealer object, contains all dealer information
	 */
	guxApp.dealerLocator.resultsFiltering = function(dealers,errorMsg){
		var self = this,
			errmessage = errorMsg||self.config.error_message.nearest_dealer_not_found,
			dealerName = $("input[type='text']",".name-search"),
			dealerNamePlaceholder = dealerName.attr("placeholder-value"),
			dealerNameVal = dealerName.val(),
			dealerNameplateVal = $("select",".vehicle-search").val(),
			filteredByName = [],
			filteredByNameplate = [];
		//reset placeholder value on IE
		if(dealerNamePlaceholder && dealerNamePlaceholder == dealerNameVal){
			dealerNameVal = "";
		}
		
		//filter by dealerName
		if(dealerNameVal && dealerNameVal.length > 0){
			$.each(dealers,function(){
				if (guxApp.tools.isAutoNaviMap()) {
					if(this._name.indexOf(dealerNameVal) != -1){
						filteredByName.push(this);
					}
				}
				else {
					if(this.DealerName.indexOf(dealerNameVal) != -1){
						filteredByName.push(this);
					}
				}
			});
			dealers = filteredByName;
		}
		//filter by dealerNameplate
		if(dealerNameplateVal && dealerNameplateVal.length > 0){
			$.each(dealers,function(){
				if (guxApp.tools.isAutoNaviMap()) {
					if (this.DealerNewVehicle.toString().indexOf(dealerNameplateVal) != -1) {    //this.DealerSpeciality
						filteredByNameplate.push(this);
					}
				}
				else {
					if (this.DealerRangeNew.indexOf(dealerNameplateVal) != -1) {    //this.DealerSpeciality
						filteredByNameplate.push(this);
					}
				}
			});
			dealers = filteredByNameplate;
		}
		self.processResults(dealers,errmessage);
	};
	/**
	 * to get Province and City from pre defined json on the page
	 */
	guxApp.dealerLocator.getOptData = function(){
		var self = this,
			dataConfig = $("#cityDropdownData"),
			dataArr = [],
			province = $("select[name='province']",self.searchContainer),
			city = $("select[name='city']",self.searchContainer);
		//initial disable city
		city.prop("disabled","disabled").closest(".dropdown").addClass("disabled");
		if (dataConfig.length > 0 && dataConfig.embeddedData().list && dataConfig.embeddedData().list.length) {
			dataArr = dataConfig.embeddedData().list[0].states;
		}
		//import Province data
		if (dataArr.length > 0){
			$.each(dataArr,function(key,val){
				$("<option value='"+val[1].name+"'>"+val[1].name+"</option>").appendTo(province); 
			});
		}
		//import City data
		province.on("change",function(){
			var provinceVal = $(this).val(),
				endLoop = false;
			city.val("");//select the default value
			city.uniform.update();//update select val in uniform
			$.each(dataArr,function(key,val){
				if(provinceVal==val[1].name){
					city.children("option:gt(0)").remove();
					$.each(val[1].cities,function(key,val){
						$("<option value='"+val[1].name+"'>"+val[1].name+"</option>").appendTo(city);
					});
					endLoop = true;
				}
				if(endLoop){return false;}
			});
			//enable city
			province.val() == ""?city.prop("disabled","disabled").closest(".dropdown").addClass("disabled"):city.prop("disabled",false).closest(".dropdown").removeClass("disabled");
		});
	};
	/**
	 * to get Country and State&City from pre defined json on the page
	 */
	guxApp.dealerLocator.getOptDataQL = function(){
		var self = this,
			dataConfig = $("#countryCityDropdownData"),
			dataArr = [],
			country = $("select[name='country']",self.searchContainer),
			statecity = $("select[name='statecity']",self.searchContainer);
		//initial disable statecity
		statecity.prop("disabled","disabled").closest(".dropdown").addClass("disabled");
		if (dataConfig.length > 0 && dataConfig.embeddedData().list && dataConfig.embeddedData().list.length) {
			dataArr = dataConfig.embeddedData().list[0].countries;
		}
		//import Country data
		if (dataArr.length > 0){
			$.each(dataArr,function(key,val){
				$("<option value='"+val[1].name+"'>"+val[1].name+"</option>").appendTo(country); 
			});
		}
		//import State&City data
		country.on("change",function(){
			var countryVal = $(this).val(),
				endLoop = false;
			statecity.val("");//select the default value
			statecity.uniform.update();//update select val in uniform
			$.each(dataArr,function(key,val){
				if(countryVal==val[1].name){
					statecity.children("option:gt(0)").remove();
					if(val[1].cities.length>0) {
						$.each(val[1].cities,function(key,val){
							$("<option value=city>"+val[1].name+"</option>").appendTo(statecity);
						});
					}
					else if(val[1].states.length>0){
						$.each(val[1].states,function(key,val){
							$("<option value=state>"+val[1].name+"</option>").appendTo(statecity);
						});
					
					}
					endLoop = true;
				}
				if(endLoop){return false;}
			});
			//enable statecity
			country.val() == ""?statecity.prop("disabled","disabled").closest(".dropdown").addClass("disabled"):statecity.prop("disabled",false).closest(".dropdown").removeClass("disabled");
		});
	};
	/**
	 * get vehicle offering from data returned
	 * @param dealer, dealer object contains all dealer infomation
	 */
	guxApp.dealerLocator.getVehiOffer = function(dealer){
		var self = this,
			vehicleOffer = {};
		dealer.PerOwnedVehicle = "type1,type2";// mocked data ,needs to be removed
		if (dealer.DealerRangeNew && dealer.DealerRangeNew.length > 0) {  //dealer.DealerRangeNew
			vehicleOffer.newCars = {
				"name" : self.config.newCars,
				"value": dealer.DealerRangeNew.split(',')
			}
		}
		if(dealer.PerOwnedVehicle && dealer.PerOwnedVehicle.length > 0){
			vehicleOffer.preOwnedCars = {
				"name" : self.config.preOwnedCars,
				"value" : dealer.PerOwnedVehicle.split(',')
			}
		}
		return vehicleOffer;
	};
	
	$(function(){
		var self = guxApp.dealerLocator;
		self.mapWrapper = $(".dealer-locator.alt-theme");
		if(self.mapWrapper.length == 0){return;}
		
		self = guxApp.dealerLocator;
		self.hasResults = false;
		self.mapController = guxApp.googleMapController;
		self.searchContainer = $(".dealer-unaware",self.mapWrapper);
		self.resultsContainer = $(".dealer-result-container",self.mapWrapper);
		self.errorContainer = $(".error",'.location-search',self.searchContainer);
		self.selResContainer = $(".selected",self.resultsContainer);
		self.colorLengend = $(".color-lengend",self.mapWrapper);
		if(!$('.store-locator-form').length || !$("#countryCityDropdownData").length) {
		self.getOptData();
		}
		else {
		self.getOptDataQL();
		//quicklane get country and city list
		}
		
		$(".title",self.searchContainer).on("click",function(){
			var title = $(this),
				subOpt = title.siblings(".sub-options");
			//before animation
			if(self.hasResults){
				if(subOpt.is(":visible")){
					self.resultsContainer.show();
				}else{					  
					self.resultsContainer.hide();
				}
			}
			subOpt.slideToggle(function(){
				//after animation
				if(subOpt.is(":visible")){//expand suboptions
					title.addClass("active");
				}else{					  //collapse suboptions
					title.removeClass("active");
				}
			});
		});
		//click event has been used by uniform.
		// $(".sub-options label",self.searchContainer).on("mouseup",function(e){
			// if(e.button!=2){//prevent from right click
		$(".sub-options label",self.searchContainer).on("click",function(e){
				if(e.target.tagName==="INPUT") {
				var label = $(this),
					nestedOpt = label.siblings(".nested-options");
				//before animation
				if(nestedOpt.is(":hidden")){
					label.addClass("active");
				}else{
					label.removeClass("active");
				}
				nestedOpt.slideToggle(function(){
					//after animation
					if(nestedOpt.length > 0 && nestedOpt.is(":hidden")){//collapsed
						nestedOpt.find("select,input[type='text']").val("").uniform.update();;//remove value
					}
				});
			 }
		});
		
		//submit
		$(".actions-bar .button",self.searchContainer).on("click",function(e){
			var formDataArr = $("select",".location-search").serializeArray(),
				province = $("select[name='province']",self.searchContainer),
				city = $("select[name='city']",self.searchContainer),
				keywordStr = "",
				country = $("select[name='country']",self.searchContainer),
				statecity = $("select[name='statecity']",self.searchContainer);

			self.filters = [];
			self.closeTabs();
				
			e.preventDefault();
			if(!$('.store-locator-form').length || !$("#countryCityDropdownData").length) {
				if(province.val()==""||city.val()==""){
					province.closest(".location-search").find(".error").addClass("active").find('.text').text(self.config.error_message.isMandatory);//temp move errormsg to config
				}else{
					$.each(formDataArr,function(key,val){
						if(val.value!=""){
							keywordStr = keywordStr + val.value;
						}
					});
					self.loadedDealers = [];
					if (guxApp.tools.isAutoNaviMap()) {
					// Search based on center point of province and city  (dealer properties) --Autonavi map
					self.mapController.searchDealersByLocation(keywordStr, false, {AdministrativeArea: province.val()||"", Locality: city.val()||""}, {}, function (dealers,errorMsg) {
						self.is_selectLocation = true;
						self.resultsFiltering(dealers,errorMsg);
					});
					}
					else {
					// Search based on province and city (dealer properties) --Thailand google map
					self.mapController.searchDealersByProperties({AdministrativeArea: province.val(), Locality: city.val()}, {}, function(dealers,errorMsg) {
						self.is_selectLocation = true;
						self.resultsFiltering(dealers,errorMsg);
					});
					}
				}
			}
			else {
			//quicklane get country and city
				if(country.val()==""||statecity.val()==""){
					province.closest(".location-search").find(".error").addClass("active").find('.text').text(self.config.error_message.isMandatory);//temp move errormsg to config
				}else{
					self.loadedDealers = [];
					if(statecity.val()=='city') {
						self.mapController.searchDealersByProperties({Country: country.val(), Locality: $("select[name='statecity'] option:selected").text()}, {}, function(dealers,errorMsg) {
							self.is_selectLocation = true;
							self.resultsFiltering(dealers,errorMsg);
						});
					}
					else if(statecity.val()=='state') {
						self.mapController.searchDealersByProperties({Country: country.val(), AdministrativeArea: $("select[name='statecity'] option:selected").text()}, {}, function(dealers,errorMsg) {
							self.is_selectLocation = true;
							self.resultsFiltering(dealers,errorMsg);
						});
					}
				}
			}
		});

		if (sessionStorage['search_province']) {
		    $('select[name=province]', self.searchContainer).val(sessionStorage['search_province']).blur();
		    $('select[name=province]', self.searchContainer).change();
		    $('select[name=province]', self.searchContainer).uniform.update();
		    sessionStorage.removeItem('search_province');
		}
		if (sessionStorage['search_city']) {
		    $('select[name=city]', self.searchContainer).val(sessionStorage['search_city']).blur();
		    $('select[name=city]', self.searchContainer).uniform.update();
		    sessionStorage.removeItem('search_city');
		}
		if (sessionStorage['search_vehicle']) {
		    $('select[name=vehicle]', self.searchContainer).val(sessionStorage['search_vehicle']).blur();
		    $('select[name=vehicle]', self.searchContainer).uniform.update();
		    sessionStorage.removeItem('search_vehicle');
		}
		if (sessionStorage['search_location']) {
		    $('input[name=location]', self.searchContainer).val(sessionStorage['search_location']).blur();
		    sessionStorage.removeItem('search_location');
		}
		$.urlParam = function(name){
			    var results = new RegExp('[\?&]' + name + '=([^&#]*)').exec(window.location.href);
			    if (results==null){
			       return null;
			    }
			    else{
			       return results[1] || 0;
			    }
			};
		var specialitiesID = !!$.urlParam('specialities')?decodeURI($.urlParam('specialities')):'';
		
		if(guxApp.tools.isAutoNaviMap()){
			$(".vehicle-search label",self.searchContainer).addClass("active").siblings(".nested-options").slideToggle();
			$("#vehicle-search").attr("checked","true");
			$("#uniform-vehicle-search").children("span").addClass("checked");
			$(".name-search label",self.searchContainer).addClass("active").siblings(".nested-options").slideToggle();
			$("#name-search").attr("checked","true");
			$("#uniform-name-search").children("span").addClass("checked");
				
			if(specialitiesID.length!=0){
				var label = $(".vehicle-search label",self.searchContainer),
				nestedOpt = label.siblings(".nested-options");
				// label.addClass("active");
				// $("#vehicle-search").attr("checked","true");
				// $("#uniform-vehicle-search").children("span").addClass("checked");
				// nestedOpt.slideToggle(function(){
					//after animation
					if(nestedOpt.length > 0){//collapsed
						$(".vehicle-search label").siblings(".nested-options").find("select").find("option[value='"+specialitiesID+"']").attr("selected","true").click();
					}
				// });
			}
		}	

	});
}(jQuery));		
		


/*
Source: 		http://stackoverflow.com/questions/5771742/underscore-js-templates-within-jsp
File name: 		underscoreInterpolate.js
Description: 	Change Underscore's template settings to use different symbols to set off interpolated code that doesn't conflict with jsp
Usage: 			Use <@ @> instead of Underscore's default <% %>
*/

var guxApp = guxApp || {};

(function($){
	guxApp.interpolate = {
		init: function(){
			_.templateSettings = {
				interpolate: /\<\@\=(.+?)\@\>/gim,
				evaluate: /\<\@([\s\S]+?)\@\>/gim,
				escape: /\<\@\-(.+?)\@\>/gim
			};
		}
	}

	$(function(){
		guxApp.interpolate.init();
	});

})(jQuery);


/*
Author: 		Brett Chaney
File name: 		scrollup.js
Description: 	Back to top button
Dependencies: 	jQuery
*/
var guxApp = guxApp || {};

(function($){
	guxApp.scrollup = {
		init: function(){
			$("#page-wrapper").append('<div class="back-top"><a><span></span></a></div>');
			$(".back-top").click(function(){
		        $("html, body").animate({ scrollTop: 0 }, 300);
			    return false;
			});

			var currentScroll = $(window).scrollTop();

			var scrolltime = false;

			$(window).scroll(function(e){
			    var newScroll = $(window).scrollTop();

			    if (newScroll > currentScroll) {
			    	guxApp.scrollup.scrolledUp = false;
			    } else if (newScroll < currentScroll) {
			    	guxApp.scrollup.scrolledUp = true;
			    } else if (newScroll === currentScroll) {
			    	guxApp.scrollup.scrolledUp = null;
			    }

			    guxApp.scrollup.userScrolled();
			    currentScroll = newScroll;

			    if (scrolltime) {
			      clearTimeout(scrolltime);
			   	}
   				scrolltime = setTimeout(guxApp.scrollup.afterScroll, 2500);

			});
		},
		afterScroll: function() {
			var scrollPos = $(window).scrollTop();

			if (scrollPos >= 480) {
				guxApp.scrollup.hideButton();
			}
		},
		userScrolled: function(){
			var scrollPos = $(window).scrollTop();
			
			if (scrollPos >= 480 && guxApp.scrollup.scrolledUp) {
				guxApp.scrollup.showButton();
			} else if (scrollPos <= 480 || guxApp.scrollup.scrolledUp === false) {
				guxApp.scrollup.hideButton();
			}
		},
		showButton: function(){
			if (Modernizr.csstransitions) {
				$(".back-top a").addClass("btn-visible");
			} else {
				$(".back-top a").clearQueue().animate({
					right: 0,
					opacity: 1
				},200);
			}
		},
		hideButton: function(){
			if (Modernizr.csstransitions) {
				$(".back-top a").removeClass("btn-visible");
			} else {
				$(".back-top a").clearQueue().animate({
					right: -60,
					opacity: 0
				},200);
			}
		}
	};

	$(function(){
		guxApp.scrollup.init();
	});

})(jQuery);


/*
 * functionalities of showroom
 * author : Ray
 * dependencies: jquery, underscorejs
 */
(function($) {

	var showroom = {
		
		init : function (){
			var self = this;
			self.container = $(".showroom-container");
			
			if(self.container.length === 0){return;}
			
			self.vehicleCard = $(".vehicle-list .vehicle-container",self.container);

			//hide price option in dropdown on page load for GUX Polk
			if ($('.body.derivative-price')[0]) {
				$(".sort-dropdown",self.container).find("[data-cat='price']").hide();

				$.subscribe('userchangesuccess.calculateprice.dfy', function(event, data) {
					$(".sort-dropdown",self.container).find("[data-cat='price']").show();
				});
			}

			$(".sort-dropdown",self.container).on("click",function(e){
				e.preventDefault();
				$(this).toggleClass("active");
			});
			//add foundation "end" to dom element as JSP is not easy to do
			$(".section-cars",self.container).children("div:last-child").addClass("end");
			
			self.floatHeader();

			//No enlarge vehicle card in mini showroom
			if(!(self.container.hasClass('mini-showroom'))){
				self.enlargeVehicleCard();
			}
			self.VehicleSorting();
		},
		/*
		 * change the position of header to float the header element
		 */
		floatHeader : function () {
			var self = this,
				header = $(".sort-area",self.container),
				sortField = header.children(".sort-dropdown");
			
			if(header.length === 0) {return;}
			
			//detect scroll position on page load
			var posDetection = function () {
				var scrollTop = $(window).scrollTop(),
					headerTop = header.offset().top;
				if(scrollTop > headerTop) {
					sortField.addClass("fixedPos");
				} else {
					sortField.removeClass("fixedPos");
				}
			};
			posDetection();
			
			//detect scroll position on user triggered scroll event
			$(window).scroll(function (){
				posDetection();
			});
		},
		/*
		 * on mobile view, enlarge "vehicle card" by click.
		 */
		enlargeVehicleCard : function () {
			var self = this,
				cloneAfter = self.container.children(".row");
			
			if(self.vehicleCard.length === 0) {return;}
			//enlarge vehicle card
			$(".vehicle > a", self.vehicleCard).on("click",function(e){
				var clonedVehicleCard = cloneAfter.siblings(".vehicle-container");
				//only if trigger on mobile view, 751 is more close to "@media #{$large-up}"
				if($(window).width() < 751 && clonedVehicleCard.length === 0){
					e.preventDefault();
					var curVehicleCard = $(this).closest(".vehicle-container");
					$("body").addClass("no-scroll has-scroll");
					curVehicleCard.clone().addClass("clone").insertAfter(cloneAfter).fadeIn(function(){
						//"hide-for-large-up" is a foundation visibility setting class, to hide the element above your query setting "@media #{$large-up}"
						$(this).addClass("hide-for-large-up");
					});
				}
			});
			//close vehicle card
			self.container.on("click",".close-vehicle",function(e){
				e.preventDefault();
				//"this" - close-vehicle button
				$(this).closest(".vehicle-container").fadeOut(function(){
					$("body").removeClass("no-scroll has-scroll");
					//"this" - vehicle-container
					$(this).remove();
				});
			});
		},
		/*
		 * sort the vehicle nameplate:
		 * by: 
		 * 1, data-bodytype : categorize vehicles , sort by price low-high within each category
		 * 2, data-price : join all vehicles , sort by price low-high
		 * 3, data-fuel : join all vehicles , sort by fuel low-high
		 */
		VehicleSorting : function() {
			var self = this;
			
			if(self.vehicleCard.length === 0) {return;}
			
			var vehicleData = self.vehicleCard.children(".vehicle-data"),
				vehicleTitle = $(".section-cars header", self.container),
				VehicleSection = $(".section-cars",self.container);
			
			//inital "data-index" for bodyType sorting use	
			vehicleData.each(function(idx){
				$(this).attr("data-index",idx);
				//"data-sort-index" use for ominture
				$(this).attr("data-sort-index",idx+1);
			});
			//"data-sort-total" use for ominture
			VehicleSection.attr("data-sort-total",VehicleSection.children(".vehicle-container:visible").length);
			
			var sorting = function (compareVal){
				//initialize all vehicles , all of them should be displayed
				VehicleSection.children(".vehicle-container").removeClass("inactive");
				//for "bodytype" sorting
				if(compareVal == "data-bodytype"){
					vehicleTitle.each(function(){
						var header = $(this),
							groupData = [];
						vehicleData.each(function(){
							var vehicle = $(this);
							if(vehicle.attr(compareVal) == header.attr(compareVal)){
								groupData.push(this);
							}
						});
						//sorting
						groupData.sort(function(a,b){
							return parseInt($(b).attr("data-index")) - parseInt($(a).attr("data-index"));
						});
						//dom manipulate
						$(groupData).each(function(){
							$(this).closest(".vehicle-container").insertAfter(header);
						});
					});
				//for all other sorting
				} else {
					var filteredVehicleData = [];
					//filter none "data-price" or "data-fuel" vehicles before sorting
					vehicleData.each(function(){
						if($(this).attr(compareVal)){
							filteredVehicleData.push(this);
						} else {//hide those none "data-price" "data-fuel" vehicle as it should not be displayed when sorting
							$(this).closest(".vehicle-container").addClass("inactive");
						}
					});
					//sorting
					filteredVehicleData.sort(function(a,b){
						return parseFloat($(a).attr(compareVal)) - parseFloat($(b).attr(compareVal));
					});
					//dom manipulate
					$(filteredVehicleData).each(function(){
						$(this).closest(".vehicle-container").appendTo($(this).closest(".section-cars"));
					});
				}
			};
			$(".sort-dropdown li",self.container).on("click",function(){
				var sortType = $(this).attr("data-cat"),
					compareVal = "data-bodytype";
				//active current option
				$(".sort-dropdown li",self.container).removeClass("active");
				$(this).addClass("active");
				
				switch (sortType)
				{
					case "body" :
						vehicleTitle.removeClass("inactive");
						break;
					case "price" :
						compareVal = "data-price";
						vehicleTitle.addClass("inactive");
						break;
					case "fuel" :
						compareVal = "data-fuel";
						vehicleTitle.addClass("inactive");
						break;
				}
				sorting(compareVal);
				self.vehicleCard.removeClass("end");
				VehicleSection.children("div:last-child").addClass("end");
				
				//ominture, reset "data-sort-index"
				var sortedVehicles = VehicleSection.children(".vehicle-container:visible");
				sortedVehicles.each(function(idx){
					$(this).children(".vehicle-data").attr("data-sort-index",idx+1);
				});
				//ominture, add total number of sorted vehicle to container for tracking
				sortedVehicles.parent(".section-cars").attr("data-sort-total",sortedVehicles.length);
			});
		}
	};

	$(function(){
		showroom.init();
	});
	
	//jQuery mobile will add "ui-link" to "a" tag which cause style issue.
	$(document).on("pageinit", function(){
		$(".showroom-container .ui-link").removeClass('ui-link');
	});

}(jQuery));


/*
Author: 		Brett Chaney
File name: 		imageRevealInit.js
Description: 	Initiates the imageReveal.js plugin and adds responsiveness
Dependencies: 	jQuery and jquery.imageReveal.js
*/

var guxApp = guxApp || {};

(function($){
	guxApp.imageReveal = {

		init: function(){
			if (!$(".imageReveal").length) {return;}

			var windowWidth = $(window).width();


            var imgLoader = imagesLoaded(".imageReveal");
            
            imgLoader.on("done", function() {

                var sliderWidth = $("#page-wrapper").width(),
                    sliderHeight = $(".imageReveal img").height();

                $(".imageReveal img").hide();
                
                $(".imageReveal").each(function () {
                    var $this = $(this);
                    $this.imageReveal({
                        width: sliderWidth,
                        height: $('img', $this).height()
                    });
                })

            });

            $(window).on("resize", function() {

                var newWindowWidth = $(window).width();

                if (newWindowWidth !== windowWidth) {

                    // destroy reveal slider
                    $.removeData($('.imageReveal'));
                    $(".imageReveal").off('mousemove click touchmove mouseout');
                    $(".imageReveal-overlay, .imageReveal-background, .imageReveal-drag-bar, .imageReveal-drag").remove();
                    $(".imageReveal, .imageReveal img").css({
                        "width" : "",
                        "height" : ""
                    });
                    
                    // get new height/width values for images
                    sliderWidth = $("#page-wrapper").width();
                    sliderHeight = $(".imageReveal img").height();

                    // re-run imageReveal plugin after window resize
                    $(".imageReveal").each(function () {
                        var $this = $(this);
                        $this.imageReveal({
                            width: sliderWidth,
                            height: $('img', $this).height()
                        });
                    })
                    
                }

                windowWidth = $(window).width();
                              
            });		
		}
	};

	$(function() {
		// initiate image reveal slider module
		guxApp.imageReveal.init();
	});

})(jQuery);


/*
Author: Ruiwen Qin
File name: textExpand.js
Description: 1. add more and less controls onto articles
             2. expand and collapse text (hide and show)

             Publish JSON data on the page such as (common\json\textexpand-config.html)

             <script id="textexpand-config" type="text/x-json">
                {
                    "more":" ...more", 
                    "less":"Less&#9652;",
                    "auto":true, //add read more button automatically by counting the textLength
                    "textLength":120
                }
            </script>

            If manually publish the read more button, wrap the hidden text inside <span class='hiddenContent'></span>

Dependencies: jQuery, underscore
*/

var guxApp = guxApp || {};

(function($){
    guxApp.textExpand = {
        init: function(){
            var controlTexts = guxApp.tools.getEmbeddedData("#textexpand-config");

            if (controlTexts == null || $('.model-walk').length) {return;}

          
            //Will automatically wrap paragraphs if the text expand class is set to auto.
            this.wrapText(controlTexts);
            
         

            guxApp.textExpand.resizeToggle();
        },
        wrapText:function(controlTexts){
            if(controlTexts.auto){
                //Select paragraphs without the read more to avoid redundancy.
                var article = $('p').filter(':not(:has(".hiddenContent"))').not('.noReadMore'),
                    textLength = parseInt(controlTexts.textLength);

                // to find out the position of all the children elements
                var locations = function (substring,string){
                    var i=-1;
                    i = string.indexOf(substring,i+1);
                    return i;
                }

 
                
              

                //Loop in the paragraph in the page and wrap it with the 'Read More' feature
                article.each(function(i,e){
                    var elem = $(e),
                        positions = [],
                        locationIndex = -1,
                        childrenElems = {},
                        startPoint = 0,
                        newElem = '';
                    
                    
                // to prevent (GUX-1303) bug
                // if the location of citation element is equals to textLength then textLength - 1
                    var arThis = $(this);
                    $(this).children('.citation').each(function() { 
                        if (arThis.text().indexOf($(this).text()) == textLength){ 
                            textLength = parseInt(textLength - 1); 
                        } 
                    });
                    if(elem.text().length > controlTexts.textLength){
                        if (elem.children().length > 0){

                            elem.children().each(function(i,e){ 
                                locationIndex = locations(String($(this).prop('outerHTML')), String(elem.html()));
                                childrenElems[locationIndex] = $(this).prop('outerHTML'); //save the children elements for restoring later
                                $(this).remove();//remove the current children elements for calculating the break point
                                positions.push(locationIndex);
                                startPoint = locationIndex; 
                            });

                            positions.push(textLength);
                            
                            positions.sort(function(a,b){return a-b});

                            startPoint = 0;

                            for (var i=0; i < positions.length; i++){

                                var position = positions[i];
                                if (position == textLength){
                                    newElem += elem.html().substring(startPoint,position);
                                    newElem += "<span class='hiddenContent'>";
                                }
                                else {
                                    newElem += elem.html().substring(startPoint,position);
                                    newElem += childrenElems[position] + ' ';
                                   
                                }
                                startPoint = position;
                            }

                            newElem += elem.html().substring(startPoint);

                            newElem += "</span>";

                            elem.html(newElem);

                            
                        }
                        else {

                            elem.html(function(){
                                return $(this).text().substring(0,textLength)+"<span class='hiddenContent'>"+ $(this).text().substring(textLength) +"</span>"
                            });
                        }

               
                    }

                });

            }

            var hidden = $(".hiddenContent");
            hidden.each(function() {
                var controlTemplate = $("<a href='#' class='control'></a>"),
                self = $(this);

                if (window.innerWidth < 780){
                    guxApp.textExpand.contentToggle($(this),controlTexts,controlTemplate);
                }
            });
        },
        resizeToggle: function(){
            if(!guxApp.tools.isIE(8)) {
                var debounceResize = _.debounce(function(){
                     if (window.innerWidth < 780){
                         guxApp.textExpand.init();
                      } else{
                        $('.control').remove();
                        $(".hiddenContent").show();
                      }
                },200);

                $(window).on('resize', debounceResize);
            }
        },

        contentToggle: function(hidden,controlTexts,controlTemplate){
            
            guxApp.textExpand.controlsInit(hidden,controlTexts,controlTemplate);

            hidden.parent().unbind('click').on('click', 'a.control', function(){
                var self = $(this),
                parentContainer = self.parent();
                if (hidden.is(':visible')) {
                    self.html(controlTexts.more);
                } else {
                    self.html(controlTexts.less);
                }
                hidden.toggle();
                return false;
            });
        },

        controlsInit: function(hidden,controlTexts,controlTemplate){
            if (hidden.next('.control').length == 0){
                hidden.hide();
                controlTemplate.html(controlTexts.more);
                hidden.parent().append(controlTemplate);
            }
        }
    }

    $(function(){
        guxApp.textExpand.init();        
    });



})(jQuery);



/*
Author: 		Randell Quitain
File name: 		secondarynav.js
Description: 	Secondary Navigation fixed width issue fix
Dependencies: 	jQuery 
*/

(function($){

	secondaryNav = {
		init: function(){

			if (!$(".secondarynav").length) {return;}

			var sNav = $('.secondarynav');
			var selected = $('.selected-sticky');
			// initialize Secondary Navigation width
			sNav.css({
				'width': sNav.closest('.component-container').width()
			});

			// add active class to current and parent page
			this.currentAndParent(sNav);

			// enable click for has-dropdown items
			this.hasDropdown(sNav);

			// properly align secondary nav on ie8 on position fixed
			this.ieAlign(sNav);

			// fixed secondary nav
			$(window).on('scroll', function() {
				var scroll = $(window).scrollTop();
					if (scroll >= 70) {
						sNav.addClass('fixed');
					} else {
						sNav.removeClass('fixed');
						selected.removeClass('fixed');
				 	}
			});

			$(window).on('resize', function(){
				secondaryNav.currentAndParent(sNav);
				secondaryNav.hasDropdown(sNav);
				if(guxApp.tools.isIE(8)) {
					secondaryNav.ieAlign(sNav);
				}
				sNav.css({
					'width': sNav.closest('.component-container').width()
				});
			});
			
		},
		currentAndParent: function(container) {
			var currentParent = $("#current-and-parent").embeddedData();
			for (var active in currentParent) {
				$('li[title="' + currentParent[active] + '"]', container).addClass('active');
			}
		},
		ieAlign: function(container) {
			if(guxApp.tools.isIE(8)) {
				if ($(window).width() < 1342){
					container.addClass('aligned');
				} else {
					container.removeClass('aligned');
				}
			}
		},
		hasDropdown: function(container) {

			var touchOrClick = Modernizr.touch ? 'touchstart' : 'click',
				wWidth = $(window).width();

			if (wWidth < 768){
				$('.has-dropdown > a', container).unbind(touchOrClick).on(touchOrClick, function() {
					$(this).toggleClass('open');
					return false;
				});
			} else {
				$('.has-dropdown > a', container).removeClass('open').unbind(touchOrClick);
			}

		}
	};

	$(function(){
		secondaryNav.init();
	});

})(jQuery);


/*
Author: 		Brett Chaney
File name: 		thumbnailGallery.js
Description: 	Toggle thumbnail category images on mobile view
Dependencies: 	jQuery 	
*/


(function($){
	var thumbGallery = {

		init: function(){

			thumbGallery.thumbnailsTotal();
			thumbGallery.toggleGallery();

			var windowWidth = $(window).width();

			$(window).on("resize", function() {

				var newWindowWidth = $(window).width();

				if (newWindowWidth !== windowWidth) {
					if ($(window).width() > 767){
						// reset content DIV height
						$("#content").css("height","");

						$(".gallery-category .thumbnails").css({"width": "100%", "max-width": "100%"});
						$('body').css('overflow','visible');
					} else {
						var thumbnailsW 	= $(".gallery-category.open").width();
						$(".gallery-category.open .thumbnails").css({"width": thumbnailsW, "max-width": "none"});
					}
				}

                windowWidth = $(window).width();
				
			});

			if (guxApp.viewport.view === "mobile") {
				thumbGallery.expandBar(9);
			} else {
				thumbGallery.expandBar(6);
			}

		},
		thumbnailsTotal: function(){

			$(".gallery-category").each(function() {

				var imagesTotal = $(this).find(".thumbnails img").length;
				$(this).find(".overlay-text span.num").html(imagesTotal).fadeIn(800).parent().fadeIn(800);

				var thumbnailsHeight = $(this).find(".thumbnails").height();
				$(this).data("thumbsheight", thumbnailsHeight);

			});

		},
		toggleGallery: function(){
			
			$(".category-title").on("click", function(e) {
				e.preventDefault();

				if (guxApp.viewport.view === "tablet") {return;}

				var galleryEl 		= $(this).parents(".gallery-category"),
					thumbnailsEl 	= $(this).parents(".gallery-category").children(".thumbnails"),
					thumbnailsW 	= galleryEl.width();
	
					thumbnailsEl.css({"width":thumbnailsW, "max-width": "none"});
					$('body').css('overflow','hidden');
					galleryEl.addClass("open").siblings().children(".thumbnails").animate({ left: "100%" }, 300, function() {
			            galleryEl.siblings().removeClass("open");
			        });

					thumbnailsEl.animate({ left: -3 }, 400, function() {
						var contentH 	= $("#content").height(),
							leftOverH 	= (galleryEl.data("thumbsheight") + 60) - contentH;

						if (leftOverH > 0) {
							//$("#content").css("height", contentH + leftOverH);
						}
					});
					$(window).trigger('resize');
			});

			$(".mobile-title").on("click", function(e) {
				e.preventDefault();
				
				// reset content DIV height
				$("#content").css("height","");

				var galleryEl 		= $(this).parents(".gallery-category"),
					thumbnailsEl 	= $(this).parents(".gallery-category").children(".thumbnails");
				$('body').css('overflow','visible');
				thumbnailsEl.animate({ left: "100%" }, 300, function() {
		            galleryEl.removeClass("open");
		        });
		        $(window).trigger('resize');
			});

		},
		expandBar: function(numItems){

			$(".gallery-category").each(function() {

				var imagesTotal = $(this).find(".thumbnails img").length;

				$(this).find(".thumbnails .item:gt(" + numItems + ")").hide();
				
				if (imagesTotal > (numItems + 1)) {
					$(this).find(".expandbar").show();
				}

			});


			$(".gallery-category").on("click", ".expandbar", function(){

				var thumbnailsEl = $(this).parent();
				
				thumbnailsEl.find(".item:hidden").slice(0, numItems + 1).fadeIn(350);

				if (thumbnailsEl.find(".item:hidden").length === 0) {
					thumbnailsEl.find(".expandbar").hide();
				}

			});

		}
	
	};

	$(function(){
		if (!$(".gallery-category").length) {return;}
		thumbGallery.init();
	});

})(jQuery);


/**
 * Created by bjie on 1/31/2015.
 */
var guxApp = guxApp || {};

/*
 Author: 		Jie Bao
 File name:     shareWidget.js
 Description: 	Add ahare button widget according to addthis library.
                Use addthis api to send shared url from input box and title from data-title attribute.
 Usage:         pass in the css class for the share bar
                eg.
                 <div class="share-panel cloned">
                    <ul>
                        <li><a href="#" data-share="" data-title="" data-country="en|cn"></a></li>
                        <li><a href="#"></a></li>
                        <li><a href="#"></a></li>
                        <li><a href="#"></a></li>
                    </ul>
                    <label>URL</label>
                    <input value="11111">
                    <a class="close">Close</a>
                 </div>
                 guxApp.shareWidget.init('.share-panel.cloned')
 Dependencies: 	jQuery and addthis(http://www.addthis.com/)
 */

(function($) {
    guxApp.shareWidget = {
        init: function(parentClass){
            var parentClass = parentClass || '.media-overlay .share-panel.cloned';
            this._shareBtnContainer = $(parentClass);
            this._shareBtns = this._shareBtnContainer.find('li');
            this._setDefaultUrl();
            this._addEventListener();
        },
        _setDefaultUrl: function(){
            var urlInput = this._shareBtnContainer.find('input');
            urlInput.val(location.href);
        },
        _addEventListener: function(){
            var self = this;
            this._shareBtns.off('click').on('click',function(e){
                e.preventDefault();
                var sharedUrl = (self._shareBtnContainer.find('input').val()) ? self._shareBtnContainer.find('input').val() : location.href;
                var sharedTitle = $(this).find('a').data('title');
                var sharedSite = $(this).find('a').data('share');
                var shareCountry = $(this).find('a').data('country');

                if((shareCountry === 'en') && (typeof addthis_sendto === 'function')){
                    addthis.update('share','url', sharedUrl);
                    addthis.update('share','title', sharedTitle);
                    addthis_sendto(sharedSite);
                }else if((shareCountry === 'cn') && (typeof jiathis_sendto === 'function')){
                    jiathis_config.url = sharedUrl;
                    jiathis_config.title = sharedTitle;
                    jiathis_sendto(sharedSite);
                }
            });
        }
    }
})(jQuery);


/*
Author: Brett Chaney
File name: hotspots.js
Description: activates the hotspot associated with each slide
Dependencies: jQuery, lib/jquery.flexslider.js
*/
var guxApp = guxApp || {};

(function($){
	guxApp.hotspots = {
		init: function(){
			if (!$(".hotspots .flexslider").length) {return;}

			var slider = $(".hotspots .flexslider"),
				currSlide;

			this.activateTrigger(slider);

			slider.on("click", ".flex-active", function() {
				guxApp.hotspots.activateTrigger(slider);
			});

			$(document).on("keyup", function() {
				guxApp.hotspots.activateTrigger(slider);
			});

			slider.touchwipe({
			  	wipeLeft: function() {
			    	setTimeout(function() {
			    		guxApp.hotspots.activateTrigger(slider);
			    	},500);
			  	}, 
			  	wipeRight: function() {
			  		setTimeout(function() {
			     		guxApp.hotspots.activateTrigger(slider);
			     	},500);
			  	}
			});

		},
		getCurrentSlide: function(slider) {
			return $(".flex-control-nav li a", slider).index($(".flex-active"));
		},
		activateTrigger: function(slider) {
			currSlide = guxApp.hotspots.getCurrentSlide(slider);
			slider.parents(".hotspots").find(".hs-triggers .trigger").removeClass("active").eq(currSlide).addClass("active");
		}
	};

	$(function(){
		guxApp.hotspots.init();
	});

})(jQuery);


/*
Author: Ruiwen Qin | Gianfranco del Mundo
File name: colorizer.js
Description: Color picker

Dependencies: jQuery
*/


(function($){
    colorizer = {
        init: function(){
            if (!$(".colorizer").length) {return;}

            var container = $(".colorizer"),
                vehicleImg = $(".vehicle-image", container),
                colorName = $(".color-name", container),
                colors = $(".color-palette li", container);

            colorizer.colorSwap(vehicleImg,colors,colorName);
            colorizer.imageSwap(colors);

            var debouncedImageSwap = _.debounce(function(){colorizer.imageSwap(colors);},500);

            $(window).on('resize', debouncedImageSwap);
        },
        colorSwap: function(vehicleImg,colors,colorName){
            var colorLinks = $("a",colors);

            colorLinks.click(function(){
                var self = $(this),
                    citation = self.find('.citation').length > 0 ? self.find('.citation').clone() : null;
                if (!self.hasClass("active")){
                    colorLinks.removeClass("active");
                    self.addClass("active");

                //pictureFill Fix for IOS, IE9 lte and IE10
                if(guxApp.tools.detectIE() || guxApp.tools.isIOS()){
                    $('img',vehicleImg).attr("src", self.attr("href"));
                } else {
                    $('source',vehicleImg).first().attr("srcset", self.attr("href"));
                    $('source',vehicleImg).last().attr("srcset", self.attr("data-smob"));
                }

                    colorName.html(self.text());
                    
                    if (citation){
                        colorName.append(citation);
                    }
                }

                //On Click iOS patch for pictureFill
                $(window).scroll();
                
                return false;
            });
        },
        imageSwap: function(colors){
            var imgUrl = guxApp.viewport.view == "mobile" ? "smob" : "desktop";

            $(colors).each(function(){
                var self = $('a',this);
                self.attr("href",self.data(imgUrl));
            });
        }
        
    };

    $(function(){
        colorizer.init();
    });

})(jQuery);


/*
Author: Ruiwen Qin
File name: tabs.js
Description: Tab switch
             Tabs become dropdown under mobile view.

             contentSwitch: display the active tab content body
             tabEvent: tab navigation items click event bind and handler

             ## HTML structure example ##
             <div class="tabs-wrap">
                <div class="tabs-switch">
                    <div class="tab-options">
                        <ul class="options">
                            <li data-tab="interior" class="active">
                                <a href="#">Interior</a>
                            </li>
                            <li data-tab="exterior">
                                <a href="#">Exterior</a>
                            </li>
                        </ul>
                    </div>
                </div>
                <div class="tabs-content">
                    <div data-tab="interior" class="tab-content active">...</div>
                    <div data-tab="exterior" class="tab-content">...</div>
                </div>
            </div>

Dependencies: jQuery
*/


(function($){
    tabSwitch = {
        init: function(){
            if (!$(".tabs-switch").length) {return;}

            var container = $(".tabs-wrap"),
                options = $(".tabs-switch .options", container),
                currentTab = $(".active", options),
                contentContainer = $(".tabs-content", container);

            tabSwitch.contentSwitch(currentTab);
            tabSwitch.tabEvent(options);
            tabSwitch.iconRemover(options);

            
            if(!guxApp.tools.isIE(8)) {
                window.onresize = function() {
                     if(window.innerWidth >= 768){
                         options.parent().removeClass("open");
                     }
                }
            }

        },
        contentSwitch: function(currentTab){
            var currentCategory = currentTab.data("tab"),
                tabContent = $('.tab-content[data-tab="' + currentCategory + '"]');

            tabContent.siblings().removeClass('active');
            tabContent.addClass("active");

            // when tabs are switched, publish the event
            $.publish('tab-switched');
        },
        tabEvent: function(options){
            var tabItems = $("li", options);

            tabItems.click(function(e){
                e.preventDefault();
                var self = $(this);
                tabItems.removeClass("active");
                self.addClass("active");
                tabSwitch.contentSwitch(self);


            });

            
            options.click(function(){
                if (window.innerWidth < 768){
                    $(this).parent().toggleClass("open");
                }
            });            
        },

        // this will check if there's only 1 tab then it will remove the icon for dropdown.
        iconRemover: function(options){
            var tab = $('li',options);
            if(!tab.eq('1').length){
                tab.find('.icon').hide();
            }
        }
    };

    $(function(){
        tabSwitch.init();
    });

})(jQuery);


/*
Author: Ruiwen Qin
File name: 360slider.js
Description: 

Dependencies: jQuery
*/

var guxApp = guxApp || {};

(function($){
    threesixtySlider = {
        init: function(){
            if (!$(".threesixty-slider").length) {return;}

            var module = $(".threesixty-slider");
            threesixtySlider.slider(module);
        },
        slider: function(module){
            module.each(function(){
                var container = $(this),
                    vrData = $(".vr-data",container),
                    imgData = guxApp.tools.getEmbeddedData(vrData),
                    imgLocation = guxApp.viewport.view == "mobile" && imgData.vrImages.smobLocation ? imgData.vrImages.smobLocation : imgData.vrImages.location,
                    vrImg = $(".vr-image",container),
                    images = [];
    

                vrImg.attr("src", imgLocation + imgData.vrImages.filenamePrefix + threesixtySlider.pad(0, imgData.vrImages.counterFormat.length) + "." + imgData.vrImages.extension);

                for (var i = imgData.vrImages.start; i < imgData.vrImages.end; i++){
                    images.push(imgLocation + imgData.vrImages.filenamePrefix + threesixtySlider.pad(i, imgData.vrImages.counterFormat.length) + "." + imgData.vrImages.extension);
                }
                
                

                if(images.length) {
                    vrImg.reel({
                        revolution: 500,
                        frames: images.length,
                        images: images,
                        responsive: true
                    });

                    $(".arrow-left", container).on("click", function(e){
                        vrImg.trigger('stepLeft');
                    });
                    
                    $(".arrow-right", container).on("click", function(e){
                        vrImg.trigger('stepRight');
                    });
                }

                // trigger the resize event when tabs are switched for fixing non-draggable issue
                $.subscribe('tab-switched', (function(){
                    vrImg.trigger('resize');
                }));
                
            });
        },
        pad: function(num,size){
            var s = num + "";
            while (s.length < size) s = "0" + s;
            return s;
        }
    };

    $(function(){
        threesixtySlider.init();
    });

})(jQuery);


/*
Author: 		Randell Quitain
File name: 		modelDisplay.js
Description: 	Change .model-display layout when its has 1 item only
				Additionally functionality: If there are more than 7 items, text controls are displayed instead of meatballs
Dependencies: 	jQuery 	
*/

(function($){
	var modelDisplay = {
		init: function(){
			var md 	 = $(".model-display"),
				self = this,
				width = $(window).width(),
				maxItems = 7; // set max meatballs displayed here before alt controls are used

			if($(".carousel-limit li", md).length <= 1) {
				md.addClass('model-single');
			}			

			$(".flexslider", md).append("<div class='alt-controls'><span class='alt-prev' /><span class='item-count'><span class='current-item' />/<span class='items-total' /></span><span class='alt-next' /></div>").find(".items-total").html($(".flex-control-nav li", md).length);

			$(".alt-controls", md).hide();

			self.bindControls(md);
			self.updateControls(md, maxItems);

			$(window).on('resize', function() {
				if ($(this).width() != width) {
      				width = $(this).width();

					setTimeout(function() {
						self.updateControls(md, maxItems);
					},500);
				}
			});
		},

		bindControls: function(md) {
			$(".alt-controls", md).on("click", ".alt-prev", function() {
				$(".flex-prev", md).trigger("click");
			});

			$(".alt-controls", md).on("click", ".alt-next", function() {
				$(".flex-next", md).trigger("click");
			});
		},

		updateControls: function(md, maxItems) {
			var items = $(".flex-control-nav li", md).length;
			
			if (items > maxItems) {
				modelDisplay.displayAltControls(md, items);
			} else {
				$(".flex-control-nav", md).show();
				$(".alt-controls", md).hide().parents('.model-display').removeClass('alt-ctrl');
			}
		},

		displayAltControls: function(md, items) {
			$(".flex-control-nav", md).hide();
			$(".alt-controls", md).css('display','inline-block').find(".items-total").html(items);
			$(".alt-controls", md).parents('.model-display').addClass('alt-ctrl');

			var slider 	  = $(".flexslider", md).data("flexslider"),
				currSlide = slider.currentSlide + 1;

			$(".alt-controls .current-item", md).html(currSlide);

			slider.vars.after = function() {
				currSlide = slider.currentSlide + 1;
				$(".alt-controls .current-item", md).html(currSlide);
			};
		}
	};

	$(function(){
		if (!$(".model-display").length) {return;}
		modelDisplay.init();
	});

})(jQuery);


/*
Author: 		Randell Quitain
File name: 		modelWalk.js
Description: 	Compare vehicles
Dependencies: 	Angular, jQuery
*/

(function($){
	var modelWalk = {
		init: function(){
			// selected sticky header
			if (!$('.selected-sticky').length) {return;};
				var selectedSticky = selectedSticky?selectedSticky:$('.selected-sticky'),
					startPoint = 70,
					startPointSecondNav = 70,
					sNav = $('.secondarynav');

          
				$(window).on('scroll', function() {
					var scroll = $(window).scrollTop();
					if (scroll > startPoint) {
						selectedSticky.addClass('fixed');
					} else {
						selectedSticky.removeClass('fixed');
					}

					if(scroll < startPointSecondNav){
		                sNav.removeClass('fullwidth');
		            } else {
		                sNav.addClass('fullwidth');     
		            }

		            if(guxApp.viewport.view == "mobile"){
						$(".title-holder").trigger("sticky_kit:detach");
					}else{
						guxApp.accordion.stickyTitle();
					}
				});

				$('.tab-nav:eq(1)').addClass('open');
				$('.tab-contents:eq(1)').addClass('open');

		},
		zebraStyling: function(){
			//this is for accordion table styling for ie8
			var accordion = $('.accordion-block');
			
			if (!$(accordion).length) {return;}
			
			if(guxApp.tools.isIE(8)) {
				$('.accordion-block .table-holder > table tr:odd').addClass('odd');
			}
		},
        recalcSticky: function(){
            var debouncedCalc = _.debounce(function() {
                if(guxApp.viewport.view !== "mobile"){
                    guxApp.accordion.stickyTitle();
                }
            },300);

            $(window).on('resize', debouncedCalc);            
        },
		/* on mobile view, enlareg "vehicle card" by click */
		enlargeVehicleCard : function() {
			var container = $("#content .model-walk.model-enhance"),
			    vehicleCard = $(".mw-wrapper .mw-content .select-models .model-container", container);
			if ( !container || vehicleCard.length===0) return;
			$(".model-data .model-select a", vehicleCard).on("click", function(e){
				var clonedVehicleCard = $(".mw-wrapper",container).siblings(".model-container");
				if(guxApp.viewport.view ==="mobile" && clonedVehicleCard.length ===0) {
					e.preventDefault();
					var curVehicleCard = $(this).closest(".model-container");
					$("body").addClass("no-scroll has-scroll");
					curVehicleCard.clone().addClass("clone").insertAfter($(".mw-wrapper",container)).fadeIn(function(){
						//"hide-for-large-up" is a foundation visibility setting class, to hide the element above your query setting "@media #{$large-up}"
						$(this).addClass("hide-for-large-up");
					});
				}
			
			});
			container.on("click",".close-vehicle",function(e){
				e.preventDefault();
				$(this).closest(".model-container").fadeOut(function(){
					$("body").removeClass("no-scroll has-scroll");
					$(this).remove();
					});
			});
		
		}
	};

	$(function(){
		modelWalk.init();
		modelWalk.zebraStyling();
		modelWalk.recalcSticky();
		modelWalk.enlargeVehicleCard();
	});
})(jQuery);


/*
Author: Bao Jie
File Name: stickyTitle.js
Description: stick the position of a jquery element into their parent container
Usage: $(stickElem).stick_in_parent(option);
argument: option: json format, containe following properties:
        parent:          The parent of the sticky element working as the container. Default to the closest parent.
        inner_scrolling: Boolean to enable or disable the ability of the sticky element to scroll independently of the scrollbar when it???s taller than the viewport.
                         Defaults to true for enabled.
        sticky_class:    The name of the CSS class to apply to elements when they have become stuck. Defaults to "is_stuck".
        offset_top:      offsets the initial sticking position by of number of pixels, can be either negative or positive
        spacer:          either a selector to use for the spacer element, or false to disable the spacer. The selector is passed to closest,
                         so you should nest the sticky element within the spacer. Defaults to Stiky Kit creating its own spacer.
        bottoming:       Boolean to control whether elements bottom out. Defaults to true
        recalc_every:    Integer specifying that a recalc should automatically take place between that many ticks.
                         A tick takes place on every scroll event. Defaults to never calling recalc on a tick.
 */

(function() {
  var $, win;

  $ = this.jQuery || window.jQuery;

  win = $(window);

  $.fn.stick_in_parent = function(opts) {
    var elm, enable_bottoming, inner_scrolling, manual_spacer, offset_top, parent_selector, recalc_every, sticky_class, _fn, _i, _len;
    if (opts == null) {
      opts = {};
    }
    sticky_class = opts.sticky_class, inner_scrolling = opts.inner_scrolling, recalc_every = opts.recalc_every, parent_selector = opts.parent, offset_top = opts.offset_top, manual_spacer = opts.spacer, enable_bottoming = opts.bottoming;
    if (offset_top == null) {
      offset_top = 0;
    }
    if (parent_selector == null) {
      parent_selector = void 0;
    }
    if (inner_scrolling == null) {
      inner_scrolling = true;
    }
    if (sticky_class == null) {
      sticky_class = "is_stuck";
    }
    if (enable_bottoming == null) {
      enable_bottoming = true;
    }
    _fn = function(elm, padding_bottom, parent_top, parent_height, top, height, el_float, detached) {
      var bottomed, detach, fixed, last_pos, offset, parent, recalc, recalc_and_tick, recalc_counter, spacer, tick;
      if (elm.data("sticky_kit")) {
        return;
      }
      elm.data("sticky_kit", true);
      parent = elm.parent();
      if (parent_selector != null) {
        parent = parent.closest(parent_selector);
      }
      if (!parent.length) {
        throw "failed to find stick parent";
      }
      fixed = false;
      bottomed = false;
      spacer = manual_spacer != null ? manual_spacer && elm.closest(manual_spacer) : $("<div />");
      if (spacer) {
        spacer.css('position', elm.css('position'));
      }
      recalc = function() {
        var border_top, padding_top, restore;
        if (detached) {
          return;
        }
        border_top = parseInt(parent.css("border-top-width"), 10);
        padding_top = parseInt(parent.css("padding-top"), 10);
        padding_bottom = parseInt(parent.css("padding-bottom"), 10);
        parent_top = parent.offset().top + border_top + padding_top;
        parent_height = parent.height();
        if (fixed) {
          fixed = false;
          bottomed = false;
          if (manual_spacer == null) {
            elm.insertAfter(spacer);
            spacer.detach();
          }
          elm.css({
            position: "",
            top: "",
            width: "",
            bottom: ""
          }).removeClass('stick').removeClass(sticky_class);

          restore = true;
        }
        top = elm.offset().top - parseInt(elm.css("margin-top"), 10) - offset_top;
        height = elm.outerHeight(true);
        el_float = elm.css("float");
        if (spacer) {
          spacer.css({
            width: elm.outerWidth()-2,
            height: height,
            display: elm.css("display"),
            "vertical-align": elm.css("vertical-align"),
            "float": el_float
          });
        }
        if (restore) {
          return tick();
        }
      };
      recalc();
      if (height === parent_height) {
        return;
      }
      last_pos = void 0;
      offset = offset_top;
      recalc_counter = recalc_every;
      tick = function() {
        var css, delta, scroll, will_bottom, win_height;
        if (detached) {
          return;
        }
        if (recalc_counter != null) {
          recalc_counter -= 1;
          if (recalc_counter <= 0) {
            recalc_counter = recalc_every;
            recalc();
          }
        }
        scroll = win.scrollTop();
        if (last_pos != null) {
          delta = scroll - last_pos;
        }
        last_pos = scroll;
        if (fixed) {
          if (enable_bottoming) {
            will_bottom = scroll + height + offset > parent_height + parent_top;
            if (bottomed && !will_bottom) {
              bottomed = false;
              elm.css({
                position: "fixed",
                bottom: "",
                top: offset
              }).addClass('stick').trigger("sticky_kit:unbottom");
            }
          }
          if (scroll < top) {
            fixed = false;
            offset = offset_top;
             elm.removeClass("stick");
            if (manual_spacer == null) {
              if (el_float === "left" || el_float === "right") {
                elm.insertAfter(spacer);
              }
              spacer.detach();
            }
            css = {
              position: "",
              width: "",
              top: ""
            };
            elm.css(css).removeClass(sticky_class).removeClass('stick').trigger("sticky_kit:unstick");
          }
          if (inner_scrolling) {
            win_height = win.height()+1000;
            if (height + offset_top > win_height) {
              if (!bottomed) {
                offset -= delta;
                offset = Math.max(win_height - height, offset);
                offset = Math.min(offset_top, offset);
                if (fixed) {
                  elm.css({
                    top: offset + "px"
                  });
                }
              }
            }
          }
        } else {
          if (scroll > top) {
            fixed = true;
            css = {
              position: "fixed",
              top: offset
            };
            css.width = elm.css("box-sizing") === "border-box" ? elm.outerWidth() + "px" : elm.width() + "px";
            elm.css(css).addClass(sticky_class);
            elm.addClass("stick");
            //elm.css('padding-top','350px');
            if (manual_spacer == null) {
              elm.after(spacer);
              if (el_float === "left" || el_float === "right") {
                spacer.append(elm);
              }
            }
            elm.addClass('stick').trigger("sticky_kit:stick");
          }
        }
        if (fixed && enable_bottoming) {
          if (will_bottom == null) {
            will_bottom = scroll + 350 + height + offset > parent_height + parent_top;
          }
          if (!bottomed && will_bottom) {
            bottomed = true;
            if (parent.css("position") === "static") {
              parent.css({
                position: "relative"
              });
            }
            return elm.css({
              position: "absolute",
              bottom: 0,
              top: "auto"
            }).removeClass('stick').trigger("sticky_kit:bottom");
          }
        }
      };
      recalc_and_tick = function() {
        recalc();
        return tick();
      };
      detach = function() {
        detached = true;
        win.off("touchmove", tick);
        win.off("scroll", tick);
        win.off("resize", recalc_and_tick);
        $(document.body).off("sticky_kit:recalc", recalc_and_tick);
        elm.off("sticky_kit:detach", detach);
        elm.removeData("sticky_kit");
        elm.removeClass("stick");
        elm.css({
          position: "",
          bottom: "",
          top: "",
          width: ""
        });
        parent.position("position", "");
        if (fixed) {
          if (manual_spacer == null) {
            if (el_float === "left" || el_float === "right") {
              elm.insertAfter(spacer);
            }
            spacer.remove();
          }
          return elm.removeClass(sticky_class);
        }
      };

      resize_complete = function () {
        var timers = {};
        return function (callback, ms, uniqueId) {
          if (!uniqueId) {
            uniqueId = "Don't call this twice without a uniqueId";
          }
          if (timers[uniqueId]) {
            clearTimeout (timers[uniqueId]);
          }
          timers[uniqueId] = setTimeout(callback, ms);
        };
      };

      //Fix performance issues in ie8;
      var debouncedTick = _.debounce(tick,100),
          debouncedTickIOS = _.debounce(tick,500);
      var debouncedRecalc = _.debounce(recalc_and_tick,100);
      var isIOS = guxApp.tools.isIOS()?true:false;
      if(guxApp.tools.isIE(8)){
        win.on("touchmove", debouncedTick);
        win.on("scroll", debouncedTick);
        win.on("resize", resize_complete(debouncedRecalc,500,"recalcComplete"));
        $(document.body).on("sticky_kit:recalc", debouncedRecalc);
        elm.on("sticky_kit:detach", detach);
      } else if(isIOS) {
        win.on("scrollstop", tick);
      } else {
        win.on("touchmove", tick);
        win.on("scroll", tick);
        win.on("resize", debouncedRecalc);
        $(document.body).on("sticky_kit:recalc", debouncedRecalc);
        elm.on("sticky_kit:detach", detach);
      }

      return setTimeout(tick, 0);
    };
    for (_i = 0, _len = this.length; _i < _len; _i++) {
      elm = this[_i];
      _fn($(elm));
    }
    return this;
  };

}).call(this);


/*
Author: 		Jessie Biros
File name: 		guxApp.accordion.js
Description: 	Accordion [used in model-walk-compare]
				How to use:
				1. add class "tabular" on your container
				2. To create tabs 
					a. create a container (eg. div) and add the class name "tab item"
					
					b. for the title of the nav add a text tag (or any container) inside "tab-item" and add class "tab-nav"
					
					c. after the 'tab-nav' create a container and add a class "tab-contents" that will serve as the wrapper of your contents
					
					d. for you to add styles (eg. margin/padding) on your contents you need to add a container again inside and add a class name "tab-data" and inside that container you may put your contents

				3. To disable a specific tab-item from opening and closing add the class "disable" to that "tab-item" DIV i.e. <div class="tab-item disable">...

				Example:
					<section class="accordion-block">
						<div class="tab-item">
							<h2 class="tab-nav">
								  //title of tab
							</h2>
							<div class="tab-contents">
								<div class="tab-data">
								  //lorem ipsum ...
								</div>
							</div>
						</div>
					</section>

Dependencies: 	jQuery
*/

var guxApp = guxApp || {};

(function($){
	guxApp.accordion = {
		init: function(){
			var accordionBlock = $('.accordion-block');

			if(!accordionBlock.length){return;}
			$('.tab-item .open').next().css('display','block');
            this.stickyTitle();
            var me = this;
			$('.tab-nav',accordionBlock).off('click').on('click', function(){
				var self = $(this);

				// if the current accordion "tab-item" has the disable class do not go any further
				if (self.hasClass('disable')){return;}

                $(".title-holder").trigger("sticky_kit:detach");
				if(!self.hasClass('open')) {
					guxApp.accordion.toggleAnimate($('.tab-nav.open:not(".disable")',accordionBlock).removeClass('open'));
					self.toggleClass('open');
					guxApp.accordion.toggleAnimate(self);
				} else {
					guxApp.accordion.toggleAnimate(self.removeClass('open'));
					$.publish("accordion-tab-nav-close");
				}
			});

			// Added Functionality to Close on Click of Close Button inside Accordion; class:close-accordion
			var closeAccordion = $('.close-accordion',accordionBlock);
			if(closeAccordion.length){
				$('.close-accordion',accordionBlock).off('click').on('click',function(e){
					e.preventDefault();
					guxApp.accordion.toggleAnimate($('.tab-nav.open',accordionBlock).removeClass('open'));
					$('.selected-sticky').addClass('fixed');
	                var offsetTop = accordionBlock.offset().top - $('.selected-sticky').outerHeight() - 50;
	                $('html,body').animate({scrollTop: offsetTop},200);
				});
			}

			$(window).on("resize",function(){
				$(".title-holder").trigger("sticky_kit:detach");
			});
		},
		toggleAnimate: function (elem){
			elem.next().animate({
				'height': 'toggle',
				opacity : 'toggle'
			}, {
				duration: 600,
				complete: function() {
					$.publish("accordion-tab-nav-open",[$(this).prev()]);
					$(document).foundation('equalizer', 'reflow');
				}
			});
		},
		toggleWaypoint: function (){
		},
		stickyTitle: function(){
			$(".title-holder").stick_in_parent({
				parent:".title-waypoint",
				offset_top: 350,
				recalc_every: 5
			});
		},
		recalcSticky: function(){
			$(document.body).trigger("sticky_kit:recalc");
		}
	};

	$(function(){
		guxApp.accordion.init();
	});

})(jQuery);


/*
Author: 		Brett Chaney
File name: 		galleryTriggerReveal.js
Description: 	Simple toggle for gallery trigger reveal
Dependencies: 	jQuery 	
*/


(function($){
	var galleryTriggerReveal = {

		init: function(){

			if($(".reveal-trigger .multi-buttons").find(".active").length < 1) {
				// if there is no active class found then add them
				$(".reveal-trigger .button").eq(0).addClass("active")
					.parents(".reveal-trigger").find(".gallery").eq(0).addClass("active");
			}
			
			$(".reveal-trigger").on("click", ".button", function(e) {
				e.preventDefault();
				
				var gallerySelected = $(this).data("gallery-type");

				$(this).parent().find(".button").removeClass("active").parent().find(".button[data-gallery-type=" + gallerySelected + "]").addClass("active")
					.parents(".reveal-trigger").find(".gallery").removeClass("active").parent().find(".gallery[data-gallery-type=" + gallerySelected + "]").addClass("active");

			});

		}		
	
	};

	$(function(){
		if (!$(".reveal-trigger").length) {return;}
		galleryTriggerReveal.init();
	});

})(jQuery);


/*!
Waypoints Sticky Element Shortcut - 3.1.1
Copyright ?? 2011-2015 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blog/master/licenses.txt
*/
(function() {
  'use strict'

  var $ = window.jQuery
  var Waypoint = window.Waypoint

  /* http://imakewebthings.com/waypoints/shortcuts/sticky-elements */
  function Sticky(options) {
    this.options = $.extend({}, Waypoint.defaults, Sticky.defaults, options)
    this.element = this.options.element
    this.$element = $(this.element)
    this.createWrapper()
    this.createWaypoint()
  }

  /* Private */
  Sticky.prototype.createWaypoint = function() {
    var originalHandler = this.options.handler

    this.waypoint = new Waypoint($.extend({}, this.options, {
      element: this.wrapper,
      handler: $.proxy(function(direction) {
        var shouldBeStuck = this.options.direction.indexOf(direction) > -1
        var wrapperHeight = shouldBeStuck ? this.$element.outerHeight(true) : ''

        this.$wrapper.height(wrapperHeight)
        this.$element.toggleClass(this.options.stuckClass, shouldBeStuck)

        if (originalHandler) {
          originalHandler.call(this, direction)
        }
      }, this)
    }))
  }

  /* Private */
  Sticky.prototype.createWrapper = function() {
    this.$element.wrap(this.options.wrapper)
    this.$wrapper = this.$element.parent()
    this.wrapper = this.$wrapper[0]
  }

  /* Public */
  Sticky.prototype.destroy = function() {
    if (this.$element.parent()[0] === this.wrapper) {
      this.waypoint.destroy()
      this.$element.removeClass(this.options.stuckClass).unwrap()
    }
  }

  Sticky.defaults = {
    wrapper: '<div class="sticky-wrapper" />',
    stuckClass: 'stuck',
    direction: 'down right'
  }

  Waypoint.Sticky = Sticky
}())
;


var guxApp = guxApp || {};

(function($){
	
	guxApp.lang = {
		init:function(){
			if($("#lang-toggle")){
				$("#lang-toggle").change(function(){
					window.location.href = $("#lang-toggle option:selected").val();
				});
			}
		}
	};

	$(function(){
		guxApp.lang.init();
	});
		
})(jQuery);


/*
Author:         Gian Franco S. del Mundo
File name:      scrollStop.js
Description:    Extending the scroll functionality of jQuery which fires an event on scroll start or scroll stop.
                Can be used on .on .live and .bind Events
Example:        .on('scrollstart',yourFunction); // Fires an Event on start scroll
                .on('scrollstop',yourFunction); // Fires an Event on scroll stop

Dependencies:   jQuery
*/

(function(){
 
    var special = jQuery.event.special,
        uid1 = 'D' + (+new Date()),
        uid2 = 'D' + (+new Date() + 1);
 
    special.scrollstart = {
        setup: function() {
 
            var timer,
                handler =  function(evt) {
 
                    var _self = this,
                        _args = arguments;
 
                    if (timer) {
                        clearTimeout(timer);
                    } else {
                        evt.type = 'scrollstart';
                        jQuery.event.handle.apply(_self, _args);
                    }
 
                    timer = setTimeout( function(){
                        timer = null;
                    }, special.scrollstop.latency);
 
                };
 
            jQuery(this).bind('scroll', handler).data(uid1, handler);
 
        },
        teardown: function(){
            jQuery(this).unbind( 'scroll', jQuery(this).data(uid1) );
        }
    };
 
    special.scrollstop = {
        latency: 300,
        setup: function() {
 
            var timer,
                    handler = function(evt) {
 
                    var _self = this,
                        _args = arguments;
 
                    if (timer) {
                        clearTimeout(timer);
                    }
 
                    timer = setTimeout( function(){
 
                        timer = null;
                        evt.type = 'scrollstop';
                        jQuery.event.handle.apply(_self, _args);
 
                    }, special.scrollstop.latency);
 
                };
 
            jQuery(this).bind('scroll', handler).data(uid2, handler);
 
        },
        teardown: function() {
            jQuery(this).unbind( 'scroll', jQuery(this).data(uid2) );
        }
    };
 
})();


/*
Author:         Brett Chaney
File name:      serviceCalculator.js
Description:    Calculator to estimate service price
Dependencies:   jQuery, tinypubsub, underscorejs, jquery.uniform
*/

// namespaces for general GUX and Service Booking methods (required for service calculator)
var guxApp = guxApp || {},
	SB = SB || {};

(function($) {

// namespace for service calculator (sc) methods
guxApp.sc = {};

// methods that handle the four select dropdowns
guxApp.sc.vehicles = {

	init: function() {

		// this object will hold all the results after the ajax calls
		guxApp.sc.cache = {};

		// lets get this calculator cracking, starting with setting up the rest services
		this.setupRestServices();

		// add iphone-ios class for iPhone to fix unwanted input zooming behaviour
		if (guxApp.tools.isIOS() == 'iPhone') {
			$('.service-calc').addClass('iphone-ios');
		}

	},

	setupRestServices: function() {

		//load configuration from template and get the urls ready
		var urls = $('#service-calc-services').embeddedData(),
			siteConfig = $('#common-config').embeddedData(),
			selectTexts = $('#service-calc-text').embeddedData();

		var urlVehicles = urls['sc.allvehicles'],
			urlServices = urls['sc.vehicleservices'],
			urlPdf = urls['sc.pdf'],
			site = siteConfig.site;

		// assign URL's to guxApp.sc namespace for future reference
		guxApp.sc.urlVehicles = urlVehicles.replace('{site}', site);
		guxApp.sc.urlServices = urlServices.replace('{site}', site);
		guxApp.sc.urlPdf = urlPdf.replace('{site}', site);
		guxApp.sc.selectTexts = selectTexts;

		// get vehicle data and populate year select
		this.populateYearSelect();

	},

	getData: function(url, onSuccess, onError) {

		$.ajax({
			url: url,
			async: true,
			cache: false,
			dataType: 'json',
			headers: {
				'Cache-Control': 'no-cache'
			},
			success: function(data) {				
				onSuccess(data);
			},
			error: function(e, extStatus) {
				onError(url, e, extStatus);
			}
		});
		
	},

	resetSelects: function(elem) {

		// disable select boxes and unbind change event
		$(elem).parents('.group').nextAll().addClass('disabled').find('select').attr('disabled', 'disabled').off('change');

		$(elem).parents('.group').nextAll().find('option:not(:first-child)').remove();

		// reset uniformjs selects
		$('select', this.wrapper).uniform();

	},

	resetErrors: function() {

		// remove any error messages
		$('.error', this.wrapper).remove();
	
	},

	deactivateResults: function() {

		// deactivate service results when the user goes back to select a new vehicle
		if ($('.service-calc.service-results').hasClass('active')) {
			$('.service-calc.service-results').removeClass('active').addClass('deactive');
			$('button.calculate', guxApp.sc.services.wrapper).removeClass('ready').attr('disabled', true);
		}

		// reset uniformjs selects
		$('select', this.wrapper).uniform();

	},

	populateSelectsDefault: function() {

		var self = this,
			firstSelect = $('select', self.wrapper)[0];

		// loop through each of the four selects and append its relevant default text
		$('select', self.wrapper).each(function(){
			var type = $(this).attr('id');
			
			$('select#' + type + ' > option:first-child', self.wrapper).text(guxApp.sc.selectTexts['select.' + type + '.text']);
		});

		guxApp.sc.vehicles.resetSelects(firstSelect);

	},

	populateYearSelect: function() {

		var self = this;

		// show loading gif
		$('.service-calc .loading').show();

		// wrapper for the four vehicle select dropdowns
		guxApp.sc.vehicles.wrapper = $('form#service-dropdowns');

		// AJAX call - populate year selectbox
		guxApp.sc.vehicles.getData(guxApp.sc.urlVehicles, function(data) {

			self.populateSelectsDefault();

			// cache the results
			guxApp.sc.cache = data.data;

			var yearSelect = $('select#year', self.wrapper);

			$.each(guxApp.sc.cache.years, function(i, value){
				yearSelect.append('<option value="' + value + '">' + value + '</option>');
			});

			// reset uniformjs on this select
			$('select', self.wrapper).uniform();

			// hide loading gif
			$('.service-calc .loading').hide();

			// bind event for year selectbox
			guxApp.sc.vehicles.yearChangeEvent();

		}, function(e, extStatus) {

			// hide loading gif
			$('.service-calc .loading').hide();

			// on AJAX error...
			guxApp.sc.vehicles.wrapper.prepend('<p class="error">' + guxApp.sc.selectTexts['error.url.vehicles'] + '</p>');

			// disable first select
			$('select#year', self.wrapper).attr('disabled', 'disabled').parents('.group').addClass('disabled');
		});

	},

	yearChangeEvent: function() {

		var self = this;

		$('select#year', self.wrapper).on('change', function() {

			var elem = $(this),
				yearVal = $(this).val();

			self.resetSelects(elem);
			self.resetErrors();

			if (yearVal !== 'default') {

				$('select#model', self.wrapper).attr('disabled', false).parents('.group').removeClass('disabled');
				
				// populate model selectbox with cached ajax results
				$.each(guxApp.sc.cache.models, function(i, value) {

					// only add models that match the year selected
					if (yearVal >= value.startyear && yearVal <= value.endyear) {
						$('select#model', self.wrapper).append('<option value="' + value.name + '">' + value.name + '</option>');
					}

				});

				// display error message if no models are found for that year
				if ($('select#model option', self.wrapper).length === 1) {
					guxApp.sc.vehicles.wrapper.prepend('<p class="error">There are no models produced for this year. Please select another year.</p>');
					self.resetSelects(elem);
				}

				// bind event for model selectbox
				self.modelChangeEvent();

			}

			// grey out/deactivate service results
			self.deactivateResults();
			
		});

	},

	modelChangeEvent: function() {

		var self = this;

		$('select#model', self.wrapper).on('change', function() {

			var elem = $(this),
				modelVal = $(this).val(),
				modelYear = parseInt($('select#year', self.wrapper).val(), 10);

			self.resetSelects(elem);

			if (modelVal !== 'default') {

				$('select#style', self.wrapper).attr('disabled', false).parents('.group').removeClass('disabled');
				
				// populate style selectbox with cached ajax results
				$.each(guxApp.sc.cache.models, function(i, value) {

					if (value.name === modelVal) {

						$.each(value.years, function(i, value) {

							if (value.year === modelYear) {

								guxApp.sc.cache.style = value.style;

								$.each(value.style, function(i, value) {
									$('select#style', self.wrapper).append('<option value="' + value.name + '">' + value.name + '</option>');
								});

							}

						});

					}

				});

				// reset uniformjs on this select
				elem.uniform();

				// bind event for style selectbox
				self.styleChangeEvent();

			}

			// grey out/deactivate service results
			self.deactivateResults();

		});

	},

	styleChangeEvent: function() {

		var self = this;

		$('select#style', self.wrapper).on('change', function() {

			var elem = $(this),
				styleVal = $(this).val();

			self.resetSelects(elem);

			if (styleVal !== 'default') {

				$('select#engine', self.wrapper).attr('disabled', false).parents('.group').removeClass('disabled');
				
				// populate engine selectbox with cached ajax results
				$.each(guxApp.sc.cache.style, function(i, value) {

					if (value.name === styleVal) {

						guxApp.sc.cache.engines = value.engines;

						$.each(value.engines, function(i, value) {
							$('select#engine', self.wrapper).append('<option value="' + value.type + '" id="' + value.id + '">' + value.type + '</option>');
						});
					
					}

				});

				// reset uniformjs on this select
				elem.uniform();

				// bind event for engine selectbox
				self.engineChangeEvent();

			}

			// grey out/deactivate service results
			self.deactivateResults();

		});

	},

	engineChangeEvent: function() {

		var self = this;

		$('select#engine', this.wrapper).on('change', function() {

			var elem = $(this),
				engineVal = $(this).val();

			if (engineVal !== 'default') {

				// empty fields 
				$('.service-results select option').remove();

				guxApp.sc.selectedVehicle = $('select#engine option:selected', this.wrapper).attr('id');

				// reset uniformjs on this select
				elem.uniform();

				// load service/additional options data for selected vehicle
				guxApp.sc.services.loadVehicleData();

			}

			// grey out/deactivate service results
			self.deactivateResults();

		});

	}

};

// methods for the selected vehicles service section 
guxApp.sc.services = {

	// months Array for 'first registration to date' select
	monthsArr: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],

	unbindEvents: function() {

		// prevent duplicate event handlers
		$('input#estimatedkm', this.wrapper).off('keypress blur');
		$('select#regyear', this.wrapper).off('change');
		$('button.calculate', this.wrapper).off('click');
		$('.show-roadside-assist', this.wrapper).off('click');
		$('.xtime-mobile-link', this.wrapper).off('click');

	},

	loadVehicleData: function() {

		var self = this,
			originalServicesURL = guxApp.sc.urlServices,
			amendedServicesURL;

		// wrapper for vehicle registration fields and service UI for the selected vehicle
		guxApp.sc.services.wrapper = $('form#recommended-service');

		// unbind already bound form elements
		self.unbindEvents();

		// show loading gif
		$('.service-calc .loading').show();

		amendedServicesURL = originalServicesURL + guxApp.sc.selectedVehicle;

		// ajax call for the services/additional options for the selected vehicle
		guxApp.sc.vehicles.getData(amendedServicesURL, function(data) {

			// hide loading gif
			$('.service-calc .loading').hide();

			// cache the results
			guxApp.sc.cache.services = data.data;

			guxApp.sc.cache.services.serviceinterval.push({
				'km': '> ' + guxApp.sc.cache.services.serviceinterval[guxApp.sc.cache.services.serviceinterval.length - 1].km,
				'number': guxApp.sc.cache.services.serviceinterval.length + 1,
				'agetext': '> ' + guxApp.sc.cache.services.serviceinterval[guxApp.sc.cache.services.serviceinterval.length - 1].agetext
			});

			self.populateRegDate();
			self.bindXtimeMobile();

			// reset total price and options
			$('.js-totalprice', self.wrapper).empty();
			$('.options-list li', self.warpper).removeClass('option-checked');
			$('.options-list li span', self.warpper).removeClass('checked');

			// force calculate button to be disabled on page refresh
			$('button.calculate', self.wrapper).attr('disabled', true);

			$('.service-calc.service-results').removeClass('deactive').fadeIn(350, function() {$(this).addClass('active');});

			// bind number only function to 'estimated kms' input
			self.numbersOnly();

			// service links equal height
			self.serviceLinksHeight();
			
			$(window).on('resize', function() {
				self.serviceLinksHeight();
			});

			// bind smooth scroll to 'Roadside Assistance' div
			$('.view-roadside-assist a', self.wrapper).on('click', function(e) {
				e.preventDefault();
				self.scrollToElem($('.roadside-assistance'));
			});

			$('.service-calc .book-service').fadeOut(350, function() {
				self.scrollToElem($('.vehicle-registration'));		
			});

		}, function(e, extStatus) {

			// on AJAX error...
			var yearSelect = $('select#year', guxApp.sc.vehicles.wrapper);

			guxApp.sc.vehicles.wrapper.prepend('<p class="error">' + guxApp.sc.selectTexts['error.url.services'] + '</p>');

			// hide loading gif
			$('.service-calc .loading').hide();

			// reset all selects
			guxApp.sc.vehicles.resetSelects(yearSelect);
		});

	},

	serviceLinksHeight: function() {

		var self = this;

		// reset heights for prev, next and active links
		$('.service-links .columns a', self.wrapper).css('height', '');

		var prevHeight = $('.service-links .prev').outerHeight(true),
			nextHeight = $('.service-links .next').outerHeight(true),
			activeHeight = $('.service-links .active').outerHeight(true),
			maxHeight = Math.max(prevHeight, nextHeight, activeHeight);

		$('.service-links .columns a', self.wrapper).css('height', maxHeight);

	},

	bindXtimeMobile: function() {

		// event handler for SMOB Xtime link
		// add Service Booking keyword as a parameter to URL 
		this.wrapper.on('click', '.xtime-mobile-link', function() {

			var thisHref 	= $(this).attr('href'),
				separator 	= (thisHref.indexOf('?') == -1) ? '?' : '&';
				SB.keyword 	= $(this).data('sb-keyword');

			// if keyword does not exist as a parameter then attach it to the URL
			if (thisHref.indexOf('keyword') == -1) {
				$(this).attr('href', thisHref + separator + 'keyword=' + SB.keyword);
			}			
			
		});

	},

	showCalcBtn: function() {

		// enable button that calculates the recommended service
		var self = this,
			calcBtn = $('button.calculate', self.wrapper);

		calcBtn.addClass('ready').attr('disabled', false);

		calcBtn.on('click', function(e) {
			e.preventDefault();
			e.stopPropagation();

			// go to calculate recommended service method based on the changes made by the user
			self.calcRecService();
		});

	},

	populateRegDate: function() {

		var self = this,
			startMonth = guxApp.sc.cache.services.startdatebreak - 1,
			currentMonth = guxApp.tools.getMonth() - 1,
			currentYear = guxApp.tools.getYear(),
			startProdYear = guxApp.sc.cache.services.year,
			vehicleYear = parseInt($('select#year option:selected', guxApp.sc.vehicles.wrapper).val(), 10);

		// populate month select
		if (startMonth === '') {

			$('#regmonth', self.wrapper).append('<option value="' + self.monthsArr[0]+ '">' + self.monthsArr[0]+ '</option>');

		} else {


			if (startProdYear === vehicleYear) {

				// populate month select with months starting from the start month break
				$.each(self.monthsArr, function(index, value) {

					if (index >= startMonth) {
						$('#regmonth', self.wrapper).append('<option value=' + value + '>' + value + '</option>');
					}

				});

			} else if (currentYear === vehicleYear) {

				// populate month select with months already gone by of the current year
				$.each(self.monthsArr, function(index, value) {

					if (index <= currentMonth) {
						$('#regmonth', self.wrapper).append('<option value=' + value + '>' + value + '</option>');
					}
					
				});

			} else {

				// populate month select with all months in array
				$.each(self.monthsArr, function(index, value) {

					$('#regmonth', self.wrapper).append('<option value=' + value + '>' + value + '</option>');

				});

			}			

		}

		// populate year select
		for (var i = (vehicleYear - 1); i < currentYear; i++) {
			$('#regyear', self.wrapper).append('<option value=' + (i + 1) + '>' + (i + 1) + '</option>');
		}

		// go to method to estimate the vehicles KM done just after user finishes selecting the vehicle
		this.initialEstimateKM();

		this.yearChangeEvent();
		this.monthsChangeEvent();

	},

	scrollToElem: function(elem) {

		$('html, body').animate({
			scrollTop: (elem.offset().top - ((guxApp.viewport.view === 'mobile') ? 65 : 75))
		},350);

	},

	numbersOnly: function() {

		var self = this;

		// method to force 'estimated KM' input to accept number input only, no other characters allowed
		// when the user focuses outside (on blur) of the input the method to add commas to a number is executed
		$('input#estimatedkm', self.wrapper).on({
			'keypress': function(e) {

				// if the character is not a digit then don't type anything
				if (e.which !== 8 && e.which !== 0 && (e.which < 48 || e.which > 57)) {
					return false;
				}				

				$(this).parent().removeClass('error-wrap');

			},

			'focus': function() {
				if (!$('button.calculate', self.wrapper).hasClass('ready')) {
					self.showCalcBtn();
				}
			},

			'blur': function() {
				this.value = guxApp.tools.numberCommas(this.value);
			}
		});			

	},

	addZero: function(num) {

		// if a number has only one zero after a decimal point this method will add an extra zero
		// i.e. from 150.0 to 150.00
		if (num % 1 !== 0) {
			
			num = parseFloat(num).toFixed(2);
			return num;
		} else {
			return num;
		}
	},

	getVehicleAge: function() {

		// calculate the age in total number of months of the current vehicle selected
		var self = this,
			selectedYear = $('select#regyear option:selected', self.wrapper).val(),
			selectedMonth = $('select#regmonth option:selected', self.wrapper).val(),
			currentMonth = self.monthsArr.indexOf(selectedMonth),
			
			remainingStartMonths = 12 - currentMonth,
			remainingEndMonths = guxApp.tools.getMonth() - 1,

			yearsWithFullMonths = (guxApp.tools.getYear() - selectedYear) - 1,
			monthsTotal = remainingStartMonths + remainingEndMonths + (yearsWithFullMonths * 12);

		return monthsTotal;

	},

	initialEstimateKM: function() {

		// estimated KM for selected vehicle and update the estimatedkm input with the result
		var self = this,
			vehicleInterval = guxApp.sc.cache.services.interval === 10000 ? 1666.67 : 1250,
			estimatedKM = Math.round(self.getVehicleAge() * vehicleInterval);

		// print result for 'estimated km' to input
		$('input#estimatedkm', self.wrapper).val(guxApp.tools.numberCommas(estimatedKM));

		// calculate recommended service
		self.calcRecService();

	},

	yearChangeEvent: function() {

		var self = this,
			firstYear = $('select#regyear option:first-child', self.wrapper).val(),
			currentMonth = guxApp.tools.getMonth() - 1,
			currentYear = guxApp.tools.getYear();

		// event handler for 'first registration to date' year select
		$('select#regyear', self.wrapper).on('change', function() {

			var selectedYear = $('select#regyear option:selected', self.wrapper).val(),
				selectedMonth = $('select#regmonth option:selected', self.wrapper).val(),
				startMonth = guxApp.sc.cache.services.startdatebreak - 1;

			// the following check is for populating the 'first registration to date' month select when the vehicle selected has a start month break
			// if not, populate the 'first registration to date' month select with all the months found in the months Array
			if (selectedYear === firstYear && startMonth >= 1) {

				$('select#regmonth option', self.wrapper).remove();

				$.each(self.monthsArr, function(index, value) {

					if (index >= startMonth) {
						$('#regmonth', self.wrapper).append('<option value=' + value + '>' + value + '</option>');
					}

				});

			} else {

				$('select#regmonth option', self.wrapper).remove();

				$.each(self.monthsArr, function(index, value) {
					$('#regmonth', self.wrapper).append('<option value=' + value + '>' + value + '</option>');
				});

				$('#regmonth option[value=' + selectedMonth + ']', self.wrapper).attr('selected', 'selected');

			}

			// the following check is for when the user selects the current year and then populates the 'first registration to date' month select accordingly
			if (currentYear === parseInt(selectedYear, 10)) {
				
				$('select#regmonth option', self.wrapper).remove();

				$.each(self.monthsArr, function(index, value) {

					if (index <= currentMonth) {
						$('#regmonth', self.wrapper).append('<option value=' + value + '>' + value + '</option>');
					}
					
				});

				$('#regmonth option[value=' + selectedMonth + ']', self.wrapper).attr('selected', 'selected');

			}

			if (!$('button.calculate', self.wrapper).hasClass('ready')) {
				self.showCalcBtn();
			}

			// reset uniformjs for month and year selects
			$('.vehicle-registration select', self.wrapper).uniform();

		});

	},

	monthsChangeEvent: function() {

		var self = this;

		// event handler for 'first registration to date' month select
		$('select#regmonth', self.wrapper).on('change', function() {

			if (!$('button.calculate', self.wrapper).hasClass('ready')) {
				self.showCalcBtn();
			}

		});

	},

	inputError: function() {

		var self = this;

		// scroll screen to 'estimated KM to date' input
		self.scrollToElem($('.estimated-km'));

		// add error class for input
		$('input#estimatedkm', self.wrapper).parent().addClass('error-wrap');

	},

	calcRecService: function() {

		var self = this,
			vehicleKM = guxApp.tools.removeCommas($('input#estimatedkm', self.wrapper).val());

		// error check for empty value
		// if value found then calculate recommended service otherwise show error
		if ($('input#estimatedkm', self.wrapper).val() === '') {

			self.inputError();

		} else {

			$('input#estimatedkm', self.wrapper).parent().removeClass('error-wrap');

			self.scrollToElem($('.vehicle-services'));

			// get step one result for service interval - KM (distance)
			// get step two result for service interval - months (age)
			var stepOneResult = self.stepOneKM(),			
				stepTwoResult = self.stepTwoMonths();

			// get recommend service and cache it (the recommended service is the highest result from step one (KM) and step two (months))
			if (stepOneResult.km >= stepTwoResult.km) {
				guxApp.sc.cache.recommended = stepOneResult;
			} else {
				guxApp.sc.cache.recommended = stepTwoResult;
			}

			// reset uniform selects
			$('select', self.wrapper).uniform();

			// unbind prev and next buttons
			$('.service-links .prev a', self.wrapper).off('click');
			$('.service-links .next a', self.wrapper).off('click');

			// cache active service as the recommended
			guxApp.sc.cache.services.activeService = guxApp.sc.cache.recommended;

			// add options for the selected vehicle to the UI
			self.appendOptions();

			// if the vehicle KM is more than 510,000 km, display the '> 510,000 km' service section
			// if vehicle is 510,000 km or under display the recommended service
			if (vehicleKM > 510000) {
				var lastInterval = guxApp.sc.cache.services.serviceinterval.length - 1;
				guxApp.sc.cache.recommended = guxApp.sc.cache.services.serviceinterval[lastInterval];

				self.populateActiveService(guxApp.sc.cache.recommended);
			} else {
				self.populateActiveService(guxApp.sc.cache.recommended);
			}

			// go to method that binds the prev/next service links
			self.bindServiceLinks();

			// display quote valid date
	        $('.valid-date', self.wrapper).html(Date.today().addDays(30).toString('dd MMMM yyyy'));
	    }

	},

	stepOneKM: function() {

		// this method calculates the recommended service in KM
		var self = this,
			vehicleKM = guxApp.tools.removeCommas($('input#estimatedkm', self.wrapper).val()),
			serviceIntervals = guxApp.sc.cache.services.serviceinterval,
			firstService = (Math.floor(vehicleKM / guxApp.sc.cache.services.interval)) - 1,
			secondService = firstService + 1,
			withinFirstService,
			withinSecondService,
			stepOneResult;

		if (firstService < 0) {
			firstService = 0;
		} else if (firstService > 33) {
			firstService = 33;
		}

		if (secondService > (serviceIntervals.length - 1)) {
			secondService = serviceIntervals.length - 1;
		}

		// calculate the recommended service in KM that is within the service tolerance of 5,000 km
		if (vehicleKM >= (serviceIntervals[firstService].km - 5000) && vehicleKM <= (serviceIntervals[firstService].km + 5000)) {
			withinFirstService = true;
		}

		if (vehicleKM >= (serviceIntervals[secondService].km - 5000) && vehicleKM <= (serviceIntervals[secondService].km + 5000)) {
			withinSecondService = true;
		}

		if (withinFirstService && withinSecondService) {
			stepOneResult = serviceIntervals[firstService];
		} else if (withinFirstService) {
			stepOneResult = serviceIntervals[firstService];
		} else if (withinSecondService) {
			stepOneResult = serviceIntervals[secondService];
		} else {
			stepOneResult = serviceIntervals[secondService];
		}

		// return result for recommended service in KM (distance)
		return stepOneResult;

	},

	stepTwoMonths: function() {
		
		// this method calculates the recommended service in months
		
		var self = this,
			vehicleAge = self.getVehicleAge(),
			serviceIntervals = guxApp.sc.cache.services.serviceinterval,
			serviceIntMonths = guxApp.sc.cache.services.interval === 10000 ? 6 : 12,
			firstService = (Math.floor(vehicleAge / serviceIntMonths)) - 1,
			secondService = firstService + 1,
			withinFirstService,
			withinSecondService,
			stepTwoResult;

		if (firstService < 0) {
			firstService = 0;
		} else if (firstService > 33) {
			firstService = 33;
		}

		if (secondService > (serviceIntervals.length - 1)) {
			secondService = serviceIntervals.length - 1;
		}

		// calculate the recommended service in months that is within the service tolerance of 6 months
		if (vehicleAge >= (serviceIntervals[firstService].months - 6) && vehicleAge <= (serviceIntervals[firstService].months + 6)) {
			withinFirstService = true;
		}

		if (vehicleAge >= (serviceIntervals[secondService].months - 6) && vehicleAge <= (serviceIntervals[secondService].months + 6)) {
			withinSecondService = true;
		}

		if (withinFirstService && withinSecondService) {
			stepTwoResult = serviceIntervals[firstService];
		} else if (withinFirstService) {
			stepTwoResult = serviceIntervals[firstService];
		} else if (withinSecondService) {
			stepTwoResult = serviceIntervals[secondService];
		} else {
			stepTwoResult = serviceIntervals[secondService];
		}

		// return result for recommended service in months (age)
		return stepTwoResult;

	},

	bindServiceLinks: function() {

		var self = this,
			prevBtn = $('.service-links .prev', self.wrapper),
			activeBtn = $('.service-links .active', self.wrapper),
			nextBtn = $('.service-links .next', self.wrapper);

			guxApp.sc.firstlink = false;

		$('a', prevBtn).on('click', function(e) {
			e.preventDefault();

			// if user clicks on empty space where prev link is then don't do anything
			// (it'll be the 'empty' one before the first service)
			if (guxApp.sc.firstlink) {
				return false;
			}
			
			guxApp.sc.lastlink = false;

			guxApp.sc.cache.services.activeService = guxApp.sc.cache.services.prevService;

			// go to method that populates the active/current service that's just been selected
			self.populateActiveService(guxApp.sc.cache.services.prevService);
		});

		// active service (the current service displayed) has no click event
		$('a', activeBtn).on('click', function(e) {
			e.preventDefault();
		});

		$('a', nextBtn).on('click', function(e) {
			e.preventDefault();

			// if user clicks on empty space where prev link is then don't do anything
			// (it'll be the 'empty' one before the first service)
			if (guxApp.sc.lastlink) {
				return false;
			}

			// cache active service as the next service
			guxApp.sc.cache.services.activeService = guxApp.sc.cache.services.nextService;

			// go to method that populates the active/current service that's just been selected
			self.populateActiveService(guxApp.sc.cache.services.nextService);
		});

	},

	populateActiveService: function(activeService) {
		
		// this method ultimately populates all the content for the active/current service selected
		var self = this,
			serviceIntervals = guxApp.sc.cache.services.serviceinterval,
			prevService = ((activeService.number - 2) >= 0) ? serviceIntervals[activeService.number - 2] : serviceIntervals[0],
			nextService = serviceIntervals[activeService.number],
			activeBtn = $('.service-links .active', self.wrapper),
			prevBtn = $('.service-links .prev', self.wrapper),
			nextBtn = $('.service-links .next', self.wrapper),
			contentWrap = $('.active-service', self.wrapper);

		guxApp.sc.cache.services.prevService = prevService;
		guxApp.sc.cache.services.nextService = nextService;

		if (activeService.number == serviceIntervals.length) {
			guxApp.sc.finalservice = true;
		} else {
			guxApp.sc.finalservice = false;
		}

		// populates the final service for the selected vehicle
		if (guxApp.sc.finalservice) {

			var finalfired = false;

			$('.service-links a .wrap', self.wrapper).fadeOut(250, function() {

				if (!finalfired) {

					guxApp.sc.lastlink = true;

					// remove all instances of the recommended class
					// it will be re-added to the correct link very soon
					$('.service-links > div', self.wrapper).removeClass('recommended');

					nextBtn.addClass('no-service');

					// populate service links
					$('.js-kms', prevBtn).text(guxApp.tools.numberCommas(prevService.km));
					$('.js-years', prevBtn).text(prevService.agetext);

					$('.js-kms', activeBtn).text(guxApp.tools.numberCommas(activeService.km));
					$('.js-years', activeBtn).text(activeService.agetext);

					// add recommended class to the previous link
					if (guxApp.sc.cache.services.prevService.km === guxApp.sc.cache.recommended.km) {
						prevBtn.addClass('recommended');
					}

					// add recommended class to the active link
					if (activeService.km === guxApp.sc.cache.recommended.km) {
						activeBtn.addClass('recommended');
					}

					finalfired = true;

				}

			});

			$('.active-service', self.wrapper).fadeOut(250, function() {

				// force 'roadside assist' to be hidden
				$('.roadside-assistance', self.wrapper).hide();

				$('.last-service', self.wrapper).fadeIn(350);

				$('.service-links a .wrap', self.wrapper).fadeIn(350);

			});

		} else {

			var fired = false;

			$('.service-links a .wrap', self.wrapper).fadeOut(250, function() {

				if (!fired) {

					// remove all instances of the recommended class
					// it will be re-added to the correct link very soon
					$('.service-links > div', self.wrapper).removeClass('recommended');

					guxApp.sc.lastlink = false;
					nextBtn.removeClass('no-service');

					// populate service links
					if (activeService.number < 2) {
						prevBtn.addClass('no-service');
						guxApp.sc.firstlink = true;
					} else {
						prevBtn.removeClass('no-service');
						guxApp.sc.firstlink = false;

						$('.js-kms', prevBtn).text(guxApp.tools.numberCommas(prevService.km));
						$('.js-years', prevBtn).text(prevService.agetext);
					}

					$('.js-kms', activeBtn).text(guxApp.tools.numberCommas(activeService.km));
					$('.js-years', activeBtn).text(activeService.agetext);

					$('.js-kms', nextBtn).text(guxApp.tools.numberCommas(nextService.km));
					$('.js-years', nextBtn).text(nextService.agetext);

					// add recommended class to the previous link
					if (guxApp.sc.cache.services.prevService.km === guxApp.sc.cache.recommended.km) {
						prevBtn.addClass('recommended');
					}

					// add recommended class to the active link
					if (activeService.km === guxApp.sc.cache.recommended.km) {
						activeBtn.addClass('recommended');
					}

					// add recommended class to the next link
					if (typeof guxApp.sc.cache.services.nextService != 'undefined' && guxApp.sc.cache.services.nextService.km === guxApp.sc.cache.recommended.km) {
						nextBtn.addClass('recommended');
					}

					// this boolean is to stop multiple callbacks/execution of the above code
					fired = true;

				}

			}).fadeIn(350);

			$('.last-service', self.wrapper).fadeOut(250);

			// fade out the active/current service, populate the content and then fade it all back in
			$('.active-service', self.wrapper).fadeOut(250, function() {

				// populate active/current service content
				$('.js-kms', contentWrap).text(guxApp.tools.numberCommas(activeService.km));
				$('.js-years', contentWrap).text(activeService.agetext);
				$('.js-baseprice', contentWrap).text(guxApp.tools.numberCommas(self.addZero(activeService.price)));

				// methods for that apply to the active service
				// see each method for more detail
				self.roadsideAssistToggle(activeService);
				self.optionsCheckboxEvent();
				self.calcTotalPrice();
				self.buildURLforPDF();

				$('.active-service', self.wrapper).fadeIn(350);

			}).fadeIn(350);

		}

	},

	appendOptions: function() {

		// render additional options with underscore templating
		var self = this,
			optionsData = guxApp.sc.cache.services.additionaloptions,
			optionsView = $('#options-template', self.wrapper).html(),
			updatedData = optionsData;

		// loop through each price and add commas
		$.each(optionsData, function(index, value) {
			var priceStr = guxApp.tools.numberCommas(optionsData[index].price);
			updatedData[index].price = priceStr;
		});
		
		// if there are no additional options hide the options DIV
		// otherwise display the additional options through the underscore template
		if (typeof optionsData !== 'object' || optionsData.length === 0) {
			$('.options-wrap', self.wrapper).hide();
		} else {
			$('.options-wrap', self.wrapper).show();
			$('.options-list', self.wrapper).html(_.template(optionsView, {options:updatedData}));
		}

		// reset uniform inputs
		$('input', self.wrapper).uniform();

	},

	roadsideAssistToggle: function(activeService) {

		var self = this,
			roadsideAssistEl = $('.roadside-assistance', self.wrapper),
			roadsideServicesNum = roadsideAssistEl.data('services-shown');

		// simple toggle to show roadside assistance link if the service active is within the service number limit
		if (activeService.number > roadsideServicesNum) {
			$('.view-roadside-assist', self.wrapper).add(roadsideAssistEl).hide();
		} else {
			$('.view-roadside-assist', self.wrapper).add(roadsideAssistEl).show();
		}

	},

	optionsCheckboxEvent: function() {

		var self = this;

		$('.js-totalprice', self.wrapper).text(guxApp.tools.numberCommas(guxApp.sc.cache.services.activeService.price));

		// update total price when additional options are selected
		$('.options-list input', self.wrapper).on('click', function() {

			self.calcTotalPrice();
			self.buildURLforPDF();

			// add class for parent so option price can be styled when checked
			if ($(this).parent().hasClass('checked')) {
				$(this).parents('li').addClass('option-checked');
			} else {
				$(this).parents('li').removeClass('option-checked');
			}

		});		

	},

	calcTotalPrice: function() {

		var self = this,
			boxes = $('.options-list li .checked'),
			optionPrices = [],
			optionsTotal = 0,
			total;

		// loop through each option and add price to 'optionPrices' array with removed commas
		boxes.each(function() {
			var price = $(this).parents('li').find('.js-price').text(),
				cleanPrice = guxApp.tools.removeCommas(price);

			optionPrices.push(parseFloat(cleanPrice));
		});

		// loop through additional option price array and add the price to the running total
		$.each(optionPrices, function() {
		    optionsTotal += this;
		});

		// add selected additional total to standard base price
		total = optionsTotal + guxApp.sc.cache.services.activeService.price;

		// inject total service price into HTML with added commas
		$('.js-totalprice', self.wrapper).text(guxApp.tools.numberCommas(self.addZero(total)));

	},

	buildURLforPDF: function() {

		var self = this,
			vehicleID = guxApp.sc.cache.services.id,
			intervalID = guxApp.sc.cache.services.activeService.id,
			selOptionsStr,
			otherOptionsStr,
			allOptions = $('.options-list', self.wrapper).find('li'),
			url = guxApp.sc.urlPdf,
			validDateStr = Date.today().addDays(30).toString('ddMMyyyy');

		// loop through the options of the active service and build two strings
		// one string for the selected options (selOptionsStr)
		// another string for the non-selected options (otherOptionsStr)
		$.each(allOptions, function(index, value) {

			if (allOptions[index].firstChild.firstChild.className === 'checked') {

				if (typeof selOptionsStr !== 'undefined') {
					selOptionsStr = selOptionsStr + '!' + allOptions[index].firstChild.id.replace('uniform-option', '');
				} else {
					selOptionsStr = allOptions[index].firstChild.id.replace('uniform-option', '');
				}

			} else {

				if (typeof otherOptionsStr !== 'undefined') {
					otherOptionsStr = otherOptionsStr + '!' + allOptions[index].firstChild.id.replace('uniform-option', '');
				} else {
					otherOptionsStr = allOptions[index].firstChild.id.replace('uniform-option', '');
				}

			}

		});

		// if no options are selected create an empty string
		if (typeof selOptionsStr == 'undefined') {
			selOptionsStr = '';
		}

		// if there are no options not selected, create an empty string
		if (typeof otherOptionsStr == 'undefined') {
			otherOptionsStr = '';
		}

		// create a URL for the PDF based on the options selected and not selected for the current vehicle and service
		url = url.replace('{vehicleid}', vehicleID).replace('{intervalid}', intervalID).replace('{selectedoptions}', selOptionsStr).replace('{otheroptions}', otherOptionsStr).replace('{currentdate}', validDateStr);

		// encode url
		var encodedURL = encodeURI(url);

		if ($('form[name=pdfForm]', self.wrapper)[0]) {
			$('form[name=pdfForm]', self.wrapper).attr('action', encodedURL);
		} else {
			$('.button.print-pdf', self.wrapper).wrap('<form action="' + encodedURL + '" method="post" name="pdfForm"></form>');
		}

		$('.button.print-pdf', self.wrapper).off('click').on('click', function(e) {
			e.preventDefault();

			if (guxApp.viewport.view === 'tablet') {
				$('form[name=pdfForm]', self.wrapper).attr('target', '_blank');
			}
			// submit form which directs user to the PDF
			document.forms.pdfForm.submit();
		});

	}

};

$(function() {

	// run service calculator init function if "service-calc" class found on page load
	if ($('.service-calc')[0]) {
		guxApp.sc.vehicles.init();
	}

});

})(jQuery);


/**
 * FF's first picture implementation is static and does not react to viewport changes, this tiny script fixes this.
 */
(function() {
	/*jshint eqnull:true */
	var ua = navigator.userAgent;

	if ( window.HTMLPictureElement && ((/ecko/).test(ua) && ua.match(/rv\:(\d+)/) && RegExp.$1 < 41) ) {
		addEventListener("resize", (function() {
			var timer;

			var dummySrc = document.createElement("source");

			var fixRespimg = function(img) {
				var source, sizes;
				var picture = img.parentNode;

				if (picture.nodeName.toUpperCase() === "PICTURE") {
					source = dummySrc.cloneNode();

					picture.insertBefore(source, picture.firstElementChild);
					setTimeout(function() {
						picture.removeChild(source);
					});
				} else if (!img._pfLastSize || img.offsetWidth > img._pfLastSize) {
					img._pfLastSize = img.offsetWidth;
					sizes = img.sizes;
					img.sizes += ",100vw";
					setTimeout(function() {
						img.sizes = sizes;
					});
				}
			};

			var findPictureImgs = function() {
				var i;
				var imgs = document.querySelectorAll("picture > img, img[srcset][sizes]");
				for (i = 0; i < imgs.length; i++) {
					if (imgs[i].currentSrc && !imgs[i].complete) {
						removeEventListener("resize", onResize);
						break;
					}
					fixRespimg(imgs[i]);
				}
			};
			var onResize = function() {
				clearTimeout(timer);
				timer = setTimeout(findPictureImgs, 99);
			};

			dummySrc.srcset = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";

			return onResize;
		})());
	}
})();


/*
Author: 		Jessie Biros
File name: 		guxNavigation.js
Description: 	global navigation functionalities and animations
				
Dependencies: 	jQuery
*/

(function($){
	var guxNav = {
		init: function(){
			if (!$("#gux-header").length) {return;}

			var header = $('#gux-header'),
				headerWrapper = $('.header-wrapper', header),
				primaryNav = $('.primary-navigation', header),
				primaryNavLarge = $(".primary-navigation-large",headerWrapper),
				tabs = $('.primary-navigation > ul', header),
				tabContents = $('.primary-navigation > .tabs-content', header),
				bilingualClick = $(".user-action-links .bilingual-menu .option > a", headerWrapper),
				accountLink = $(".user-action-links .account-link",header),
				isMobile = guxApp.tools.isMobile(),
				headerModal = $(".header-pop-up"),
				//clone = $('.header-wrapper', header).clone(),
				body = $('body');

				

			// this will trigger the burger icon on mobile
			// burger icon event listener
			$('.burger-icon > div', header).on('click',function(){
				var directHeaderWrapper = $("#gux-header > .wrapper > .header-wrapper")
				$('> .content.active', tabContents).removeClass('active');
				//headerWrapper.removeClass('stick');
				if(directHeaderWrapper.length > 1){
					directHeaderWrapper.first().remove();
				}
				$('> li', tabs).removeClass('active');
				primaryNav.removeAttr("style"); 
				header.removeClass('show-panel');
				header.toggleClass('show');
				$(this).parent().toggleClass('open');
				body.toggleClass('no-scroll');

			});

			// function that will run when tabs are being triggered on mobile view
			$("li > a",tabs).on("click", function(event){
				var self = $(this),
					target = self.attr("href"),
					parent = self.parent(),
					tabsWrapper = self.parents(".tabs-mob").next(".tabs-content");
				if(guxApp.viewport.view == "mobile"){
					if(self.parent().hasClass("open-panel")){
						event.preventDefault();
						header.addClass('show-panel');
						parent.siblings().removeClass("active");
						parent.addClass("active");
						tabsWrapper.children(".content").removeClass("active");
						tabsWrapper.children(target).addClass("active");
						setTimeout(setHeight,31);
					} else {
						return true;
					}
				}	
			});

			//callback function after css3 animation/transition finished
			// this is for the animation on mobile (e.g. the car transition inside the accordion)
			$(tabContents).bind('oanimationend transitionend animationend webkitAnimationEnd', function() { 
			   if(header.hasClass("show-panel")){
			   	setHeight();
			   }
			   
			});

			

			// event for hiding the 2nd panel [back button mobile]
			$('.hide-panel', tabs).on('click',function(){
				header.removeClass('show-panel');
				primaryNav.removeAttr("style");
				return false;
			});

			// slide up animation of the items inside accordion on mobile 
			$(".tab-nav", header).on("click", function(){
				var activeTab = $(".accordion-block .tab-item .tab-nav.open", tabContents),
					accContents = $(".tab-data > ul > li");

				if(activeTab.length > 0){
				    activeTab.next().find(accContents).each(function(i,el){
				      setTimeout(function(){
			      		$(el).animate({
				       		"margin-top" : 0,
				       		opacity : 1
				        },300);
				      },100 + (i * 100));
				    }).promise().done(function(){
				    	activeTab.parent().siblings(".tab-item").find(accContents).each(function(){
					       $(this).css({
					       		"margin-top" : "30%",
					       		"opacity" : "0"
					       });
					    });
				    });
				 } 

				 else{
				 	$(this).next().find(accContents).each(function(){
				      $(this).animate({
				       		"margin-top" : "30%",
				       		opacity : 1
				       },300);
				    });
				 }
			});

			// event listener when the animation of accordion is finished
			// the publish is in accordion.js (on complete)
			$.subscribe('accordion-tab-nav-open', function(e,tabNavClicked){
				var activeTab = $(".accordion-block .tab-item .tab-nav.open", tabContents),
					tab = $(".accordion-block .tab-item .tab-nav", tabContents),
					accContents = $(".tab-data > ul > li");

				// if the accordion tab clicked is outside the primary navigation then do not continue
				if (!($(tabNavClicked).parents('.primary-navigation').length)) {
					return;
				}

				if(activeTab.length === 0){
					tab.next().find(accContents).each(function(){
				       $(this).css({
				       		"margin-top" : "30%",
			       			"opacity" : "0"
				       });
				    });
				}

				// needs a delay to make sure everything is complete to get correct height
				setTimeout(function() {
					setHeight();
				},850);
					
				if($(tabNavClicked).hasClass("open")){
					
					header.animate({scrollTop:0},{
						duration: 100,
						complete: function(){
							var scrollVal = $(tabNavClicked).offset().top;
							header.animate({scrollTop:scrollVal},600);
						}
					});
					
				}
			});

			// this will get the height of the wrapper and assign it to 
			// primaryNav [mobile] to adjust the border to the bottom
			function setHeight(){
				primaryNav.removeAttr("style"); 
				var contHeight = guxNav.getWrapperHeight();
			    primaryNav.height(contHeight);
			}

			// on resize event [transition from mobile to desktop and/or when 
			// resizing the height on small view]
			var debouncedResizeHeight = _.debounce(function() {
					if(guxApp.viewport.view == "mobile"){
						headerModal.css("display","none");
						if($(header).hasClass("show-panel")){
							setHeight();
						}
					}else{
						//setToLeft();
						if($(".open-panel",primaryNavLarge).hasClass("opened")){
							var width = $(window).width();
							headerModal.css("display","block");

							// this is for wrapping of columns inside the row
							// if the view is on tablet, it will get all the columns and wrap it inside a row by 3's
							if(width >= 768 && width <= 980) {
			                    equalizeModelHeight($(".open-panel.opened",primaryNavLarge).children(".nav-panel").find(".links-list > .columns"),3);
			                }else{
			                	var addedRow = $('.primary-navigation-large .added-row')
			                	 if($(addedRow).length){
				                    addedRow.contents().unwrap();
				                }
			                }
						}

						$(".burger-icon").removeClass("open");
						if(!$(header).hasClass("global-nav-large-show")){
							body.removeClass('no-scroll');
						}
					}
	        },100);
			
			// call the window resize event
			$(window).on('resize', debouncedResizeHeight);

			// close the search box and/or the global navigation for large view in case 
			// a click outside its parent div will be triggered
			$("html").on("click", function(e){
				var target = e.target;

				if(!($(e.target).hasClass('search-input') || $(e.target).parents().hasClass('search-input'))){
					$(".search-input", header).hide();
				}

				if(!($(e.target).parents().hasClass("primary-navigation-large"))){
					closeNavLarge();
				}

				if(!$(target).parents().hasClass("exempt")){
					if((headerModal.css("display") != "none")){
						$("body").removeClass("no-scroll");
						headerModal.fadeOut();
					}
				}
			});


			// search box toggle
			// show and hide the search panel in global navigation for large view
			$(".search-box > a").on("click", function(e){
				e.preventDefault();
				var searchInput = $(".search-input");
				if(($(this).next(searchInput).css("display") == "none")){
					$(this).next(searchInput).show().find("input[name=searchKeyword]").focus();
					headerModal.fadeIn();
				}else{
					$(this).next(searchInput).hide();
					headerModal.fadeOut();
				}
				
				closeNavLarge();
				e.stopPropagation();
			});

			// detect if desktop or not then assign event listener
			// for Bilingual Language
			// this will attach :hover for dektop view and on("click") if tablet view
			if(isMobile === null){
				$(bilingualClick).hover(function(e){
					e.preventDefault();
				 	$(this).next().toggle();
				});

				$(bilingualClick).next().hover(function(){
					$(this).toggle();
				});
				
			} else{
				$(bilingualClick).on("click", function(e){
					e.preventDefault();
				 	$(this).next().toggle();
				 	return true;
				});
			}
			
			// hide dropdown initially
			$(".nav-panel .nameplate", primaryNavLarge).hide();
			$(".nav-panel .wrapper", primaryNavLarge).hide();

			// event listener for primary navigataion links list
			// this will trigger the drop down if there is a nav panel inside
			$(".open-panel > a", primaryNavLarge).on("click",function(e){
				var self = $(this),
					siblings = self.parent().siblings(),
					navPanel = self.siblings(".nav-panel");

					navPanel.css("top","49px");

				//check first if there's a dropdown
				if((self.siblings(".nav-panel").length)){
					e.preventDefault();
					siblings.removeClass("opened");
					siblings.find(".nav-panel .nameplate").css("display","none");
					siblings.find(".nav-panel .wrapper").css("display","none");
					siblings.find(".nav-panel .links-list").css("display","none");
					self.parent().toggleClass("opened");

					if (self.parent().hasClass("opened")){
						headerModal.one().fadeIn();
						if(self.parent().hasClass("withTabs")){
							navPanel.find(".wrapper").slideDown(150, function(){
								navPanel.find(".nameplate").slideDown(100);
							});
						}else{
							navPanel.find(".links-list").slideDown("fast");
						}

					} else{
						headerModal.one().fadeOut();
						if(self.parent().hasClass("withTabs")){
							navPanel.find(".nameplate").slideUp(150, function(){
								navPanel.find(".wrapper").slideUp(100);
							});
						}else{
							navPanel.find(".links-list").slideUp("fast");
						}
					}
				} 

				// this will wrap the columns to a row
				// it will wrap it by 3's
				if(self.parent().hasClass('opened')){
					equalizeModelHeight($(self.next(".nav-panel").find(".links-list > .columns")));
				}else{
					var addedRow = $('.primary-navigation-large .added-row');
					 if($(addedRow)){
	                    addedRow.contents().unwrap();
	                }
				}
			});
			
			// function that will call the add row with parameter
			function equalizeModelHeight(el){
                var width = $(window).width(),
                    modelElem = el;
                if(width >= 768 && width <= 980) {
                    addRow(modelElem,3);
                }
            }

            // will wrap the columns by 3s to row
			function addRow(elem, numOfDivs){
				for(var i = 0; i < elem.length; i+=numOfDivs) {
                  elem.slice(i, i+numOfDivs).wrapAll("<div class='row added-row'></div>");
                }
			}

			//function that closes the nav dropdown
			function closeNavLarge(){
				var openPanel = $(".open-panel", ".primary-navigation-large"),
					panelWithTabs = $(".open-panel.opened.withTabs",primaryNavLarge),
					openPanelOpened = $(".open-panel.opened",primaryNavLarge);

				if(panelWithTabs.length > 0){
					openPanelOpened.children(".nav-panel").find(".nameplate").slideUp(300, function(){
						panelWithTabs.children(".nav-panel").find(".wrapper").slideUp("fast", function(){
							openPanel.removeClass("opened");
						});
					});
				}
				else if((openPanelOpened.length > 0)){
					openPanelOpened.children(".nav-panel").find(".links-list").slideUp("fast", function(){
						openPanel.removeClass("opened");
					});
				}
			}
			
			guxNav.guxNavTab($(".nav-tab > a",".nav-panel"));

			//guxNav.is_loggedin();
			$.subscribe('profile-done', (function(){
				if(typeof guxPersonalisation.components !== "undefined") {
					if(guxPersonalisation.psn.profile.authState === "OW"){
						$("a span:last-child",accountLink).attr("style", "display: none !important");
					}
				}
			}));

			// var sticky_relocate = _.debounce(function() {
			// 	var directHeaderWrapper = $('#gux-header > .wrapper > .header-wrapper');
			//     var window_top = header.scrollTop();
			//     var div_top = directHeaderWrapper.offset().top;

			//     console.log("len : ", directHeaderWrapper.length);
			    
			//     if(header.hasClass('show')){
			//     	if (window_top > div_top) {
			// 	        directHeaderWrapper.addClass('stick');
				        
			// 	        if(directHeaderWrapper.length < 2){
			// 	        	$('.wrapper', header).prepend(clone);
			// 	        }
				       
			// 	    } else {
			// 	    	if(directHeaderWrapper.length > 1){
			// 	    		directHeaderWrapper.first().remove();
			// 	    	}
			// 	        directHeaderWrapper.removeClass('stick');
			// 	    }
			//     }
			    
			// },50);

			// header.scroll(sticky_relocate);
			
		},

		getWrapperHeight: function(){
			var wrapper = $("#gux-header > .wrapper"),
				headerWrapper = $(".header-wrapper",wrapper);

				return(wrapper.outerHeight(true) - headerWrapper.outerHeight(true));
		},

		guxNavTab: function(e){
			$(e).on("click", function(e){
				e.preventDefault();
				var self = $(this),
					parent = $(this).parent(),
					index = self.parent().index(),
					subPanels = parent.parent().next(".wrapper").find(".inner-panels").children(".sub-panel");

				parent.siblings().removeClass("active");
				parent.addClass("active");
				subPanels.removeClass("active").eq(index).addClass("active");
			});
		},

		getBottom: function(e){
			return $(e).outerHeight(true);
		}
	};

	$(function(){
		guxNav.init();
	});

})(jQuery);


/*
Author: 		Gianfranco del Mundo
File name: 		faqSearch.js
Description: 	Predictive Search and FAQ Search JS
Dependencies: 	jQuery, typeahead.js

Example HTML: 	
*/
(function($){
	var search = {
		init: function(){
			var searchPanel = $('.faq-search');
			if(!searchPanel.length){ return; }

			//Hide the search counter result
			//$('.filter-count').hide();

			this.initConfig();
			this.initTypeAhead();
			this.listenDropdownEvent();
			this.addMoreResultsEvent();
			//Change the underscore template variable to search.
			 _.templateSettings.variable = "search";


		},
		//Hide when list of topics is greater than 15
		addMoreResultsEvent: function(){
			var elemOfTopics = $('.list-content ul li');
			var noOfTopics = elemOfTopics.length,
				buttonEl = $('.list-content .button');

			if(noOfTopics > 15){	
				$(elemOfTopics).filter(':gt(15)').hide();
				$(buttonEl).show();
			} else {
				$(buttonEl).hide();
			}

			$(buttonEl).click(function(e){
				e.preventDefault();
				$(buttonEl).hide();
				$(elemOfTopics).filter(':gt(15)').slideDown();
			});
		},
		//Add an Event Listener to the dropdown to populate the second dropdown
		listenDropdownEvent: function(){
			if(!$('.dropdown-topics').length){ return;}

			$('#category').change(function(e) {
				if(!(isNaN($("#category option:selected").val()))){
				  	search.initDropdown($("#category option:selected").val());
				  	$('#subcategory option').not(':eq(0)').remove();	
				} else {
					$('#subcategory').attr('disabled','disabled');
					$('#subcategory').prev().attr('disabled','disabled');
				}
			});

			$('#subcategory').change(function(e) {
			  	$('#topic-dropdowns .button').attr("href", $("#subcategory option:selected").data().value);
			  	//for omniture value
			  	if($("#category option:selected").text()&& $("#subcategory option:selected").text()){
				  	var data_cat = $("#category option:selected").text().toLowerCase();
				  	var data_subcat = $("#subcategory option:selected").text().toLowerCase();
				  	$('#topic-dropdowns .button')
				  		.attr('data-cat',data_cat)
				  		.attr('data-subcat',data_subcat);
			  	}
			});

			$('#subcategory').attr('disabled','disabled');
			$('#subcategory').prev().attr('disabled','disabled');

			var submitButton = $('#topic-dropdowns button');

			submitButton.click(function(e){
				if(submitButton.attr('href') == ''){
					e.preventDefault();
				
				}
			});
		},
		// Initialize URLs to be used for AJAX Calls; init Bloodhound is for the predictive Search initialization
		initConfig:function(){
			//Get Urls Ready
			var urls = $('#faq-services').embeddedData(),
				siteConfig = guxApp.tools.commonConfigData();

			var urlQuery = urls['faq.queryservices'],
				urlTopic = urls['faq.topicitems'],
				site = siteConfig.site;
				//Replace the SITE url based on box
				search.urlQuery = urlQuery.replace('{site}', site);
				search.urlTopic = urlTopic.replace('{site}', site);

			this.initBloodHound();

			//If no dropdown present, don't compile underscore
			if(!$('.dropdown-topics').length){ return;}

			this.config = {
				selectedIndex:'',
				selectedId:'',
				dropdown:{},
				templateDropdown: _.template($('#subdropdown').html())
			};
		},
		//Define and initialize Bloodhound Suggestion Engine
		initBloodHound: function(){
			//Define Suggestion Engine
			this.topics = new Bloodhound({
			    datumTokenizer: function (datum) {
			        return Bloodhound.tokenizers.whitespace(datum.value);
			    },
			    queryTokenizer: Bloodhound.tokenizers.whitespace,
			    remote: {
			    	//Will change the site url later on REST;
			        url: search.urlQuery,
			        filter: function (topics) {
			        	return $.map(topics.topics, function(topic) { 
						  return { 
						   	value: topic.title,
						   	url: topic.url
						  }; 
						});
			        }
			    },
			    limit:5
			});

			// Initialize the Bloodhound suggestion engine
			this.topics.initialize();
		},
		//Initialize Typeahead
		initTypeAhead: function(){
			var self = this;

			$('#faq .typeahead').typeahead({
					minLength:3
				},
				{
				name: 'value',
				displayKey: 'value',
				source: self.topics.ttAdapter(),
				templates: {
					//For now the Text is hardcoded in JS, but will change this later after the code review
					empty:function(){
						//$('#faq .error').slideDown();
					},
				    suggestion: function(data) { // data is an object as returned by suggestion engine
				        return '<div class="tt-suggest-topic"><a href="'+ data.url  +'">' + data.value + '</a></div>';
				    }
				}
			});
		},
		//Populate Second Dropdown
		initDropdown: function(optionId){
			var self = this;
			this.getData(search.urlTopic.replace('{topicId}',optionId),function(data){

				$('#subcategory').attr('disabled', false);
				$('#subcategory').prev().attr('disabled', false);

				self.config.dropdown = data.items;
				$('#subcategory').append(self.config.templateDropdown( self.config ));
				$.uniform.update();
			},
			function(e, extStatus){
			});
		},
		/*
			A reusable function to get the data using AJAX
		*/
		getData: function(url, onSuccess, onError) {
			$.ajax({
				url: url,
				async: true,
				cache: false,
				dataType: 'json',
				headers: {
					'Cache-Control': 'no-cache'
				},
				success: function(data) {				
					onSuccess(data);
				},
				error: function(e, extStatus) {
					onError(url, e, extStatus);
				}
			});
			
		}

	};

	$(function() {
		search.init();
	});

})(jQuery);


/*
Author: Gianfranco del Mundo
File name: paymentPresenter.js
Description: 

Dependencies: 
*/

(function($) {
	
	var pp = {
		init : function (){
			this.ppBlock = $('.payment-presenter');
			if(!this.ppBlock.length){return;}
			
			 _.templateSettings.variable = "pp";
			
			//jQuery code snippet to get the dynamic variables stored in the url as parameters and store them as JavaScript variables ready for use with your scripts
			var self = this;


			$.urlParam = function(name){
			    var results = new RegExp('[\?&]' + name + '=([^&#]*)').exec(window.location.href);
			    if (results==null){
			       return null;
			    }
			    else{
			       return results[1] || 0;
			    }
			}

			self.nameplateId = '';
			self.initRevealModel();
			self.registerCloseShowroom();	
			self.initMiniShowroom();
			self.initConfig();
			self.initDropdown();
			self.updateBox(".change-model li", "value");
			self.updateBox("#terms-dropdown .dropdown-list li", "terms");
			self.initRestService();
			self.initPriceFormatter();
			guxApp.innerPopup.init();

			//Subscribe done template compile
			$.subscribe('template-compiled', function(){
				//Show or Hide Standard or Subvented Block whichever is available
				if(self.config.derivativeData.terms[self.config.termIndex]){
					var standardBool = _.has(self.config.derivativeData.terms[self.config.termIndex], 'standard');

					if(standardBool){
						$('.payment-carousel .slides .item.standard',self.ppBlock).parent().css({'display':'inline-block'});
					} else {
						$('.payment-carousel .slides .item.standard',self.ppBlock).parent().css({'display':'none'});
					}
				}

				if(self.config.derivativeData.terms[self.config.termIndex]){
					var subventedBool = _.has(self.config.derivativeData.terms[self.config.termIndex], 'subvented');

					if(subventedBool){
						$('.payment-carousel .slides .item.subvented',self.ppBlock).parent().css({'display':'inline-block'});
					} else {
						$('.payment-carousel .slides .item.subvented',self.ppBlock).parent().css({'display':'none'});
					}
				}

				$('.loading-icon',self.ppBlock).hide();
				//Show Carousel block after html is rendered.
				$('.payment-carousel').slideDown();
				//To recalculate sizing in FlexSlider.
				$('.flexslider').trigger('resize');
			});
			
			
		},
		initConfig : function(){
			if(!$('#payment-block').length){return;}
        	this.config = {
	        	modelData:{},
	        	derivativeData:{},
	        	modelId:'',
	        	derivativeId:'',
	        	derivativeIndex:0,
	        	termIndex:0,
	        	site:'',
	        	emailBody:'',
	        	emailSender:'',
	        	groupingSep:'',
	        	currencySymbol:'',
	        	templateModel: _.template($('#payment-block').html()),
	        	templateTerms: _.template($('#terms-block').html()),
	        	templateCarousel: _.template($('#carousel-block').html()),
	        	templateSubvented: _.template($('#subvented-block').html()),
	        	templateAccordion: _.template($('#accordion-temp').html()),
	        	templateActionBar: _.template($('#action-bar').html())
        	}
        },
		initRestService : function(){
			//load configuration from template and get the urls ready
			var urls = $('#payment-services').embeddedData(),
				siteConfig = guxApp.tools.commonConfigData(),
				selectTexts = $('#payment-text').embeddedData(),
				mpzConfig = $('#mpz-config').embeddedData();

			var urlModel = urls['pp.model'],
				urlDerivatives = urls['pp.derivative'],
				site = siteConfig.site;
				this.config.site = site;
			// Check if theURL if it's coming from the BnP if not then show miniShowroom
			var bnpModelId = $.urlParam('ctx');

			this.config.emailBody = selectTexts['email.body'];
			this.config.emailSender = selectTexts['email.sender'];

			this.config.groupingSep = mpzConfig['groupingSeparator'];
			this.config.currencySymbol = mpzConfig['currencySymbol'];

			pp.urlModel = urlModel.replace('{site}', site);	
			pp.urlDerivatives = urlDerivatives.replace('{site}', site);

			if(bnpModelId){
				this.populateModelSelect(pp.urlModel.replace('{modelid}',bnpModelId.substring(4)));
				this.config.modelId = bnpModelId.substring(4);

			} else {
				$('#mini-showroom').foundation('reveal', 'open');
			}
		},
		/*
		* Add event listener to handle reveal modal behavior
		*/
		initRevealModel: function(){
			$(document).on('opened.fndtn.reveal', '[data-reveal]', function () {
				guxApp.innerPopup.init({
					container:'.vehicle-list',
					popup:'.inner-popup'
				});
			});

			$(document).on('closed.fndtn.reveal', '[data-reveal]', function () {
				guxApp.innerPopup.init({
					container:'#page-wrapper',
					popup:'.inner-popup'
				});

				guxApp.innerPopup.init();
			});


			$(document).on('close.fndtn.reveal', '[data-reveal]', function () {
				$('.inner-popup.active .close-popup').trigger('click');
			});

			$(document).on('open.fndtn.reveal', '[data-reveal]', function () {
				$('.inner-popup.active .close-popup').trigger('click');
			});

			if(!$('.mini-showroom').length){return;}
			$('.vehicle-footer').contents().remove();
		},
		/*
		* Populate the Nameplate SelectBox
		*/
		populateModelSelect: function(nameplateId) {

			var self = this;

			// show loading gif - Placeholder for Loading later
			
			// AJAX call - populate Nameplate selectbox
			pp.getData(nameplateId, function(data) {
				// cache the results
				self.config.modelData = data.nameplate;
				self.populateTermsSelect(self.config.modelData.derivatives[self.config.derivativeIndex].id);
				//omniture
				 if( window._da && window._da.om && ND && ND.omniture ) {
					 _da.nameplate = {year: self.config.modelData.year, name: self.config.modelData.analyticsName, cat: self.config.modelData.analyticsCategory, id: self.config.modelId};
				 }
			},
				function(e, extStatus) {
					// hide loading gif - Placeholder
					
					// on AJAX error...
					// pp.vehicles.wrapper.prepend('<p class="error">' + pp.selectTexts['error.url.vehicles'] + '</p>');

					// disable first select
					// $('select#year', self.wrapper).attr('disabled', 'disabled').parents('.group').addClass('disabled');
			});
			

		},
		
		/*
		* A function the fills up the terms based on the modelId
		*/
		populateTermsSelect: function(modelId) {
			// show loading gif - Placeholder for Loading later
			// AJAX call - populate Terms selectbox
			if(!modelId){return;}
			var self = this;

			self.config.derivativeId = modelId;

			pp.getData(pp.urlDerivatives.replace('{derivativeid}',modelId), function(data) {

				// cache the results
				//pp.cacheTerms = data.derivative;
				self.config.derivativeData = data.derivative;
				if (guxApp.viewport.view === "mobile" && self.config.derivativeData.hotDealSmobUrl !=null) {
					self.config.derivativeData.latestOfferUrl = self.config.derivativeData.hotDealSmobUrl;
				}else{
					self.config.derivativeData.latestOfferUrl = self.config.derivativeData.hotDealUrl;
				}

				$('.model-container',self.ppBlock).html(self.config.templateModel( self.config ));
				$('#terms-dropdown .group .terms-container',self.ppBlock).html(self.config.templateTerms( self.config ));

				//Hide if no property (Standard or Subvented Published)
				$('.payment-carousel .slides .item.standard',self.ppBlock).html(self.config.templateCarousel( self.config ));
				$('.payment-carousel .slides .item.subvented',self.ppBlock).html(self.config.templateSubvented( self.config ));
				$('.accordion-block .payment-details',self.ppBlock).html(self.config.templateAccordion( self.config ));
				$('.action-holder',self.ppBlock).html(self.config.templateActionBar( self.config ));

				$.publish('template-compiled');

				},
				function(e, extStatus) {
					// hide loading gif - Placeholder
					// on AJAX error...
					// pp.vehicles.wrapper.prepend('<p class="error">' + pp.selectTexts['error.url.vehicles'] + '</p>');

					// disable first select
					// $('select#year', self.wrapper).attr('disabled', 'disabled').parents('.group').addClass('disabled');
			});

		},
		/*
			A reusable function to get the data using AJAX
		*/
		getData: function(url, onSuccess, onError) {
			$.ajax({
				url: url,
				dataType: 'json',
				success: function(data) {				
					onSuccess(data);
				},
				error: function(e, extStatus) {
					onError(url, e, extStatus);
				}
			});
			
		},
		initMiniShowroom : function(){
			var showroomBlock = $('.mini-showroom'),
				self = this;

			$('.section-cars',showroomBlock).on("click","a",function(e){
				if(!($(e.target).data('disclosure'))){
					e.preventDefault();
					//Get Nameplate ID from mini showroom then cache it 
					self.nameplateId = $(this).closest('.vehicle').find('.vehicle-content').data().nameplateid;
					self.config.modelId = self.nameplateId;
					$('#mini-showroom .showroom-error').fadeOut();
					$('#mini-showroom').foundation('reveal', 'close');
					//Re-Init Rest URLs
					self.populateModelSelect(pp.urlModel.replace('{modelid}',self.config.modelId));	
					self.resetIndexes();
				} else {

				}
			});

			//Update inner-popup position based on mini-showroom
			$.subscribe('popup-opened', function(){
				if(guxApp.innerPopup.setting.container == ".vehicle-list"){
					var popupPosX = $('.inner-popup.active').css('top'),
						computedPosX = popupPosX.substr(0,popupPosX.length-2) - $(window).height()/4 + 'px';
						console.log(computedPosX);
						$('.inner-popup.active').css({top:computedPosX});
				}
			});

		},
		initDropdown : function(){
			$('.payment-presenter').on("click",".sort-dropdown",function(e){
				e.preventDefault();
				$(this).toggleClass("active");
			});
		},
		resetIndexes : function(){
			this.config.termIndex = 0;
			this.config.derivativeIndex = 0;
		},
		updateBox : function(elem, prop) {
			var self = this;

			$('.payment-presenter').on("click",elem, function(e){
				e.preventDefault();
				//active current option
				$(".sort-dropdown li",self.container).removeClass("active");
				$(this).addClass("active");
				$(this).parent().prev().html('<span></span><a href="#">' + $("> a",this).text() + '</a>');
				if(prop === "value"){	
					self.config.termIndex = 0;
					self.config.derivativeIndex = $(".change-model .sort-dropdown li",self.container).index(this);
					$('.model-container',self.ppBlock).html(self.config.templateModel( self.config ));
					$('#terms-dropdown .group .terms-container',self.ppBlock).html(self.config.templateTerms( self.config ));
					self.populateModelSelect(pp.urlModel.replace('{modelid}',self.config.modelId));	
					self.renderPartials();
				} else {
					self.config.termIndex = $("#terms-dropdown .sort-dropdown li",self.container).index(this);
					self.renderPartials();
				}

				$.publish('template-compiled');
			});
		},
		renderPartials : function(){	
			var self = this;

			$('.payment-carousel .slides .item.standard',self.ppBlock).html(self.config.templateCarousel( self.config ));
			$('.payment-carousel .slides .item.subvented',self.ppBlock).html(self.config.templateSubvented( self.config ));
			$('.accordion-block .payment-details',self.ppBlock).html(self.config.templateAccordion( self.config ));
			$('.action-holder',self.ppBlock).html(self.config.templateActionBar( self.config ));
		},
		registerCloseShowroom : function(){
			var showroomCont = $('#mini-showroom'),
				self = this;

			$('.heading .icon-close', showroomCont).click(function(){

				// check if a derivative has already been selected
				// if not then show error
				if (typeof self.config.derivativeId === 'string') {
					self.showroomError();
				} else {
					$(showroomCont).foundation('reveal', 'close');
				}
				
			});

			$('body').on('click', '.reveal-modal-bg', function() {

				// check if a derivative has already been selected
				// if not then show error
				if (typeof self.config.derivativeId === 'string') {
					self.showroomError();
					return false;
				}
				
			});
		},
		showroomError : function(){
			$('#mini-showroom .showroom-error').fadeIn();
		},
		initPriceFormatter : function(){
			var self = this;
			guxApp.priceFormatter.initialise({
				formatString: self.config.currencySymbol,
				thousandsSeparator: self.config.groupingSep
			});
		}
	};

	$(function(){
		pp.init();
	});

	//jQuery mobile will add "ui-link" to "a" tag which cause style issue.
	$(document).on("pageinit", function(){
		$(".showroom-container .ui-link").removeClass('ui-link');
	});

}(jQuery));


/*
Author: 		Brett Chaney
File name: 		guxFooter.js
Description: 	GUX Footer disabling accordion tabs on specific screen sizes 
				GUX Footer addthis sharing initialisation
Dependencies: 	jQuery and underscore.js
*/

var guxApp = guxApp || {};

(function($){

guxApp.footer = {

	init: function() {

		var self = this;
			self.wrapper = $('#gux-footer');
			self.windowWidth = $(window).width();
		
		// go no further if GUX footer wrapper is not found on page
		if (!self.wrapper.length) {return;}

		self.disableTabs();
		self.disableTelDesktop();

		setTimeout(function(){
			self.centerCols();
		}, 500);


		// window resize event for GUX footer
		$(window).on('resize', _.debounce(self.resizeFuncs, 250));

		// load addthis sharing functionality
		guxApp.shareWidget.init("#gux-footer .social-icons");

	},

	resizeFuncs: function() {
		var newWindowWidth = $(window).width();

		if (newWindowWidth !== guxApp.footer.windowWidth) {
			guxApp.footer.disableTabs();
			guxApp.footer.disableTelDesktop();
			guxApp.footer.centerCols();
		}

		guxApp.footer.windowWidth = $(window).width();
	},

	disableTabs: function() {

		var self = this;

		if ($(window).width() > 767 && $(window).width() < 990) {

			// do this for tablet (768px - 989px)
			$('.site-links .tab-1 .tab-nav, .site-links .tab-2 .tab-nav', self.wrapper).addClass('disable');
			$('.site-links .tab-3 .tab-nav, .site-links .tab-4 .tab-nav, .site-links .tab-5 .tab-nav, .site-links .tab-6 .tab-nav', self.wrapper).removeClass('disable');
			$('.site-links .tab-1 .tab-nav', self.wrapper).removeClass('open');
		} 
		else if ($(window).width() > 989) {

			// do this for desktop (990px +)
			$('.site-links .tab-item .tab-nav', self.wrapper).addClass('disable');
		} else {

			// do this for mobile (320px - 767px)
			$('.site-links .tab-item .tab-nav', self.wrapper).removeClass('disable');
		}

	},

	disableTelDesktop: function() {

		var self = this;

		// disable the telephone link if the user is viewing in a window wider than 989 pixels
		// it works as an expected tel anchor in windows below 990 pixels
		// NOTE: this can be applied globally to all anchor links with href="tel:..." by removing "self.wrapper" code below
		$('a[href^="tel"]', self.wrapper).on('click', function(e) {
			if ($(window).width() > 989) {
				e.preventDefault();
				return false;
			} else {
				return true;
			}
		});

	},

	centerCols: function() {

		if ($(window).width() > 991) {

			// loop through each site link row
			// usually there should be only one row but there is a loop anyway for the rare case an extra row of site links is added
			$('.site-links > .row', this.wrapper).each(function() {

				// get total width of columns
				var totalWidth = 0,
					columns = $('.columns', this).find('.columns'),
					wrapWidth = $(this).parent().width();

				// loop through each column and calculate the total width of all columns
				columns.each(function() {
					totalWidth = totalWidth + $(this).outerWidth(true);
				});

				// minus padding of 25 pixels of total
				// these pixels are taken from the last column right padding for the H4
				totalWidth = totalWidth - 25;

				if (wrapWidth >= totalWidth) {
					// horizontally center row by adding left margin for ltr and right margin for rtl 
					if ($("body").hasClass("rtl")) {
						$(this).css('margin-right', parseInt((wrapWidth - totalWidth) / 2));
					} else {
						$(this).css('margin-left', parseInt((wrapWidth - totalWidth) / 2));
					}
				}

			});

		} else {

			$('.site-links > .row').css({marginLeft: '', marginRight: ''});

		}	

	}

};

$(function() {
	guxApp.footer.init();
});

})(jQuery);


/*
Author: Gianfranco del Mundo
File name: creditInvestor.js
Description: 

Dependencies: jQuery
*/

(function($) {
	
	var investor = {
		init : function(){
			if(!$('.model-display.index-bar').length){return;}

			this.registerControlEvents();
			this.highlightSelectedItem();
		},
		highlightSelectedItem : function(){
			
			$.subscribe('flex-complete',function(){

			var targetDataList = $('.flexslider.carousel-limit .slides li a');
			
				targetDataList.each(function(){
					var thisTargetData = $(this),
						targetDataKey = thisTargetData.attr("href");
					if(window.location.href === targetDataKey){
						thisTargetData.addClass('active');
					}
				});
			});

			
		},
		registerControlEvents: function(){
			$('.next-smob').click(function(e){
			    e.preventDefault();
			    var prevButton = $('.smob-controls .prev-smob');
			    $('.flexslider.carousel-limit').flexslider('next');
   			    prevButton.show();
			    return false;
			});

			$('.prev-smob').click(function(e){
			    e.preventDefault();
			    var nextButton = $('.smob-controls .next-smob'),
			    	prevButton = $('.smob-controls .prev-smob');
			    $('.flexslider.carousel-limit').flexslider('prev');

			    if(nextButton.is(':hidden')){
			    	nextButton.show();
			    }


			    return false;
			});
		}
	};

	$(function(){
		investor.init();
	});

}(jQuery));


/*
Author: Roy Anonuevo
File name: visualIndicator.js
Description: Adding visual indicator feature

			 How to use: 
			 Just add a class "visual-indicator" on the module you want to have that feature.
	   		 
	   		 Example: 	   		 
	   		 <section class="billboard visual-indicator"></section>

Dependencies: jQuery, Underscore
*/

(function($){

	var visualIndicator = {

		init: function(){

			if(!$('.visual-indicator').length){return;}
			
			var template = '<div class="indicator"><span></span></div>';
			
			var self = this;

			// cache dom
			this.$window = $(window);
			this.$visualIndicator = $('.visual-indicator');
			this.$visualIndicator.append(template); // append the indicator
			this.$indicator = this.$visualIndicator.find('.indicator');

			// assign values
			this.indicatorHeight =  this.$indicator.height(),
			this.indicatorBottom = parseInt(this.$indicator.css("bottom"));
			this.hasFlexSlider = false;
			this.additionalHeight = 90;
			this.paginationDefaultBottom = 0;
			
			this.indicatorOffset = this.indicatorHeight + (this.paginationDefaultBottom - (this.indicatorHeight + this.indicatorBottom));


			var reposition = _.debounce(self.reposition.bind(self), 100);

			// bind listener
			this.$window.on('resize', reposition);
			this.$window.on('scroll', self.reposition.bind(self));
		},

		checkFlexControlNav: function(){
			// check if flex control navigation exists
			if(this.$visualIndicator.find('.flex-control-nav').length){		
				this.$pagination = this.$visualIndicator.find('.flex-control-nav');
				this.paginationDefaultBottom = parseInt(this.$pagination.css("bottom"));
				this.indicatorOffset = this.indicatorHeight + (this.paginationDefaultBottom - (this.indicatorHeight + this.indicatorBottom));
				this.hasFlexSlider = true;
			}
		},

		reposition: function(){
			// check if there's a flexslider and flex nav control
			if(this.$visualIndicator.find('.flexslider').length && this.hasFlexSlider == false){
				this.checkFlexControlNav();
			}

			var winHeight = this.$window.height(),
				visualIndicatorPosition = this.$visualIndicator.position(),
				visualIndicatorHeight = this.$visualIndicator.outerHeight(),
				maxHeight = visualIndicatorPosition.top + visualIndicatorHeight,				
				scrollBottom = this.$window.scrollTop() + winHeight,
				minHeight = visualIndicatorPosition.top + (visualIndicatorHeight * 3 / 4) + this.paginationDefaultBottom;
				
			if(scrollBottom < minHeight){								
				var bottomPosition = maxHeight - (minHeight - this.paginationDefaultBottom);

				if(this.hasFlexSlider){
					this.$pagination.removeClass("indicator-fixed").css("bottom", bottomPosition);
				}

				// adding and removing 'ie8repaint' class are for ie8 repaint issue		
				this.$indicator.removeClass("indicator-fixed").css("bottom", bottomPosition - this.indicatorOffset).addClass("indicator-visible").addClass('ie8repaint').removeClass('ie8repaint');
			}else{
				if(scrollBottom < maxHeight){
					if(this.hasFlexSlider){
						this.$pagination.css("bottom", "").addClass("indicator-fixed");
					}

					// adding and removing 'ie8repaint' class are for ie8 repaint issue		
					this.$indicator.css("bottom", "").addClass("indicator-fixed indicator-visible").addClass('ie8repaint').removeClass('ie8repaint');
				} else {
					if(this.hasFlexSlider){
						this.$pagination.css("bottom", "").removeClass("indicator-fixed");
					}

					// adding and removing 'ie8repaint' class are for ie8 repaint issue		
					this.$indicator.css("bottom", "").removeClass("indicator-fixed indicator-visible").addClass('ie8repaint').removeClass('ie8repaint');
				}

				maxHeight += this.additionalHeight;

				if(scrollBottom < maxHeight){
					this.$indicator.addClass("indicator-visible");
				}
			}
		}
	}

	$(function(){
        visualIndicator.init();        
    });

})(jQuery);



/*
Author: 		Randell Quitain
File name: 		component-billboard.js
Description: 	Display a personalised billboard component
Dependencies: 	jQuery
Usage: 			
*/

var guxPersonalisation = guxPersonalisation || {};

(function($){

	guxPersonalisation.billboard = {

		// each component requires an init function 
		init: function(element) {
			this.ruleEngine(element);
		},
		ruleEngine: function(element) {

			// get personalised URL
			var psnURL = guxPersonalisation.rest.getURL('psn', element);

			// get personalised data
			guxPersonalisation.rest.getData(psnURL).done(function (data) {

				// check if data is available
				if(data && data != null && !_.isEmpty(data)) {
					
					// get a much cleaner data
					var cleanData = guxApp.tools.cleanData(data);

					// render content
					guxPersonalisation.rest.renderTemplate(element, cleanData);

					if(typeof picturefill !== "undefined" ) { picturefill(); }

					// image preloader
					guxPersonalisation.rest.imageLoader(element, function() {
						// loader
						guxPersonalisation.rest.loader(element);

						// reinit billboardCarousel
						guxApp.billboardCarousel.init(element);
					});

				} else {
					element.hide();
				}
				
			}).fail(function (jqXHR, textStatus, errorThrown) {
				// console.log('Not able to fetch ' + psnURL + ' (' + errorThrown + ')');
				element.hide();
			});

		}

	}

})(jQuery);


/*
Author: 		Ruiwen Qin
File name: 		component-showroom.js
Description: 	Display or suppress showroom component
Dependencies: 	jQuery
Usage: 			
*/

var guxPersonalisation = guxPersonalisation || {};

(function($){


	guxPersonalisation.showroom = {

		// each component requires an init function 
		init: function(element) {
			this.ruleEngine(element);
		},
		ruleEngine: function(element) {

			if (guxPersonalisation.psn.profile.authState === "OW") {
				element.hide();
			} else {
				element.show();
				if(typeof picturefill !== "undefined" ) { picturefill(); }
				// image preloader
				guxPersonalisation.rest.imageLoader(element, function() {
					// loader
					guxPersonalisation.rest.loader(element);
				});
			}

		}

	};

})(jQuery);


/*
Author: 		Ruiwen Qin
File name: 		component-promotions.js
Description: 	Display or suppress promotions component
Dependencies: 	jQuery
Usage: 			
*/

var guxPersonalisation = guxPersonalisation || {};

(function($){


	guxPersonalisation.promotions = {

		// each component requires an init function 
		init: function(element) {
			this.ruleEngine(element);
		},
		ruleEngine: function(element) {

			if (guxPersonalisation.psn.profile.authState === "OW") {
				element.hide();
			} else {
				element.show();
				// reinit billboardCarousel
				guxApp.billboardCarousel.init(element);
				if(typeof picturefill !== "undefined" ) { picturefill(); }
				// image preloader
				guxPersonalisation.rest.imageLoader(element, function() {
					// loader
					guxPersonalisation.rest.loader(element);
				});
			}
		}

	};

})(jQuery);


/*
Author: 		Randell Quitain
File name: 		component-locate-dealer.js
Description: 	Display or suppress Locate a Dealer component
Dependencies: 	jQuery
Usage: 	

* History
* 2015/12/11, Steven Xue, SMW - INC000015398018 - REQ #6689341 - Dragonfly Front end issue about dealer telephone number not display the sam, Line 248, remove .replace(/\s/g, '')		
*/

var guxPersonalisation = guxPersonalisation || {};

(function($){


	guxPersonalisation.locatedealer = {

		// each component requires an init function 
		init: function(element) {
			
			$(element).hide();
			
			var self = this,
 				// dealerLocator = guxApp.dealerLocator,
 				miniDealerContainer = element,
 				// mapController = guxApp.tools.isBingMap()?guxApp.bingMapController:guxApp.googleMapController,
				mapController = guxApp.tools.isAutoNaviMap()?guxApp.autonaviMapController:guxApp.googleMapController,
				map = mapController.map || null,
				searchField = $('.input-panel input[type=text]', miniDealerContainer);

			miniDealerContainer.hide();

			self.container = miniDealerContainer;
			self.config = mapController.config;
			self.mapContainer = $('#map-container')[0];
			self.mapController = mapController;

			self.day = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][(new Date()).getDay()];

			this.ruleEngine(element);

			self.is_mobile = guxApp.viewport.view == "mobile";

			// init UI
 			$('.search-panel .btn-current', miniDealerContainer).on('click', function(e) {
 				e.preventDefault();
 				self.searchByPosition(searchField);
 			});

 			$('.search-panel', miniDealerContainer).on('submit', function(e) {
				e.preventDefault();
				// setTimeout(function(){				
				self.searchDealersByKeyword($('.keyword-field', miniDealerContainer).val(), false);
				// },3000);
				return false;
			});

			$('.btn-search', miniDealerContainer).on('click', function(e) {
				if ($(this).is('.trackable') && !e.originalEvent) return false;
			});

			searchField.on('focus', function() {
				var elem = this,
					placeholder = $(elem).attr('placeholder'),
					value = $(elem).val();
				
				if ($(elem).attr('placeholder')) {
					$(elem).data('placeholder', placeholder);
					$(elem).removeAttr('placeholder');
				}

				// if (value) {
				// 	$(elem).data('data', value);
				// 	$(elem).val('');
				// }

			});

			searchField.on('blur', function() {
				var elem = this,
					placeholder = $(elem).attr('placeholder'),
					value = $(elem).val();

				if (!value) {
					// if ($(elem).data('data')) {
					// 	$(elem).val($(elem).data('data'));
					// } else {
						$(elem).attr('placeholder', $(elem).data('placeholder'));
					// }
				}

			});

			$('.input-panel input[type=text]', miniDealerContainer).on('keyup', self.autoCompleteTrigger);

			if (guxPersonalisation.locatedealeralt) {
			    guxPersonalisation.locatedealeralt.init(self);
			}

		},
		ruleEngine: function(element) {

			var self = this,
				mapController = self.mapController;

			// loader
			guxPersonalisation.rest.loader(element);

			// if (guxPersonalisation.psn.profile.authState === "OW") {

				// element.hide();

			// } else {

				// element.hide();
				if (guxPersonalisation.psn.profile.authState === "AN") {

					// element.show();
					
					// temp
					var locationAware = false;

					// reset blocks
					// location aware initialization

					guxApp.locationAware.locationDetection(function(addressInfo, isAutoDetection){
						if(!guxApp.tools.isAutoNaviMap()&&addressInfo){
							mapController.searchDealersByLocation(addressInfo, $('.input-panel input[type=text]', self.container),{},{}, function(results, response) {

								// location not found
								if (!results) {
									self.showError( (response)?response:self.config.error_message.location_not_found);
									return false;
								}

								self.is_autoDetection = isAutoDetection;

								self.processResults(results);

							}, null, true);
							
						} else {
							element.show();
						}
					});
				}

			// }
		},

		selectMarker: function(marker, number_icon) {

			var	self = this,
				mapController = self.mapController,
				map = mapController.map;

			map.deselectMarkers();
			if(!guxApp.tools.isAutoNaviMap()) marker.select();
			map.panTo(marker.getPosition());

			if(!self.is_mobile) marker.showInfoWindow();

			$('.listing-number.active', self.container).removeClass('active');
			number_icon.addClass('active');

		},

		initMarkerIcon: function(dealer, index, number_icon, is_featured) {
			var self = this,
				container = $(self.container),
				mapController = self.mapController,
				map = mapController.map,
				marker;

			marker = map.addGuxMarker(dealer.location, index, _.template($('#infobox-template').html(), dealer), function(dealer) {
				return function() {
					self.selectMarker(marker, number_icon);
					
				}
			}(dealer));
			
			number_icon.on('click', function() {
				self.selectMarker(marker, number_icon);
			});

			return marker;

		},

		
 		processResults: function(dealers, errmessage) {

 			var self = guxPersonalisation.locatedealer,
 				container = $(self.container),
 				mapController = self.mapController,
				map = mapController.map,
				selected_marker = 0,
				map_is_open = false,
				origin = {
				    lat: self.mapController.currentLat,
				    lng: self.mapController.currentLong
				};

			var slides_container = $('.slides', container);

			if (!dealers.length) {
				self.showError(errmessage);
				$('.input-panel', self.container).removeClass('active');
				return;
			}

			var limit_dealers = dealers.slice(0,5);
			$.each(limit_dealers, function(i, dealer) {

				dealer['hours'] = mapController.getDeptSchedule(dealer);
				
				var index = i;
				
				$.extend(dealer, {
					address: mapController.makeDealerAddress(dealer, self.config.addressFormat),
					dealershipURL: mapController.makeDealerURL(dealer),
					index: index,
					is_mobile: self.is_mobile,
					is_open: mapController.is_dealerOpen(dealer, self.day),
					closeTime: mapController.getCloseTime(dealer, self.day),
					mapURL: mapController.makeMapURL(dealer.location, mapController.currentLocationCoords)
				});
				
				dealer['day_str'] = [];
				dealer['day_str_translated'] = [];
				for (var i in self.config.translation.day_str) {
					dealer['day_str'].push(i);
					dealer['day_str_translated'].push(self.config.translation.day_str[i])
				}

				// checking if url is properly formatted
				if ((dealer.PrimaryURL != "") && (dealer.PrimaryURL.indexOf("http://") != 0)) {
					dealer.PrimaryURL = "http://" + dealer.PrimaryURL;
				}

				if (!dealer['distance']) {
                	dealer['distance'] = "";
                }

				dealer['nextOpenTime'] = mapController.getNextOpenTime(dealer);
				var schedule = mapController.scheduleString(dealer, dealer.hours, self.day);
				dealer['schedule'] = schedule.description;
				dealer['scheduleType'] = schedule.type;
				dealer['phoneNumbers'] = (dealer['PrimaryPhone'] && dealer['PrimaryPhone'].length) ? dealer['PrimaryPhone'].split(';') : [];
				dealer['dealerNewVehicle'] = (dealer['DealerNewVehicle'] && dealer['DealerNewVehicle'].length) ? dealer['DealerNewVehicle'].replace(/\s/g, '').split(/[;,]/g) : [];
			});
			
			// show featured nearest
			var featured_dealer = limit_dealers[0],
				other_dealers = _.rest(limit_dealers),
				featured_dealer_elem = _.template($('#preferred-dealer-template').html(), featured_dealer),
				number_icons = [];

			var preferred = $('.preferred-dealer', container).html(featured_dealer_elem),
				featured_number_icon = $('.listing-number', preferred);
			
			$('.slides .preferred .item', container).html(_.template($('#preferred-dealer-mobile-template').html(), featured_dealer));
			featured_number_icon.addClass('active');

			var featured_marker = self.initMarkerIcon(featured_dealer, 1, featured_number_icon, true);


			// other dealers
			_.each(other_dealers, function(dealer, i) {

				var index = i + 2;

				dealer["index"] = index;

				var dealerElem = $(_.template($('#other-dealers-template').html(), dealer)),
					number_icon = $('.listing-number', dealerElem);

				slides_container.append(dealerElem);
				self.initMarkerIcon(dealer, index, number_icon);

			});
			if (_da&&_da.module&&_da.module.template){
				$("section.personalisation a[href*='intcmp='],section.smartnextsteps a[href*='intcmp=']").each(function(idx){
					var attrHref = $(this).attr("href");
					var temp = "STATUS";
					if(attrHref.indexOf(temp)!=-1){	
						$(this).attr("href",attrHref.replace(temp,_da.module.template));
					}	
				});
			}
			
			self.container.show();
			self.showLocationAwarePanel();

			$('.revealer-open', container).on('click', function(e) {

				mapController.displayMap();
				map.setCenter({ lat:featured_dealer.location.lat, lng:featured_dealer.location.lng});
				
				if (!map_is_open) {
					// map.setZoom(10);
					featured_marker.select();
					if(!self.is_mobile) featured_marker.showInfoWindow();

					map_is_open = true;
					map.setZoom(10);
					// map.setBounds(dealers, 1);
				}

				e.preventDefault();
				return false;

			});

			$('.link-search', container).on('click', function(e) {
				sessionStorage['dealers'] = JSON.stringify(dealers);
				sessionStorage['search_keyword'] = $('.input-panel').find('.keyword-field').val();
			});

			$('.input-panel', self.container).removeClass('active');

			guxApp.billboardCarousel.init();
		},

		searchByPosition: function(searchField, oncompletecallback) {
 			// event handler for search dealers from current position

 			var self = this,
 				// dealerLocator = guxApp.dealerLocator
 				container = self.container,
				mapController = self.mapController,
				map = mapController.map || null,
				errmessage = self.config.error_message.nearest_dealer_not_found,
				geoLocationTimeout = null;

			$('.error', self.container).hide();

			if ($('.input-panel', self.container).is('.active')) return false;
			$('.input-panel', self.container).addClass('active');

			if (!!navigator.geolocation) {

				navigator.geolocation.getCurrentPosition(function(position) {
										
					var lat = position.coords.latitude,
						lng = position.coords.longitude;

					clearTimeout(geoLocationTimeout);
					geoLocationTimeout = null;

					mapController.getAddressStringFromCoord({ "lat": lat, "lng": lng }, function (result, status) {
						
							searchField.val(result);
							if (oncompletecallback && $.isFunction(oncompletecallback)) {
							mapController.searchDealersByLocation(result, searchField, {},{},function (dealers, status) {
								oncompletecallback(dealers, status);
            						});	
							}
							else {
							mapController.searchDealersByLocation(result, searchField, {},{},self.processResults, self.config.error_message.location_not_found);
							}

					});


				}, function(err) {

					clearTimeout(geoLocationTimeout);
					geoLocationTimeout = null;

					if (oncompletecallback && $.isFunction(oncompletecallback)) {
					    oncompletecallback(false, err);
					}

					switch (err.code) {
						case err.PERMISSION_DENIED:
							self.showError(self.config.error_message.geolocation_error_denied);
							break;
						case err.POSITION_UNAVAILABLE:
							self.showError(self.config.error_message.geolocation_error);
							break;
						case err.TIMEOUT:
							self.showError(self.config.error_message.geolocation_error_timeout);
							break;
					}
					
					$('.input-panel', self.container).removeClass('active');

				}, { timeout: 7*1000 });


			} else {
				clearTimeout(geoLocationTimeout);
				geoLocationTimeout = null;
				// $('.search-panel .btn-current').hide();
				self.showError(self.config.error_message.geolocation_error_denied);
				$('.input-panel', self.container).removeClass('active');
			}
			
			geoLocationTimeout = setTimeout(function() {
				self.showError(self.config.error_message.geolocation_error_timeout);
				$('.input-panel', self.container).removeClass('active');	
			}, 7000);

 		},

 		searchDealersByKeyword: function(keyword, matchParams) {

			var self = this,
				mapController = self.mapController,
				map = mapController.map,
				is_postcode = /^\d/.test(keyword),
				errmessage = self.config.error_message.dealer_not_found,
				matchParams = matchParams || {},
				containsParams = {},
				origin = {
					lat: mapController.currentLat,
					lng: mapController.currentLong
				};

			self.is_autoDetection = false;
			self.filters = [];

			$('.error', self.container).hide();

			if ($('.input-panel', self.container).is('.active')) return false;
			$('.input-panel', self.container).addClass('active');

			if (keyword == "" || !keyword) {
				self.showError(self.config.error_message.blank_field);
				$('.input-panel', self.container).removeClass('active');
				return;
			}

			setTimeout(function() {
			mapController.searchDealersByKeyword(keyword, $('.input-panel input[type=text]', self.container), self.processResults, errmessage);
			},3000);

			self.loadedDealers = [];

		},

		// autoCompleteTrigger: function(e) {

		// 	var self = guxPersonalisation.locatedealer,
		// 		mapController = guxApp.googleMapController,
		// 		map = mapController.map,
		// 		searchKey = $(this).val(),
		// 		strlen = searchKey.length,
		// 		search_panel = $('.search-panel'),
		// 		location_limit = self.config.auto_suggest_limit,
		// 		user_intent_delay = null;

		// 	var keys_regex = new RegExp("^[a-zA-Z0-9]+$");
		//     var str = String.fromCharCode(!e.charCode ? e.which : e.charCode);

		//     if (user_intent_delay) {
		//     	clearTimeout(user_intent_delay);
		//     	user_intent_delay = null;
		//     }


		// 	// enable predictive search
		// 	if (keys_regex.test(str) && !!searchKey && (/[A-Z]{2,}/.test(searchKey) || strlen >= self.config.autocomplete_char_count)) {
					

		// 		user_intent_delay = setTimeout(function() {

		//     		if ($('.input-panel', self.container).is('.active')) return false;

		// 			guxApp.googleMapController.map.autocomplete(searchKey, location_limit, function(results) {

		// 				var locations = results.locations,
		// 					dealers = _.pluck(results.dealers, "DealerName");

		// 				self.showSuggestions(_.union(dealers, locations), search_panel);

		// 			});

		// 		}, 300);

		// 	} else {
		// 		$('.dealer-disambiguation', search_panel).hide();
		// 	}

		// },

		autoCompleteTrigger: function(e) {

			var self = guxPersonalisation.locatedealer,
				mapController = self.mapController,
				map = mapController.map,
				searchKey = $(this).val(),
				strlen = searchKey.length,
				search_panel = $('.search-panel'),
				location_limit = self.config.auto_suggest_limit,
				user_intent_delay = null,
				key = !e.charCode ? e.which : e.charCode;

			var keys_regex = new RegExp("^[a-zA-Z0-9]+$");
		    var str = String.fromCharCode(key).valueOf();

		    // prevent trigger if ctrl/alt key is pressed
		    if (e.altKey || e.ctrlKey || key == 17 || key == 18) return false;


		    if (user_intent_delay) {
		    	clearTimeout(user_intent_delay);
		    	user_intent_delay = null;
		    }


		    // arrow keys
		    if (key == 38 || key == 40) {

		    	switch(key) {
		    		case 38:
		    			var direction = true;
		    			break;
		    		case 40:
		    			var direction = false;
		    			break;
		    	}

		    	if ($('.dealer-disambiguation', self.container).is(':visible')) self.selectSuggestion(this, direction);

		    	return;
		    } 

			// enable predictive search
			if (!!searchKey && (/[A-Z]{2,}/.test(searchKey) || strlen >= self.config.autocomplete_char_count)) {
				// keys_regex.test(str) &&	

				user_intent_delay = setTimeout(function() {

		    		if ($('.input-panel', self.container).is('.active')) return false;

		    		mapController.map.autocomplete(searchKey, location_limit, function (results) {

						var locations = results.locations,
							dealers = _.pluck(results.dealers, "DealerName");

						if (locations.length || dealers.length) {
							self.showSuggestions(_.union(dealers, locations), search_panel);
						}

					});

				}, 300);

			}

		},

		selectSuggestion: function(field, up) {

			var suggestion_holder = $('.search-panel .dealer-disambiguation'),
				current_selected = $('li.active', suggestion_holder),
				next = (current_selected.next().length)?current_selected.next():$('li', suggestion_holder).eq(0),
				prev = (current_selected.prev().length)?current_selected.prev():$('li', suggestion_holder).eq($('li', suggestion_holder).length-1);

			current_selected = next;

			if (up) {
				current_selected = prev
			}
			
			current_selected.addClass('active').siblings().removeClass('active');
			$(field).val($('a', current_selected).text());

		},

		showSuggestions: function(suggestions, container) {

			$('.search-panel .error').hide();

			if (suggestions.length) {

				$('.dealer-disambiguation', container).show();
				$(".dealer-disambiguation ul", container).html(_.template($("#dealer-disambiguation").html(), {suggestions:suggestions}));
				$('.dealer-disambiguation a', $(container)).on("click", function(e) {
					
					e.preventDefault();

					$(".input-panel input[type=text]", container).val($(this).text());
					$('.dealer-disambiguation', container).hide();
					$(container).trigger('submit');

				});
			} else {
				$('.dealer-disambiguation', container).hide();
			}
		},

 		showLocationAwarePanel: function() {

 			var container = $(this.container);

 			$('.dealer-unaware', container).hide();
			$('.location-aware', container).show();

 		},

 		showError: function(errorText) {
			$('.error', this.container).show().find('.text').text(errorText);
			$('.dealer-disambiguation', self.container).hide();
 		}
	};

})(jQuery);


/*
Author: 		Doris
File name: 		component-locate-dealer-alt.js
Description: 	Display or suppress Locate a Dealer component
Dependencies: 	jQuery
Usage: 			
*/

var guxPersonalisation = guxPersonalisation || {};

(function($){

    guxPersonalisation.locatedealeralt = {

        init: function (locatedealer) {
            var self = this;
            self.locatedealer = locatedealer;
            self.altThemeContainer = self.locatedealer.container.hasClass('alt-theme') ? self.locatedealer.container : [];
            self.searchbtn = $('.actions-bar .button', self.altThemeContainer);
            self.searchContainer = $('.search-panel', self.altThemeContainer);
            self.vehicle = $("select[name='vehicle']", self.searchContainer);
            self.location = $("input[name='location']", self.searchContainer);
            if (!self.altThemeContainer.length) return;

            self.vehicle && self.vehicle.length && self.vehicle.val('') && self.vehicle.uniform.update();
            self.location && self.location.length && self.location.val('');
            
            //self.locatedealer.container.show();

            self.getOptData();
            self.searchbtn.on('click', function (e) {
                e.preventDefault();
                
                var formDataArr = $("select, input", self.searchContainer).serializeArray(),
				    province = $("select[name='province']", self.searchContainer),
				    city = $("select[name='city']", self.searchContainer),
                    vehicle = $("select[name='vehicle']", self.searchContainer),
                    location = $("input[name='location']", self.searchContainer),
                    keywordStr = "",
					matchParams = {},
					containParams = {};

                self.searchbtn.siblings('.error').removeClass('active');

                if (province.val().length && city.val().length) {
                    $.each(formDataArr, function (key, val) {
                        if (val.value != "") {
                            keywordStr = keywordStr + val.value;
                        }
                    });
                    self.locatedealer.loadedDealers = [];
 					if (guxApp.tools.isAutoNaviMap()) 
                        {
							matchParams={AdministrativeArea: province.val()||"", Locality: city.val()||""};
							containParams={_name:location.val()||"",DealerNewVehicle:vehicle.val()||""};
							self.locatedealer.mapController.searchDealersByLocation(keywordStr, false , matchParams , containParams, function(dealers,errorMsg) {
								errorMsg = errorMsg||((!!guxPersonalisation.locatedealer.config.error_message)?guxPersonalisation.locatedealer.config.error_message.dealer_not_found:"No results were Found. Please try a different search."),
								sessionStorage['dealers'] = JSON.stringify(dealers);
								sessionStorage['search_province'] = province.val();
								sessionStorage['search_city'] = city.val();
								sessionStorage['error_message'] = errorMsg;
								location.length && location.val().length && (sessionStorage['search_location'] = location.val());
								vehicle.length && vehicle.val().length && (sessionStorage['search_vehicle'] = vehicle.val());
								if (window.history.pushState) {
									window.history.pushState('', '', window.location.href);
								}
								window.location.href = self.searchContainer.attr('action');
							});	
                        }
						else {
							self.locatedealer.mapController.searchDealersByProperties({AdministrativeArea: province.val(), Locality: city.val()}, {}, function(dealers,errorMsg) {
								errorMsg = errorMsg||((!!guxPersonalisation.locatedealer.config.error_message)?guxPersonalisation.locatedealer.config.error_message.dealer_not_found:"No results were Found. Please try a different search."),
								sessionStorage['dealers'] = JSON.stringify(dealers);
								sessionStorage['search_province'] = province.val();
								sessionStorage['search_city'] = city.val();
								sessionStorage['error_message'] = errorMsg;
								location.length && location.val().length && (sessionStorage['search_location'] = location.val());
								vehicle.length && vehicle.val().length && (sessionStorage['search_vehicle'] = vehicle.val());
								if (window.history.pushState) {
									window.history.pushState('', '', window.location.href);
								}
								window.location.href = self.searchContainer.attr('action');
							});	
						}
                        					
                }
                else {
                    self.searchbtn.siblings('.error').addClass('active').find('.text').text(self.locatedealer.mapController.config.error_message.isMandatory);
                }
                
                return false;
            });
            $('.btn-current', self.searchContainer).off('click').on('click', function (e) {
                e.preventDefault();
                self.locatedealer.searchByPosition($("input[name='location']", self.searchContainer), function (dealers, status) {
                    if (dealers) {
                        sessionStorage['dealers'] = JSON.stringify(dealers);
                        window.location.href = self.searchContainer.attr('action');
                    }
                })
            });

        },
        getOptData: function () {
            var self = this,
                dataConfig = $("#cityDropdownData"),
			    dataArr = [],
			    province = $("select[name='province']", self.altThemeContainer),
			    city = $("select[name='city']", self.altThemeContainer);
            //self.searchbtn.addClass('disabled').attr("disabled", "disabled");
            //initial disable city
            city.prop("disabled", "disabled").closest(".dropdown").addClass("disabled");
            province.uniform.update();
            city.uniform.update();
            if (dataConfig.length > 0 && dataConfig.embeddedData().list && dataConfig.embeddedData().list.length) {
                dataArr = dataConfig.embeddedData().list[0].states;
            }
            //import Province data
            if (dataArr.length > 0) {
                $.each(dataArr, function (key, val) {
                    $("<option value='" + val[1].name + "'>" + val[1].name + "</option>").appendTo(province);
                });                
            }
            //import City data
            province.on("change", function () {
                var provinceVal = $(this).val(),
                    endLoop = false;
                city.val("");//select the default value
                city.uniform.update();//update select val in uniform
                $.each(dataArr, function (key, val) {
                    if (provinceVal == val[1].name) {
                        city.children("option:gt(0)").remove();
                        $.each(val[1].cities, function (key, val) {
                            $("<option value='" + val[1].name + "'>" + val[1].name + "</option>").appendTo(city);
                        });
                        endLoop = true;
                    }
                    if (endLoop) { return false; }
                });
                //enable city
                province.val() == "" ? city.prop("disabled", "disabled").closest(".dropdown").addClass("disabled") : city.prop("disabled", false).closest(".dropdown").removeClass("disabled");
                //city.val().length ? self.searchbtn.removeClass('disabled').attr("disabled", false) : self.searchbtn.addClass('disabled').attr("disabled", "disabled");
            });
            //city.on('change', function () {
            //    city.val().length ? self.searchbtn.removeClass('disabled').attr("disabled", false) : self.searchbtn.addClass('disabled').attr("disabled", "disabled");
            //});
        }

    };
    

})(jQuery);


/*
Author: 		Randell Quitain
File name: 		component-recently-viewed.js
Description: 	Display or suppress recently viewed component
Dependencies: 	jQuery
Usage: 			
*/

var guxPersonalisation = guxPersonalisation || {};

(function($){

	guxPersonalisation.recentlyviewed = {

		// each component requires an init function 
		init: function(element) {
			this.ruleEngine(element);
		},
		ruleEngine: function(element) {

			if (guxPersonalisation.psn.profile.authState === "OW") {
				
				element.hide();
				
			} else {

				if (guxPersonalisation.psn.profile.authState === "AN") {
					
					var success = function (value, status, jqXHR) {

						var recentlyViewedVehicles = value[0]['RecentlyViewedVehicles'],
							viewed = {};

						// console.log(recentlyViewedVehicles);

						// check if data is available
						if((recentlyViewedVehicles && recentlyViewedVehicles != null && !_.isEmpty(recentlyViewedVehicles))) {

							// PHASE 1 -  Get unique rvv ids
							var rvvURL = guxPersonalisation.rest.getURL('rvv'),
								total = guxApp.tools.getObjectLength(recentlyViewedVehicles),
								rvvId = [],
								uniqueRVVData = {};

							// push all viewed 
							for (var i = 0; i <= (total-1); i++) {
								viewed[i] = recentlyViewedVehicles[i];
							};

							var viewedLength = guxApp.tools.getObjectLength(viewed);

							// list all gathered id of FPS rvv
							for (var i = viewedLength - 1; i >= 0; i--) {

								// get/push valid nameplate
								if(typeof viewed[i] != 'undefined' && viewed[i]._nameplate != ':' && viewed[i]._on != '') {
									var viewedId = viewed[i]._nameplate.split(':')[0],
										viewedOn = viewed[i].on;
									rvvId.push({ 'rid': viewedId, 'on': viewedOn });
								}

							};

							// get only the unique id from FPS RecentlyViewedVehicle
							var uniqueRVVId = _.uniq(rvvId, function(item){ return JSON.stringify(item.rid) });

							// sort unique id's by most recent
							var sort = _.sortBy(uniqueRVVId, function(item) { return JSON.stringify(item.on); }),
								nextMostRecently = sort.reverse();

							// console.log(nextMostRecently);

							// get rvv data
							guxPersonalisation.rest.getData(rvvURL).done(function (data) {

								// check if data is available
								if(data && data != null && !_.isEmpty(data)) {

									var element = guxPersonalisation.components.componentItems["recentlyviewed"],
										trueIndex = 0;

									// compare uniqueRVVId from FPS to RVV data
									for (var r = nextMostRecently.length - 1; r >= 0; r--) {

										for (var p = data.length - 1; p >= 0; p--) {

											// check if FPS RVV id is equal to RVV data id
											if(nextMostRecently[r].rid === data[p].id) {
												
												var dataRVV = {
													"id": data[p].id,
													"on": nextMostRecently[r].on,
													"modelPageUrl": data[p].modelPageUrl,
													"modelSmobPageUrl": data[p].modelSmobPageUrl,
													"imageMidResURL": data[p].imageMidResURL,
													"modelYear": data[p].modelYear,
													"vehicleName": data[p].name,
													"price": guxApp.priceFormatter.format(data[p].price)
												}

												// push the data of the unique id's to object
												uniqueRVVData[trueIndex] = dataRVV;

												trueIndex++;

											}

										};

									};

									// console.group('Unique recently viewed vehicles fetched data:');
									var sort = _.sortBy(uniqueRVVData, function(item) { return JSON.stringify(item.on); }),
										finalRVVData = sort.reverse();
									
									// console.log(finalRVVData);

									// PHASE 2 - Check total number of nextMostRecently and display proper content
									// default set limit - zero-based
									var viewedUniqueRVVData = guxApp.tools.getObjectLength(finalRVVData),
										limit = 0,
										rvvData = {};

									if(viewedUniqueRVVData > 1) {

										// return data equals to 2-3
										if(viewedUniqueRVVData >= 2 && viewedUniqueRVVData <= 3) {

											// console.group('2 to 3 (viewedUniqueRVVData: '+viewedUniqueRVVData+')');

											// rvv length is equal to 2, display next 1 recently viewed vehicle
											if(viewedUniqueRVVData === 2) {
												// console.log('display 1 next recently viewed vehicles:');
												limit = 2;
											}

											// rvv length is equal to 3, display next 2 recently viewed vehicle
											if(viewedUniqueRVVData === 3) {
												// console.log('display 2 next recently viewed vehicles:');
												limit = 3;
											}

											// console.group('1 - 2 most recently viewed vehicles:');
										
										} else if (viewedUniqueRVVData >= 4) {

											// console.group('4 and up (viewedUniqueRVVData: '+viewedUniqueRVVData+')');

											// rvv length is equal to 4 and up, display next 3 recently viewed vehicle
											// console.group('3 most recently viewed vehicles:');
											limit = 4;
											
										}

										// populate final rvvData with next recent data
										for (var i = 1; i <= limit; i++) {
											if(i != limit) rvvData[i] = finalRVVData[i];
										};

										// console.log(rvvData);

										element.show();

										// render content
										guxPersonalisation.rest.renderTemplate(element, rvvData);

										// reinit billboardCarousel
										guxApp.billboardCarousel.init(element);	

										// image preloader
										guxPersonalisation.rest.imageLoader(element, function() {
											// loader
											guxPersonalisation.rest.loader(element);
										});

									} else {
				
										// return data equal less than 1
										// console.log('0 to 1 returned data. Hide the component.');
										element.hide();
										
									}

								} else {
									// console.log('No Build and Price model');
									element.hide();
								}
								
							}).fail(function (jqXHR, textStatus, errorThrown) {
								// console.log('Not able to fetch ' + rvvURL + ' (' + errorThrown + ')');
								element.hide();
							});
							
						} else {

							// console.log('No RVV!');
							element.hide();

						}

					};

					var error = function (value, status, jqXHR) {
						// console.log("FPS isn't loaded. Hide component.");
						element.hide();
					};

					// get RVV
					guxPersonalisation.fps.get([{ 'RecentlyViewedVehicles': {} }], success, error);

				} else {

					element.hide();
					
				}

			}
		}

	};

})(jQuery);


/*
Author: 		Ruiwen Qin
File name: 		component-know-vehicle.js
Description: 	Display or suppress showroom component - Get to Know Your Vehicle
Dependencies: 	jQuery
Usage: 			
*/

var guxPersonalisation = guxPersonalisation || {};

(function($){


	guxPersonalisation.knowvehicle = {

		// each component requires an init function 
		init: function(element) {
			this.ruleEngine(element);
		},
		ruleEngine: function(element) {

			if (guxPersonalisation.psn.profile.authState === "OW") {

				// nameplate REST URL
				var nameplateURL = guxPersonalisation.rest.getURL('nameplates', element);

				// check nameplate supported
				guxPersonalisation.rest.getData(nameplateURL).done(function (data) {

					// check if data is available
					if(data && data != null && !_.isEmpty(data) && !_.isEmpty(data.data.tiles)) {

						// render content
						guxPersonalisation.rest.renderTemplate(element, data.data);

						// get now value from dfy.u cookie
						var cookieUser = $.parseJSON( $.cookie('dfy.u') ),
							headingText = $(element).find('.heading h1').text(),
							subHeadingText = $(element).find('.heading h2').text();

						// put nameplate name on .heading
						$(element).find('.heading h1').text(headingText.replace('%1', data.data.modelShortName));
						$(element).find('.heading h2').text(subHeadingText.replace('%1', data.data.modelShortName));

						// reinit billboardCarousel
						guxApp.billboardCarousel.init(element);

						// reinit openModal
						guxApp.mediaOverlay.init();

						// image preloader
						guxPersonalisation.rest.imageLoader(element, function() {
							// loader
							guxPersonalisation.rest.loader(element);
						});
							
					} else {
						element.hide();
					}
					
				}).fail(function (jqXHR, textStatus, errorThrown) {
					// console.log('Not able to fetch ' + nameplateURL + ' (' + errorThrown + ')');
					element.hide();
				});

				
			} else {
				element.hide();
			}
		}

	};

})(jQuery);


/*
Author: 		Randell Quitain
File name: 		component-dealer-message.js
Description: 	Display or suppress dealer message component
Dependencies: 	jQuery
Usage: 			
*/

var guxPersonalisation = guxPersonalisation || {};

(function($){


	guxPersonalisation.dealermessage = {

		// each component requires an init function 
		init: function(element) {
			this.ruleEngine(element);
		},
		ruleEngine: function(element) {

			if(guxPersonalisation.psn.profile.authState === "OW" && guxPersonalisation.psn.profile.dc !== "") {
				
				element.show();

				// get dealers URL
				var psnURL = guxPersonalisation.rest.getURL('dealers', element);

				// get personalised data
				guxPersonalisation.rest.getData(psnURL).done(function (data) {

					// check if data is available
					if(data && data != null && !_.isEmpty(data)) {

						// get now value from dfy.u cookie
						var cookieUser = $.parseJSON( $.cookie('dfy.u') ), destURL;

						// get destination url
						guxApp.googleMapController.getCoordsFromAddressString(cookieUser.pc, function(coor) {
							var destination = {
									'lat': data['latitudeLongitude'].latitude,
									'lng': data['latitudeLongitude'].longitude
								},
								origin = {
									'lat': coor[0].lat,
									'lng': coor[0].lng
								};

							// inject mapURL
							data.destinationURL = guxApp.googleMapController.makeMapURL(destination, origin);

							// render content
							guxPersonalisation.rest.renderTemplate(element, data);

							// put nameplate name on .heading
							$(element).find('.message p').text($(element).find('.message p').text().replace('[Name]', cookieUser.fn));
							$(element).find('.message p').text($(element).find('.message p').text().replace('[Nameplate]', cookieUser.now));

							// loader
							guxPersonalisation.rest.loader(element);
						});
					} else {
						element.hide();
					}
					
				}).fail(function (jqXHR, textStatus, errorThrown) {
					// console.log('Not able to fetch ' + psnURL + ' (' + errorThrown + ')');
					element.hide();
				});

			} else {
				element.hide();
			}

		}

	};

})(jQuery);


/*
Author: 		Randell Quitain
File name: 		component-popular-accessories.js
Description: 	Display or suppress popular accessories
Dependencies: 	jQuery
Usage: 			
*/

var guxPersonalisation = guxPersonalisation || {};

(function($){


	guxPersonalisation.accessories = {

		// each component requires an init function 
		init: function(element) {
			this.ruleEngine(element);
		},
		ruleEngine: function(element) {

			if (guxPersonalisation.psn.profile.authState === "OW") {

				// nameplate REST URL
				var nameplateURL = guxPersonalisation.rest.getURL('nameplates', element);

				// check nameplate supported
				guxPersonalisation.rest.getData(nameplateURL).done(function (data) {

					// check if data is available
					if(data && data != null && !_.isEmpty(data) && !_.isEmpty(data.data.tiles)) {

						// render content
						guxPersonalisation.rest.renderTemplate(element, data.data);

						// get now value from dfy.u cookie
						var cookieUser = $.parseJSON( $.cookie('dfy.u') ),
							headingText = $(element).find('.heading h1').text();

						// put nameplate name on .heading
						$(element).find('.heading h1').text(headingText.replace('%1', data.data.modelShortName));

						// reinit billboardCarousel
						guxApp.billboardCarousel.init(element);

						// image preloader
						guxPersonalisation.rest.imageLoader(element, function() {
							// loader
							guxPersonalisation.rest.loader(element);
						});
							
					} else {
						element.hide();
					}
					
				}).fail(function (jqXHR, textStatus, errorThrown) {
					// console.log('Not able to fetch ' + nameplateURL + ' (' + errorThrown + ')');
					element.hide();
				});

				
			} else {
				element.hide();
			}
		}

	};

})(jQuery);


/*
Author: 		Randell Quitain
File name: 		component-brand-gallery.js
Description: 	Display or suppress brand gallery component
Dependencies: 	jQuery
Usage: 			
*/

var guxPersonalisation = guxPersonalisation || {};

(function($){


	guxPersonalisation.brandgallery = {

		// each component requires an init function 
		init: function(element) {
			this.ruleEngine(element);
		},
		ruleEngine: function(element) {

			// loader
			guxPersonalisation.rest.loader(element);
			
			if (guxPersonalisation.psn.profile.authState === "OW") {
				element.hide();
			} else {
				element.show();
			}
		}

	};

})(jQuery);


/*
Author: 		Randell Quitain
File name: 		component-smart-nextsteps.js
Description: 	Display or suppress Smart Next Steps component
Dependencies: 	jQuery
Usage: 			
*/

var guxPersonalisation = guxPersonalisation || {};

(function($){

	guxPersonalisation.smartnextsteps = {

		// each component requires an init function
		init: function() {
			this.ruleEngine();
		},
		ruleEngine: function() {

			var configInfo = guxApp.tools.commonConfigData(),
				country = (configInfo != null && configInfo.iso2country) ? configInfo.iso2country : null,
				fstools = (configInfo != null && configInfo.fsTools) ? $.map( configInfo.fsTools.split('#'), function(v){ return v === "" ? null : v; }) : null,
				antools = (configInfo != null && configInfo.anTools) ? $.map( configInfo.anTools.split('#'), function(v){ return v === "" ? null : v; }) : null,
				owtools = (configInfo != null && configInfo.owTools) ? $.map( configInfo.owTools.split('#'), function(v){ return v === "" ? null : v; }) : null,
				fstoolsMob = (configInfo != null && configInfo.smobFsTools) ? $.map( configInfo.smobFsTools.split('#'), function(v){ return v === "" ? null : v; }) : null,
				antoolsMob = (configInfo != null && configInfo.smobAnTools) ? $.map( configInfo.smobAnTools.split('#'), function(v){ return v === "" ? null : v; }) : null,
				owtoolsMob = (configInfo != null && configInfo.smobOwTools) ? $.map( configInfo.smobOwTools.split('#'), function(v){ return v === "" ? null : v; }) : null,
				kbas = $.map( guxPersonalisation.psn.profile.kba.split('#'), function(v){ return v === "" ? null : v; }),
				steps;
			
			if(guxApp.viewport.view === 'mobile'){
				if (guxPersonalisation.psn.profile.authState === "OW") {
						steps = owtoolsMob;
				} else {
					if (guxPersonalisation.psn.profile.authState === "FS") {
						//checked what step is next in depending on published sns component - FS
						steps = fstoolsMob;
					} else if (guxPersonalisation.psn.profile.authState === "AN"){
						steps = antoolsMob;
					}
				}
			} else {
				if (guxPersonalisation.psn.profile.authState === "OW") {
						steps = owtools;
				} else {
					if (guxPersonalisation.psn.profile.authState === "FS") {
						//checked what step is next in depending on published sns component - FS
						steps = fstools;
					} else if (guxPersonalisation.psn.profile.authState === "AN"){
						steps = antools;
					}
				}
			}
				this.snsArbiter(steps, kbas);
		},
		snsArbiter: function(steps, kbas) {

			// save in arr the Steps got from dfytranslations
			var arr = steps;

			// Check if a step is already done and remove it from the array.
			for(var key in kbas){
				var _kba = kbas[key];
				var indexHolder  = $.inArray(_kba.toString().slice(0,-1), steps);
				if(indexHolder != -1 && _kba != null) {
					steps.splice(indexHolder, 1);
				} else {
				} 
			}

			if(steps != undefined || steps != null){
				if(steps[0] != "" && steps[0] != undefined && steps[0] != null){
					//Show the current Step
					this.showNextStep($('.' + steps[0].toLowerCase()), true, true);
				} else {
					// If owner's registration is available for the market. Show it after all the steps is completed.
					if ( $( ".smartnextsteps.owner-reg" ).length ) {
						this.showNextStep($('.smartnextsteps.owner-reg'), true, true);
					}
				}
			}
		},
		showNextStep: function(element, isResponsiveImg, isCarousel) {

			// hide all smart next steps component
			$('.smartnextsteps').hide();

			// show specific component
			element.show();

			if(typeof picturefill !== "undefined" && isResponsiveImg === true) {
				picturefill();
			}
			
			if(isCarousel === true) {
				// reinit billboardCarousel
				guxApp.billboardCarousel.init(element);

				if(guxApp.viewport.view !== "mobile" && $('.flex-direction-nav', element).length > 0) { $('.flex-direction-nav', element).show(); }
			}

			// image preloader
			guxPersonalisation.rest.imageLoader(element, function() {
				// loader
				guxPersonalisation.rest.loader(element);
			});

		}

	};

})(jQuery);


/*
Author: 		Ruiwen Qin
File name: 		component-init.js
Description: 	
Dependencies: 	jQuery
Usage: 			
*/

var guxPersonalisation = guxPersonalisation || {};

(function($){


	guxPersonalisation.components = {

		componentItems: {},

		init: function() {

			if (!$(".personalisation").length) {return;}

			$(".personalisation").each(function(){
				//go through the personalisation modules on the page, and store the module name and dom elements into componentsArry
				var $this = $(this);
				guxPersonalisation.components.componentItems[$this.data("psn-module")] = $this;
			});

		},
		execute: function() {

			// init only when personalisation component found
			var billboardEl = guxPersonalisation.components.componentItems["billboard"],
				brandGallaryEl = guxPersonalisation.components.componentItems["brandgallery"],
				knowVehicleEl = guxPersonalisation.components.componentItems["knowvehicle"],
				dealerMsgEl = guxPersonalisation.components.componentItems["dealermessage"],
				locateDealerEl = guxPersonalisation.components.componentItems["locatedealer"],
				accessoriesEl = guxPersonalisation.components.componentItems["accessories"],
				promotionsEl = guxPersonalisation.components.componentItems["promotions"],
				rvvEl = guxPersonalisation.components.componentItems["recentlyviewed"],
				showRoomEl = guxPersonalisation.components.componentItems["showroom"];

			if($(billboardEl).length > 0) {
				guxPersonalisation.billboard.init(billboardEl);
			}

			if($(brandGallaryEl).length > 0) {
				guxPersonalisation.brandgallery.init(brandGallaryEl);
			}

			if($(knowVehicleEl).length > 0) {
				guxPersonalisation.knowvehicle.init(knowVehicleEl);
			}

			if($(dealerMsgEl).length > 0) {
				guxPersonalisation.dealermessage.init(dealerMsgEl);
			}
			if($(locateDealerEl).length > 0) {
				if (guxApp.tools.isAutoNaviMap()&&!guxApp.autonaviMapController) {
				//amap controller not loaded
					$.subscribe('amap-api-done', (function(){
					guxPersonalisation.locatedealer.init(locateDealerEl);
					}));				
				}
				else {
				//google map or amap controller loaded
					guxPersonalisation.locatedealer.init(locateDealerEl);				
				}
			}
			if($(accessoriesEl).length > 0) {
				guxPersonalisation.accessories.init(accessoriesEl);
			}

			if($(promotionsEl).length > 0) {
				guxPersonalisation.promotions.init(promotionsEl);
			}

			if($(rvvEl).length > 0) {
				guxPersonalisation.recentlyviewed.init(rvvEl);
			}

			if($(showRoomEl).length > 0) {
				guxPersonalisation.showroom.init(showRoomEl);
			}

			guxPersonalisation.smartnextsteps.init();
			
		}

	};

	$(function(){
		guxPersonalisation.components.init();
	});

})(jQuery);


/*
Author: 		Randell Quitain
File name: 		personalisation-fps.js
Description: 	Use FPS API Get
Dependencies: 	jQuery
Usage: 			
*/

var guxPersonalisation = guxPersonalisation || {};

(function($){
	guxPersonalisation.fps = {
		
		done: false,
		get: function(obj, success, error, callback){

			var execute;

			function OnPersonalizationScriptLoaded() {
				// do the personalization stuff in here after it's been loaded
			}

			// check if valid callback function
			if(typeof callback === "function") {
				execute = callback();
			}

			// check if FPS object exist
			if(typeof FPS != "undefined") {
				FPS.get(obj, { success: success, error: error, complete: execute });
			} else {
				return false;
			}
			
		}
		
	}

})(jQuery); 


/*
Author: 		Randell Quitain
File name: 		personalisation-rest.js
Description: 	Build 'personalised' URL
Dependencies: 	jQuery, jquery.cookie.js, underscore.js
Usage: 			getURL(source of rest, current component element)				- used to build the personalised URL for psn, nameplates, rvv and fps
				getData(personalised url) 										- used for collecting the data using the personalised URL
				cleanData(data) 												- reorganize the data
				getObjectLength(object) 										- get object length
				getEmbeddedData(current component element, x-json id)			- read JSON data using the "embeddedData" module specific to a component module
				urlPersonalisation(profile session/cookie)						- for building actual the personalisation rest parameters
				renderTemplate(current component element, data from getData())	- rendering templates of components
				loader(element)													- check if component is ready then show it if its done
				imageLoader(element, callback)									- check if images are done loaded
*/

var guxPersonalisation = guxPersonalisation || {};

(function($){
	guxPersonalisation.rest = {

		getURL: function(source, element) {

			var dfyp = guxPersonalisation.psn.profile,
				dfyu = ($.cookie('dfy.u')) ? $.parseJSON( $.cookie('dfy.u') ) : null,
				assetType = $(element).data('psn-type'),
				contentId = $(element).data('psn-id'),
				configInfo = guxApp.tools.commonConfigData(),
				restInfo = guxApp.tools.restServicesData(),
				ownedVehicle = (dfyu != null) ? dfyu.now : null,
				site = (configInfo != null && configInfo.site) ? configInfo.site : null,
				priceZone = (configInfo != null && configInfo.priceZone) ? configInfo.priceZone : null,
				brand = (configInfo != null && configInfo.brand) ? configInfo.brand : null,
				countryCode = (configInfo != null && configInfo.countryCode) ? configInfo.countryCode : null,
				serviceURL;

			// for billboard component data
			if(source === 'psn') {
				serviceURL = restInfo ? restInfo.psn : null;
				if(serviceURL !== null && site !== null && assetType && contentId) {
					serviceURL = serviceURL.replace('{site}', guxApp.tools.encode(site));
					serviceURL = serviceURL.replace('{assettype}', guxApp.tools.encode(assetType));
					serviceURL = serviceURL.replace('{contentid}', guxApp.tools.encode(contentId)) + '?profile=' + this.urlPersonalisation(dfyp);
				}
			}
			// for getting rvv data
			else if(source === 'rvv') {
				serviceURL = restInfo ? restInfo.rvv : null;
				if(serviceURL !== null && site !== null && priceZone) {
					serviceURL = serviceURL.replace('{site}', guxApp.tools.encode(site));
					serviceURL = serviceURL.replace('{priceZone}', guxApp.tools.encode(priceZone));	
				}
			}
			// for getting to know your vehicle & popular accessories data
			else if(source === 'nameplates') {
				serviceURL = restInfo ? restInfo.nameplates : null;
				if(serviceURL !== null && ownedVehicle !== null && ownedVehicle !== "" && $(element).data('psn-module') && site !== null) {
					serviceURL = serviceURL.replace('{nameplate}', guxApp.tools.encode(ownedVehicle));
					serviceURL = serviceURL.replace('{type}', ($(element).data('psn-module') === 'accessories') ? guxApp.tools.encode('accessories') : guxApp.tools.encode('know-your-vehicle'));
					serviceURL = serviceURL.replace('{site}', guxApp.tools.encode(site));
				}
			}
			// for dealers via code data
			else if(source === 'dealers') {
				serviceURL = restInfo ? restInfo["dealer.code"] : null;
				if(serviceURL !== null && dfyp.dc !== "") {
					serviceURL = serviceURL.replace('{site}', guxApp.tools.encode(site));
					serviceURL = serviceURL.replace('{code}', guxApp.tools.encode(dfyp.dc));
				}
				
			}
			// using fps
			else if(source === 'fps') {
				serviceURL = restInfo ? restInfo.fps : null;
				if(serviceURL !== null && brand !== null && countryCode !== null) {
					serviceURL = serviceURL.replace('{brand}', guxApp.tools.encode(brand));
					serviceURL = serviceURL.replace('{countryCode}', guxApp.tools.encode(countryCode));
				}
			}
			
			return serviceURL;

		},
		getData: function(url) {
			return $.ajax({
				url: url,
				type: 'GET',
				dataType: 'json'
			})
		},
		urlPersonalisation: function(session) {
			var psnJSON = {};
			// check if profile item available, if exist add them to JSON, encoded
			_.each(session, function (value, i) {
				(session['authState'] && session['authState'] != '') ? psnJSON['authState'] = guxApp.tools.encode(session['authState']) : null;
				(session['now'] && session['now'] != '') ? psnJSON['now'] = guxApp.tools.encode(session['now']) : psnJSON['now'] = "";
				(session['noi'] && session['noi'] != '') ? psnJSON['noi'] = guxApp.tools.encode(session['noi']) : null;
				/*(session['tools'] && session['tools'] != '') ? psnJSON['tools'] = guxApp.tools.encode(session['tools']) : null;
				(session['kba'] && session['kba'] != '') ? psnJSON['kba'] = guxApp.tools.encode(session['kba']) : null;*/
			});
			return JSON.stringify(psnJSON).replace(/\s/g, '%20');
		},
		renderTemplate: function(element, data) {
			var module = element.data('psn-module'),
				markup = $('#' + module + '-template', element).html();
			// build template - on a specific container
			// $(element).html(_.template(markup, {data:data}));
			element.find('.' + module + '-template').html(_.template(markup, {data:data}));
		},
		loader: function(element) {
			element.children('.loading').remove();
			element.children('.psn-loader').removeClass('psn-loader');
		},
		imageLoader: function(element, callback) {
			var imgLoad = imagesLoaded( element );
			imgLoad.on( 'always', function( instance ) {
				// show carousel nav
				if(guxApp.viewport.view !== "mobile" && $('.flex-direction-nav', element).length > 0) { $('.flex-direction-nav', element).show(); }
				if(typeof callback === "function") { callback(); }
			});
		}

	};

})(jQuery);


/*
Author: 		Randell Quitain
File name: 		personalisation.js
Description: 	Check auth status and setup cookies
Dependencies: 	jQuery, jQuery.cookie, jquery.tinypubsub, FPS
Usage: 			
*/

var guxPersonalisation = guxPersonalisation || {};

(function($){
	guxPersonalisation.psn = {
		uuid: {},
		profile: {},
		init: function(){

			/*
			Test UserCookie
			$.cookie('dfy.u', '{"fn":"John","now":"Mustang","s":"OW","authid":"311982","authby":"005","pcode":"MUSTANG","pc":"3000"}');
			*/

			var success, error;

			// subscribe to profile-done
			$.subscribe('profile-done', (function(){
				if(typeof guxPersonalisation.components !== "undefined") {
					// console.log('Start all components.');
					guxPersonalisation.components.execute();
				}
			}));

			// when FPS success
			success = function (value, status, jqXHR) {
				guxPersonalisation.psn.setProfile(value);
			};

			// when FPS fail
			error = function (value, status, jqXHR) {
				// console.log("FPS isn't loaded, dfy.p value based on FPS will not be updated.");
				// guxPersonalisation.psn.setProfile();
				return;
			};

			// check is FPS is available
			if(typeof FPS !== "undefined") {
				FPS.get([{ 'KBA': {} }, { 'LastViewedVehicle': {} }, { 'RecentlyViewedVehicles': {} }, { 'PreferredDealer': {} }], { success: success, error: error });
			} else {
				// console.log("FPS does not exist, dfy.p value based on FPS will not be updated.");
				// guxPersonalisation.psn.setProfile();
				return;
			}

			// $(window).on('resize',function(){
			// 	guxPersonalisation.psn.init();
			// });

		},
		setUUID: function(){
			if (!$.cookie('dfy.uuid')) {
				if (typeof uuid !== "undefined"){
					var configInfo = guxPersonalisation.psn.commonConfig(),
						cookieDomain = window.location.host;
					if(configInfo !== null && configInfo.cookieDomain) {
						cookieDomain = configInfo.cookieDomain;
					}
					// temporary adobe id
					guxPersonalisation.psn.uuid = { "id": uuid.v1() };
					// expiration: 5 years
					$.cookie('dfy.uuid', JSON.stringify(guxPersonalisation.psn.uuid), { expires: 1825, path: '/', domain: cookieDomain });
				}
			} else {
				guxPersonalisation.psn.uuid = $.parseJSON( JSON.stringify($.cookie('dfy.uuid')) );
			}
		},
		setProfile: function(data){
			// check if sessionStorage is supported
			if(typeof sessionStorage !== "undefined") {
				if (sessionStorage.getItem("dfy.p") === null) {
					sessionStorage.setItem("dfy.p", JSON.stringify(this.fillProfile(data)));
					// create adobeid on first visit
					guxPersonalisation.psn.setUUID();
				} else {
					// check/update  = $.parseJSON( JSON.stringify($.cookie('dfy.uuid')) );
					guxPersonalisation.psn.setUUID();
					sessionStorage.setItem("dfy.p", JSON.stringify(this.fillProfile(data)));
				}
			} else {
				// if sessionStorage is not supported - create cookie
				if (!$.cookie('dfy.p')) {
					var configInfo = guxPersonalisation.psn.commonConfig(),
						cookieDomain = window.location.host;
					if(configInfo !== null && configInfo.cookieDomain) {
						cookieDomain = configInfo.cookieDomain;
					}
					$.cookie('dfy.p', JSON.stringify(this.fillProfile(data)), { path: '/', domain: cookieDomain });
					// create adobeid on first visit
					guxPersonalisation.psn.setUUID();
				} else {
					// check/update  = $.parseJSON( JSON.stringify($.cookie('dfy.uuid')) );
					guxPersonalisation.psn.setUUID();
					$.cookie('dfy.p', JSON.stringify(this.fillProfile(data)), { path: '/', domain: cookieDomain });
				}
			}
		},
		fillProfile: function(value) {

			// standalone check if object is empty
			function isEmpty(obj) {
				for(var prop in obj) {
					if(obj.hasOwnProperty(prop)){ return false; }
				}
				return true;
			}

			// sort via "on"
			function sortOnDesc(arr) {
				var data = arr.sort(function(a, b) {
					var _a = a.on, _b = b.on;
					return _a <= _b ? -1 : 1;
				});
				return data.reverse();
			}

			// parse cookies/common-config
			var configInfo = guxPersonalisation.psn.commonConfig(),
				cookieUUID = null,
				cookieUser = null,
				cookieDL = null;

			if($.cookie('dfy.uuid')) {
				cookieUUID = $.parseJSON( $.cookie('dfy.uuid') );
			}
			
			if($.cookie('dfy.u')) {
				cookieUser = $.parseJSON( $.cookie('dfy.u') );
			}

			if($.cookie('dfy.dl')) {
				cookieDL = $.cookie('dfy.dl');
			}

			// FPS based values
			var noi = "NoVehicle",
				kba = "",
				f = "", 
				rvv = [],
				dc = (cookieDL != null) ? cookieDL : "";
				
			// set FPS values
			if(typeof value !== "undefined" && value !== null && !isEmpty(value)) {

				// console.group('FPS data:');
				// console.log(value);

				var kbas = value[0]['KBA'],
					lastViewedVehicle = value[1]['LastViewedVehicle'],
					recentlyViewedVehicles = value[2]['RecentlyViewedVehicles'],
					preferredDealer = value[3]['PreferredDealer'];

				if(typeof kbas !== "undefined" && !isEmpty(kbas)) {
					kba = "#";
					for (var key in kbas) {
						if (kbas.hasOwnProperty(key)) {
							kba += kbas[key]._KBA + "#";
						}
					}
				}

				/* buggy */
				// if(typeof lastViewedVehicle != "undefined" && lastViewedVehicle != null && !isEmpty(lastViewedVehicle)) {
				// 	noi = lastViewedVehicle[0]._nameplate.split(':')[1];
				// }

				if(typeof recentlyViewedVehicles !== "undefined" && !isEmpty(recentlyViewedVehicles)) {
					// sort to recently viewed - temporary lastViewedVehicle
					var lastViewedVehicle = sortOnDesc(recentlyViewedVehicles);
					noi = lastViewedVehicle[0]._nameplate.split(':')[1];
					for (var key in recentlyViewedVehicles) {
						if (recentlyViewedVehicles.hasOwnProperty(key)) {
							rvv.push({ "_nameplate": recentlyViewedVehicles[key]._nameplate });
						}
					}
					rvv = JSON.stringify(rvv);
				}

				if(typeof preferredDealer !== "undefined" && !isEmpty(preferredDealer)) {
					// sort to preferred dealer
					var preferredDealer = sortOnDesc(preferredDealer);
					// override dfy.d value if FPS is available
					dc = preferredDealer[0]._paCode;
				}
			}
			
			// check tools
			var tools = "";

			// define initial value
			var authState = "",
				now = "",
				id = (cookieUUID) ? cookieUUID.id : "",
				authid = "", /*TBD - based on dfy.p*/
				fn = "";

			//console.log(sessionStorage.getItem("dfy.p"));
			// set values depending on authState
			if(this.viewport() === "mobile"){
				if (cookieUser !== null) {
					authState = cookieUser.s;
					now = cookieUser.now;
					authid = cookieUser.authid;
					fn = cookieUser.fn;
				} else if (cookieUUID === null) {
					authState = "FS";
					// assign tools depending on authState
					if(configInfo != null && configInfo.smobFsTools) {
						tools = configInfo.smobFsTools;
					}
				} else if (cookieUUID != null && cookieUser === null) {
					authState = "AN";
					// assign tools depending on authState
					if(configInfo != null && configInfo.smobAnTools) {
						tools = configInfo.smobAnTools;
					}
				}
			} else {
				if (cookieUser !== null) {
					authState = cookieUser.s;
					now = cookieUser.now;
					authid = cookieUser.authid;
					fn = cookieUser.fn;
				} else if (cookieUUID === null) {
					authState = "FS";
					// assign tools depending on authState
					if(configInfo != null && configInfo.fsTools) {
						tools = configInfo.fsTools;
					}
				} else if (cookieUUID != null && cookieUser === null) {
					authState = "AN";
					// assign tools depending on authState
					if(configInfo != null && configInfo.anTools) {
						tools = configInfo.anTools;
					}
				}
			}
			// set profile
			guxPersonalisation.psn.profile = {
				"authState"	: 	authState,
				"now"		: 	now,
				"noi"		: 	noi, 
				"id"		: 	id, 
				"authid"	:  	authid,
				"tools"		:  	tools, 
				"kba"		:  	kba,
				"fn"		:  	fn, 
				"f"			:   f,
				"rvv"		:  	rvv,
				"dc"		:  	dc
			}
			
			// profile cookie/session creation done
			$.publish('profile-done');
			

			return guxPersonalisation.psn.profile;
		},
		commonConfig: function() {
			// standalone check #common-config
			if ($('#common-config').length) {
				return $('#common-config').embeddedData();
			} else {
				return null;
			}
		},
		viewport: function() {
			var view = "";
			if ($(window).width() < 768){
				this.view = "mobile";
			}
			else {
				this.view = "tablet";
			}
			return view;
		}
	}

	$(function(){
		guxPersonalisation.psn.init();
	});

})(jQuery);


/* shoppref.js */
/*
 * shoppref.js
 * Author:gbaker 13/12/2011 
 */

/*globals window, document, jQuery, ND, SiteConf */
ND.shoppingPreferenceManager = (function($, undefined){
	
	var 
		/*
		 * The Cookie manager for shopping preferences
		 */
		shoppingPreferenceManager = {
		
			prefix: "shopping.pref.",
	
			/*
			 * List of supported Shopping Preferences, and their short names
			 */
			list: { postcode: "pc", usage: "us", usageLabel: "us.l", region: "rg", regionLabel: "rg.l", pricezone:"pz", pricezoneLabel:"pz.l", priceformatData:"pf" },
			
			/*
			 * Constructor of sorts
			 */
			init: function() {				
				this.cache = {};
				this.store = {};
				this.listen();
				this.upgradeCookie();
			},
			
			/*
			 * Prepare the stores, executed on demand to minise overhead.
			 */
			prepare: function() {
				var self = this;
				var cookieDomain=null;
				var configInfo = (typeof $('#common-config') != 'undefined' && $('#common-config').length > 0) ? JSON.parse($('#common-config').html()) : null;			
				if(configInfo != null && configInfo.cookieDomain){
					cookieDomain=configInfo.cookieDomain;
				}
				$.each( self.list, function(type, typeShort) {
					var value, store;
					
					// Use shortname to keep the cookie small.
					store = Object.create(ND.cacheStore);
					store.key = "sp." + typeShort;
					store.expires = 365;
					if(cookieDomain){
						store.domain=cookieDomain;
					}

					// Cache locally so don't need to grab from the cookie later
					if( value = store.get() ) {
						self.cache[type] = value;
					}
					
					self.store[type] = store;
				});
				
				// When done, erase action
				self.prepare = $.noop;				
			},
			
			/*
			 * Listen to the PUBSUB channel for Shopping Prefenences
			 */
			listen: function() {
				var self = this;
				
				this.pubsub = {
					// Saving Data
					save: function(event, data) {
						data && self.setStoreData( data );
						
						//Broadcast change event (this is confirmed / complete data, as compared to the raw, possible incomplete data from ".save" )
						$.publish( self.prefix + "change", self.getStoreData() );
					},
					// Clear all
					clear: function(event, data) {
						self.clearStoreData();
						
						//Broadcast change event (this is confirmed / complete data, as compared to the raw, possible incomplete data from ".save" )
						$.publish( self.prefix + "change", self.getStoreData() );
					},
					// Retrieve
					retrieve: function(event, fn) {
						$.isFunction(fn) && fn.apply( null, [ event, self.getStoreData() ]);
					},
					//destroy, used by mobile, when changing page.
					destroy: function() {
						self.destroy();
					}
				};

				for( var channel in this.pubsub ) {
					$.subscribe( this.prefix + channel, this.pubsub[channel] );
				}
			},
			
			/*
			 * Get the shopping data
			 */
			getStoreData: function() {
				this.prepare();

				// Return a clone of the cache
				return $.extend( {}, this.cache );
			},
			
			/*
			 * Set the shopping data
			 */
			setStoreData: function( data ) {
				var self = this;
				
				self.prepare();
				
				// Manipulate the data for defaults
				data = this.checkDefaults( data );
				
				// Iterate the data and save it
				data && $.each( data, function(type, value) {
					
					if( type in self.list ) {
						
						// Store in the cookie
						self.store[type].set( value )
						
						// Cache locally so don't need to grab from the cookie later
						if( typeof value !== 'undefined' && String(value).length) {
							self.cache[type] = value;
						} else {							
							delete self.cache[type];
						}
					}
				});
			},
			
			/*
			 * Function to clear the data
			 */
			clearStoreData: function() {
				this.cache = {};
				
				$.each( this.store, function(type, store) {
					store.set();
				});
			},
			
			/*
			 * Function to insist on default values.
			 * Hot Deals, when postcode is provided, a usage is set as default.
			 */
			checkDefaults: function( data ) {
				if( data && data.postcode && !this.cache.usage && !data.usage ) {
					data.usage = 'p';
					data.usageLabel = 'Personal';
				}
				return data;
			},
			
			/*
			 * Function to upgrade the old postcode cookie into the new one.
			 * Can remove this sometime in the future after this has been live for a while.
			 */
			upgradeCookie: function() {
				var polkData, polkStore;
				
				polkStore = Object.create(ND.cacheStore);
				polkStore.key = 'price.usage';
				var configInfo = (typeof $('#common-config') != 'undefined' && $('#common-config').length > 0) ? JSON.parse($('#common-config').html()) : null;			
				if(configInfo != null && configInfo.cookieDomain){
					polkStore.domain=configInfo.cookieDomain;
				}
				
				if( polkData = polkStore.get() ) {
					// Upgrade the cookie
					$.publish( this.prefix + "save", polkData );	
					// Clear the old cookie
					polkStore.set();
				}
			},
			
			
			/*
			 * Cleanup method
			 */
			destroy: function() {
				for( channel in this.pubsub ) {
					$.unsubscribe( this.prefix + channel, this.pubsub[channel] );
				}
				this.cache = this.store = this.pubsub = this.prefix = this.list = null;
			}
			
		};
	
	
	/*
	 * Expose function that creates new shoppingPreferenceManager
	 * - ND.shoppingPreferenceManager 
	 */
	return function( arg ) {
		var manager = Object.create( shoppingPreferenceManager );
		manager.init.call( manager, arg );
		return manager;
	};
	
}(jQuery));


(function(){
	var ND = window.ND = window.ND || {};
			
	var fps = ND.fps = {
					
		_init: function( _fpstag ) {
			this._fpstag = _fpstag;			

		},
		
		// store links
		pageClicks : {},
		
		
		/*
		 * Track Page Views. 
		 */			
		trackPageView: function( params ) {			
			// if function is to be implemented, it will be the same as trackLink, so
			// console.log('Tracking FPS trackPageView');
			fps.trackFps(params);
		},
		
		trackLink: function( params ) {
			// console.log('Tracking FPS trackLink');
			//TODO
			//function executed when a trackable link is clicked
			// this function should track information to FPS The code should
			// call trackFps function (as links and pages are to be tracked in
			// the same way). What might differ might be a parameter format
			fps.trackFps(params);
		},
		
		

		trackFps:  function(params) {	
			// console.log('Tracking FPS');
			var kbaEvents = '';
			var setViewedVehicle = {};
			var setDelear = {};
			var setKBA = {};
			var setTool = {};
			var setAnonymous = {};
			var setOwner = {};
			var setKBARTDC = {};
			var setKBABRQC = {};
			var setKBABAPC = {};
			var setKBARAQC = {};
						
						
			var derivativeName = '';
			var derivativeID = '';
			var nameplateBrand = '';
			var nameplateYear = '';
			var nameplateName = '';
			var nameplateID = '';
			
			var bolSetFPS = false;
			
			
			// console.log('params = ' + params );
			if(typeof params !== 'undefined') {
				// console.log('params.nameplate = ' + params.nameplate );
			}
			
			if (typeof params !== 'undefined' && typeof params.nameplate !== 'undefined' ) {//'params contains nameplate information or other information relevant for FPS') {
	
				if(typeof _da !== 'undefined' && typeof _da.nameplate !== 'undefined') {
					
					
					if(params.nameplate == _da.nameplate.name) {												
						
						if(typeof _da.om.site !== 'undefined' ) {
							nameplateBrand =  _da.om.site;
						}
						
						if(typeof _da.nameplate !== 'undefined') {
							
							if(typeof _da.nameplate.name !== 'undefined') {
								nameplateName = _da.nameplate.name;
							}
							
							if(typeof _da.nameplate.id !== 'undefined') {
								nameplateID = _da.nameplate.id;
							}
							
							if(typeof _da.nameplate.year !== 'undefined' ) {
								nameplateYear =  _da.nameplate.year;
							}

						}
						
						if(typeof _da.der !== 'undefined') {
							
							if(typeof _da.der.name !== 'undefined') {
								derivativeName = _da.der.name;
							}
							
							if(typeof _da.der.id !== 'undefined') {
								derivativeID = _da.der.id;
							}

						}
						
											
						if(nameplateName != '') {
							   // console.log('FPS Set ViewedVehicle via Params');
							   setViewedVehicle = { 'ViewedVehicle': { _year: nameplateYear, _brand: nameplateBrand , _nameplate: nameplateID + ':' + nameplateName, _trim: derivativeID + ':' + derivativeName, _interior: '' , _exterior: '' }, metadata: { active: 'true' } }
							   bolSetFPS = true;
						}
					
					}
				}
	
			} else {
					
				if(typeof _da !== 'undefined') {
													
					if(typeof _da.om.site !== 'undefined' ) {
						nameplateBrand =  _da.om.site;
					}
					
					if(typeof _da.nameplate !== 'undefined') {
						
						if(typeof _da.nameplate.name !== 'undefined') {
							nameplateName = _da.nameplate.name;
						}
						
						if(typeof _da.nameplate.id !== 'undefined') {
							nameplateID = _da.nameplate.id;
						}
						
						if(typeof _da.nameplate.year !== 'undefined' ) {
							nameplateYear =  _da.nameplate.year;
						}

					}
					
					if(typeof _da.der !== 'undefined') {
						
						if(typeof _da.der.name !== 'undefined') {
							derivativeName = _da.der.name;
						}
						
						if(typeof _da.der.id !== 'undefined') {
							derivativeID = _da.der.id;
						}

					}
					
					// console.log('Nameplate = ' + nameplateName );
										
					if(nameplateName != '') {
						   // console.log('FPS Set ViewedVehicle via _da');
						   setViewedVehicle = { 'ViewedVehicle': { _year: nameplateYear, _brand: nameplateBrand , _nameplate: nameplateID + ':' + nameplateName, _trim: derivativeID + ':' + derivativeName, _interior: '' , _exterior: '' }, metadata: { active: 'true'} }
						   bolSetFPS = true;
					}

				}
			}

		
		
			if (typeof _da.events !== 'undefined') {				
				var currentEvent;
							
				
				if(typeof guxPersonalisation !== 'undefined' ) {
					
					if(typeof guxPersonalisation.psn.profile.kba !== 'undefined') {
						kbaEvents = guxPersonalisation.psn.profile.kba;
					}
				}

				
				for (var i = 0; i < _da.events.length; i++) {
				
					currentEvent = _da.events[i];
					
					if(currentEvent == 'event2') {
						
						if(kbaEvents.search('BAPC') == -1) {
						     // console.log('FPS Set KBAEvent BAPC');
							setKBABAPC = {'KBAEvent': {_KBA: 'BAPC'}, metadata: { active: 'true' } };
							bolSetFPS = true;
						}
					}

					if(currentEvent == 'event3') {
						
						if(kbaEvents.search('RAQC') == -1) {
						     // console.log('FPS Set KBAEvent RAQC');
							setKBARAQC = {'KBAEvent': {_KBA: 'RAQC'}, metadata: { active: 'true' } };
							bolSetFPS = true;
						}
					}
					
					if(currentEvent == 'event15') {
						if(kbaEvents.search('BRQC') == -1) {
							// console.log('FPS Set KBAEvent BRQC');
							setKBABRQC = {'KBAEvent': {_KBA: 'BRQC'}, metadata: { active: 'true' } };
							bolSetFPS = true;
						}
					}

					if(currentEvent == 'event20') {
						if(kbaEvents.search('RTDC') == -1) {
							// console.log('FPS Set KBAEvent RTDC');
							setKBARTDC = {'KBAEvent': {_KBA: 'RTDC'}, metadata: { active: 'true' } };
							bolSetFPS = true;
						}
					}					
					
				}
				

			}			

			
			if(typeof guxPersonalisation !== 'undefined' ) {
				
				
				if(typeof guxPersonalisation.psn.profile.authid !== 'undefined') {
					
					setOwner = {'ExternalRef': {_type: 'DFL', _id: guxPersonalisation.psn.profile.authid}, metadata: { active: 'true' } };
					bolSetFPS = true;
				}
				
				if(typeof guxPersonalisation.psn.profile.id !== 'undefined') {

					setAnonymous = {'ExternalRef': {_type: 'DFLA', _id: guxPersonalisation.psn.profile.id}, metadata: { active: 'true' } };
					bolSetFPS = true;
				}
				
				
			}			
			
			if(typeof FPS !== 'undefined') {
				
				if(bolSetFPS) {
					// Set all at once to minimized network connection
					FPS.set([ setViewedVehicle, setKBABAPC, setKBABRQC, setKBARTDC, setKBARAQC, setOwner, setAnonymous  ]);
				}

			
			}

		},
		
		trackEvent: function( params ) {
			// console.log('FPS Tracking Event');
			//TODO track favouriting dealer here and other 
			if (params.type == 'fav-dealer') {
				if(typeof FPS !== 'undefined') {
					FPS.set([ { 'PreferredDealer': { _paCode: params.code }, metadata: { active: 'true' } }]);
				}
			} else if (params.type == 'specified postcode') {
				//FPS.set( ... );
			} //else if {
				//TODO add all types here
			//}
		},
		trackSocial: function( params ) {
			// empty not needed at the current state, left here for
			// compatibility and future extensions reasons
		},			
		trackField: function( params ) {
			// empty not needed at the current state, left here for
			// compatibility and future extensions reasons
		},
		preCollection: function( options, params) {
			//this functional is called before tracking call is made.
			//TODO place here any code which has to happen before page track is made. like reading cookies or DOM metadata

		}

	};

})();


(function(){
	var ND = window.ND = window.ND || {};
	
	var omniture = ND.omniture = {
					
		_init: function( _omtag ) {
			this._omtag = _omtag;
		},
		
		// store links
		pageClicks : {},
		//store module component types
		moduleTypes : {},
		
		/*
		 * Track Page Views. 
		 */			
		trackPageView: function( params ) {
			//empty not needed at the current state, left here for compatibility reasons
			if (typeof params.login !== 'undefined') {
				s.eVar42 = 'x';
			}

		},
		createHier1 : function( hier1 ){
			if (typeof hier1 !== 'undefined') {
				s.hier1 = hier1;
			} else {
				s.hier1 = _da.hier;
			}
			
			//if (typeof _da.nameplate !== 'undefined') {
			//	s.hier1 = s.hier1 + ':' + _da.nameplate.year + ':' + _da.nameplate.cat + ':' + _da.nameplate.name;
			//}
		},
		createPageName : function( params ){			
			if (typeof params !== 'undefined' && params !== '' && typeof params.pname !== 'undefined'&& params.pname !== '') {
				s.pageName = s.eVar11 = s.prop11 = params.pname;
			} else {
				s.pageName = s.eVar11 = s.prop11 = _da.pname;
			}
			if (_da.funnel.stepname) {
				s.pageName = s.pageName + ':' + _da.funnel.stepname;
				s.eVar11 = s.eVar11 + ':' + _da.funnel.stepname;
				s.prop11 = s.prop11 + ':' + _da.funnel.stepname;
			}
			//lincoln2014 site search
			if (_da.pagenumber) {
				s.pageName = s.pageName + _da.pagenumber;
				s.eVar11 = s.eVar11 + _da.pagenumber;
				s.prop11 = s.prop11 + _da.pagenumber;
			}
			//sync omniture
			if (typeof _da.sync!== 'undefined'){
				if (typeof _da.sync.version  !== 'undefined') {
					s.pageName = s.pageName + ':' + _da.sync.version;
					s.eVar11 = s.eVar11 + ':' + _da.sync.version;
					s.prop11 = s.prop11 + ':' + _da.sync.version;
				}
			}
			if (typeof _da.prefix !== 'undefined') {	//set for prefix
				s.pageName = _da.prefix  + ':' + s.pageName;
				s.eVar11 = _da.prefix  + ':' + s.eVar11;
				s.prop11 = _da.prefix  + ':' + s.prop11 ;
			}
			
			if(typeof params !== 'undefined' && typeof params.nameplate !== 'undefined' && params.nameplate !== 'none'){
				s.pageName = s.pageName + ':' + params.nameplate;
			}else if (typeof _da.nameplate !== 'undefined') {	//set for nameplate based templates only
				s.pageName = s.pageName + ':' + _da.nameplate.name;
			}
			//add radui ominture tag
			if (typeof _da.radui !== 'undefined'){
				var raduiTag=_da.radui,windowWidth=$(window).width();
				raduiTag=raduiTag.split("|");
				if (windowWidth > 976) {
					//desktop
					s.prop54 =s.eVar54=raduiTag[0]+raduiTag[1];
				} else if (windowWidth < 977 && windowWidth > 767) {
					//tablet
					s.prop54=s.eVar54=raduiTag[0]+raduiTag[2];
				} else if (windowWidth < 768) {
					//smobile
					s.prop54 =s.eVar54=raduiTag[0]+raduiTag[3];
				}
			}

		},
		
		setRegion: function() {
			if (typeof _da.region !== 'undefined') {
				s.prop2 = s.eVar2 = _da.region;
			} else {
				s.prop2 = s.eVar2 = undefined;
			}
		},
		
		trackDerivativeDetails: function() {
			//v18	"Body Model,Trim"
			//v19	"Ext:Int Color Code"
			//v20	Accessories Picked
			//v21	Veh. Options Picked	
			//v23	"Option	Pkgs Picked"
			//v24	"Engine: Trans"
			//v25 	Price
			s.eVar18 = s.eVar19 = s.eVar20 = s.eVar21 = s.eVar23 = s.eVar24 = s.eVar25 = undefined;
			if (typeof _da.der  !== 'undefined') {
				if (typeof _da.der.name !== 'undefined') {
					s.eVar18 = _da.der.name;
				} 
				if (typeof _da.der.colour !== 'undefined' && typeof _da.der.trim !== 'undefined') {
					s.eVar19 = _da.der.colour + ':' + _da.der.trim;
				} 
				if (typeof _da.der.features !== 'undefined') {
					s.eVar20 = _da.der.features;
				}
				if (typeof _da.der.options !== 'undefined') {
					s.eVar21 = _da.der.options;
				}
				if (typeof _da.der.optionpacks !== 'undefined') {
					s.eVar23 = _da.der.optionpacks;
				} 
				if (typeof _da.der.engine  !== 'undefined') {
					s.eVar24 = _da.der.engine;
				}
				if (typeof _da.der.price   !== 'undefined') {
					s.eVar25 = _da.der.price;
				}
			} 
		},
		
		trackLink: function( params ) {
			if (params === undefined) {
				return;
			}
			//need to also set channel here...there is a case in
			//build and price where pre collection is not called yet.
			s.channel = _da.funnel.name;
			s.eVar4 = s.prop4 = _da.om.lang;	//language
			s.eVar14 = s.prop14 = _da.om.client;	//client
			s.eVar15 = s.prop15 = _da.om.site;	//site	
			//set the media value undefined
			s.prop57 = s.eVar57 = undefined; 
			s.prop55 = s.eVar55 = undefined;
			//fix end
			s.linkTrackVars=_da.om.linkTrackVars;
			s.linkTrackEvents=_da.om.linkTrackEvents;
			if (_da.nameplate && _da.nameplate.name && params.nameplate === undefined) {
				params.nameplate = _da.nameplate.name;
			}	
			//track pagename
			if (typeof params.pname !== 'undefined') {
				omniture.createPageName(params);
			} else {
				omniture.createPageName(params);
			}
			
			//set h1 based on data-hier attribute
			if (typeof params.hier1 !== 'undefined' && params.hier1 !== '') {
				omniture.createHier1(params.hier1);
			} else {
				omniture.createHier1(_da.hier);
			}
			
			if (params.intcmp){
				s.eVar13 = s.prop13 = params.intcmp;
			}else  {
				//?????	
			}			
			
			if (params.referred){
				s.eVar6 = s.prop6 = params.referred;
			}else  {
				s.eVar6 = s.prop6 = undefined;
			}			
			
			s.prop5 = params.onclicks;
			s.prop18 = params.leadtype;
			s.prop48 = s.eVar48 = params.tool;
			s.prop49 = s.eVar49 = params.tooldesc;
			
			if (typeof _da.deviceType !== 'undefined') {
                s.eVar54 = _da.deviceType;
            }
			
			s.events = params.events;
			if (params.year || typeof _da.nameplate !=="undefined") {
				if(params.year){
					s.prop12 = s.eVar12 = params.year;
				}
				if(typeof _da.nameplate !=="undefined" && !params.year){
					s.prop12 = s.eVar12 =_da.nameplate.year;
				}
			}else{
				s.prop12 = s.eVar12 = undefined;
			}
			if (params.nameplate && params.nameplate !== 'none') {
				s.prop16 = s.eVar16 = params.nameplate;
				params.title = params.titleNameplate == 'none' ? params.title : params.title + ':' + params.nameplate;
				omniture.trackDerivativeDetails();
			}else{
				s.prop16 = s.eVar16 = undefined;
			}
			
			if (params.content) {
				s.prop56 = s.eVar56 = params.content;
				if(s.prop5=="video start" || s.prop5=="video finish"){
					
					s.prop5 = s.prop5;
					
				}else{
					
					s.prop5 = s.prop5 + ':' + params.content;
				}
				
			} else {
				s.prop56 = s.eVar56 = undefined;
			}
			omniture.setRegion();
			//add a nameplate to the link, if defined in context
			//if (_da.nameplate) {
			//	params.title += (':' + _da.nameplate.name);
			//}
	//		_.debounce( function() {
			// add freq param

			// Turn on for parameter debugging and a tree-list of the data
			//console.log("Tracking link parameters: ");
			//console.dir(params);
			
			//gux module type
			if (typeof params.moduletype !== 'undefined') {
	            s.prop24 = params.moduletype;
	        }else{
	        	s.prop24 = undefined;
	        }
	        //gux c25 module name
	        if (typeof params.modulename !== 'undefined') {
	        	 s.prop25 = params.modulename;
	        }else{
	        	s.prop25 = undefined;
	        }

			//gux c23 click
	        omniture.setModulePage(params.moduleaction);
	        //gux v35/c21
	        omniture.createSearchTag(params);
	        var linkTitle = params.title;
	        if (typeof _da.prefix !== 'undefined' && params.type !=='e') {
	        	linkTitle = _da.prefix + ":"+linkTitle;
	        }
			if(typeof params.freq === 'undefined'){
				s.tl(params.link, params.type, linkTitle);
			}else if (params.freq =="page" && !omniture.pageClicks[linkTitle]){
				s.tl(params.link, params.type, linkTitle);				
				omniture.pageClicks[linkTitle] = linkTitle;
			}else if (params.freq =="category" && (!omniture.pageClicks[params.onclicks] || (params.moduletype && !omniture.moduleTypes[params.moduletype]))){
				s.tl(params.link, params.type, linkTitle);				
				omniture.pageClicks[params.onclicks] = params.onclicks;
				if(params.moduletype) omniture.moduleTypes[params.moduletype] = params.moduletype;
			}
	//		}, 1000);
		},
		trackMedia: function( params ) {
			// begin track video			
			if (params.content) {
				s.prop56 = s.eVar56 = params.content;
			} else {
				s.prop56 = s.eVar56 = undefined;
			}
			if (params.progress && params.content) {
				s.prop57 = s.eVar57 = params.content + ":"+params.progress;
			} else {
				s.prop57 = s.eVar57 = undefined;
			}
			if (params.segment) {
				 s.eVar55 = params.segment;
			} else {
				s.eVar55 = undefined;
			}			
			if (params.content && s.pageName) {
				s.prop55 = params.content +":"+ s.pageName;
			} else {
				s.prop55 = undefined;
			}
			if (params.mediaType) {
				s.pev3 = params.mediaType;
			} else {
				s.pev3 = undefined;
			}
			if (params.linkType) {
				s.pe = params.linkType;
			} else {
				s.pe = undefined;
			}
			if (params.events) {
				s.events = params.events;
			} else {
				s.events = undefined;
			}
			if (params.onclicks) {
                s.prop5 = params.onclicks;
			} else {
			    s.prop5 = undefined;
			} 
			//gux module type
			if (typeof params.moduletype !== 'undefined') {
	            s.prop24 = params.moduletype;
	        }else{
	        	s.prop24 = undefined;
	        }
	        // gux c25 module name
	        if (typeof params.modulename !== 'undefined') {
	        	 s.prop25 = params.modulename;
	        }else{
	        	s.prop25 = undefined;
	        }

			//gux c23 click
	        omniture.setModulePage(params.moduleaction);
			//end  track video
			s.t();
		},
		trackEvent: function( params ) {
			// empty not needed at the current state, left here for
			// compatibility and future extensions reasons
		},
		trackSocial: function( params ) {
			// empty not needed at the current state, left here for
			// compatibility and future extensions reasons
		},			
		trackField: function( params ) {
			// empty not needed at the current state, left here for
			// compatibility and future extensions reasons
		},
		createSearchTag:function(params){
			
			if(typeof _da.searchKeyword !== 'undefined'){
				s.eVar22=s.prop22=_da.searchKeyword;
			}else{
				s.eVar22=s.prop22= undefined;
			}
			if(typeof params!=='undefined' && typeof params.totalresult!=='undefined' && typeof params.resultnumber!=='undefined'){
				s.eVar35= s.prop21 = params.resultnumber+ ':' +params.totalresult;
			}
			else if(typeof _da.totalresult !== 'undefined'){
					if(typeof _da.resultnumber !== 'undefined'){
						s.eVar35=s.prop21=_da.resultnumber+":"+_da.totalresult;
					}else {
						s.eVar35=s.prop21=_da.totalresult;
					}
			}else {
				s.eVar35 = s.prop21 = undefined;
			}
			if(typeof params!=='undefined' && typeof params.cat!=='undefined' && typeof params.subcat!=='undefined'){
				s.eVar43= s.prop43 = params.cat+ ':' +params.subcat;
			}else{
				s.eVar43= s.prop43 = undefined;
			}
		},
		setModulePage:function(param){
			if (typeof param!== 'undefined' && typeof _da.module!== 'undefined' && typeof _da.module.page!=='undefined' && typeof _da.module.template!=='undefined'){
				moduleAction = param;
				s.prop23 = _da.module.page +":"+ _da.module.template + ":"+moduleAction;	
			}else{
				s.prop23 = undefined;
			}
		},
		preCollection: function( options, params) {
			//set some global stuff
			s.eVar4 = s.prop4 = _da.om.lang;	//language
			s.eVar14 = s.prop14 = _da.om.client;	//client
			s.eVar15 = s.prop15 = _da.om.site;	//site
			s.prop56 = s.eVar56 = undefined;
			
			//track pagename,c11/v11 and hierarchy
			if (typeof params !== 'undefined') {
				omniture.createPageName(params);
				omniture.createHier1(params.hier);
			} else {
				omniture.createPageName(undefined);
				omniture.createHier1(undefined);
			}

			s.channel = _da.funnel.name;
			s.prop39 = s.prop5 = undefined;
			
			if (typeof _da.nameplate !== 'undefined') {	//set for nameplate based templates only
				s.prop16 = s.eVar16 = _da.nameplate.name;
				s.prop12 = s.eVar12 = _da.nameplate.year;
			} else {
				s.prop12 = s.eVar12 = s.prop16 = s.eVar16 = undefined;
				s.prop36 = s.eVar34 = undefined;
			}
			omniture.trackDerivativeDetails();
			
			if (typeof params !== 'undefined' && params.tool !== 'undefined') {
				s.prop48 = s.eVar48 = params.tool;
				if (params.tooldesc !== 'undefined') {
					s.prop49 = s.eVar49 = params.tooldesc;
				}
			} else if (typeof _da.tool !== 'undefined') {
				s.prop48 = s.eVar48 = _da.tool.name;
				if (_da.tool.descriptor) {
					s.prop49 = s.eVar49 = _da.tool.descriptor;
				} else {
					s.prop49 = s.eVar49 = undefined;
				}
			} else {
				s.prop49 = s.eVar49 = s.prop48 = s.eVar48 = undefined;
			}
			
			if (typeof _da.lead !== 'undefined') {
				s.prop18 = s.eVar28 = _da.lead.type;
				if (_da.lead.optins) {
					s.prop20 = _da.lead.optins;
				} else {
					s.prop20 = undefined;
				}
			} else {
				s.prop18 = s.eVar28 = s.prop20 = undefined;
			}
			
			omniture.setRegion();
			
			if (typeof _da.events !== 'undefined') {
				s.events =  "";
				for (var i = 0; i < _da.events.length; i++) {
					if (s.events.length === 0) {
						s.events += _da.events[i];
					} else {
						s.events += ("," + _da.events[i]);
					}
				}
			} else {
				s.events = "";
			}
			//dealer info
			if (typeof _da.dealer !== 'undefined' && typeof _da.dealer.code!== 'undefined') {
                s.prop1 = s.eVar1 = _da.dealer.code;
			} else {
                s.prop1 = s.eVar1 = undefined;
			}
			
			if (typeof _da.user !== 'undefined' && typeof _da.user.loggedin !== 'undefined') {
                s.prop3 = s.eVar3 = _da.user.loggedin;
			} else {
                s.prop3 = s.eVar3 = undefined;
			}
			if (typeof _da.user !== 'undefined' && typeof _da.user.registered !== 'undefined') {
                s.prop45 = s.eVar45 = _da.user.registered;
			} else {
                s.prop45 = s.eVar45 = undefined;
			}
			if (typeof _da.onclicks !== 'undefined') {
                s.prop5 = _da.onclicks;
			} else {
			    s.prop5 = undefined;
			} 
			omniture.createSearchTag();
			//gux c23
			var moduleAction ="impress"
			omniture.setModulePage(moduleAction);
		}

	};

})();


/*
 * analytics.js
 * Author:gbaker 11/05/2011 
 *
 * #Exported API methods
 * ND.analytics.create				//Function to create Analytics Wrapper Implementation
 * ND.analytics.register			//Function to register Analytics Wrapper Implementation
 */
  
 var ND = (function(module, $) {
 
	var implementation = {},
		registrations = [];
	
	/*
	 * Omniture wrapper implementation (defined in analytics-omniture-impl.js)
	 */
	implementation.omniture = ND.omniture;
	
	
	//TODO Add fps implementation here (defined in fps-omniture-impl.js)
	implementation.fps = ND.fps;
	
	
	/*
	 * Webtrends Wrapper Implementation
	 */
	implementation.webtrends = (function(){
		
		function _dcsMultiTrack( _tag, arr ) {
			arr = arr || [];
			/*Need we clear all the cached parameters before tracking?*/
			//_tag.dcsCleanUp();
			_tag.dcsMultiTrack.apply( _tag , arr );
		}
		
		/* Helpers */
		var helpers = {
			
			// Looper
			each: function( help, arr, params) {
				$.each( help.split(','), function( i, item ) {
					helpers[item].apply( this, [arr, params] )
				});	
			},
			
			//Individuals
			title: function( arr, params ) {
				if( params && 'title' in params ) {
					$.merge( arr, ["WT.ti", params.title]);
				}			
			},
            funnel: function( arr, params ){
                if( params && 'funnel' in params) {
                    $.merge( arr, ["WT.si_n", params.funnel] );
                }
            },
            step: function( arr, params ){
                if( params && 'step' in params) {
                    $.merge( arr, ["WT.si_p", params.step] );
                }
            },
			event: function( arr ) {
				$.merge( arr, ["WT.dl", "99"]);
			},
			link: function( arr ) {
				$.merge( arr, ["WT.dl", "0"]);
			},	
			share: function( arr, params ) {
				if( params && 'socialId' in params ) {
					$.merge( arr, ["WT.z_share", params.socialId]);
				}
			},	
			uri: function ( arr, params ) {
				if( params && 'uri' in params ) {
					$.merge( arr, ["DCS.dcsuri", params.uri]);
				}
			},
			field: function( arr, params ) {
				if( params && 'field' in params) {
					var field = params.field;
					if(field.name){
						$.merge( arr, ["DCSext." + params.field.name, params.field.value || "" ]);
					}else if(field.constructor == Array){
						var r = [];
						for(var idx = field.length; --idx > -1 ; ){
							field[idx].name
								&& r.push("DCSext." + field[idx].name, field[idx].value || "");
						}
						$.merge( arr, r);
					}
				}
			},
			meta: function( a, b ) {
				return $(['<meta name="', a, '" content="', b, '"/>'].join(""));
			}
		}
			
		return {
			/*
			 * Constructor
			 */
			_init: function( _tag ) {
				this._tag = _tag;
			},
			
			/*
			 * Track Page Views. 
			 */			
			trackPageView: function( params ) {
				var arr = [];
				helpers.each( "title,uri", arr, params);					
				_dcsMultiTrack( this._tag, arr );
			},
			trackLink: function( params ) {
				var arr = [];
				helpers.each( "title,uri,link", arr, params);					
				_dcsMultiTrack( this._tag, arr );
			},
			trackEvent: function( params ) {
				var arr = [];
				helpers.each( "event,title,uri", arr, params);					
				_dcsMultiTrack( this._tag, arr );		
			},
			trackSocial: function( params ) {
				var arr = [];
				helpers.each( "event,title,uri,share", arr, params);					
				_dcsMultiTrack( this._tag, arr );
			},			
			trackField: function( params ) {
				var arr = [];
				helpers.each( "event,field,funnel,step", arr, params);					
				_dcsMultiTrack( this._tag, arr );
			},			
			/*
			 *  Before default tracking is triggered.
			 *
			 *	Function to handle when the form builder is on the page.
			 *  This function will be executed right before the Webtrends default tracking function
			 *  This gives ample time to prepare any special Meta Data require for this formpage.
			 *
			 *  Function will inject <meta> tags for WT.
			 */
			preCollection: function( options ) {
				var funnel = options.funnel || false,
					meta = $('meta:last');
				
				if( funnel && funnel.name ) {
					 meta.after( helpers.meta("WT.si_n", funnel.name ) );
				}
				if( funnel && funnel.stepname ) {
					 meta.after( helpers.meta("WT.si_p", funnel.stepname ) );
				}
				
			}
			
		};
	}());
		
	
	
	/*
	 * Exports 
	 */
	module.analytics = {

		/*
		 * Create instance of webtrends wrapper
		 */
		create: function( name, engine ) {
		
			function TrackerClass() {};
			TrackerClass.prototype = implementation[name];
			var tracker = new  TrackerClass();
		
			//var tracker = Object.create( implementation[name] )
			
			tracker._init( engine );
			delete tracker._init;
			tracker.name = name;
			return tracker;
		}, 
		
		/*
		 * Register the PUBSUB channel handlers 
		 * 
		 * PASTE this code into console if you want to see that is going on
		 *  	$.each( 'page,event,link,social'.split(',') , function( i, item ) {
		 * 			$.subscribe('/analytics/'+item+'/', function(e, data) { console.log( e.type, data ) });
		 *		})
		 */
		register: function( tracker ) {
			if( !tracker ) { return; }
			
			//check if this tracker is already registered
			for (i = 0; i < registrations.length; i++) {
				if (tracker.name === registrations[i].name) {
					//console.log("Tracker ["+registrations[i].name+"] already registered.")
					return;
				}
			}
			
			
			//TODO... use rules... 
			// -- remove track and lowercase
			var mapping =  {
				"pageview": "trackPageView",
				"link": "trackLink",
				"social": "trackSocial",
				"event": "trackEvent",
				"field": "trackField",
				"media":"trackMedia"
			}
			
			$.each( mapping, function(channel, funcName) {
				if( funcName in tracker ) {
					$.subscribe( "/analytics/" + channel + "/", (function( tracker, fn ) {
						return function( event, data ) {
							fn.apply( tracker, [data] );
						}
					})(tracker, tracker[funcName]) );
				}
			});
			
			registrations.push( tracker );
		},
		
		/*
		 *  Return a Helper function for grabbing content out of the DOM and using it in tracking.
		 */
		grabber: function() {
			
			function urlise( str ) {
				str = (str || "").toLowerCase()
					.replace(/[\s'"!@#$%\^\&\*\(\),\.<>;:\[\]{}?+/\\-_=]/g, "-")
					.replace(/(-){2,}/g, "-")
					.replace(/^-|-$/g, "");
					
				return str;
			}
			
			//Helper function
			return function( options ) {
				
				var elem, value, url, best;
				
				if( options.link ) {
					elem = $( options.link );			
					value = elem.attr("data-tracking-value") || elem.attr("title") || elem.text() || "",
					url = urlise( value );
				}
				
				if( options.meta ) {
					elem = $( options.meta );		
					value = elem.attr("content") || "",
					url = urlise( value );
				}
				
				if( options.inner ) {
					elem = $( options.inner );		
					value = elem.text() || "",
					url = urlise( value );
				}
				
				if( options.name ) {
					value = options.name,
					url = urlise( options.name );
				}

				return {
					value: value,
					url: url
				}
				
			}
			
		}
	}

	
	return module;
 
 }(window.ND || {}, jQuery));


/* context.js */
/**
 * @author szabetian
 * @project VOI prepopulation/Form builder/dealer locator
 * @description pre-populates model/series drop downs on forms if form is
 *              associated with proper context (by publisher). It also adds
 *              context param to links with ctx-voi class
 * 
 * @depends on shoppref.js (to read cookie and add pc param)
 */
ND.Context = (function($) {
	
	var 
	
	voiConfig = {
			excludedModels : ''
	},
	
	privateFunctions = {
			
		restServices : {
			fetchVOIData : function(url) {
				privateFunctions.restServices.ajaxCall(url, function(jqXHR) {
					privateFunctions.displayVehicleBanner(jqXHR);
					privateFunctions.displayDisclaimer(jqXHR);
					privateFunctions.populateModelDropdown(jqXHR);
                    privateFunctions.populateVehicleDropdown(jqXHR);
				});
			},
			fetchColorData: function(url, callback) {
				
				privateFunctions.restServices.ajaxCall(url, function(jqXHR) {
					var i = 0,
						colors = [];
					
					for (i = 0; i < jqXHR.length; i++) {
						colors.push({
							name: jqXHR[i].name,
							order: jqXHR[i].order,
							code: jqXHR[i].code
						});
					}
					
					callback(colors);
					
				});
			},
			ajaxCall : function(url, successCallback) {
				$.ajax({
					url: url,
					dataType: 'json', 
					success: function(jqXHR, textStatus, textResponse) {
						if (typeof jqXHR !== 'undefined' && jqXHR != null) {
							successCallback(jqXHR);
						}
					}, 
					error : function(jqXHR, textStatus, textResponse) {
						//console.log('Could not fetch voi rest data');
					}
				});
			}
			
		},
	
		
	   /**
         * Extracts context param (ctx=m:1178856483523;d:1178856483570) from URL
         */
		extractContext : function(idx, url) {
			idx += 4;
			var lastParam = url.indexOf('&', idx);
			return url.substring(idx, lastParam > idx ? lastParam : url.length );
		},
		
		addContextToHref : function(elmnt, ctx) {
	        var href = elmnt.attr('href'),
	            ctxIdx;
	        if (typeof href !== 'undefined') {
		        if ((ctxIdx = href.indexOf('ctx=')) > 0) {
		             // if there is already a ctx, compare it with new one
		            var indexOfLastAnd = href.lastIndexOf('&');
		            if (indexOfLastAnd < ctxIdx) {
		                indexOfLastAnd = href.length;
		            }
		
	            var oldCtx = href.substring(ctxIdx, indexOfLastAnd);
	            if (oldCtx !== ctx) {
	               href = href.replace(oldCtx, ctx);
	               elmnt.attr('href', href).attr('data-ajax', 'false');
	            }
	
	        } else if (href.length > 1) {  // don't add to # hrefs
	            if(href.indexOf('?') > 0) {
	                href +='&';
	            } else {
	                href += '?';
	            }
	            elmnt.attr('href', href + ctx).attr('data-ajax', 'false');
		        }
	        }
	    },
	    
		addDropdownChangeListeners: function($modelDD, voiRestData) {
			
			var $seriesDD = $('#voi-series-name'),
				$colorDD = $('#voi-colour-dd');
			if ($seriesDD.length > 0) {
				var $firstOption;
				if (privateFunctions.firstTime) {
					$firstOption = $seriesDD.html();
					privateFunctions.firstTime = false;
				}
				
				$modelDD.on('change', function (e) {
				    e.stopImmediatePropagation();
					var result = privateFunctions.findIdForName($modelDD.val(), null, voiRestData);
					
					if (result.m != null) {
						privateFunctions.setModelDropDownValue(result);
						privateFunctions.populateSeriesDropdown($seriesDD, voiRestData[result.mIdx].derivatives, $firstOption, $colorDD);
					} else {
						privateFunctions.populateSeriesDropdown($seriesDD, [], $firstOption, $colorDD);
					}
				});
				
				$seriesDD.on('change', function() {
					var result = privateFunctions.findIdForName($modelDD.val(), $seriesDD.val(), voiRestData);
					
					if (result.d != null) {
						privateFunctions.setDerivativeDropDownValue(result);
					}
					if ($colorDD.length > 0) {
						privateFunctions.populateColorDropdown($seriesDD, $('#voi-colour-dd'));
					}
				});
				
				
				if ($colorDD.length > 0) {
					$colorDD.on('change', function() {
						privateFunctions.setColorDropDownValue($colorDD);
					});
				}
			}
		},

        addDealerDropDownListeners: function($modelDD, voiRestData){
            var $versaoDD = $('#FormSales_Derivative'),
                $corDD = $('#FormSales_Color');

            var $firstOption = $versaoDD.html();

            $modelDD.on('change',function(){
                if($modelDD.get(0).selectedIndex !== 0){
                    $versaoDD.parent().css('display', 'block');
                }else{
                    $versaoDD.parent().css('display', 'none');
                    $corDD.parent().css('display', 'none');
                }
                var result  = privateFunctions.findIdForName($modelDD.val(), null, voiRestData);

                if(result.m != null){
                    //privateFunctions.setVehicleDropDownValue(result);
                    privateFunctions.populateSeriesDropdown($versaoDD, voiRestData[result.mIdx].derivatives,$firstOption, $corDD);
                }else{
                    privateFunctions.populateSeriesDropdown($versaoDD, [], $firstOption, $corDD);
                }
            });

            $versaoDD.on('change', function(){
                if($versaoDD.get(0).selectedIndex !== 0){
                    $corDD.parent().css('display', 'block');
                }else{
                    $corDD.parent().css('display', 'none');
                }
                var result = privateFunctions.findIdForName($modelDD.val(), $versaoDD.val(), voiRestData);

                if(result.d != null){
                    //privateFunctions.setDerivativeDropDownValue(result);
                }
                if($corDD.length > 0){
                    privateFunctions.populateColorDropdown($versaoDD, $corDD);
                }
            });

            if($corDD.length > 0){
                $corDD.on('change', function(){
                    privateFunctions.setColorDropDownValue($corDD);
                });
            }

        },
		
		findIdForName: function(modelName,derivativeName,voiRestData) {
			var i,j, derivative;
			var result = { m : null, d : null,//ids 
					mIdx : -1, dIdx : -1, 
					dy: null,//derivative year
					dcks: null,//derivative cks code
					mcks: null,//model cks code
					dqcode: null,//derivative quote code
					dtdcode: null,//derivative test drive code
					dbcode: null//derivative brochure code
					};
	
			for (i = 0; i < voiRestData.length; i++) {
				if (modelName === voiRestData[i].name) {
					
					result.m = voiRestData[i].id;
					result.mcks = voiRestData[i].modelCode;
					result.mIdx = i;
					if (derivativeName != null) {
						for (j = 0; j < voiRestData[i].derivatives.length; j++) {
							derivative = voiRestData[i].derivatives[j];								
							if (derivativeName === derivative.name) {
								result.dcks = derivative.derivativeCode;
								result.dy = derivative.year;
								result.d = derivative.id;
								result.dIdx = j;
								result.dqcode = derivative.quoteFulfilmentCode;
								result.dtdcode = derivative.testdriveFulfilmentCode;
								result.dbcode = derivative.brochureFulfilmentCode;
								break;
							}
						}
					}
					break;
				}
			}
			
			return result;
		},
		
		firstTime : true,
		
		displayVehicleBanner: function(voiRestData) {
			var ctx = publicFunctions.toJSONFromUrl();
			if (ctx != null && typeof ctx.m !== 'undefined' && ctx.m != null) {
				// consider using ND.Utils.lazyLoadImage
				var $bannerCFF = $('#voi-banner'),
					$banners = $('.voi-banner'),
					bannerUrl,
					$bannerDiv;
				if ($bannerCFF.length > 0 && $banners.length > 0) {
					for (i = 0; i < voiRestData.length; i++) {
						if (ctx.m === voiRestData[i].id) {
							bannerUrl = voiRestData[i][voiConfig.formRequestType + 'Banner'];
							if (typeof bannerUrl !== 'undefined' && bannerUrl != null && bannerUrl !== '') {
								// display loader
								
								// show loading image
								$banners.each(function() {
									$(this).removeAttr('style');
								});
								
								var img = new Image();
								// call this function after it's loaded
								img.onload = function() {
									// make wrapperformbuilder.data.EmailHandler
                                    // fully visible
									$banners.each(function() {
										$(this).find('img').attr('src',bannerUrl);
									});
								};
								// begin loading the image from ...
								img.src = bannerUrl;
							}
							break;
						}
					}
				}
			}
		},
		
		displayDisclaimer: function(voiRestData) {
			var ctx = publicFunctions.toJSONFromUrl();
			if (ctx != null && typeof ctx.m !== 'undefined' && ctx.m != null) {
				// consider using ND.Utils.lazyLoadImage
				var $disclaimer = $('#voi-disclaimer'),
					disclaimerText = null,
					foundDrv = false,
					i,j;
				if ($disclaimer.length > 0) {
					for (i = 0; i < voiRestData.length; i++) {
						if (ctx.m === voiRestData[i].id) {
							if (typeof ctx.d !== 'undefined' && ctx.d != null) {
								for (j = 0; j < voiRestData[i].derivatives.length; j++ ) {
									if (ctx.d === voiRestData[i].derivatives[j].id) {
										disclaimerText = voiRestData[i].derivatives[j]['derivative' + voiConfig.formRequestTypeUppercase + 'Disclaimer'];
										if (typeof disclaimerText !== 'undefined' && disclaimerText != null) {
											$disclaimer.hide().html(disclaimerText).fadeIn('fast');
											foundDrv = true;
										}
										break;
									}
								}
							}
							
							if (!foundDrv) {
								disclaimerText = voiRestData[i][voiConfig.formRequestType + 'Disclaimer'];
								if (typeof disclaimerText !== 'undefined' && disclaimerText != null) {
									$disclaimer.hide().html(disclaimerText).fadeIn('fast');
								}
							}
						} 
					}
				}
			}
		},
		
		populateModelDropdown: function(voiRestData) {
			var $dd = $('#voi-model-name');
			
			if ($dd.length > 0) {
				var options = [],
					excludedSerEl = $("#modelseries"),
					filterList = [],
					optionList = voiRestData.slice(0),
					i;
				//if there is excludedSeries defined, remove from option list	
				if(excludedSerEl.length>0){
					var excludeSerJson = $.parseJSON(excludedSerEl.html()),
						excludeModel = excludeSerJson.excludedModels;
					if(excludeModel&&excludeModel.length>0){
						var excludeModelArr = excludeModel.split(",");//convert excluded list from string to array
						for(var k = 0; k < voiRestData.length; k++){
							var count = 0;
							//if there is excludedSeries defined, remove from option list
							if(excludeModelArr && excludeModelArr instanceof Array && excludeModelArr.length>0){
								for(var j = 0; j < excludeModelArr.length; j++){
									if($.trim(voiRestData[k].name)==$.trim(excludeModelArr[j])){
										count++;//record as a flag if match exclude element
									}
								}
								//filter the array element, store those not in the exclude list
								if(count==0){
									filterList.push(voiRestData[k]);
								}
							}
						}
					}
				}
				//update list if has filter element
				if(filterList.length > 0){
					optionList = filterList.slice(0);
				}
				
				for (var i = 0; i < optionList.length; i++) {
					options.push('<option value="' + optionList[i].name + '">' + optionList[i].name + '</options>');
				}
				$dd.append(options.join(''));
				if (ND.FormBuilder && ND.FormBuilder.styleSelectOptions) {
					ND.FormBuilder.styleSelectOptions($dd);
				}
				privateFunctions.addDropdownChangeListeners($dd, voiRestData);
			
				var ctx = publicFunctions.toJSONFromUrl();
				if (ctx != null && (typeof ctx.m !== 'undefined' && ctx.m != null) ) {
					for (i = 0; i < voiRestData.length; i++) {
						if (ctx.m === voiRestData[i].id) {
							$dd.val(voiRestData[i].name);
							privateFunctions.setModelDropDownValue(ctx);
							//trigger change only if ctx exists
							$dd.trigger('change');
							break;
						}
					}
				}
				privateFunctions.refreshMobileDropdown($dd);
			}
		},

        populateVehicleDropdown: function(voiRestData) {
            var $vehicleDropdown = $('#FormSales_Model');
            var options = [];
            var optionList = voiRestData.slice(0);
            for(var i = 0; i < optionList.length; i++){
                options.push('<option value="' + optionList[i].name + '">'+ optionList[i].name +'</option>');
            }
            $vehicleDropdown.append(options.join(''));
            privateFunctions.addDealerDropDownListeners($vehicleDropdown, voiRestData);
        },
		
		
		setHiddenInputValue: function(selector, value) {
			if (value != undefined) {
				var $hiddenInput = $(selector);
				if ($hiddenInput.length > 0) {
					$hiddenInput.val(value);
				}
			}
		},
		
		setModelDropDownValue: function(value) {
			privateFunctions.setHiddenInputValue('#voi-model-id', value.m);
			privateFunctions.setHiddenInputValue('#voi-model-cks-code', value.mcks);
		},

		populateSeriesDropdown: function($dd, modelDerivatives, $firstOption, $colorDD) {
			
			if (typeof modelDerivatives !== 'undefined' && modelDerivatives != null && modelDerivatives.length > 0) {
				var options = [],
				i;	
				for (i = 0; i < modelDerivatives.length; i++) {
					options.push('<option value="' + modelDerivatives[i].name + 
								 '" data-derivativeid="' + modelDerivatives[i].id + '">' + modelDerivatives[i].name + '</options>');
				}
				$dd.empty().html($firstOption).append(options.join(''));
				if (ND.FormBuilder && ND.FormBuilder.styleSelectOptions) {
					ND.FormBuilder.styleSelectOptions($dd);
				}
				var ctx = publicFunctions.toJSONFromUrl(),
					derivative;
			
				if (ctx != null && ((typeof ctx.d !== 'undefined' && ctx.d != null))) {
					for (i = 0; i < modelDerivatives.length; i++) {
						derivative = modelDerivatives[i];
						if (ctx.d === derivative.id) {
							$dd.val(derivative.name);
							// /console.log('setting value of dropdown: ' +
                            // select + ' to ' + derName);
							privateFunctions.setDerivativeDropDownValue(ctx);
							
							$dd.trigger('change');
							break;
						}
					}
				} else {
					privateFunctions.populateColorDropdown($dd, $colorDD);
				}
				
			} else {
				$dd.html($firstOption);
				privateFunctions.populateColorDropdown($dd, $colorDD);
				
			}
			privateFunctions.refreshMobileDropdown($dd);
		},
		setDerivativeDropDownValue : function(value) {
			privateFunctions.setHiddenInputValue('#voi-series-id', value.d);
			privateFunctions.setHiddenInputValue('#voi-series-cks-code', value.dcks);
			privateFunctions.setHiddenInputValue('#voi-series-year', value.dy);
			privateFunctions.setHiddenInputValue('#voi-series-quote-code', value.dqcode);
			privateFunctions.setHiddenInputValue('#voi-series-brochure-code', value.dbcode);
			privateFunctions.setHiddenInputValue('#voi-series-testdrive-code', value.dtdcode);			
		},
		
		colorDropdownFirstOption : null,
		
		populateColorDropdown: function($seriesDD, $dd) {
			if ($dd.length > 0) {
				
				if (privateFunctions.colorDropdownFirstOption == null) {
					privateFunctions.colorDropdownFirstOption = $dd.html();
				}
			
				// call ajax service
				
				var derivativeId = $seriesDD.find(':selected').data('derivativeid');
				
				if (typeof derivativeId !== 'undefined' && derivativeId != null) {
					var colorUrl = voiConfig.colorUrl.replace('{site}', voiConfig.site)
					  .replace('{priceZone}', voiConfig.priceZone)
					  .replace('{derivative}', derivativeId);

					$dd.empty().html('<option value="">' + voiConfig.pleaseWaitMsg + '</options>');

					privateFunctions.restServices.fetchColorData(colorUrl, function(colorData) {
						var options = [],
							i;
						for (i = 0; i < colorData.length; i++) {
							options.push('<option value="' + colorData[i].code + '">' + colorData[i].name + '</options>');
						}
						$dd.empty().html(privateFunctions.colorDropdownFirstOption).append(options.join(''));
						if (ND.FormBuilder && ND.FormBuilder.styleSelectOptions) {
							ND.FormBuilder.styleSelectOptions($dd);
						}
						privateFunctions.refreshMobileDropdown($dd);
					});
				}
//                if (typeof derivativeId !== 'undefined' && derivativeId != null) {
//                    $dd.empty().html('<option value="">wait</options>');
//                    privateFunctions.restServices.fetchColorData('../../../../latest-offers-2014-client/carve/RAD2013/rest/dealer-color.js', function(colorData) {
//                            var options = [],
//                                i;
//                            for (i = 0; i < colorData.length; i++) {
//                                options.push('<option value="' + colorData[i].code + '">' + colorData[i].name + '</options>');
//                            }
//                            $dd.empty().html(privateFunctions.colorDropdownFirstOption).append(options.join(''));
//                            if (ND.FormBuilder && ND.FormBuilder.styleSelectOptions) {
//                                ND.FormBuilder.styleSelectOptions($dd);
//                            }
//                            privateFunctions.refreshMobileDropdown($dd);
//                    });
//                }
                else {
					$dd.empty().html(privateFunctions.colorDropdownFirstOption);
				}
				privateFunctions.refreshMobileDropdown($dd);
			}
		},
		
		refreshMobileDropdown: function($dd) {
			if ( $.mobile ) {
				$dd.selectmenu('refresh', true);
			}
		},
		
		setColorDropDownValue : function(colourDropdown) {
			privateFunctions.setHiddenInputValue('#voi-colour-code', colourDropdown.find(':selected').val());
			privateFunctions.setHiddenInputValue('#voi-colour-name', colourDropdown.find(':selected').text());
		},
			
		
		/**
         * if we have a form and config, make an ajax call and retrieve the VOI
         * list
         */
	    init : function() {
	    	
	    	var $restConfig = $('#rest-services'),
	    		$modeSeriesConfig = $('#modelseries'),
	    		$commonConfig = $('#common-config'),
	    		$form = ('form');
	    	// if there is at least one form on the page
            $('#FormSales_Derivative').parent().css('display','none');
            $('#FormSales_Color').parent().css('display','none');
	    	if ($form.length > 0) {
	    		
	    		// from legacy code...can't move it
		    	publicFunctions.legacyDisplayVehicleBanner();
				publicFunctions.legacyDisplayVehicleDisclaimer();
	    			
	    		if ($restConfig.length > 0 && $modeSeriesConfig.length > 0) {
		    		$.extend(voiConfig, JSON.parse($modeSeriesConfig.html()),
					    				JSON.parse($restConfig.html()),
					    				JSON.parse($commonConfig.html()));
		    		
		    		if (voiConfig.formRequestType) {
		    			var firstChar = voiConfig.formRequestType.charAt(0);
		    			voiConfig.formRequestTypeUppercase = voiConfig.formRequestType;
		    			voiConfig.formRequestType = voiConfig.formRequestType.replace(firstChar, firstChar.toLowerCase());
		    		}
		    		
		    		voiConfig.voiUrl = voiConfig.voiUrl.replace('{site}', voiConfig.site).replace('{makeName}', voiConfig.make);
		    		voiConfig.voiUrl += voiConfig.excludedModels;
		    		
		    		privateFunctions.restServices.fetchVOIData(voiConfig.voiUrl);
	    		}
                //privateFunctions.restServices.fetchVOIData('../../../../latest-offers-2014-client/carve/RAD2013/rest/dealer-vehicle.js');
	    	}
	    }
	    
	    
	},
	
	publicFunctions = {
			
		//used to prevent smob logic from double firing 
		//once after page init and once after document ready.
		isContextInitialised : false,
		
		startUp : function() {
	    	
	    	if (!publicFunctions.isContextInitialised) {
				// need to do this check on every page regardless
				publicFunctions.addContextToLinks();
				publicFunctions.addPostcodeContextToLinks();
				
				// if we have a form and config, make an ajax call and retrieve the
	            // VOI list
				privateFunctions.init();
				publicFunctions.isContextInitialised = true;
	    	}
	    },
		/**
         * Converts parameterised context to JSON
         * 
         * d:<derivativeid>;m:<modelid>
         */
		toJSON : function(contextParam) {
			var result = {};
			if (typeof contextParam !== 'undefined') {
				params = contextParam.split(";");
				for (var i = 0; i < params.length ; i++) {
					var nameValuePair = params[i].split(':');
					if (nameValuePair.length == 2) {// ensure it's a name value
                                                    // pair
						result[nameValuePair[0]] = nameValuePair[1];
					}
				}
			}
			return result;
		},
		
		/**
         * builds the context param (ctx=m:1178856483523;d:1178856483570)
         */
		buildContext: function(additionalParams) {
			var params = new Array();
			if ((typeof _da !== 'undefined') && (typeof _da.nameplate !== 'undefined') && (typeof _da.nameplate.id !== 'undefined') && _da.nameplate.id != '') {
				
				params.push( 'm:' + _da.nameplate.id);
			} 
			if	((typeof _da !== 'undefined') && (typeof _da.der !== 'undefined') && (typeof _da.der.id !== 'undefined') && _da.der.id != '') {
				params.push( 'd:' + _da.der.id);
			}
            if (typeof additionalParams !== 'undefined' && additionalParams != null) {
                for (key in additionalParams) {
                    params.push( key + ':' + additionalParams[key]);
                }
            }
// console.log('built ctx=' + params.join(';') + ' context');
			return params.length > 0 ? ('ctx=' + params.join(';')) : '';
		},

		/**
         * if the url does not contain the context variable, it might still
         * exist (if we are on a smart mobile site). in that case check for a
         * div with data-role page; if that div has a data-url with ctx param
         * then call this method with the new url.
         */
		toJSONFromUrl: function(url) {
			url = decodeURIComponent(url || window.location.href);
			
			// console.log('looking for ctx in url ' + url);
			var idx = url.indexOf('ctx=');
			var ctx = null;
			if (idx > 0) {
				ctx = privateFunctions.extractContext(idx, url);
			} else {
				// perhaps we are on a mobile site
				var mobileUrl = null;
				var page = null;
				if ((page = $('div[data-role="page"]').filter(':visible')) != null && 
					(mobileUrl = page.attr('data-url')) != null) {
					if ((idx = mobileUrl.indexOf('ctx=')) > 0) {
						ctx = privateFunctions.extractContext(idx, url);
					} 	
				}
			}
			if (ctx != null) {
				ctx = publicFunctions.toJSON(ctx);
			}
			// console.log('ctx is = ' + ctx);
			return ctx;
		},
		
		/**
         * adds context param (ctx=m:1178856483523;d:1178856483570) to links
         * with 'ctx-voi' class
         */
		addContextToLinks: function() {
			var ctx = publicFunctions.buildContext();
// console.log('addContextToLinks');
			$('a.ctx-voi').each(function() {
                privateFunctions.addContextToHref($(this), ctx);
			});
		},
        /**
         * If postcode cookie exists, add ctx=pc:3000 to links with class ctx-pc
         */
        addPostcodeContextToLinks: function() {
            $.publish('shopping.pref.retrieve', function(e, postcodeData) {
                if (typeof postcodeData !== 'undefined' && postcodeData != null &&
                    typeof postcodeData.postcode !== 'undefined' && postcodeData.postcode != null)  {
                    var ctx = publicFunctions.buildContext({pc : postcodeData.postcode });
                    $('a.ctx-pc').each(function() {
                        var link = $(this);
                        // we have to add a class to the link to make sure we
                        // don't
                        // add the param twice, as page DOM still remains part
                        // of the page after page change.
                        if (!link.hasClass('ctx-pc-added')) {
                            privateFunctions.addContextToHref(link, ctx);
                            // for smob. adding data-ajax="false" to ensure form
                            // reloads properly
                            // since it's a form post, it shouldn't be captured
                            // in history anyways.
                            link.attr('data-ajax', 'false');
                        }
                    });
                }
            });
        },
		
		/**
         * inserts a banner image on forms that have been properly setup for VOI
         * prepopulation
         */
		legacyDisplayVehicleBanner: function() {
			var ctx = publicFunctions.toJSONFromUrl();
			if (ctx != null && typeof ctx.m !== 'undefined' && ctx.m != null) {
				// consider using ND.Utils.lazyLoadImage
				var $bannerCFF = $('#voi-banner'),
					$data = $('#model-context-banner');
				if ($bannerCFF.size() && $data.size()) {
					var content = JSON.parse($data.html());
					// console.log('legacyDisplayVehicleBanner');
					if (typeof content[ctx.m] !== 'undefined') {
						 var url = content[ctx.m];
						 // console.log('legacyDisplayVehicleBanner: found
                            // url for model[' + ctx.m + ']: ' + url);
						 $bannerCFF.html('<img src="' + url + '" />');
						
					}
				}
			}
		},
		
		/**
         * inserts a derivative disclaimer text on confirmation page that have
         * been properly setup for VOI prepopulation
         */
		legacyDisplayVehicleDisclaimer : function() {
			var ctx = publicFunctions.toJSONFromUrl(),
				$disclaimer = $('#voi-disclaimer');
			if (ctx != null && $disclaimer.size()) {
				var $derivativeData = $('#derivative-context-disclaimer');
				if ((typeof ctx.d !== 'undefined' && ctx.d != null) && $derivativeData.size()) {
					var derivativeDisclaimer = $derivativeData.embeddedData();
					if (derivativeDisclaimer[ctx.d] != null) {
						var disclaimerText = derivativeDisclaimer[ctx.d];
						// console.log('legacyDisplayVehicleDisclaimer: found
                        // disclaimer for derivative[' + ctx.d + ']: ' +
                        // disclaimerText);
						$disclaimer.hide().html(disclaimerText).fadeIn('fast');
					} else {
						publicFunctions.legacyDisplayNameplateDisclaimer(ctx, $disclaimer);
					}
				} else {
					publicFunctions.legacyDisplayNameplateDisclaimer(ctx, $disclaimer);
				} 
			}
		},
		
		/**
         * inserts a disclaimer text for namteplates on confirmation page that
         * have been properly setup for VOI prepopulation
         */
		legacyDisplayNameplateDisclaimer : function(ctx, $disclaimer) {
			var $modelData = $('#model-context-disclaimer');
			if ((typeof ctx.m !== 'undefined' && ctx.m != null) && $modelData.size()) {
				var modelDisclaimer = $modelData.embeddedData();
				if (modelDisclaimer[ctx.m] != null) {
					var disclaimerText = modelDisclaimer[ctx.m];
					// console.log('legacyDisplayVehicleDisclaimer: found
                    // disclaimer for model[' + ctx.m + ']: ' + disclaimerText);
					$disclaimer.hide().html(disclaimerText).fadeIn('fast');
				}
			}
		},
		
		/**
         * Populates nameplate dropdown on any form that has a valid ctx=m:<modelId>
         */
		legacyPopulateModelDropdown: function(select, hiddenInput, modelNameList) {
			var ctx = publicFunctions.toJSONFromUrl(),
				$dd = $('#' + select);
			if (ctx != null && ((typeof ctx.m !== 'undefined' && ctx.m != null) && $dd.length > 0)) {
				var modelName = modelNameList[ctx.m];
				if (modelName && modelName != null) {
					$dd.val(modelName);
					$dd.trigger('change');
					// console.log('setting value of dropdown: ' + select + ' to
                    // ' + modelName);
					var $hi = $('#' + hiddenInput);
					if ($hi.size()) {
						$hi.val(ctx.m);
					}
				}
			}
		},
		
		/**
         * Populates derivative dropdown on any form that has a valid ctx=m:<modelId>;d:<derivativeId>
         */
		legacyPopulateSeriesDropdown: function(select, hiddenInput, derivativeNameList) {
			var ctx = publicFunctions.toJSONFromUrl(),
				$dd = $('#' + select);
			
			if (ctx != null && ((typeof ctx.d !== 'undefined' && ctx.d != null) && $dd.length > 0)) {
				var derName = derivativeNameList[ctx.d];
				if (derName && derName != null) {
					$dd.val(derName);
					$dd.trigger('change');
					// /console.log('setting value of dropdown: ' + select + '
                    // to ' + derName);
					var $hi = $('#' + hiddenInput);
					if ($hi.size()) {
						$hi.val(ctx.d);
					}
				}
			}
		}
		
		
	};
	
	/**
     * Execute voi-prepopulation for web
     */
	$(document).ready(publicFunctions.startUp);
	
	return publicFunctions;
	
})(jQuery);


/*
 * A place for Tracking code when there is no other.
 */
var ND = (function(module, $, window, document) {
	
	trackWebtrendFields = function() {
		/*
         * Tracking that implement by DOM ready.
         */
        var _da = window._da;
        if(_da === undefined) {
        	return;
        }
        var trackFields = _da.trackFields;
        if(trackFields !== undefined){
            var fields = [], key;
            for(key in trackFields){
                fields.push({
                    name: key,
                    value: trackFields[key]
                });
            }

            $.publish('/analytics/field/', { field : fields });
        }
	}	
	
	module.analyticsBinder = {
			
		/*
		 * Create instance of webtrends wrapper
		 */
		bind: function() {
			$(document).ready(function(){
				
				// Localise a grabber function. Grabber function helps with content values and urls
				var grabber = ND.analytics.grabber();
				
				/*
				 * <meta name="dfy.title" content="Focus" />
				 */
				master = grabber( { meta: "meta[name='dfy.title']" } );
			
				/*
				 * Social Links
				 */
				$('.socialmedia-wrapper').delegate('.socialmedia a', 'click', function(e){
				
					var link = grabber( { link: this } ),
						data = { 
							title: 'Follow ' + master.value + ' on ' + link.value,
							uri: '/follow/' +  link.url
						};
						
					$.publish('/analytics/social/', data);
					
				});
	
				
				/*
				 * When an Overlay opens.. 
				 * It is not based on the <A> tag because overlays are a complex beast.
				 * It's based on the overlay itself regardless of what trigger the event that opened it.
				 * See Unit Tests for example variations
				 */
				$.subscribe( "overlay.done", function( e, eventData ){
					var heading, link, name, data = {}, 
						blind = true,
						excludeClass = ".country-overlay"; //exclude select country overlay.
	
					if( eventData && eventData.contents && $(excludeClass, eventData.contents).size() < 1) {
	
						//Grab content
						heading = eventData.contents ? grabber( { link: eventData.contents.find(".head h1") } ) : {};
						link = grabber( { link: eventData.anchor } )
						name = grabber( { name: eventData.name } )
						
						//If no values are usable, then we are Blind tracking this overlay
						blind = !heading.value && !link.value && !name.value && !eventData.assetid;
						
						data = { 
							title: master.value + ' | ' + (name.value || heading.value || link.value || eventData.assetid),
							uri: '/' + master.url + '/overlay/' +  (name.url || heading.url || link.url || eventData.assetid)
						};
	
						if ( blind ) {
							data = { 
								title: master.value + ' | Overlay',
								uri: '/' + master.url + '/overlay'
							};
						}
						
						$.publish('/analytics/event/', data);
					
					}
				}); 
	
				/* 
				 * TBD: RSS
				 */
				$(".rss").delegate("a", "click", function(e){
					var link = grabber( { link: this } ),
						data = { 
							title: 'RSS',
							uri: link.url
						};
	
					$.publish('/analytics/event/', data);
				});
	
				/* 
				 * AddThis: 
				 * When click on AddThis link
				 * The add this layout is insert to body by script.
				 * Create a delegate event on document.
				 */
				$(document).delegate(".at_item", "click", function(e){
					var link = grabber( { link: this } ),
						data = { 
							title: ' Send to ' + link.value,
							uri: '/share/' + link.url,
							socialId: link.value
						};
	
					$.publish('/analytics/social/', data);
	
				});
	
				/*
				 * AddThis China
				 */
				$(document).delegate(".addlist a", "click", function(e){
					var link = grabber( { link: this } ),
						data = { 
							title: ' Send to ' + link.value,
							uri: '/share/' + link.url,
							socialId: link.value
						};
	
					$.publish('/analytics/social/', data);
	
				});
	
				/* 
				 * TBD: Like button 
				 */
				/*
				$(".fb-like").mouseover(function(e){
					var target = e.target; 
					if(e.tagName == "IFRAME"){
						
					}
				})
				*/;
	
				/*
				 * TBD: Google Plus Button
				 */
				/*
				$(".addthis_button_google_plusone").mouseover(function(e){
					var target = e.target; 
					if(e.tagName == "IFRAME"){
						
					}
				});
				*/
	
				/*
				 * TBD: Form Field Drop Off
				 */
				$('#dragonflyform').delegate('.ff-track-drop-off', 'focusout', function(e) {
	
					var field = $(this),
						data = {
							field: {
								name: field.attr('name') || this.id,
								value: field.val()
							}
						};
	
					//TBD: "parameters about the prefix "DCSext.xxx"
					$.publish('/analytics/field/', data);
				});
	
				/*
				 * VOI
				 */
				$('#dragonflyform').submit(function(e){
					var $model = $("#VOI_ModelSeries_Model", form);
					var $services = $("#VOI_ModelSeries_Series", form);
	
					if(!$model.size() && !$services.size()){
						return;
					}
	
					var form = $(this),
						data = {
							field: [
								{
									name: "model",
									value: $model.val()
								},
								{
									name: "series",
									value: $services.val()
								}
							]
						};
	
					$.publish('/analytics/field/', data);
				});
	
				/*
				 * View 360 Button: 2.8.1
				 */ 
				$('.view360-button a').click(function(e){
					
					var link = grabber( { link: this } ),			
						data = { 
							title: master.value + ' | ' + link.value,
							uri: '/' + master.url + '/360-view'
						};
						
					$.publish('/analytics/event/', data);
					
				});
	
				/* 
				 * Switch(Flash): 2.8.2
				 * */ 
				$("#car-swapper a").click(function(e){
					var link = grabber( { link: this } ),
						data = { 
							title: master.value + ' | ' + link.value,
							uri: '/' + master.url + '/switch-to-super-cab'
						};
	
					$.publish('/analytics/event/', data);
				});
	
				/*
				 * Switcher(banner): 2.8.3
				 */
				$('.slider .next, .slider .prev').click(function(e){
	
					var link = grabber( { link: this } ),
						data = { 
							title: master.value + ' | ' + link.value,
							uri: '/' + master.url + '/switch-to-banner'
						};
	
					$.publish('/analytics/event/', data);
				});
				
				/*
				 */ 
				$('.download').click(function(e){
					data = { 
						title: 'this is my link',
						link: this,
						type: 'd'
					};
	
					$.publish('/analytics/link/', data);			
				});
				var publishTrackData = function(elem,e){
					
					if ($(elem).hasClass("mobile") && guxApp.viewport.view !== "mobile") {
						return;
					}
					/*
					if(!$(elem).hasClass("noprevent")){
						e.preventDefault();
					}*/
					var $link = $(elem);
					var img, name, type, onclick, trigger = false, nameplate, leadtype, tool, events, year, pname,intcmp,hier,tooldesc,content,freq,moduletype,modulename,moduleaction,
					totalresult,resultnumber,titleNameplate,cat,subcat,referred,search;
					//link has omniture tracking data, capture the data and publish to pubsub
					if ((name = $link.attr('data-name')) && 
						(type = $link.attr('data-type'))) {
						onclick = $link.attr("data-onclicks");
						nameplate = $link.attr("data-nameplate");
						year = $link.attr("data-nameplate-year");
						leadtype = $link.attr("data-leadtype");
						tool = $link.attr("data-tool");
						tooldesc = $link.attr("data-tooldesc");
						events = $link.attr("data-events");
						pname = $link.attr("data-pname");
						intcmp = $link.attr("data-intcmp");
						hier = $link.attr("data-hier"); 
						content = $link.attr("data-content"); 
						freq = $link.attr("data-freq"); 
						moduletype = $link.attr("data-moduletype");
						modulename = $link.attr("data-modulename");
						moduleaction = $link.attr("data-moduleaction");
						totalresult = $link.attr("data-totalresult");
						resultnumber = $link.attr("data-resultnumber");
						titleNameplate = $link.attr("data-titlenameplate");	
						cat = $link.attr("data-cat");	
						subcat = $link.attr("data-subcat");
						referred= $link.attr("data-referred");
						search= $link.attr("data-search");
					} 
					//look for images inside the link, if the img has any omniture tracking data, publish to pubsub
					else if ((img = $link.find('img').first()) &&
								(name = img.attr('data-name')) && 
								(type = img.attr('data-type'))){
						onclick = img.attr("data-onclicks");
						nameplate = img.attr("data-nameplate");
						year = img.attr("data-nameplate-year");
						leadtype = img.attr("data-leadtype");
						tool = img.attr("data-tool");
						tooldesc = img.attr("data-tooldesc");
						events = img.attr("data-events");
						pname = img.attr("data-pname");
						intcmp = img.attr("data-intcmp");
						hier = img.attr("data-hier"); 
						content = img.attr("data-content"); 
						freq = img.attr("data-freq"); 
						moduletype = img.attr("data-moduletype");
						modulename = img.attr("data-modulename");
						moduleaction = img.attr("data-moduleaction");
						totalresult = img.attr("data-totalresult");
						resultnumber = img.attr("data-resultnumber");	
						titleNameplate = img.attr("data-titlenameplate");	
						cat = img.attr("data-cat");
						subcat = img.attr("data-subcat");
						referred= img.attr("data-referred");
						search= img.attr("data-search");
					}
					
					//check the type
					if ($link.hasClass('external-disclaimer')) { type = 'e'};
					//if name not set by data-name attribute, get the link name
					if (!name) {
						var link = grabber( { link: elem } )
						name = link.value;
					}
					//check personalisation click
					if (typeof moduleaction == 'undefined' 
						&& !($(elem).hasClass("open-video-flip")) 
						&& ($link.closest("section").hasClass('personalisation') 
						|| $link.closest("section").hasClass('smartnextsteps'))
						|| $link.hasClass('open-media-overlay')){						
						moduleaction = 'click';
					} else if (typeof moduleaction !== 'undefined'  && moduleaction=="none"){						
						moduleaction = undefined;
					}
					//gux Popular Accessories /Get to Know Your Vehicles			
					if ($link.closest("section").data('psn-module')=='knowvehicle' || $link.closest("section").data('psn-module')=='accessories'){						
						if(typeof $.cookie('dfy.u') !== "undefined" && typeof $.cookie('dfy.u') !== "function") {
							cookieUser = JSON.parse($.cookie('dfy.u'));
						}
						if (cookieUser != null) {
							modulename = cookieUser.now;
						 }
					}
					
					//gux showroom -- no longer needed
					//if($link.closest(".section-cars").data("sort-total") && $link.closest(".vehicle-data").data("sort-index")){
					//	totalresult = $link.closest(".section-cars").data("sort-total");
					//	resultnumber = $link.closest(".vehicle-data").data("sort-index");
					//}
					
					//for nameplate year and video carousel omniture
					var $section = $link.closest("section");
					if(_da.nameplate){
						if($section.hasClass("video-carousel") || $section.hasClass("reveal-slider")) {
							modulename = _da.nameplate.name;
						}
						if(!year) year = _da.nameplate.year;
					}
					
					//moduleaction
					$.publish('/analytics/link/', { 
						title: name,
						link: this,
						type: type,
						onclicks: onclick,
						leadtype: leadtype,
						tool: tool,
						tooldesc: tooldesc,
						events: events,
						year: year,
						nameplate: nameplate,
						pname: pname,
						intcmp: intcmp,
						hier1:hier,
						content:content,
						freq:freq,
						moduletype:moduletype,
					    modulename:modulename,
					    moduleaction:moduleaction,
					    totalresult:totalresult,
						resultnumber:resultnumber,
						titleNameplate: titleNameplate,
						cat:cat,
						subcat:subcat,
						referred:referred,
						search:search
					});	
				};
				/*$wait(function(){
					$(".trackable,.external-disclaimer").live({mouseover:function(e){},mousedown:function(){alert("live-mousedown")}});
					//$(".trackable,.external-disclaimer").on('click',function(e){alert('on')});
				})*/
				
				//$('.trackable,.external-disclaimer').click(function(e){
				//$(document).delegate(".trackable,.external-disclaimer","click",function(e){
				//$(document).on("click",'.trackable,.external-disclaimer',function(e){
				$(".trackable,.external-disclaimer").live('click',function(e){
					if($('.staging-wrap .trackable').size()>0){
						return;
					}
					publishTrackData($(this),e);
				});
				//quick lane share
				$("#content-tooltip").on("click",'.trackable',function(e){
					publishTrackData($(this),e);
				});
				
				
				//needed to use .on method to fire omniture tag for mini-dealer locator expand
				$(".mini-dealer .revealer-vertical .revealer-open.trackable").on('click',function(e){
					publishTrackData($(this),e);
				});
				
				// add omniture on gux billboard next/prev,billboard bullet
				$(".flex-direction-nav .flex-next, .flex-direction-nav .flex-prev, .flex-control-nav.flex-control-paging a,.alt-controls span.alt-prev,.alt-controls span.alt-next").live("click",function(e){		
					var $link = $(this);
					var $section = $link.closest("section");
					
					if(guxApp.viewport.view === "mobile" &&($(this).hasClass("flex-prev")||$(this).hasClass("flex-next"))) return;
					else if(guxApp.viewport.view !== "mobile" && $section.hasClass("hotspots")) return;
					
					if(!$section) return;
					publishTrackData($section,e);
				});				
				
				//gux nameplate colorizer
				//this is added because adding trackable on colorized module will not trigger omniture click event propagation
				$(".color-palette li a").on("click",function(e){
					var $link = $("#colorizer_data_analytics");
					publishTrackData($link,e);
				});
				
				//for nameplate reveal-slider module
				$(".imageReveal").on('mouseover',function(e) {
					$(".reveal-slider .imageReveal-drag").on('mousedown',function(e) {
						var $link = $(this);
						var $section = $link.closest("section");
						if(!$section) return;
						publishTrackData($section,e);
					});
					
					$(".imageReveal").off('mouseover');
				});
				
				//gux dealer omniture
				$(".view-all-dealers",$("section.dealer-locator")).live("mouseup",function(e){
					e.preventDefault();
					$(this).trigger('click');
					if (window._da && window._da.om && ND && ND.omniture) {
						_da.funnel.stepname='results';
						_da.events = "event1,event43".split(',');	
						_da.dealer = {};
					}
				});
				$.subscribe('dealers-done', (function(){
					if (window._da && window._da.om && ND && ND.omniture) {
						//each dealer search will init the dealer freq
						$.each(ND.omniture.pageClicks, function(key, value){
							if(key.match("^dealer")){
								ND.omniture.pageClicks[key] =  undefined;
							}
						});
						var data_tool = "event:find dealer";
						_da.funnel.stepname='results';
						//fire once per visit
						if(typeof _da.events == "undefined"){
							_da.events = "event1,event43".split(',');
							//data_tool = "event:find dealer";
						}else {
							_da.events = '';
							//data_tool = '';
						}							
						_da.dealer = {};
						
						var totalNum = $('.dealer-result-container .count .num').text();
						var vehicleData,$analyticsData = $("#vehilcesdata"),analyticsData;
						if($(".vehicle-search .nested-options select[name='vehicle']").length > 0 && $analyticsData && $analyticsData.length > 0){
							nameplateIndex = $(".vehicle-search .nested-options select[name='vehicle']").get(0).selectedIndex;
							analyticsData = JSON.parse($analyticsData.html());
							if (nameplateIndex && analyticsData && analyticsData["vehiclesdata"]) {
								vehicleData = analyticsData["vehiclesdata"][nameplateIndex - 1];
							}
						}
						if(totalNum){
							var totalResult = Number(totalNum);
							var perPage = 5;
							var totalPage = Math.floor((totalResult + perPage - 1 ) / perPage);
							var postcode = $('.dealer-result-container .result-list .dealer-result:first-child').data("postcode");
							_da.region = postcode;
							if(vehicleData){
								_da.nameplate ={"name":vehicleData.name,"year":vehicleData.year,'id':vehicleData.id};
							}else{
								_da.nameplate = undefined;
							}
							// the c49/v49 is not fired,c48/v48 should be fired every time
//							ND.analyticsTag.trackOmniturePage({
//								tool: data_tool,
//								tooldesc:'find dealer:1 of '+totalPage
//							});	
							ND.analyticsTag.trackOmniturePage({
								tool: data_tool
							});	
						}
						//only track once
						//$.unsubscribe('dealers-done');
					}
				}));
				$("section.dealer-locator .dealer-result .dealer-heading a,section.dealer-locator .dealer-result .details").live("click",function(e){					
					var dealerId = $(this).closest(".dealer-result").data("dealerid");
					var postcode = $(this).closest(".dealer-result").data("postcode");
					if (window._da && window._da.om && ND && ND.omniture) {
						_da.funnel.stepname='dealer:info';
						_da.events = '';
						_da.dealer = {code:dealerId};
						_da.region = postcode;
						_da.tool = {};
						ND.analyticsTag.trackOmniturePage();
					}
				});
				//add ominture on per 360 movement
				$("#overlay .vr-container .360trackable").live("slide",function(e){
					if($('.staging-wrap .trackable').size()>0){
						return;
					}
					e.preventDefault();
					$(this).trigger('click');
					publishTrackData($(this),e);
					$("#overlay .vr-container .360trackable").die("slide");//only need to trigger once
				})
				
				/* for B515 experience tracking */
				$('.staging-wrap .trackable').live("click",function(e){
					var $link = $(this);
					publishTrackData($link,e);
				});
				
				/* for Service Calculator */
				$('.service-calc #service-dropdowns').on("change","select",function(e){
					var $link = $(this);
					var $section = $link.closest("section");
					var year = $("#year option:selected" ).text();
					var model = $("#model option:selected" ).text();
					var style = $("#style option:selected" ).text();
					var engine = $("#engine option:selected" ).text();	

					if(year !== guxApp.sc.selectTexts["select.year.text"] && model !== guxApp.sc.selectTexts["select.model.text"]
						&& style !== guxApp.sc.selectTexts["select.style.text"] && engine !== guxApp.sc.selectTexts["select.engine.text"]){

						publishTrackData($section,e);
					}
				});
				
		        /*
		         * Email tracking: Email Link Tracking Handler
		         * Attach an event (on click) to all emailto links. [ Design P12 ]
		        */
		        var mailHandler = function(e){
		            var anchorHref = e.target.href || '';
		                anchorFormat = anchorHref.toLowerCase();
	
		            if(anchorHref && anchorFormat.indexOf("mailto:") > -1){
		                anchorFormat = anchorFormat.replace(/[^\w]+/g, '-');
		                var data = { 
		                        title: anchorHref + ' | Email',
		                        uri: '/' + master.url + '/email/' + anchorFormat
		                    };
	
		                $.publish('/analytics/event/', data);
		            }
		        };
	
		        /*
		         * External dealer website tracking:
		         * Attach an event to all external links(click out). [ Design P12 ]
		        */
		        var externalHandler = function(e){
		            var anchor = e.target, anchorClass = anchor.className;
	
		            //There will be 2 case: 1) It's in the external-disclaimer overlay. 2) It's an external link whout popup overlay
		            if(anchorClass && typeof(anchorClass)==="string" &&
		                (anchorClass.indexOf("external") > -1 || anchorClass.indexOf("external-disclaimer ") > -1)){
	
		                var href = $(anchor).attr("href"),
		                	hrefFormat ="";
		                if(typeof(href)!="undefined"){
		                	hrefFormat = href.replace(/[^\w]+/g, '-');
		                }
		                var data = {
		                        title: "Offsite:" + href,
		                        uri: '/' + master.url + '/external/' + hrefFormat
		                    };
	
		                $.publish('/analytics/event/', data);
		            }
		        };
	
		        //Handles all Omniture tracking links in an overlay
		        var trackingHandler = function(e) {
		        	var anchor = e.target, anchorClass = anchor.className;
	
		            //fullscreen button
					 if(anchorClass && typeof(anchorClass)==="string" && anchorClass.indexOf("btn-fullscreen") > -1) {
		            	//gallery view full screen button
		        		var linkName = s.eVar11 + ':full screen' //link name from a page name
		        		$.publish('/analytics/link/', { 
		        			title: linkName,
		        			link: this,
		        			type: 'o',
		        			onclicks: 'view full screen'
		        		});		
		        	}
		        }
		        
		        if ((_da.nameplate !== undefined && _da.nameplate.id !== undefined) || 
		        	(_da.derivative !== undefined && _da.derivative.id !== undefined)) {
		        	//delegate to context
		        	ND.Context.addContextToLinks();
		        } 
		        	
	
		        /*
		         * Global Click Tracking Listener
		         * One event listener intead of binding on every link, 
		         * In order to let it work on dynamic anchors that injected by Javascript.
		         */
		        $(document).bind("click", "a", function(e){
		        	//some listener may prevent/cancel the event listener.
		            if(e && e.target){
		                externalHandler(e);
		                mailHandler(e);
		                trackingHandler(e);
		            }
		        });
		        
		        trackWebtrendFields();
		        
			})
		}			
	}
	
	return module;
	
	
}(window.ND || {}, jQuery, window, document));



/*
		<!-- Configuration, must come from site wide configuration -->
		<script type="text/javascript">
		var _da = {}, _tag = _da.wt = {};
		// Web Trends ID, same ID for whole publication.
		_tag.dcsid="dcs3e9phnudz5bdfu8tzlamfrh_8n7o";
		// The hostname of the website.. Notice the DOT..  -> ".ford.com.au"
		_tag.fpcdom=".hostnamegoeshere.com";
		// The Time Zone
		_tag.timezone=10;
		</script>
*/

 (function(globals, $){

  /**
   * Private functions
   */
	var _isAnalyticsConfigured = function() {
		// Minimum variables required
		if( !globals._da ||
			!globals.ND ||
			!globals.ND.analytics ) {
			return false;
		}
		return true;
	};
	
	var _isWebTrendsConfigured = function() {
		if( globals._tag && 
				globals._da.wt && 
				globals._tag === globals._da.wt &&
				globals.WebTrends ) {
			return true;
		}
		return false;
	};
	
	/**
	 * Do not track single page applications(such as build and price)/mobile applications.The flag is set 
	 * in the view of the single page application.
	 */
	var _isNonSpecialWebAppOmnitureConfigured = function() {
		if(globals._da.om && 
		  (typeof globals._da.om.singlePageApp === 'undefined' || 
		   globals._da.om.singlePageApp === false) &&
		   (globals._da.om.mobileApp === undefined ||
		   globals._da.om.mobileApp === false)) {
			return true;
		}
		return false;
	};
	
	/**
	 * Tracks single page applications only as they need to set omniture variables manually (such as build and price).
	 * The flag is set in the view of the single page application.
	 */
	var _isSinglePageAppOmnitureConfigured = function() {
		if(!_isAnalyticsConfigured()) {
			return false;
		}
		if(globals._da.om && 
		   globals._da.om.singlePageApp === true) {
			return true;
		}
		return false;
	};
	
	/**
	 * Tracks mobile applications using jquery mobile.
	 * The flag is set in the view of the mobile application.
	 */
	var _isMobileAppOmnitureConfigured = function() {
		if(!_isAnalyticsConfigured()) {
			return false;
		}
		if(globals._da.om && 
		   globals._da.om.mobileApp === true) {
			return true;
		}
		return false;
	};
	
	

	//
	// TODO added new trackFps function here, something along these lines:
	//
	
	//var _trackFps = function(_tag, options, wtTracker, params) {
	var _trackFps = function(params) {
		

		//TODO not sure about this if - but likely we also need it here 
		if (_da.skipTracking == undefined || globals._da.skipTracking === false) {
			
			//Create Dragonfly FPS Tracking implementation
			var fpsTracker = ND.analytics.create( 'fps', s );
			
			//Register the DFY tracker implementation for custom activities
			ND.analytics.register( fpsTracker );
			
			//TODO Not sure what parameters are needed in these 2 calls ...
			
			//Give dragonfly a chance to inject meta tags dynamically
			fpsTracker.preCollection(_da, params);
			
			//Execute the normal default page load tracking function.
			//fpsTracker.trackPageView( _da, params);
			fpsTracker.trackPageView( params);
		}		
	};
	
	
	
	var _trackWebTrends = function(_tag, options, wtTracker) {
		//Initalise
		_tag = new WebTrends();

		//Extend.. Similiar as $.extend
		$.extend( _tag, options );
		
		//Further Initalise
		_tag.dcsGetId();
		
		//Create Dragonfly Tracking implementation
		wtTracker = ND.analytics.create( 'webtrends', _tag );
		
		//Register the DFY tracker implementation for custom activities
		ND.analytics.register( wtTracker );
		
		//Copy object
		var choice = $.extend( {}, _da );
		delete choice.wt;
	
		//Give dragonfly a chance to inject meta tags dynamically
		wtTracker.preCollection( choice );
		
		//Execute the normal default page load tracking function.			
		_tag.dcsCollect();
		
		//Expose the parameter
		ND.analytics._tag = _tag;
	};
	
	var _trackOmniture = function(params) {
		
		if (_da.skipTracking == undefined || globals._da.skipTracking === false) {
			//Create Dragonfly Tracking implementation
			var omTracker = ND.analytics.create( 'omniture', s );
			
			//Register the DFY tracker implementation for custom activities
			ND.analytics.register( omTracker );
			
			var _counterField = $('.searchresults-list .no-of-results');// for lincoln result page only. need send out the total No of results
			if(_counterField.length>0){
				_da.pname = _da.pname +':' + $.trim(_counterField.html());
			}
			//Give dragonfly a chance to inject meta tags dynamically
			//module page will need profile is ready
			if (typeof _da.module!=='undefined' && typeof _da.module.page!=='undefined' && typeof _da.module.template=='undefined'){
				var cookieUser = null,cookieUUID = null,moduleTemplate=null;
				if($.cookie('dfy.u')) {
					cookieUser = $.parseJSON($.cookie('dfy.u'));
				}
				if($.cookie('dfy.uuid')) {
					cookieUUID = $.parseJSON($.cookie('dfy.uuid'));
				}
				// set values depending on cookie
				if (cookieUser !== null) {
					moduleTemplate = "owner";					
				} else if (cookieUUID === null) {
					moduleTemplate = "new";
				} else if (cookieUUID != null && cookieUser === null) {
					moduleTemplate = "return";
				}				
				if (moduleTemplate!=null){
					_da.module.template = moduleTemplate;
					$("section.personalisation a[href*='intcmp='],section.smartnextsteps a[href*='intcmp='],section.personalisation form[action*='intcmp=']").each(function(idx){
						var attrName="",attrValue="";
						var attrHref = $(this).attr("href");
						var attrAction = $(this).attr("action");
						if(attrHref!= null && typeof attrHref!=='undefined'){
							attrName = "href";
							attrValue = attrHref;
						}else if(attrAction!= null && typeof attrAction!=='undefined'){
							attrName = "action";
							attrValue = attrAction;
						}
						var temp = "STATUS";
						if(attrValue.indexOf(temp)!=-1){	
							$(this).attr(attrName,attrValue.replace(temp,moduleTemplate));
						}	
					});
				}
				omTracker.preCollection( _da, params);
				//Execute the normal default page load tracking function.
				s.t();	
			}else{
				omTracker.preCollection( _da, params);
				//Execute the normal default page load tracking function.
				s.t();
			}
			
		}
	};
	 
	
	var _track = function() {
		// Minimum variables required
		if(!_isAnalyticsConfigured()) {
			return;
		}
	
	
		/* WEBTRENDS ONLY
	     * This if block represnets the integration of Webtrends only
		 */
		if(_isWebTrendsConfigured()) {
				
				//Create the real Tag
			var _tag,
				//The _tag configuration
				options = globals._tag,
				//Other
				wtTracker;
			
			//When the DOM is ready.
			$(document).ready(function() {
				_trackWebTrends(_tag, options, wtTracker);
				ND.analyticsBinder.bind();
			});
	
			
			//Export the _tag into the global space so that it looks like a normal webtrends tag in the DOM inspector
			globals._tag = globals._da.wt = _tag;
			
		}
	
		/* 
		 * The following is an example of how another implementation might work
		 * Google Analytics
		 * /
		if( globals._gaq && 
			globals._da.ga && 
			globals._gaq === globals._da.ga ) {
				
			//Create Dragonfly Tracking implementation
			var gaTracker = ND.analytics.create( 'google', _gaq );
			
			//Register the DFY tracker implementation for custom activities
			ND.analytics.register( gaTracker );
	
			// When the DOM is ready and analytics is ready.
			$(document).ready(function() {
				//Give dragonfly a chance to inject meta tags dynamically
				gaTracker.preCollection( _da );
				
				//Execute the normal default page load tracking function.
				_gaq.push(['_trackPageview']);
			});		
		}
		 */
	
			
		/* 
		 * Omniture implmentation
		 */
		if(_isNonSpecialWebAppOmnitureConfigured()) {
	 
			// When the DOM is ready and analytics is ready.
			$(document).ready(function() {
				if(_isNonSpecialWebAppOmnitureConfigured()) {

					_trackOmniture();
					_trackFps(); // added
					ND.analyticsBinder.bind();
				}
			});
			
			//TODO add similar code for FPS here
			globals._tag_om = globals._da.om;
			
		}  if(_isMobileAppOmnitureConfigured()) {
			
			/* 
			 * Omniture mobile implmentation
			 */
			
			/**
			 * if this method gets called we are on a mobile device that's using jquery mobile
			 */
			$(document).bind("mobileinit", function(){
				$(document).bind('pagechange', function() {
					
					_trackOmniture();
					//TODO wherever we have _trackOmniture() called, we also have to add trackFps();
					_trackFps();
					ND.analyticsBinder.bind();
				});
				//TODO add similar code for FPS here
				globals._tag_om = globals._da.om;
			});
		}
	}
	
	_track();
	
	/**
	 * WARNING: must be called explicitly every time page changes in single page app
	 */
	ND.analyticsTag = ND.analyticsTag || {
		
		trackOmnitureSinglePageApp : function() {
			if(_isSinglePageAppOmnitureConfigured()) {
				_trackOmniture();
				_trackFps(); // added by remjo
				//DO NOT bind more than once (ND.analyticsBinder.bind()), it's called in _setOnce
				//we want to set globals._da.om only once so remove the method after it's set.
				if (ND.analyticsTag._setOnce !== undefined) {
					ND.analyticsTag._setOnce();
					delete ND.analyticsTag._setOnce;
				}
			}
		},

		trackOmniturePage : function(params) {

			_trackOmniture(params);
			_trackFps(params); // added by remjo
		},
		
		_setOnce : function() {
			globals._tag_om = globals._da.om;
			ND.analyticsBinder.bind();
		},
		
		isSinglePageAppOmnitureConfigured: _isSinglePageAppOmnitureConfigured
	};
	
	
	
}(window, jQuery));

// Now that this code is executed  ->  _tag instanceof WebTrends




/*
Author: 		Ivy/Brett
File name: 		brightcoveTrack.js
Description: 	track brightcove event  video start/video finish
Dependencies: 	jQuery,brightcove
Usage: 			
*/

var ND = window.ND = window.ND || {};

(function($){

	var newWidth, year, modulename, mediaName,ts25,ts50,ts75,ts100,
		currWidth = window.innerWidth,
		trackPos = { "0" : 1, "0.25" : 1, "0.5" : 1, "0.75" : 1, "1" : 1},
		settings= {"track":"11111"};

	ND.Brightcove = {

		//template loaded event handler
		onTemplateLoad: function (experienceID) {
		  	// get references to the player and API Modules and Events
			ND.Brightcove.player = brightcove.api.getExperience(experienceID);
			ND.Brightcove.APIModules = brightcove.api.modules.APIModules;
			trackPos = { "0" : 1, "0.25" : 1, "0.5" : 1, "0.75" : 1, "1" : 1};
		},

		// template ready event handler
		onTemplateReady: function (evt) {
			ND.Brightcove.videoPlayer = ND.Brightcove.player.getModule(ND.Brightcove.APIModules.VIDEO_PLAYER);
			ND.Brightcove.experienceModule = ND.Brightcove.player.getModule(ND.Brightcove.APIModules.EXPERIENCE);
			ND.Brightcove.cuePointsModule = ND.Brightcove.player.getModule(ND.Brightcove.APIModules.CUE_POINTS);
			
			ND.Brightcove.videoPlayer.getCurrentVideo(function(video){
				var videoLengthEightyPercent = video.length/1000 * 0.8;
				ND.Brightcove.cuePointsModule.addCuePoints(video.id, [videoLengthEightyPercent]);
			});
			
			ND.Brightcove.resizeVideo();
			ND.Brightcove.videoPlayer.addEventListener(brightcove.api.events.MediaEvent.PROGRESS,function(e){				
				 var omTitle, omEvents,omType,omProgress,omSegment;				
				 var percent = Math.round(e.position / e.duration *100) / 100;
				 if (trackPos[percent]) {
			          switch (percent) {
			            case 0:
			              if (settings.track.charAt(0) == "1") {
			                omTitle = "video start";
			                omEvents = "event56";
			                mediaName = e.media.displayName; 
			                omType = "m_s";
			                omProgress = "0%";
			                omSegment = "1:M:0-25";
			              }
			              break;
			            case 0.25:
			              if (settings.track.charAt(1) == "1") {	
			            	omTitle = "video 25%";
			            	ts25 = Math.round(e.position);
			                omEvents = "event58,event61="+ts25+",event62";
			                omType = "m_i";
			                omProgress = "25%";
			                omSegment = "1:M:0-25";
			              }
			              break;
			            case 0.5:
			              if (settings.track.charAt(2) == "1") {
			            	omTitle = "video 50%";
			            	ts50 = Math.round(e.position);
			                omEvents = "event59,event61="+(ts50 - ts25)+",event62";
			                omType = "m_i";
			                omProgress = "50%";
			                omSegment = "2:M:25-50";
			              }
			              break;
			            case 0.75:
			              if (settings.track.charAt(3) == "1") {
			            	omTitle = "video 75%";
			            	ts75 = Math.round(e.position);
			                omEvents = "event57,event61="+(ts75 - ts50)+",event62";
			                omType = "m_i";
			                omProgress = "75%";
			                omSegment = "3:M:50-75";
			              }
			              break;
			            case 1:
			              if (settings.track.charAt(4) == "1") {
			                omTitle = "video finish";
			                ts100 = Math.round(e.position);
			                omEvents = "event60,event61="+(ts100 - ts75)+",event62";
			                omType = "m_i";
			                omSegment = "4:M:75-100";
			              }
			              break;
			          }
			          trackPos[percent] = 0;
//			          console.log("omTitle="+omTitle);
//			          console.log("omEvents="+omEvents);
//			          console.log("mediaName="+mediaName);
//			          console.log("omType="+omType);
//			          console.log("omProgress="+omProgress);
//			          console.log("omSegment="+omSegment);
			          if (omType) { 
			        	  ND.Brightcove.trackEvent(omEvents,omType,omProgress,omSegment);
			          }
				 }
			});
//			ND.Brightcove.videoPlayer.addEventListener(brightcove.api.events.MediaEvent.PLAY,function(e){
//				if (e.position == 0) {
//					mediaName = e.media.displayName; 
//					omTitle = "video start";
//					omEvents = "event56";
//					ND.Brightcove.trackEvent();
//				}
//			});
//			ND.Brightcove.videoPlayer.removeEventListener(brightcove.api.events.MediaEvent.PLAY);
//			
//			ND.Brightcove.videoPlayer.addEventListener(brightcove.api.events.CuePointEvent.CUE,function(e){
//				omTitle = "video finish";
//				omEvents = "event57";
//				ND.Brightcove.trackEvent();
//			})
//			ND.Brightcove.videoPlayer.removeEventListener(brightcove.api.events.CuePointEvent.CUE);
			ND.Brightcove.videoPlayer.addEventListener(brightcove.api.events.MediaEvent.COMPLETE, function(e){
				/*mediaName = e.media.displayName; 
				omTitle = "video finish";
				omEvents = "event57";
				ND.Brightcove.trackEvent();
				*/
				//For replaying.
				trackPos = { "0" : 1, "0.25" : 1, "0.5" : 1, "0.75" : 1, "1" : 1};
			});
			//ND.Brightcove.videoPlayer.removeEventListener(brightcove.api.events.MediaEvent.COMPLETE);

			// HTML5 iframe resize fix
			// Code taken from: http://docs.brightcove.com/en/video-cloud/smart-player-api/samples/responsive-sizing.html#HtmlMode
			ND.Brightcove.videoPlayer.getCurrentRendition(function(renditionDTO) {
			
				if (renditionDTO) {
					ND.Brightcove.calulateNewPercentage(renditionDTO.frameWidth, renditionDTO.frameHeight);
				} else {
					ND.Brightcove.videoPlayer.addEventListener(brightcove.api.events.MediaEvent.PLAY, function(event) {
						ND.Brightcove.calulateNewPercentage(event.media.renditions[0].frameWidth, event.media.renditions[0].frameHeight);
					});
				}
			});

			var evt = document.createEvent("UIEvents");
			evt.initUIEvent("resize",true,false,0);
			window.dispatchEvent(evt);
		},

		trackEvent: function(omEvents,omType,omProgress,omSegment){
			if (mediaName && omType && window._da && window._da.om && ND && ND.omniture ) {
			    var  data ={
				    "events":omEvents,
				    "linkType":omType,
				    "content":mediaName,
				    "progress":omProgress,
				    "segment":omSegment,
				    "mediaType":"video"
			    };
				ND.omniture.trackMedia(data);			    
			}
		},

		calulateNewPercentage: function(width,height) {
			var newPercentage = ((height / width) * 100) + "%";
			document.getElementById("videocontainer").style.paddingBottom = newPercentage;
		},

		resizeVideo: function() {
			window.onresize = function(evt) {
				newWidth = window.innerWidth;

				// only run this code if the browser width changes
				if (currWidth !== newWidth) {
					var resizeWidth = $(".BrightcoveExperience").width(),
						resizeHeight = $(".BrightcoveExperience").height();

					if (ND.Brightcove.experienceModule.experience.type == "html") {
						ND.Brightcove.experienceModule.setSize(resizeWidth, resizeHeight);
					}

					currWidth = window.innerWidth;
				}
			};
		}
	};

})(jQuery);


/*
Author: Ruiwen Qin
File name: video.js
Description: Initialize jwPlayer
Dependencies: jQuery, jwPlayer
*/
var guxApp = guxApp || {};

(function($){
	guxApp.video = {
		settings : {},
		defaults : {
	    	width : 593,
	    	height : 348,
	      	modes : [
	          {
	            type : 'html5',
	            config : {
	              // skin : "../../src/themes/ftd/skin/glow/glow.xml"
	              skin: "/themes/ftd/skin/glow/glow.xml"
	            }
	          }, 
	          {
	            type : 'flash',
	            // src : '../../src/themes/ftd/swf/player.swf',
	            src: "/themes/ftd/swf/player.swf",
	            config : {
	              // skin : "../../src/themes/ftd/skin/glow.zip"
	              skin: "/themes/ftd/skin/glow.zip"
	            }
	          } ],
	      	// Close tracking by default (begin, 25, 50, 75, finish)
	      	track : "00000",
	      	play : false
	    },

		init: function(){
			if (!$("#video-inner").length) {return;}
			
			//prepare setting options
			guxApp.video.dataSetup();
			guxApp.video.load("jwplayer-js", "/themes/ftd/js/lib/jwplayer.js");
		    $ready("jwplayer", guxApp.video.videoSetup);
			//video options setup and video initialize
			//guxApp.video.videoSetup();
			
		},
		//load script dynamicly
	    load: function(id, src){
	      if(document.getElementById(id)) return;

	      var js, fjs = document.getElementsByTagName("script")[0];
	      js = document.createElement("script");
	      js.id = id;
	      js.src = src;
	      fjs.parentNode.insertBefore(js, fjs);
	    },
		dataSetup: function(){
			if ($("#video-config").length > 0){
				var videoConfig = $("#video-config").embeddedData();
			}
			
			if (videoConfig !== undefined && !guxApp.tools.isEmpty(videoConfig)){
				guxApp.video.settings = $.extend({},guxApp.video.defaults,videoConfig);

				// customize skin for html5 video player
			    if (videoConfig.skin){
			    	// guxApp.video.settings.modes[0].config.skin = "../../src/themes/ftd/skin/" + guxApp.video.settings.skin + "/" + guxApp.video.settings.skin + ".xml";
			    	guxApp.video.settings.modes[0].config.skin = "/themes/ftd/skin/" + guxApp.video.settings.skin + "/" + guxApp.video.settings.skin + ".xml";
			    }
			}
		},
		videoSetup: function(){

			/*if (guxApp.viewport.view === "mobile") {
				guxApp.video.settings.play = false;
			} else {
				guxApp.video.settings.play = true;
			}*/

			var playerOptions = {
	        	image: guxApp.video.settings.image,
	        	modes: guxApp.video.settings.modes,
	        	levels : [ {
	          		type : 'video/mp4',
	          		file : guxApp.video.settings.file
	        	}],
	        	width: guxApp.video.settings.width,
	        	autostart:guxApp.video.settings.play,
	        	'plugins' : {}
	      	};

	      	if (guxApp.video.settings.controlbar) {
		    	playerOptions.controlbar = "none";
		    }

		    if (guxApp.video.settings.caption) {
        		playerOptions["plugins"]["captions-2"] = {
          			"file" : guxApp.video.settings.caption
        		};
      		}

      		//video initialize
      		jwplayer("video-inner").setup(playerOptions);
      		
      		jwplayer().onReady(function(){
      			var videoContainer = $("#modalWrap .modal-body"),
      				containerWidth = videoContainer.width(),
      				playerHeight,ratio;

      			//hide control bar until video starts to play
  				if (guxApp.video.settings.hideControls){
      				jwplayer().getPlugin("controlbar").hide();
      			}

      			//Don't hide control bar if using chrome.
      			console.log(guxApp.tools.isMobile());
      			if(!(guxApp.tools.isMobile() == "Android")){
      				jwplayer().getPlugin("controlbar").hide();
      			}

      			//set height of the player based on the ratio
      			if (guxApp.video.settings.ratio){
		      		var prop = guxApp.video.settings.ratio.split(":");
		      		ratio = prop[1] / prop[0];
		      		playerHeight = containerWidth * ratio;
		      		jwplayer().resize(containerWidth,playerHeight);
		      	}

      			//resize the dimension of the player along with window size
      			$(window).resize(function(){
		            containerWidth = videoContainer.width();
		            playerHeight = containerWidth * ratio;
		            jwplayer().resize(containerWidth,playerHeight);
      			});

      			// hide close button on fullscreen
      			$("#video-inner").on("click", "#video-inner_jwplayer_controlbar_fullscreenButton", function() {
		            $(".modal .icon-close").hide();
		        });
		        
				// show close button on fullscreen
		        $("#video-inner").on("click", "#video-inner_jwplayer_controlbar_normalscreenButton", function() {
		            $(".modal .icon-close").show();
		        });

      			jwplayer().play(guxApp.video.settings.play);

      			$(".modal-body").removeClass("loading-video");
  			});

  			jwplayer().onPlay(function(){
          		jwplayer().getPlugin("controlbar").show();
          		jwplayer().resize(jwplayer().getWidth(),jwplayer().getHeight());
        	});

        	// tracking impl
          	guxApp.video.settings.track != "00000" && guxApp.video.track(guxApp.video.settings);
	},
		// track video
	    track : function(settings) {
	      	// tracking flag
	      	var trackPos = { "0" : 1, "0.2" : 1, "0.5" : 1, "0.7" : 1, "0.8" : 1},
	          	ti = settings.title || "",
	          	dcsuri = settings.url || "",
	          	pname = settings.pname || "",
	          	hier = settings.hier|| "";
	      	jwplayer().onTime(function(e) {
	        	var percent = Math.round(e.position / e.duration * 10) / 10, action;
	        	var omTitle, omEvents, year, nameplate='none';	        	
	        	if (trackPos[percent]) {
	          		switch (percent) {
			            case 0:
			              if (settings.track.charAt(0) == "1") {
			                action = "Play";
			                omTitle = "video start";
			                omEvents = "event56";
			              }
			              break;
			            case 0.2:
			              if (settings.track.charAt(1) == "1") {
			                action = "Play 25";
			              }
			              break;
			            case 0.5:
			              if (settings.track.charAt(2) == "1") {
			                action = "Play 50";
			              }
			              break;
			            case 0.7:
			              if (settings.track.charAt(3) == "1") {
			                action = "Play 75";
			              }
			              break;
			            case 0.8:
			              if (settings.track.charAt(4) == "1") {
			                action = "Finish";
			                omTitle = "video finish";
			                omEvents = "event57";
			              }
			              break;
	          		}

	          		trackPos[percent] = 0;

		          	if (omTitle && omEvents) {
		        		if (window._da && window._da.om && ND && ND.omniture ) {
		        			var clip_n = settings.clip_n || ti;	
//		        			$.publish('/analytics/link',{
//		              			'link':true,
//		              	      	'onclicks':omTitle,
//		              			'events':omEvents,
//		              			'type':'o',
//		              			'content':clip_n,
//		              			'title':omTitle,
//		              			'nameplate':'none',
//		              			'pname':pname,
//		              			'hier1':hier
//		              		});
		        			if(_da.nameplate && _da.nameplate.year) year = _da.nameplate.year;
					    	if(_da.nameplate && _da.nameplate.name) nameplate = _da.nameplate.name;
					    	
		        			ND.omniture.trackLink({
		              			'link':true,
		              	      	'onclicks':omTitle,
		              			'events':omEvents,
		              			'type':'o',
		              			'content':clip_n,
		              			'title':omTitle,
		              			'nameplate':nameplate,
		    				    "titleNameplate":"none",
		              			'pname':pname,
		              			'hier1':hier,
		              			'year':year
		        			});
		    		  	}
		          	}          	          
//		          	if (action) {
//		            	var clip_n = settings.clip_n || (ti + (e.duration>>0)) ;
//		          
//			            // Tracking implementation
//			            ND.analytics._tag.dcsMultiTrack(
//			                "WT.ti", ti + action,
//			                "DCS.dcsuri", (dcsuri + action.replace(/ /g, '')).toLowerCase().replace(/ /g, '-'),
//			                "WT.clip_ev", action.replace(/ /g,''),
//			                "WT.clip_n", clip_n,
//			                "WT.dl", 7
//			            );
//		          	}
	        	}
	    	});

	      	// For replaying.
	      	jwplayer().onComplete(function(){
	        	trackPos = { "0" : 1, "0.2" : 1, "0.5" : 1, "0.7" : 1, "0.8" : 1};
	      	});
    	}
	};

})(jQuery);



(function($){$.fn.hoverIntent=function(f,g){var cfg={sensitivity:7,interval:100,timeout:0};cfg=$.extend(cfg,g?{over:f,out:g}:f);var cX,cY,pX,pY;var track=function(ev){cX=ev.pageX;cY=ev.pageY;};var compare=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);if((Math.abs(pX-cX)+Math.abs(pY-cY))<cfg.sensitivity){$(ob).unbind("mousemove",track);ob.hoverIntent_s=1;return cfg.over.apply(ob,[ev]);}else{pX=cX;pY=cY;ob.hoverIntent_t=setTimeout(function(){compare(ev,ob);},cfg.interval);}};var delay=function(ev,ob){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);ob.hoverIntent_s=0;return cfg.out.apply(ob,[ev]);};var handleHover=function(e){var p=(e.type=="mouseover"?e.fromElement:e.toElement)||e.relatedTarget;while(p&&p!=this){try{p=p.parentNode;}catch(e){p=this;}}if(p==this){return false;}var ev=jQuery.extend({},e);var ob=this;if(ob.hoverIntent_t){ob.hoverIntent_t=clearTimeout(ob.hoverIntent_t);}if(e.type=="mouseover"){pX=ev.pageX;pY=ev.pageY;$(ob).bind("mousemove",track);if(ob.hoverIntent_s!=1){ob.hoverIntent_t=setTimeout(function(){compare(ev,ob);},cfg.interval);}}else{$(ob).unbind("mousemove",track);if(ob.hoverIntent_s==1){ob.hoverIntent_t=setTimeout(function(){delay(ev,ob);},cfg.timeout);}}};return this.mouseover(handleHover).mouseout(handleHover);};})(jQuery);


(function($){
	
	var MegaMenu = function (container) {
		var menu = this;
		menu.container = container;
		menu.timeout = 100;
		menu.interval = 100;
		menu.sensitivity = 2;
		
		//hide li title bug 167937 Internal image ID will be shown up when mouse rollover to the extreme right of the vehicle image on the top navigation bar
		
		$("#nav>li").attr('title','');
		//end hide
		
		this.showMenu = function () {
			$(menu.container).addClass("active");
			$("DIV.mega-menu", menu.container).show();
		};
		
		this.hideMenu = function () {
			$(menu.container).removeClass("active");
			$("DIV.mega-menu", menu.container).hide();
		};
		
		
		//hide li title bug 167937 Internal image ID will be shown up when mouse rollover to the extreme right of the vehicle image on the top navigation bar
		
		$("#nav>li").attr('title','');
		//end hide
		
		this.init = function () {
			// Hover over/out
			$(this.container).hoverIntent({
				over: this.showMenu,
				out: this.hideMenu,
				interval: this.interval,
				sensitivity: this.sensitivity,
				timeout: this.timeout
			});
			/*
			// Click
			$(this.container).bind("click", function () {
				menu.showMenu();
				return false;
			});
			*/
			// Close button
			$("DIV.close-button A").bind("click", function () {
				menu.hideMenu();
				return false;
			});
		};
	};
	
	$(function(){
		$("#nav > LI").each(function () {
			if ($(this).children("DIV.mega-menu").size() > 0) {
				var megaMenu = new MegaMenu(this);
				megaMenu.init();
			}
			else if ($(this).children("DIV.menu").size() > 0) {
				$(this).hover(
					function() {
						$(this).addClass("active");
					},
					function() {
						$(this).removeClass("active");
					}
				);
			}
		});
	});
	
})(jQuery);


/* Copied from ftd/js/global.js */
/* Will be removed when the new GUX header design is ready */

(function($){
	// search-pannel focus func
	var searchLabel = {
		init: function(){
			if (!$(".search-pannel").length) {return;}

			$(".search-pannel").each(function(){
				var kw = $(this).find(".keyw");
				var kwVal = kw.val();
				kw.focus(function (){
					$(this).val("");
				});
				kw.blur(function (){
					var newkwVal = kw.val();
					if (newkwVal == ""){
						$(this).val(kwVal);
					}else{
						$(this).val(newkwVal);
					}
				});
			});
		}
	}

	$(function(){
		searchLabel.init();
	});
	
})(jQuery);


/* History go back button: reset state, and go back implement. */
(function($){
	$.fn.historyBack = function(){
		return this.each(function(){
			//using override "onclick" to avoid duplicate click event rised.
			this.onclick = function(e){
				//window.history.go(-1);
				
                e.stopPropagation();
                e.preventDefault();
                window.history.back(-1);
				
			};
		});
	};
})(jQuery);


/* Copied from ftdsmob/js/codebinding.js */
/* Will be removed when we fully utilize the responsive site*/
(function($) {
    $(function(){
        $(".back").historyBack();
    })

})(jQuery);


/*
Author: Ruiwen Qin
File name: imagelazyloading.js
Description: 
Dependencies: jQuery
Usage: 1. Add .lazy-loading class onto img tags
	   2. Use img/blank.gif as img src
	   3. Specify real image url in data-image-src attribute in img tag

	   Example: 
	   <img class="lazy-loading" src="media/blank.jpg" data-image-src="vehicle_fiesta.jpg" width="146" height="109" alt="Fiesta" />
*/

(function($){
	imageLazyLoading = {
		init: function(){
			if (!$(".lazy-loading").length) {return;}
			var images = $(".lazy-loading");
			imageLazyLoading.loading(images);
		},
		loading: function(images){
			images.each(function(){
				var image = $(this),
					src = image.data("imageSrc");
				image.prop("src",src);
			});
		}
	};

	$(function(){
		imageLazyLoading.init();
	});

})(jQuery);


/* shoppref.js */
/*
 * shoppref.js
 * Author:gbaker 13/12/2011 
 */

/*globals window, document, jQuery, ND, SiteConf */
ND.shoppingPreferenceManager = (function($, undefined){
	
	var 
		/*
		 * The Cookie manager for shopping preferences
		 */
		shoppingPreferenceManager = {
		
			prefix: "shopping.pref.",
	
			/*
			 * List of supported Shopping Preferences, and their short names
			 */
			list: { postcode: "pc", usage: "us", usageLabel: "us.l", region: "rg", regionLabel: "rg.l", pricezone:"pz", pricezoneLabel:"pz.l", priceformatData:"pf" },
			
			/*
			 * Constructor of sorts
			 */
			init: function() {				
				this.cache = {};
				this.store = {};
				this.listen();
				this.upgradeCookie();
			},
			
			/*
			 * Prepare the stores, executed on demand to minise overhead.
			 */
			prepare: function() {
				var self = this;
				var cookieDomain=null;
				var configInfo = (typeof $('#common-config') != 'undefined' && $('#common-config').length > 0) ? JSON.parse($('#common-config').html()) : null;			
				if(configInfo != null && configInfo.cookieDomain){
					cookieDomain=configInfo.cookieDomain;
				}
				$.each( self.list, function(type, typeShort) {
					var value, store;
					
					// Use shortname to keep the cookie small.
					store = Object.create(ND.cacheStore);
					store.key = "sp." + typeShort;
					store.expires = 365;
					if(cookieDomain){
						store.domain=cookieDomain;
					}

					// Cache locally so don't need to grab from the cookie later
					if( value = store.get() ) {
						self.cache[type] = value;
					}
					
					self.store[type] = store;
				});
				
				// When done, erase action
				self.prepare = $.noop;				
			},
			
			/*
			 * Listen to the PUBSUB channel for Shopping Prefenences
			 */
			listen: function() {
				var self = this;
				
				this.pubsub = {
					// Saving Data
					save: function(event, data) {
						data && self.setStoreData( data );
						
						//Broadcast change event (this is confirmed / complete data, as compared to the raw, possible incomplete data from ".save" )
						$.publish( self.prefix + "change", self.getStoreData() );
					},
					// Clear all
					clear: function(event, data) {
						self.clearStoreData();
						
						//Broadcast change event (this is confirmed / complete data, as compared to the raw, possible incomplete data from ".save" )
						$.publish( self.prefix + "change", self.getStoreData() );
					},
					// Retrieve
					retrieve: function(event, fn) {
						$.isFunction(fn) && fn.apply( null, [ event, self.getStoreData() ]);
					},
					//destroy, used by mobile, when changing page.
					destroy: function() {
						self.destroy();
					}
				};

				for( var channel in this.pubsub ) {
					$.subscribe( this.prefix + channel, this.pubsub[channel] );
				}
			},
			
			/*
			 * Get the shopping data
			 */
			getStoreData: function() {
				this.prepare();

				// Return a clone of the cache
				return $.extend( {}, this.cache );
			},
			
			/*
			 * Set the shopping data
			 */
			setStoreData: function( data ) {
				var self = this;
				
				self.prepare();
				
				// Manipulate the data for defaults
				data = this.checkDefaults( data );
				
				// Iterate the data and save it
				data && $.each( data, function(type, value) {
					
					if( type in self.list ) {
						
						// Store in the cookie
						self.store[type].set( value )
						
						// Cache locally so don't need to grab from the cookie later
						if( typeof value !== 'undefined' && String(value).length) {
							self.cache[type] = value;
						} else {							
							delete self.cache[type];
						}
					}
				});
			},
			
			/*
			 * Function to clear the data
			 */
			clearStoreData: function() {
				this.cache = {};
				
				$.each( this.store, function(type, store) {
					store.set();
				});
			},
			
			/*
			 * Function to insist on default values.
			 * Hot Deals, when postcode is provided, a usage is set as default.
			 */
			checkDefaults: function( data ) {
				if( data && data.postcode && !this.cache.usage && !data.usage ) {
					data.usage = 'p';
					data.usageLabel = 'Personal';
				}
				return data;
			},
			
			/*
			 * Function to upgrade the old postcode cookie into the new one.
			 * Can remove this sometime in the future after this has been live for a while.
			 */
			upgradeCookie: function() {
				var polkData, polkStore;
				
				polkStore = Object.create(ND.cacheStore);
				polkStore.key = 'price.usage';
				var configInfo = (typeof $('#common-config') != 'undefined' && $('#common-config').length > 0) ? JSON.parse($('#common-config').html()) : null;			
				if(configInfo != null && configInfo.cookieDomain){
					polkStore.domain=configInfo.cookieDomain;
				}
				
				if( polkData = polkStore.get() ) {
					// Upgrade the cookie
					$.publish( this.prefix + "save", polkData );	
					// Clear the old cookie
					polkStore.set();
				}
			},
			
			
			/*
			 * Cleanup method
			 */
			destroy: function() {
				for( channel in this.pubsub ) {
					$.unsubscribe( this.prefix + channel, this.pubsub[channel] );
				}
				this.cache = this.store = this.pubsub = this.prefix = this.list = null;
			}
			
		};
	
	
	/*
	 * Expose function that creates new shoppingPreferenceManager
	 * - ND.shoppingPreferenceManager 
	 */
	return function( arg ) {
		var manager = Object.create( shoppingPreferenceManager );
		manager.init.call( manager, arg );
		return manager;
	};
	
}(jQuery));


/**
 * @author: Sohrab Zabetian
 * @project: hotdeals
 * @description: use geopostion to find postcode/matching addresses using bing
 * 
 * How to use:
 * 
 *  ND.geoLocator(options).findLocation();
 * 
 * options : {
 * 		success(postcode (number) , address (Array) results for more advanced processing) [required]: when address is found,
 * 		error (error message) [required]: when address is not found,
 * 		enableHighAccuracy [optional, default false],
 *		maximumAge [optional, default 120000], 
 *		timeout[optional, default 60000]
 *	}
 */

ND.geoLocator = function(options) {
	var bingMapGeoLocatorUrl = "http://dev.virtualearth.net/REST/v1/Locations/";

	
	var $bingConfig = $('#bing-config');
	var $currentPositionTranslationConfig = $('#current-position-config');
	var bingMapsKey = "AneS6_OFtD0WZ43Xzp3kTumQpZGNxlycZiFErrnU6cmNmwqKFU3wRBZ7f80Q7MT6";
	if ($bingConfig.length) {
		var bingConfigData = $bingConfig.embeddedData();
		bingMapsKey = bingConfigData['bing-maps-key']; 
	}
	
	var currentPositionTranslationConfigData = {
		"geo-trans-denied-access-error" : "User denied the request for Geolocation",
		"geo-trans-loc-unavail-error" : "Location information is unavailable",
		"geo-trans-req-timeout-error" : "The request to get user location timed out",
		"geo-trans-unknown-error" : "Unknown error"
	};
	
	if ($currentPositionTranslationConfig.length) {
		currentPositionTranslationConfigData = $.extend(currentPositionTranslationConfigData,$currentPositionTranslationConfig.embeddedData());
	}
	
	var generalError = currentPositionTranslationConfigData['geo-trans-unknown-error'];
	var getPostalCodeByCoordinates = function(position) {
		var urlString = bingMapGeoLocatorUrl + position.coords.latitude + ", " + position.coords.longitude;
		$.ajax({
	      url: urlString,
	      dataType: "jsonp",
	      jsonp: "jsonp",
	      //timeout: 12000,
		  data: { key: bingMapsKey },
		  success: function (data) {
			 if (data && data.resourceSets && data.resourceSets.length > 0) {
				var result = data.resourceSets[0];
				if (result && result.estimatedTotal > 0 && result.resources.length > 0) {
					if (options.success) {
						var postcode = result.resources[0].address['postalCode'];
						options.success(postcode, result.resources);
					}
				} else {
//					console.dir(data);
					handleError(generalError);
				}
			 } else {
//				 console.dir(data);
				 handleError(generalError);
			 }
		  },
		  error: function(jqXHR, textStatus, errorThrown){
			  handleError(generalError);
	      }
	   });
	};
	
	var handleError = function(errorMsg) {
		if (options.error) {
			options.error(errorMsg);
		}
	};
	
	/**
	 * @param error.code	short	an enumerated value
	 */
	var locationNotFound = function(error) {
		var tranlatedError = generalError;
		switch(error.code) {
	    	case error.PERMISSION_DENIED:
	    		tranlatedError = currentPositionTranslationConfigData['geo-trans-denied-access-error'];//"User denied the request for Geolocation."
		      break;
		    case error.POSITION_UNAVAILABLE:
		    	tranlatedError = currentPositionTranslationConfigData['geo-trans-loc-unavail-error']; // 'Location information is unavailable.';
		      break;
		    case error.TIMEOUT:
		    	tranlatedError = currentPositionTranslationConfigData['geo-trans-req-timeout-error']; //"The request to get user location timed out."
		      break;
	    }
		
		handleError(tranlatedError);
	};
	
	return {
		findLocation : function() {
			if (navigator.geolocation) {
				navigator.geolocation.getCurrentPosition(
					getPostalCodeByCoordinates,
					locationNotFound,{
					enableHighAccuracy : options.highAccuracy || false,
					maximumAge:(options.maxAge || 120000), 
					timeout: (options.timeout || 60000)
					}
				);
			} else {
				handleError(generalError);
			}
		},
		
		locationNotFound: locationNotFound
	};
};


/*
Discription: For latest offer click event, to open the postcode overlay
             Combitation of '/ftd/web-hotdeals.js' and '/ftdsmob/mobile-hotdeals.js'
*/

ND.platformDependentHotDeal = {

    regionObtainer: {
        /**
		 * Display region link on the page. 
		 * @param model
		 */
        view: function (model) {
            if ($.mobile) {
                var existing = this._panel.find('.hotdeals-postcode');
                // Create the HTML to be injected
                render = $.tmpl(this.tmpl, model);
                //			console.log('postcodeTemplate.view');


                //Either replace or inject
                if (existing.length > 0) {
                    existing.replaceWith(render);
                    //				console.log('postcodeTemplate.view - > replacing with old');
                } else {
                    //				console.log('postcodeTemplate.view - > appending to page');
                    this._panel.append(render);
                }

                //used for mobile only, has no effect on web
                this._panel.trigger('create');
            }
            else {
                var existing = this._panel.find('.hotdeals-postcode'),
                    // Create the HTML to be injected
                    render = $.tmpl(this.tmpl, model);
                //Either replace or inject
                if (existing.length) {
                    existing.replaceWith(render);
                } else {
                    this._panel.append(render);
                }
            }
        },

        bindAdditionalListeners: function () {
            if ($.mobile) {
                var self = this;

                var locationTimeout;
                var doesCurrentLocationButtonExist = $('input.hotDeals-form-currentLocation').length > 0;
                if (doesCurrentLocationButtonExist) {
                    $(document).on('click', 'input.hotDeals-form-currentLocation', function (e) {

                        e.preventDefault();
                        self.loadingStatus(true);

                        locationTimeout = setTimeout(function () {
                            self.loadingStatus(false);
                            geoLocator.locationNotFound(1);
                        }, 20000);

                        var geoLocator = ND.geoLocator({
                            success: function (postcode) {
                                clearTimeout(locationTimeout);
                                //						console.log('success: clearTimeout');
                                self.loadingStatus(false);
                                //						console.log('Found postcode ' + postcode);
                                var form = $(self.formSelector);
                                form.find('#postcode').val(postcode);
                                form.submit();
                            },
                            error: function (message) {

                                //						console.log('error: clearTimeout');
                                self.loadingStatus(false);
                                self.formError(message);
                            },
                            maximumAge: 15000,
                            timeout: 15000
                        });
                        geoLocator.findLocation();
                    });
                }

                $(document).on('submit', '#hotDeals-form', function () {
                    if (doesCurrentLocationButtonExist) {
                        clearTimeout(locationTimeout);
                    }
                    return false;
                });

                //clean up the overlay for next round
                $.subscribe('overlay.usercancel', function () {
                    var form = $(self.formSelector);
                    form.find('#postcode').val('');
                    self._errorMsg.slideUp('fast');
                });

                $(document).on('click', '.cancel', function (e) {
                    e.preventDefault();
                    $('.close-button a').click();
                });

                $(window).unbind('scroll');
            }
        },

        loadingStatus: function (working) {
            if ($.mobile) {
                $.mobile.loading(working ? 'show' : 'hide');
                if($('#overlay .fbform .group > span.ui-icon').length==0){
                    $('#overlay .fbform .group > input[type=button],#overlay .fbform .group > input[type=submit]').parent().append("<span class='ui-icon ui-icon-arrow-r ui-icon-shadow'></span>");
                }
            }
            else {
                var self = this;

                // Clear delay
                self._loaderTimeout && clearTimeout(self._loaderTimeout);

                // Delay the error
                self._loaderTimeout = setTimeout(function () {
                    if (!self._form) { return; }
                    self.loader || (self.loader = $('<span class="loader"/>').appendTo(self._form.find('.final')));
                    self._form.toggleClass("loading", working);
                    self._loaderTimeout = null;
                }, 100);
            }
        }
    },

    hotDeal: {
        needPostcodeTemplate: function (selector) {
            if ($.mobile) {
                var hd = $.mobile.activePage.find(selector);
                return hd.length > 0 ? hd : null;
            }
            else {
                var hd = $(selector);
                return hd.length ? hd : null;
            }
        }
    }
};


/*
 * hotdeals.js
 * Author: Glenn Baker
 */

/*globals window, document, jQuery, ND, SiteConf */
ND.hotDeals = (function($, undefined){
	
	var /* Generic Error string */
		genericError = "Oops! There was an internal problem",
		
		/* 
		 * Error codes for the JSON service
		 */
		errorCodes = {
			MISSING_POSTCODE: "MISSING_POSTCODE",
			INVALID_POSTCODE: "INVALID_POSTCODE",
			INCORRECT_POSTCODE: "INCORRECT_POSTCODE",
			SUCCESS: "SUCCESS"
		},
		
		/*
		 * Object: hotDeals
		 * 
		 * The Hot Deals manager, takes care of links and cookie considerations
		 */
		hotDeals = {

			/*
			 * Constructor of sorts
			 */
			init: function( options ) {
				// console.log('hotdeal.init()');
				options || ( options = {} );
			
				var self = this;
				self.enabledRedirect = true;
				
				//Required links for page
				self.elementsSelector = options.links || '.overlay-hotdeals, .force-overlay-hotdeals';
				self.elementPanelSelector = options.panel || '#hotdeals-panel';
				
				self.bindLinks();
				self.initPubsub();				
				self.render();
			},
			
			/*
			 * Listen to the PUBSUB channel for Shopping Prefenences
			 */
			initPubsub: function() {
				var self = this;
				
				this.pubsub = {
					change:function( event, data ) {
						data = data || {};
						self.postcode = data.postcode;
						self.region = data.region;
					}
				};
				
				// Get the current postcode right now.
				$.publish( "shopping.pref.retrieve", this.pubsub.change );

				// Register for the changes in the future
				$.subscribe( "shopping.pref.change", this.pubsub.change );
				
				$.subscribe( "shopping.pref.destroy", this.destroy );
			},
			
			/*
			 * Renders the tmpl
			 */
			render: function() {
				var hdPanel = needPostcodeTemplate( this.elementPanelSelector );
				if( hdPanel != null ) {
					this._template = Object.create( postcodeTemplate );
					this._template.conf = self.conf;
					this._template.init( hdPanel , this.getPostcode(), this.getRegion() );					
				}
				return this._template;
			},
			
			/*
			 * Function for getting the postcode
			 */
			getPostcode: function() {
				return this.postcode;
			},
			
			/*
			 * Function for getting the region
			 */
			getRegion: function() {
				return this.region;
			},
			
			/*
			 * Function for getting the Obtainer
			 */
			getObtainer: function() {
				return this._obtainer;
			},			
			
			/*
			 * Binds the overlay links
			 */
			bindLinks: function() {
				var self = this;
				
				$(document).on( "click", self.elementsSelector, function(e) {
					
					var region, postcode, 
						ignoreCookie = $(this).hasClass('force-overlay-hotdeals');

					//Possibly ignore the cookie.
					if( ignoreCookie ) {

						e.preventDefault();
						self.obtainRegion( this );
					
					//	Otherwise
					} else {
					
						e.preventDefault();
	
						region = self.getRegion();
						postcode = self.getPostcode();
	
						if( region || postcode ) {
							self.handleRegion( this, region, postcode );
						} else {
							self.obtainRegion( this );
						}
					}
				});
			},
			
			/*
			 * There is region in cookie, 
			 * But we still need to go and get the destination URL
			 */
			handleRegion: function( elem, region, postcode ) {
				var self = this,
					//"el.href" will return different result when href="", IE return location.host, FF return location.href;
					regionURL = this.ajaxRegionURL($(elem).attr("href") || location.href, region, postcode );

				$.when( regionURL )
					.done( function( data ) {
						
						/*
						 * Success
						 * { "region": "Region1", "regionName": "Melbourne", "regionId": "1248851195750", "url": "http://master2.ndprod.corp.nextdigital.com/en/hot-deals/victoria?sitetype=web&site=Master2", "cid": "1248851260705" } 
						 * Error
						 * { "errorCode": "INVALID_POSTCODE", "error": "There is no region for your postcode" }
						 */

						if( data ) {
						
							//Default value is success if there was no error.
							data.errorCode || ( data.errorCode = errorCodes.SUCCESS);

							if( data.errorCode === errorCodes.SUCCESS && data.region && data.url ) {
						
								// UC-01 7.1.5.	MAP POSTCODE TO REGION: Dragonfly maps the postcode value to obtain the corresponding region. The JavaScript-enabled browser will cache the postcode and set in cookie.
								
								// Confirmed Postcode and region gets set in cookie
								$.publish( "shopping.pref.save", {
									postcode: postcode,
									region: data.region,
									regionLabel: data.regionName
								});
							
								// Send user to region page
								self.doneRedirect( data.url || elem.href );
							
							} else if( data.errorCode === errorCodes.INVALID_POSTCODE )  {
								
								// UC-01 - 8.4 2. DISPLAY ERROR MESSAGE: Dragonfly displays error message advising end user that postcode chosen does not exist. End user stays on the current page being loaded.
								if (typeof self._template === 'undefined') { 
									//On home page, there is no template, hence if an invalid postcode is entered the code will break as
									//tries to find an element to display an error message on the page.
									//as a remedy, just redirect the user to national page and let them see the error message there.
									self.doneNational( elem );
								} else {
									self.doneCasualError(data.error );	
								}
								// Invalid postcode, let's remove it.
								$.publish( "shopping.pref.save", {
									postcode: undefined,
									region: undefined,
									regionLabel: undefined
								});
							
							} else {
								
								self.doneObtainerError( data.error || genericError );
							}

						} else {
							
							// Serious issue
							self.doneObtainerError( genericError );

						}
					
					})
					.fail( function() {
						self._obtainer.loadingStatus( false );					
						self.doneNational( elem );
					});
				
				//Return the promise
				return regionURL;
			},

			/* 
			 * Function to create the Region URL XHR object.
			 */
			ajaxRegionURL: function( destination, region, postcode ) {
				this.conf || ( this.conf = $("#hotdeals-data").embeddedData() );
				
				var params = {
					url: destination
				};
				
				if( postcode ) {
					params.postcode = postcode;
				}

				if( region ) {
					params.region = region;
				}
				
				var promise = $.ajax({
					url: this.conf['xhr-hotdeals-data'],
					dataType: 'json',
					cache: true,
					data: params
				});
								
				return promise;
			},
			
			/*
			 * Do what the link would normally do, but we already prevented the default behaviour.
			 */
			doneRedirect: function( href ) {
				//console.log('doneRedirect');
				if( window.location.href.indexOf( href ) < 0 ) {
					$.publish('hotdeals.redirect', {url: href});
					if( this.enabledRedirect ) {
						window.location.href = href;
					}
				} else {
					this.doneNoRedirect();
				}
			},	
			
			/*
			 *	There was a problem so error message.
			 */
			doneObtainerError: function( msg ) {
				$.publish('hotdeals.noredirect');
				if( this._obtainer ) {
					this._obtainer.loadingStatus( false );
					this._obtainer.formError( msg );
				}
			},
			
			doneNational: function(elem) {
				window.location.href =  $(elem).attr('href');
			},

			/*
			 *	There was a problem so error message.
			 */
			doneCasualError: function( msg ) {
				this.doneNoRedirect();
				this._template.setError( msg );
			},

			
			/*
			 * Function to cleanup if we are not redirecting
			 */
			doneNoRedirect: function() {
				//console.log('doneNoRedirect');
				$.publish('hotdeals.noredirect');
				if( this._obtainer ) {
					this._obtainer.destroy();
					delete this._obtainer;
				}
			},

			/*
			 * There was no region in cookie, 
			 * So let's ask the user to select from overlay
			 */
			obtainRegion: function( elem ) {
				
				var obtainer, self = this;
				
				/*
				if( self._obtainer ) {
					self._obtainer.destroy();					
				}
				*/

				obtainer = Object.create(regionObtainer);
				obtainer.conf = self.conf;
				obtainer.init( { 
					
					/*
					 * Successful form submit. That is all.
					 * Please note the overlay must still be open.
					 */
					formSubmit: function( postcode ) {
						
						//Handle the Result of the Overlay Form
						self.handleRegion( elem, false, postcode );
														
					},
					
					/*
					 * Overlay was cancelled
					 * 
					 */
					cancel: function() {
						if( $(elem).hasClass('force-overlay-hotdeals') ) {
							self.doneNoRedirect();
						} else {
							//UC-01 8.5.2: DISPLAY NATIONAL PAGE
							self.doneRedirect( elem.href );
						}
					}
					
				});				
				self._obtainer = obtainer;
			},
		
			/*
			 * Cleanup method
			 */
			destroy: function() {
				//console.log('ND.hotDeal.destroy');
				if( this._obtainer ) {
					this._obtainer.destroy();
					delete this._obtainer;
				}
				if( this._template ) {
					this._template.destroy();
					delete this._template;
				}
				
				$(document).off("click", this.elementsSelector);
				for( channel in this.pubsub ) {
					$.unsubscribe( "shopping.pref." + channel, this.pubsub[channel] );
				}
				this.pubsub = this.conf = this._template = this._obtainer = null;
			}
			
		},
		
		
		/*
		 * Object: regionObtainer
		 * 
		 * Region Obtainer. Takes it to the next level, launching the overlay and 
		 * Rendering the form
		 */
		regionObtainer = {

			/*
			 * Constructor of sorts
			 */
			init: function( options ) {
				var self = this;
				
				this._guid = +new Date();
				
				this.options = options;
				this.formSelector = options.formSelector || '#hotDeals-form';
				this.conf || ( this.conf = $("#hotdeals-data").embeddedData() );
				
				if( this.conf['xhr-hotdeals-form'] ) {
					
					//Launch overlay
					$.publish('overlay.launch', {
						url: this.conf['xhr-hotdeals-form'],
						positionType: 'window',
						name: "Hot Deals Select Region",
						//type: 'overlay-hotdeals',
						success: function() {
							self._form = $(self.formSelector);
							if( self._form.size() ) {
								self.ready();
							} else {
								self.error();
							}
						}
					});					
				}
			},
			
			/*
			 * Ready to take postcode orders!
			 * I.e the Overlay is readu
			 */
			ready: function() {
				this.bindError();
				this.bindSubmit();
				this.bindAdditionalListeners.call(this);
				this.bindCancel();
				this.loadingStatus( false );
				this.setFocus();
				$.publish('hotdeals.obtainerReady');
			},
			
			/*
			 * Obtainer to go away quietly.
			 */
			done: function() {
				// Check if the overlay is still open based on the form exist.
				if( $( this.formSelector ).length ) {
					$.publish('overlay.hide');
				}
			},
			
			setFocus: function() {
				this._form.find('input[type="text"]').first().select();
			},
			
			/*
			 *	Bind to the overlay hotdeals form submit
			 */
			bindSubmit: function() {
				var self = this;
				//console.log('hotdeals.bindSubmit()');
				
				
				$(document).off('submit', '#hotDeals-form').on('submit', '#hotDeals-form', function( e ) {
					
					e.preventDefault();					
					//console.log('hotdeal->submit');
					var form = self._form;
					
				 	//grab local 
					var $postcodeField = form.find('[name=postcode]');
					var postcode = $postcodeField.val();
					
					//Validate Form
					if( $.trim( postcode ).length === 4 && !isNaN(postcode) ) {
						//prevent multi submission
						
						self.loadingStatus( true );
						self.formSuccess( postcode );
						//clear the fields for next round
						$postcodeField.val('');
					} else {
						self.formError();
					}
					return false;
				});
				
				
				$(document).on('keydown', '#hotDeals-form #postcode', function( e ) {
					
					self._errorMsg.slideUp('fast');
				});
				
			},
			
			bindAdditionalListeners: ND.platformDependentHotDeal.regionObtainer.bindAdditionalListeners,
			
			/*
			 *	Bind to the cancel of the overlay
			 */			
			bindCancel: function() {
				this.loadingStatus( false );		
				if( this.options.cancel ) {
					$.subscribeOnce('overlay.usercancel', this.options.cancel );
				}
			},
			
			/*
			 * Bind for error
			 */
			bindError: function() {
				
				var self = this;
				self.loadingStatus( false );		
				this._errorMsg =  this._form.find('.error');
				this.standardError =  this._form.find('#standard-error').text();

				$(document).on('keydown', '#hotDeals-form #postcode', function( e ) {
					self._errorMsg.slideUp('fast');
				});
			},
			
			/*
			 * Function helper for the loading status
			 */
			loadingStatus: ND.platformDependentHotDeal.regionObtainer.loadingStatus,
			
			/*
			 * Form success
			 * - Overlay does not get closed.
			 */
			formSuccess: function( postcode ) {
				this.loadingStatus( false );		
				this.options.formSubmit.call( null, postcode );
			},
			
			/*
			 * Form error
			 */
			formError: function( msg ) {
				this.loadingStatus( false );		
				this._errorMsg
					.text( msg || this.standardError )
					.slideDown('fast');
			},
			
			/*
			 * An error
			 */
			error: function() {
				//console.log("Error: regionObtainer");
			},
			
			/*
			 * Cleanup method
			 */
			destroy: function() {
				this.done();
				$(document)
					.off('submit', '#hotDeals-form')
					.off('click', '#hotDeals-form .hotDeals-form-currentLocation')
					.off('keydown', '#hotDeals-form #postcode');				
				$.unsubscribe('overlay.usercancel', this.options.cancel );
				this._form = this.conf = null;
			}
		},
		
		
		/*
		 * Helper function to see if the postcodeTemplate object is neccessary
		 */
		needPostcodeTemplate = ND.platformDependentHotDeal.hotDeal.needPostcodeTemplate,		
		
		/*
		 * Object: postcodeTemplate
		 * 
		 * The HTML view for the postcode
		 */
		//TODO..   $.extends( Object.create( hotDealsAbstract ), {
		postcodeTemplate = {
			
			/*
			 * Constructor of sorts
			 */
			init: function( panel, postcode, region) {
				this._panel = panel;
				this._postcode = postcode;
				this._region = region;				
				
				this.conf || ( this.conf = $("#hotdeals-data").embeddedData() );
				
				//Compile main template
				this.tmpl = $('#tmpl-hotdeals-links').template();
				
				this.updatePostCode();
				
				this.subscribing();
				
				this.controller();
			},
			
			/*
			 * Listen to the PUBSUB channel for Shopping Prefenences
			 */
			subscribing: function() {
				var self = this;
				
				this.pubsub = {
					change:function( event, data ) {
						data = data || {};
						self._postcode = data.postcode;
						self._region = data.region;
						self.controller();
					}
				};

				// Register for the changes in the future
				$.subscribe( "shopping.pref.change", this.pubsub.change );
			},
			
			/*
			* Update postcode in the contents
			*/
			updatePostCode: function() {
				if(this._postcode){
					$(".user-selected-postcode").text(" " + this._postcode);
				}else{
					$(".user-selected-postcode-msg").hide();
				}
			},
			
			/*
			 * Control the render;
			 */
			controller: function() {
				
				this.view( 
					this.model( 
						this.useError()
					) 
				);
				
			},	
			
			/*
			 * The data for the tmpl
			 */
			model: function( error ) {
				var model =  {};
				
				// Current postcode
				model.postcode = this._postcode;
				
				// Is page region is different to the region in cookie
				model.wrongPostcode = ( this._postcode && this.getPageRegion() && this._region !== this.getPageRegion() );
				
				// The error (is a string or false)
				model.error = error;
				
				return model;
			},
			
			/*
			 * Render the view
			 */
			view: ND.platformDependentHotDeal.regionObtainer.view,
			
			/*
			 * Returns the region for the current page
			 */
			getPageRegion: function() {
				return this.conf["page-region"];
			},
			
			/*
			 *  Set's the error for templating
			 */
			setError: function( error ) {
				this._error = error;
			},
			
			/*
			 * Use the error once
			 */
			useError: function() {
				var err = $.type( this._error ) === 'string' ? this._error : false;
					
				//reset the error once used
				delete this._error; 

				return err;
			},
			
			/*
			 * Cleanup method
			 */
			destroy: function() {
				$.unsubscribe( "shopping.pref.change", this.pubsub.change );
			}			
		};
		 
	/*
	 * Expose function that creates new hotDeals
	 * - ND.hotDeals 
	 */
	return function( arg ) {
		var manager = Object.create( hotDeals );
		manager.init.call( manager, arg );
		return manager;
	};
	
}(jQuery));


(function($, window, undefined){

	//namespacing
	var ND = window.ND = window.ND || {};
	ND.API = ND.api || {};
	
	ND.cacheStore = {
			get:function(){
				var value = $.trim($.cookie(this.key));
				try {
					return value ? JSON.parse(value) : "";
				} catch (e) {
					return value || "";
				}			
			},
			set:function(value){
				value = $.isPlainObject(value) ? JSON.stringify(value) : value;
				if(this.get() !== value) {
					//Session cookie
					var options = {path:'/'};
					if( this.expires ) {
						options.expires = this.expires; 
					}			
					if(this.domain){
						options.domain=this.domain;
					}	
					$.cookie(this.key, value || null, options);
				}
			},
			is:function(){
				return this.get() != null ? (this.get().toString().length > 0) : false;
			},
			contains:function(value){
				return this.get().indexOf(value) > -1;
			}
		};
		
		//Quick (single callback) Deferred Implementation.
		ND.deferred = function() {

			var cb, 
				resolved,
				run = function() {
					cb && cb.call();						
				};
			
			return {
				resolve: function() {
					resolved = true;
					run();
				},
				done: function( fn ) {
					cb = fn;
					resolved && run()
				}
			};		
		};

			
	
	
	//Protect from missing LAB/loader script.
	if(window['$wait'] === undefined) {
		window['$wait'] = function(fn){
			fn();
		}
	}
	
})(jQuery, window);


/* 
Discription: For latest offer click event, to load postcode related modules
             And extended functions from ftd/js/mini-plugins.js && ftd/js/lib/es5-shim-parts.js
*/

(function ($, win, doc) {

    //ftd/js/mini-plugins.js
    $.fn.killFlash = function () {
        this.length && this.each(function () {
            var flash = $(this).flash();
            flash.remove && flash.remove();
        });
        return this;
    };

    $.fn.doOnce = function (func) {
        this.length && func.apply(this);
        return this;
    };

    $.fn.metaBasedFlash = (function () {
        var defaults = {},
			getData = function (flash) {
			    var data = flash.length > 0 ? flash.metadata({ type: 'class' }) : 0,
					ret = (data && 'swf' in data) ? data : 0;

			    return ret
			};

        return function (options) {
            this.length && this.each(function () {
                var item = $(this),
					data = getData(item);
                options = $.extend(defaults, options);

                if (data) {
                    //extend the JSON object extracted from the class with some system wide ones.
                    data = $.extend(true, data, options.swfobject);

                    item.flash(data);
                    item.addClass("flash-loaded");
                    if (options['success']) {
                        options.success.apply(this)
                    }
                }
            });
            return this;
        }

    })();

    //ftd/js/lib/es5-shim-parts.js
    if (!Object.create) {
        Object.create = function (prototype, properties) {
            var object;
            if (prototype === null) {
                object = { "__proto__": null };
            } else {
                if (typeof prototype != "object")
                    throw new TypeError("typeof prototype[" + (typeof prototype) + "] != 'object'");
                var Type = function () { };
                Type.prototype = prototype;
                object = new Type();
            }
            if (typeof properties !== "undefined")
                Object.defineProperties(object, properties);
            return object;
        };
    }
	
	// If  in Qunit test suite, then we stall.
	if(!!window.QUnit) { return; }

	$(doc).ready(function(){
		// shoppref.js
		
		ND.shoppingPreferenceManager();
		// hotdeals.js
		ND.hotDeals();
		
	});
	
})(jQuery, window, document);


(function($, undefined){
	
	/*
	 * Overlay URL. This reproduces the URL that Facebook URL Linter creates.
	 * eg. http://developers.facebook.com/tools/lint/?url=http%3A%2F%2Fwww.ford.com.au%2Fservlet%2FSatellite%3Fc%3DDFYPage%26cid%3D1248884660596%26pagename%3DFOA%252Fcontroller%26site%3DFOA%23overlay%3D1234567890BD
	 */
	function overlayURL( url, assetid ) {
		url = url || "";
		return escape(url.split('#')[0] + '#overlay=' + assetid).replace("\/", "%2F", "g")			
	}
	
	/*
	 * Overlay Object.
	 */
	var Overlay = function (list, text, rtl) {
		var overlay = this,
			positionNameXaxis = rtl ? 'left' : 'right',
			cacheStore = {};
		
		overlay.container;
		overlay.text = text || {close: "Close",of: "of",prev: "Previous",next: "Next",loading: "Loading Content...",error: "There seems to be a problem."};
		overlay.list = list;
		overlay.fadeSpeed = 200;
		overlay.timeout = 8000;
		overlay.view360Class = "view-360";
		overlay.lightClass = "overlay-light";
		overlay.disclaimerClass = "external-disclaimer";
		
		overlay.init = function (curElem) {
			
			overlay.prepareBannerModes(curElem);			
			overlay.injectContainer();
			overlay.injectControls();
			overlay.registerLiveEvents();
		};
		
		//** INIT FUNCTIONS
		
		//INIT: Events register once
		overlay.registerLiveEvents = function () {
			$(".close-button A, .close-overlay", overlay.container).live("click", function () {
				
				overlay.hide();
				
				$(".overlayblackbg").remove();
				addedBlackbg=false;
				if (overlay.asset != null){
					$.bbq.removeState("overlay");
				}
				
				if($("#overlay").hasClass("syncsltoverlay")==true){
					
					$("#overlay").removeClass("syncsltoverlay");
					
				}
				$.publish('overlay.usercancel');	
				return false;
			});
			
			$(".controls .previous:not(.disabled)", overlay.container).live("click", function () {
				var prevPage = overlay.currentPage * 1 - 1;
				overlay.moveTo(prevPage);
				$.publish('overlay.userprevious');
				return false;
			});
			
			$(".controls .next:not(.disabled)", overlay.container).live("click", function () {
				var prevPage = overlay.currentPage * 1 + 1;
				overlay.moveTo(prevPage);
				$.publish('overlay.usernext');
				return false;
			});
			
			
			$(".click-out A", overlay.container).live("click", function () {
				overlay.hide();
			});			
			
			$(".controls .disabled", overlay.container).live("click", function () {
				return false;
			});
			
			
			
		};
		
		//INIT: Inject Overlay Base mark-up
		overlay.injectContainer = function () {
			var emptyDiv, loading,
			markup = {
				container: function () {
					return '<div id="overlay" class="overlay-box"></div>';
				},
				emptyDIV: function () {
					return '<div class="overlay-box-inner"></div>';
				},
				loading: function () {
					return '<div class="loading"><div class="image"></div><p>' + overlay.text.loading + '</p></div>';
				}
			};
			overlay.jcontainer = $(markup.container())
			overlay.container = overlay.jcontainer.get(0);
			emptyDiv = $(markup.emptyDIV());
			loading = $(markup.loading());
			
			overlay.innerWrapper = emptyDiv; 
			
			overlay.jcontainer.append(emptyDiv).append(loading);
			$("body").append(overlay.container);	
			
							
		};	
		
		//INIT: Decypher if there is a banner
		overlay.setPositionMode = function(type) {
			overlay.modePosition =  type && overlay.positions[type] ? overlay.positions[type] : overlay.defaultPosition
		};
		
		//INIT: Decypher if there is a banner
		overlay.prepareBannerModes = function(curElem) {
			var jbanner = $('#banner'),
				jhero = $('.principal-hero'),
				offset = '',
				banner = false,
				positions = overlay.positions = {};

			
				
			if( (banner = jhero.size()) ) {
				offset = '0 30';
			} else if ( (banner = jbanner.size())) {
				offset = '0 -5';
			}
			
			//Open overlay in window mode if anchor has class centeroverlay
			if (curElem) {
				
				if (curElem.srcElement)  var currentClasses = curElem.srcElement.className;
 					else if (curElem.target) var currentClasses = curElem.target.className;

 				if (currentClasses.toLowerCase().indexOf("centeroverlay") >= 0)
					banner = false;
 			}			
				
			//C520 feature page, so overlay can open in window mode
			if ($('.featuregeneric .principal-hero').size() > 0)
				banner = false;
						
			positions.banner = {
				of: $('#body'),
				my: 'center bottom',
				at: 'center top',
				offset: offset, 
				collision: 'none',
				//Extra prop for overlay
				scrollTop:true
			};
			
			positions.window = {
				of: window,
				my: 'center',
				at: 'center',
				collision: 'none',
				using: function(hash){
					hash[positionNameXaxis] = (hash[positionNameXaxis] >= 0 ? hash[positionNameXaxis] : 0); 
					$(this).css(hash);
				}
			};

			// Current Position	& Default		   
			overlay.modePosition = overlay.defaultPosition = banner ? positions.banner : positions.window;
			
		};
		
		//INIT: Inject the close button and pagination
		overlay.injectControls = function () {
			var controls, closeButton, markup = {
					closeButton: function () {
						return '<div class="close-button"><span><a href="#">' + overlay.text.close + '</a></span></div>';
					},
					controls: function (item) {
						return '<div class="controls"><ul><li class="pagination"><p><span class="current">1</span> ' + overlay.text.of + ' <span class="total">1</span></p></li><li class="previous"><a href="#" title="' + overlay.text.prev + '">' + overlay.text.prev + '</a></li><li class="next"><a href="#" title="' + overlay.text.next + '">' + overlay.text.next + '</a></li></ul></div>';
					}
				};
			
				//The Close Button
				overlay.closeButton = $(markup.closeButton());

				//Hide Pagination for later showing
				controls = $(markup.controls()).hide();
				
				//Insert into the document
				overlay.jcontainer.append(overlay.closeButton).append(controls);
				
				//View Gallery Button
				if($(".view-gallery").length > 0){		
					var viewGalleryButton = $(".view-gallery").clone(false);	
					overlay.jcontainer.append(viewGalleryButton);
					viewGalleryButton.hide();
				}

				
				//
				if($("#overlay").parent().hasClass("lincoln")==true){
					ND.lincolnResetOl();
				}
				
				
		};
		
		// Push state to history (jQuery.bbq.js)
		overlay.pushState = function(){
			var state = {}, asset;
			
			if ($(overlay.anchor).attr("class")){
				asset = $(overlay.anchor).attr("class").match(/asset-\d+/);
			}
			
			if (asset != null){
				overlay.asset = asset;
				overlay.assetid = asset[0].substr(6);
				state["overlay"] = overlay.assetid;
				$.bbq.pushState(state);
			}
		};
		
		
		var socialCache = {};
		
		// Inject Facebook and Add This Button
		overlay.injectSocial = function(){
			
			var share = $("#overlay .share"),
				parent = share.parent(),
				template,
				render,
				done;
			
			//Fade In Social Widgets
			function doneFn() {
				if( !done ) {
					share.fadeIn(200);
					
					//Special initaliser code for add this.
					window.addthis && window.addthis.button( '.addthis-overlay');
					
					done = true;
				}
			}
			
			
			if( share.size() > 0 && overlay.assetid ) {
				
				if( socialCache[overlay.assetid] ) {
					
					share = socialCache[overlay.assetid];
					
				} else {
					
					//Remove it from the DOM
					share.remove();
					
					//Compile Template
					template = overlay.socialTemplate || (overlay.socialTemplate = $('#tmpl-overlay-share').template());
					
					//Render the Template
					render = $.tmpl(template, {replaceURL: overlayURL( window.location.href, overlay.assetid) });
					
					//using html as tmpl plugin is Beta. html will at least create new DOM elements
					share.html(render.html());
				}
					
				parent.prepend( share.hide() )
				
				//Once the facebook like iframe is loaded.. Fade all social widgets in.
				share.find('iframe').bind('load', doneFn);
				
				//Set a timeout incase the face book iframe takes too long.
				setTimeout(doneFn, 5e2);
				
				//Cache the share DOM element
				socialCache[overlay.assetid] = share;
			}
				
		};
		
		var vrCache = {};
		
		// Support VR in the overlay
		overlay.enableVR = function(){
			
			var vrContainer = overlay.jcontainer.find(".vr-container");
			
			var currentIndex = 0, nextIndex = 1;
			var compareNames = [];
			var cacheData = []; // There appears to be a design flaw somehwere in this system.  I need to re-visit it later.
			
			// Set the overlay's position to absolute for this particular overlay, since we want it to stay in place
			// And I didn't want to change it in the CSS lest it break any other overlay functionality
			$("#overlay").css("position", "absolute");
			
			var pad = function(num, size) {
				    var s = num+"";
				    while (s.length < size) s = "0" + s;
				    return s;
				};
			
			
			
			vrContainer.each(function(index){
				var container = $(this);
				
				var vr = container.find('.vr'), data, images, imagesData;
				
				/**
				 * 
				 * JSON spec
				 * 
				 * {
				 * 	"name": "Focus",
				 * 	"vrImages": {
				 * 		"location": http://faptest.edgesuite.net/test-dir/360demo/C346/, // Forward-slash must be included at the end
				 * 	
				 * 	}
				 * }
				 * 
				 */
				// Useful data and images
				data = vr.length > 0 ? vr.parent().find(".vr-data").embeddedData() : 0;
				imagesData = (data && 'vrImages' in data) ? data.vrImages : {};
				
				cacheData.push(data);

				// Cache vehicle data for toggle button
				overlay.jcontainer.data("cache", cacheData);
				
				// Set the initial image source, for great justice
				if (index === 0) {
					vr.attr("src", imagesData.location + imagesData.filenamePrefix + pad(0, imagesData.counterFormat.length) + "." + imagesData.extension)
				}
				
				// If the vr already exists then replace the placeholder with the existing vr.
				// Had to be moved due to automagic above being required and making this entirely ineffective in its old position :(
				/*
				if( vrCache[ vr.attr('src') ] ) {
									vr.replaceWith( vrCache[ vr.attr('src') ] );
									return;
								}*/
				
				
				// Populate the parent array of names with this one, too!  So that we may add them to our button.
				compareNames.push(data.name);
				vr.parent().data("name", data.name);
				
				// Create the overlay dynamically
				$("<span class='car-info'>"+data.name+"</span>").appendTo(container);
				
				images = [];
				
				for (var i=imagesData.start; i<=imagesData.end; i++){
					images.push(imagesData.location + imagesData.filenamePrefix + pad(i, imagesData.counterFormat.length) + "." + imagesData.extension);
				}
				
				if( images.length ) {
					vr.reel({
						revolution: 500,
						frames: images.length,
						images: images
					}); 
				}
			})

			// VR Cursor
			$('.jquery-reel-interface').on('mousedown', function() {
				if (!$.support.optSelected) {
				    $(this).removeClass('reel-cursor').addClass('grab-cursor-ie');
				} else {
					$(this).addClass('grab-cursor');
				}
			});
			$('.jquery-reel-interface').on('mouseup', function() {
				if (!$.support.optSelected) {
					$(this).removeClass('grab-cursor-ie').addClass('reel-cursor');
				} else {
					$(this).removeClass('grab-cursor');
				}
			});

			// display directions  
           $('.reeldirections').fadeTo(1500, 0.7); 
	
			// Create the toggle button
			if (vrContainer.length > 1) {
				
				var currentElem = vrContainer.eq(currentIndex); // little bit hacky but that's ok
				var vrToggleButton = $("<button class='vr-toggle'>" + overlay.jcontainer.data("cache")[nextIndex].name + "</button>")
					.on("click", function(e){
						var elem = vrToggleButton;
						currentIndex++;
						nextIndex++;
						if (currentIndex >= vrContainer.length) currentIndex = 0;
						if (nextIndex >= vrContainer.length) nextIndex = 0;
						// Change the inner text of this button to correspond with the next car to be toggled.
						// Here comes a repetition of code
						elem.html(vrContainer.eq(nextIndex).find("span.car-info").html()); // Word Display should probably be left to the template for i18n considerations
						// This could probably be cleaned up a bit but it works right at this moment.
						currentElem.css("display", "none");
						// Switch to the next element
						currentElem = vrContainer.eq(currentIndex);
						
						currentElem.css("display", "block");
						
					})
					.appendTo(vrContainer);
			}

			overlay.moveToPosition();
		};
		
		// Save the VR from being trashed
		overlay.storeVR = function() {
			var vr = overlay.jcontainer.find('.vr')
			vrCache[ vr.attr('src') ] = vr;
			vr.detach();
		};
		
		//** EVENT FUNCTIONS
		
		//Reposition the overlay.. Especially on window resize.
		overlay.moveToPosition = function(){
			if (overlay.shown) {
				overlay.jcontainer.position(overlay.modePosition);
				if($("#overlay").position().top<0){
					
					$("#overlay").css("top", "0");
					
				}
				// fixing ipad position issue
				if ( /iPhone|iPad|iPod/.test( navigator.platform ) ) {
					overlay.jcontainer.css("left", "10px");
				}
			}
			
		};
			
		/*
		 * Load the URL.. delegates to 
		 * 	.loadContent() or .loadDisclaimerContent()
		 */
		overlay.load = function (anchor, type, url, options) {
			options = options || {};
			
			//Patch for analytics
			overlay.namedTitle = options.name || "";
			
			//Protect Repeat calls. This will fix the issue of Two ajax calles that occurs when the hash change event
			//calls the overlay to load again. We can fix this by checking that the overlay is already in the same State
			//that the repeat call is asking of it. Why send open and send an Ajax call when the overlay is already open
			//on the same URL and same <a> tag.
			if( overlay.shown ) {
				if( anchor !== null && typeof anchor !== 'undefined' && overlay.anchor === anchor ) { return ; }
				if( (anchor === null || typeof anchor === 'undefined') && overlay.contentUrl === url ) { return ; }
			}
			
			//Try to prevent too much flash execution.
			if( overlay.flashLoadTimer ) {
				clearTimeout( overlay.flashLoadTimer );								
			} 

			// Support disabling the clsoe button for SYNC
			overlay.closeButtonEnabled = (typeof options.disableClose === 'undefined') || !options.disableClose
			
			// Optionsl position Type
			overlay.setPositionMode(options.positionType);				
			
			// Scroll up to the top of the page
			if (overlay.modePosition.scrollTop) {
				$('html, body').animate({scrollTop:0}, 'fast');
			}
			
			// Store ref to the Anchor and a ref to the URL
			overlay.anchor = anchor;
			overlay.contentUrl = $(anchor).attr("href");

			// Support Hash Urls
			overlay.asset = ($(anchor).attr("class") || "").match(/asset-\d+/);
			if (overlay.asset != null){
				overlay.pushState(overlay.asset[0]);
			}

			// Clear settings
			overlay.resetType();

			// Config new settings
			if (type === "urlOnly") {
				overlay.contentUrl = url;
				overlay.loadContent( options.success );
			}
			else if (type === "disclaimer") {
				overlay.loadDisclaimerContent();
				overlay.updateClassDisclaimer();
			}
			else if (type === "overlay-sync"){
				overlay.contentUrl = url;
				$("#overlay").addClass("overlay-sync");
				overlay.loadContent( options.success );
				
			}
			else if(type==="syncoverlay5"){
				
				$("#overlay").addClass("syncsltoverlay");
			    if(addedBlackbg==false){
					
					var pheight=$(document).height(); 
					var pwidth=$(document).width(); 
					$("#overlay").before("<div class='overlayblackbg' style='height:"+pheight+"px;width:"+pwidth+"px;' ></div>");
					$("#overlay").addClass("syncsltoverlay");
					addedBlackbg=true;
				}
				
				overlay.contentUrl = url;
				overlay.loadContent();
				
			}else {
				overlay.loadContent();
				overlay.updateClassOnOverlay();
			}
			
			// Display the overlay on the screen of the user to see.
			overlay.show();			
			overlay.moveToPosition();
		};
		
		
		/* Flexible size of overlay
		 * This function was added very late in the game to try and ease the strict size of the overlay
		 */
		overlay.checkSize = function() {
			var padding = parseInt(overlay.innerWrapper.css('padding-left')) * 2,
				contents = overlay.innerWrapper.children().first(),
				width = contents.outerWidth(),
				height = contents.outerHeight();
			
			if($(".view-gallery").length > 0){
				height = height + 30;
				overlay.jcontainer.find(".secondary").css("min-height","385px");
			}
			overlay.previousWidth = overlay.jcontainer.css('width');
			overlay.previousHeight = overlay.jcontainer.css('height');
			overlay.jcontainer.css({'width':width + padding, 'height':height + padding});			
			overlay.moveToPosition();
			

		};
		
		/*
		 * Reset some CSS that is required for smooth functioning
		 */
		overlay.resetCSS = function() {
			
			overlay.jcontainer.css({
				'display':'block',
				'top':'',
				'left':'',
				'width':overlay.previousWidth,
				'height':overlay.previousHeight
			});
		};
		
		/*
		 * SHOW OVERLAY
		 */
		overlay.show = function (callback) {
			overlay.shown = overlay.shown || false;
			if (!overlay.shown) {
				overlay.shown = true;
				overlay.jcontainer.fadeIn(overlay.fadeSpeed, callback);
			}
			overlay.moveToPosition();			
			
		};

		/*
		 * HIDE OVERLAY
		 */		
		overlay.hide = function () {
			overlay.shown = false;
			overlay.updateClassnames("removeActive");
			
			overlay.storeVR();
			
			//Empty the contents of the overlay
			overlay.empty();
			
			//Hide Pagination
			overlay.jcontainer.find(".controls").hide();
			overlay.jcontainer.find(".view-gallery").hide();
			
			//Hide it will effect;
			overlay.jcontainer.fadeOut(overlay.fadeSpeed, function(){
				//Restore display block (must use Left)
				overlay.resetCSS();				
			})
			
			
		};
		
		
		/*
		 * EMPTY OVERLAY
		 * We do this so we can kill the flash.. Damn Flash!
		 */		
		overlay.empty = function () {
			
			//Kill that damned flash.
			overlay.jcontainer && overlay.jcontainer.find('.flash').killFlash();
			
			//Empty the contents of the overlay
			overlay.innerWrapper.empty();
		};
		
		/*
		 * When overlay is all done and loaded
		 */
		overlay.done = function() {
			$.publish('overlay.done', { contents: overlay.innerWrapper, assetid: overlay.assetid, name: overlay.namedTitle });
			// And yes, we're gonna call this here too, because I said so.  Rationality not included.  If symptoms persist, seek psychiatric attention.
			setTimeout(overlay.moveToPosition, 1000); // After one second, because this is still failing on silly old firefox.
		}
		
		//External Disclaimer Click Content
		overlay.loadDisclaimerContent = function () {
			var markup = {
				link: function (link) {
					return '<p class="click-out"><a href="' + link.href + '" title="' + link.text + " " + link.href + '" target="_blank">' + link.text + " " + link.href + '</a></p>';
				}
			}
			var link = {
				text: overlay.text.externalLink,
				href: overlay.contentUrl
			};
			var html = overlay.text.disclaimer;
			html = '<div class="ext-disc">' + html + markup.link(link) + "</div>";
			overlay.innerWrapper.html(html);
			overlay.checkSize();
			
		};
		
		
		//Fill the overlay with content
		overlay.loadContent = function ( successFn ) {
			var jcontainer = overlay.jcontainer,
				overlayContentArea = overlay.innerWrapper,
				overlayLoading = $(".loading",jcontainer),
				success,
				noGutsNoGlory,
				pageEnabled = "pagination-enabled";
			
			// Show or Hide the close button
			if( overlay.closeButtonEnabled ) {
				overlay.closeButton.show();
			} else {
				overlay.closeButton.hide();
			}
			
			jcontainer.addClass("loading");
			overlayLoading.children("P").text(overlay.text.loading);
			overlayLoading.children("DIV.image").show();
						
			//Had to group all these actions so that they could be executed a couple of times.
			noGutsNoGlory = function(fn) {
				overlay.empty();
				if(arguments.length > 0) {
					fn.apply(overlay);
				}
				overlay.updateClassnames();
				
				if (overlay.list.totalCount > 0) {
					jcontainer.addClass(pageEnabled);
					overlay.pagination();
				} else {
					jcontainer.removeClass(pageEnabled);
				}
				
				overlay.customScrollBar();
			}
			
			//Store timestamps so we can compare in the success
			var thisRequest = +new Date();
			overlay.activeRequest = thisRequest;
			
			//Ajax success
			success = function(data, status, xhr) {

				//If this callback is not the latest Overlay AJAX request, then cancel
				if( thisRequest !== overlay.activeRequest ) {
					return; 
				}
				
				noGutsNoGlory(function(){
					jcontainer.removeClass("loading");
					overlayContentArea.html(data);
					
					//Load flash in a timer so that it can be delayed and a little better managed.
					overlay.flashLoadTimer = setTimeout(function() {
						//If this callback is not the latest Overlay AJAX request, then cancel
						if( thisRequest !== overlay.activeRequest ) { return; }
						jcontainer.find('.flash').metaBasedFlash();
					}, 300);
					
					overlay.checkSize();
					overlay.injectSocial();
					overlay.enableVR();
					overlay.done();
				});
				cacheStore[overlay.contentUrl] = data;
				
				//Publish.
				$.publish('overlay.success');
				
				//Callback too
				if( successFn ) {
					successFn.call();
				}
				else {
					overlay.moveToPosition(); // Seriously, we have to call this everywhere now for some reason, as a failsafe measure.  Might as well be infinite looping.  *sigh*
				}
			};

			overlay.pushState();
			
			//Store the Response so that the next click doesn't return to the server
			if(cacheStore[overlay.contentUrl]) {
				success(cacheStore[overlay.contentUrl]);
				return;
			}
			
			//Clear the contents so that it is free of content if there is an error.
			noGutsNoGlory();
			
			$.ajax({
				url:overlay.contentUrl,
				timeout:overlay.timeout,
				success: success,
				dataType:'html',
				error: function (request, error) {
					//Add the buttons in again... :S .
					noGutsNoGlory();
					overlayLoading.children("DIV.image").hide();
					overlayLoading.children("P").text(overlay.text.error);
					delete cacheStore[overlay.contentUrl];					
				}
			});
			
			
		};
		
		/*
		 * Prefetch the URL and store it in cache
		 * Call this method in advance, if you want to avoid the user seeing the *Loading* Dialog
		 * This change was added for the SYNC USB transfer process which uses abuot 6 overlays in sequence.
		 */
		overlay.prefetch = function( url ) {
			
			// Check if already fetched
			if( cacheStore[url] ) { return; }
			
			// Fetch and store in the local cache store for Overlays.
			$.ajax({
				url: url,
				timeout: overlay.timeout,
				success: function(data) {
					cacheStore[ url ] = data;
				}
			});
		};
		
		/*
		 * Function to initalise of re-inialise the custom scrollbar within the overlay.
		 */
		overlay.customScrollBar = function() {
			//Scroll bars
			overlay.jcontainer
				.find('.secondary .body, .custom-scroll')
				.doOnce(function(){
					$(this)
						.jScrollPane({showArrows:false, scrollbarWidth: 13, scrollbarOnLeft:rtl});
				});
		};
		
		/*
		 * Function to initalise of re-inialise anything with the overlay that needs to be
		 */
		
		overlay.reinitalise = function() {
			overlay.customScrollBar();
		};
		$.subscribe('overlay.reinitalise', overlay.reinitalise );
		
		/*
		 * 	Modify classes for updateClassOnOverlay mode
		 */
		overlay.updateClassOnOverlay = function () {
			var link = $(overlay.anchor);
			overlay.jcontainer.toggleClass( overlay.view360Class, link.hasClass(overlay.view360Class) );
			overlay.jcontainer.toggleClass( overlay.lightClass, link.hasClass(overlay.lightClass) );
		};
		
		/*
		 * 	Modify classes for updateClassDisclaimer mode
		 */
		overlay.updateClassDisclaimer = function () {
			if ($(overlay.anchor).hasClass(overlay.disclaimerClass)) {
				overlay.jcontainer.addClass(overlay.disclaimerClass);
			}
			else {
				overlay.jcontainer.removeClass(overlay.disclaimerClass);
			}
		};

		/*
		 * It frustrates me that in order to support a different size overlay I need to modify the overlay script.
		 * Modify classes for updateClassDisclaimer mode
		 
		overlay.updateClassCalcPrice = function () {
			if ($(overlay.anchor).hasClass(overlay.disclaimerClass)) {
				overlay.jcontainer.addClass(overlay.disclaimerClass);
			}
			else {
				overlay.jcontainer.removeClass(overlay.disclaimerClass);
			}
		};*/
		
		overlay.resetType = function () {
			//Actions that must occur to reset the overlay every time it is shown.
			overlay.jcontainer.removeClass(overlay.lightClass);
			overlay.jcontainer.removeClass(overlay.view360Class);
			overlay.jcontainer.removeClass(overlay.disclaimerClass);			
		};
		
		overlay.updateClassnames = function (method) {
			if (overlay.anchor !== undefined) {
				var overlayType = ".overlay" + (overlay.listType() ? "-" + overlay.listType() : "");
				
				$(overlayType).closest(".item.active").removeClass("active");
				
				if (method !== "removeActive") {
					$(overlay.anchor).closest(".item").addClass("active");
				}
			}
		};
		

		
		overlay.listType = function () {
			var type;
			var classname = $(overlay.anchor).attr("class") || "";
			
			if (classname !== undefined) {
				if (classname.match(/overlay-group/) !== null) {
					var group = classname.match(/group[0-9]*/);
					type = group[0];
				}
				else {
					type = "";
				}

				return type;
			}
			
			return "";
			
		};
		
		overlay.pagination = function () {
			var type = overlay.listType();
			var innerChild = overlay.innerWrapper.children("div");
			var height = innerChild.outerHeight();
			if (type !== "") {
				overlay.updateCurrentPage = overlay.setPagination(overlay.list[type].count);
				overlay.updateCurrentPage(overlay.list[type].items[overlay.contentUrl].order);
				//to stop control displaying with loader
				if ((innerChild.length > 0) && (height > 100 )) {
					overlay.jcontainer.find(".controls").show();
					overlay.jcontainer.find(".view-gallery").show();
				}
				
			}
		};
		
		overlay.setPagination = function (total) {
			// Total
			$(".pagination .total", overlay.container).text(total);
			
			return function (current) {
				// Current
				overlay.currentPage = current;
				$(".pagination .current", overlay.container).text(current);
				overlay.disablePaginationButtons(current, total);				
			};
		};
		
		overlay.disablePaginationButtons = function (current, total) {
			if (current === 1) {
				$(".controls .previous", overlay.container).addClass("disabled");
			}
			else {
				$(".controls .previous", overlay.container).removeClass("disabled");
			}
			if(current === total) {
				$(".controls .next", overlay.container).addClass("disabled");
			}
			else {
				$(".controls .next", overlay.container).removeClass("disabled");
			}
		};
		
		overlay.moveTo = function (prevPage) {
			var type = overlay.listType();
			var items = overlay.list[type].items;
			var href, node;
			
			for (var item in items) {
				if (items[item]["order"] === prevPage) {
					node = items[item]["node"];
					href = items[item]["href"];
				}
			}
			
			overlay.anchor = node;
			overlay.contentUrl = href;
			
			overlay.asset = ($(overlay.anchor).attr("class") || "").match(/asset-\d+/);
			if (overlay.asset != null){
				overlay.pushState(overlay.asset[0]);
			}
			
			overlay.loadContent();
		};
		
		//redundant
		//overlay.wireEvents = function(){};
		
	};
	
	var populatePaginationList = function () {
		var list = {},
		totalCount = 0,
		count, i, max = 50;
		
		for (i = 1; i < max; i = i + 1) {
			
			if ($("A.overlay-group" + i).size() > 0) {
				count = 0;
				
				list["group"+i] = {};
				$("A.overlay-group" + i).each(function (j) {
					var node = this;
					var href = $(node).attr("href");
					if (href.indexOf("#") == 0){
						href = href.substr(1);
						
					}
					list["group"+i]["items"] = (j === 0) ? {} : list["group"+i]["items"];
					
					if (! list["group"+i]["items"][href]) {
						list["group"+i]["items"][href] = {
							href: href,
							node: node,
							order: count + 1
						};
						totalCount = totalCount + 1;
						count = count + 1;
					}
				});
				list["group"+i]["count"] = count;
				
			}
			else {
				break;
			}
		}
		list["totalCount"] = totalCount;
		
		return list;
	};
	
	
	var appendOverlay = function (curElem) {
		if ($("#overlay").size() === 0) {
			
			var textContainer = $("#javascript-text"),
				text = $(textContainer.html()),
				getText = function( key ) {
					return text.find("."+key).html();
				},				
				textVals = textContainer.size() ? {
					close: getText("close"),
					of: getText("of"),
					prev: getText("prev"),
					next: getText("next"),
					loading: getText("loading"),
					error: getText("error"),
					disclaimer: getText("disclaimer-text"),
					externalLink: getText("disclaimer-link")
				} : null;

			var overlay = new Overlay(populatePaginationList(), textVals, window.ND && ND.rtl);
			
			overlay.init(curElem);

			$(window).bind('resize', function(){
				overlay.moveToPosition();
			}).bind('scroll', function(){
				overlay.moveToPosition();
			});
			
			return overlay;
		}
	};
	
	// This function is called by child window to retrieve the current item information
	getCurrentItem = function(){
		var item = $("#overlay .controls .current").text();
		return item;
	};
	addedBlackbg=false;
	;
	
	$(function(){
		
		var overlay;
		
		//Open the overlay if the id exists in URL
		$(window).bind('pageLoadedWithOverlay', function(e){
			if( overlay === undefined) { return;}
			
			var url;

			if( window.location.toString().indexOf("#") > 0 ) {
				
				url = $.bbq.getState("overlay") || "";
				//if( url && $("#overlay").is(':hidden')){
				if( url ){
					$('a[class*=' + url + ']').filter('.overlay').eq(0).trigger("click");
				}
			}

			if ( !url && overlay.shown ) {
				overlay.hide();
			}
		});
		
		$wait(function(){
		
		if ($("A.overlay, A.external-disclaimer,A.overlay-sync,A.overlay-light").size() > 0) {
				
			if(window.location.toString().indexOf("#overlay")!=-1){
				//overlay = overlay || appendOverlay();
				if ($("#overlay").size() === 0) {
				//console.log("append");
				overlay =  appendOverlay();
				}else{
				//console.log("overlay");	
				overlay =  overlay;
				}
			}	
			
				
			$("A.overlay").bind("click", function (e) {
				
				if ($("#overlay").size() === 0) {
				
				overlay =  appendOverlay(e);
				}else{
					
				overlay = overlay;
				}
			     
				

				//toggle the custom class of the container.
				var reg = /overlay-[^\s$]+/,
                    $this = $(this);
					$overlay = $("#overlay"),
					newClass = $this.attr("class").match(reg);
				if(newClass){
					oldClass = $overlay.attr("class").match(reg);
					oldClass && $overlay.removeClass(oldClass.join(' '));
					$overlay.addClass(newClass[0] + " overlay-box");
				}
				
				if($this.hasClass("blackbackground")){
					
					if(addedBlackbg==false){
					
					var pheight=$(document).height(); 
					var pwidth=$(document).width(); 
					$("#overlay").before("<div class='overlayblackbg' style='height:"+pheight+"px;width:"+pwidth+"px;' ></div>");
					$("#overlay").addClass("syncsltoverlay");
					addedBlackbg=true;
					}
				}
				

                //inject the custom contents if link contains data attributes that start with "tmpl-"
                var tmplData = $this.attr("data");
                if(tmplData && tmplData.indexOf("tmpl-") == 0){
                    overlay.load(null, "urlOnly", $this.attr("href"), {
                        success: function(){
                            var template = $('#' + tmplData).template();
                            $('#' + tmplData.substr(5)).append( $.tmpl( template ) );
                            //reset the scrollbar, since the content has been changed.
                            overlay.reinitalise();
                        }
                    });
                }else{
                    overlay.load(this);
                }

				e.preventDefault();
				e.stopPropagation();
				flag = true;
				return false;
			});
			
			
			$("A.overlay-light").bind("click", function (e) {
				
				if ($("#overlay").size() === 0) {
				
				overlay =  appendOverlay(e);
				}else{
					
				overlay =  overlay;
				}
				
				overlay.load(this);
				$("#overlay").addClass();
				e.preventDefault();
				e.stopPropagation();
				flag = true;
				return false;
			});
			
			$("A.external-disclaimer").live("click", function (e) {
				if ($("#overlay").size() === 0) {
				
				overlay =  appendOverlay(e);
				}else{
					
				overlay =  overlay;
				}
				var href = $(this).attr("href");
				overlay.load(this, "disclaimer")
				e.preventDefault();
				e.stopPropagation();
				return false;
			});
			
			$(".overlay-parent").bind("click", function (e) {
				if ($("#overlay").size() === 0) {
				
				overlay =  appendOverlay(e);
				}else{
					
				overlay =  overlay;
				}
				var link = $(this).find("A:eq(0)");
				if (link.size() > 0) {
					overlay.load(link);
				}
				e.preventDefault();
				e.stopPropagation();
				return false;
			});
			
			if (!ND.API || !ND.API.isBuildAndPrice) {
			    $(window).trigger('pageLoadedWithOverlay');
			}
			
			
		}})//end 
		
		//ND.API for Flash
		ND.API.launchOverlay = ND.launchOverlay = function(url, options) {
			overlay = overlay || appendOverlay();

			if(!options) options = {};
			var type = options.type || "urlOnly";

			if (url !== undefined) {
				
				overlay.load(null, type, url, options);
			}

			//implement custom class
			if(options.customClass){
				var reg = /overlay-[^\s$]+/,
					$overlay = $("#overlay"),
					oldClass = $overlay.attr("class").match(reg);
				oldClass && $overlay.removeClass(oldClass.join(' '));
				$overlay.addClass(options.customClass + " overlay-box");
			};
		};
		
		$.subscribe('overlay.launch', function(event, options){
			options && ND.launchOverlay(options.url, options);
		});
		
		
		$.subscribe('overlay.hide', function(event){	
			overlay && overlay.hide();
		});
		
		$.subscribe('overlay.prefetch', function(event, options){
			overlay = overlay || appendOverlay();
			overlay.prefetch( options.url );
		});
		
		ND.API.getOverlay = function(){
			overlay = overlay || appendOverlay();
			return 	overlay;
		};
		
		
		if (ND.API && ND.API.isBuildAndPrice) {
		    $(window).trigger('pageLoadedWithOverlay');
		}
		
	});
	
})(jQuery);


/*
Author:         Brett Chaney
File name:      mediaOverlay.js
Description:    initiates Bootstrap modals
Dependencies:   jQuery, jquery.flexslider.js, carousel.js and bootstrap.modal.js
Usage:          add class="open-media-overlay" to anchor that will open the modal. The href of the modal content needs to be in the href of the link.
                For an image carousel modal, group images like this: class="overlay-groupx". Where "x" is the number of the group.
                An example: <a href="modal-media-image1.html" class="open-media-overlay overlay-group1" data-media-type="image" itemprop="contentUrl">
                                <img src="media/gallery/gallery-exterior2.jpg" alt="gallery exterior" itemprop="thumbnailUrl">
                            </a>
*/

var guxApp = guxApp || {};

(function($){
    guxApp.mediaOverlay = {
        overlayHTML: "<section class='image-carousel'><div class='row fullwidth'><div class='large-12 columns'><div class='carousel carousel-main flexslider'><ul class='slides'></ul></div><div class='carousel carousel-fader flexslider'><ul class='slides'></ul></div></div></div></section>",

        init: function(){
            var self = this;

            // this will fetch the json value from gux/common/json/mediaOverlay-config.html
            self.slideText = guxApp.tools.getEmbeddedData("#media-overlay-services");

            
            if (!$(".open-media-overlay").length){return;}

            guxApp.mediaOverlay.hideDetailsClick = false;
            guxApp.mediaOverlay.overlayOpen = false;

            // this is for the external disclaimer overlay
            // move close button
            $(".buzz a.external-disclaimer").on("click", function() {
                setTimeout(function(){
                    $(".overlay-box.external-disclaimer .close-button").clone().prependTo($(".ext-disc")).show();
                },200);
            });

            $("#modalWrap .modal-body").append(this.overlayHTML);

            $(".open-media-overlay").on("click", function(e) {
                e.preventDefault();

                var elem            = $(this),
                    mediaType       = elem.data("media-type"),
                    reg             = /overlay-[^\s$]+/,
                    overlayGroup    = elem.attr("class").match(reg),
                    videoType       = elem.data("video-type");

                $(this).addClass("active-overlay");

                self.updateMobileCarousel($(this));

                if (mediaType === "video") {
                    $(".modal-body").addClass("loading-video");
                }

                guxApp.mediaOverlay.appendAssetID(elem);

                if (guxApp.mediaOverlay.overlayOpen === false) {
                    guxApp.mediaOverlay.openOverlay(elem, overlayGroup, mediaType, videoType);
                }
            });

            $(".open-media-overlay").on('touchstart', function() {
                $(this).parent().addClass('hover');
            }).on('touchend',function(){
                $(this).parent().removeClass('hover');
            });

            function triggerOverlay() {
                if (window.location.toString().indexOf("#overlay") != -1) {
                    var assetIDClass = "asset-" + guxApp.mediaOverlay.getOverlayID();
                
                    $("a[data-overlay-id="+ assetIDClass + "]").eq(0).trigger("click");
                }
            }

            window.onhashchange = triggerOverlay;

            triggerOverlay();
        },

        
        updateMobileCarousel: function($curSpot){
            var sliderIndex = $curSpot.parent().index() - 1;
            var mobHook = $curSpot.parents('.hs-triggers').next('.flexslider').find('.flex-control-nav li').eq(sliderIndex).find('a');
            mobHook.click();
        },

        getOverlayID: function(){
            var hash = window.location.hash,
                overlayId;

            if (hash.indexOf("?")!=-1) {
                hash =  hash.substring(0, hash.indexOf("?"));
            }

            overlayId = hash.substring(9);          
            
            return overlayId;
        },

        appendAssetID: function(elem) {
            if (!elem.data("overlay-id")){return;}

            var overlayID   = elem.data("overlay-id"),
                idxAsset = overlayID.indexOf("-"),
                assetStr = overlayID.substring(idxAsset + 1);

            $(".modal").addClass(assetStr);

            if (Modernizr.history) {
                window.history.pushState(null, null, "#overlay=" + assetStr);
            } else {
                window.location.hash="#overlay=" + assetStr;
            }
        },

        openOverlay: function(elem, overlayGroup, mediaType, videoType){
            $("#modalWrap").addClass("media-overlay").prepend("<div class='loading-overlay' />").modal({
                    "backdrop" : false,
                    "keyboard" : false
                });

            if (mediaType === "video") {
                $(".modal").attr("itemtype", "http://schema.org/VideoGallery");
                $(".modal .modal-content").addClass("video");
            }

            guxApp.mediaOverlay.overlayOpen = true;
            
            this.populateSlides(elem, overlayGroup, mediaType, videoType);
        },

        applyVideosStrategy: function(videoType){
            if(videoType === 'jwplayer'){
                
                if ($(".BrightcoveExperience").length) {
                    $(".BrightcoveExperience").remove();
                }
                guxApp.video.init();           

            }else if(videoType === 'brightcove'){
                
                if(brightcove){
                    $(".modal-body").removeClass("loading-video");
                    brightcove.createExperiences();            
                }

            }
            return;
        },

        populateSlides: function(elem, overlayGroup, mediaType, videoType) {
            if(mediaType === "video"){

                var videoLink = elem.attr("href");

                $(".media-overlay .carousel-main .slides").load(videoLink, function() {

                    $(".modal .content").parent().prependTo(".modal .carousel-fader .slides");              

                    $(".modal .modal-body").addClass("single-slide").find(".carousel-main .slides > li").css("display", "list-item");

                    guxApp.mediaOverlay.applyVideosStrategy(videoType);
                    guxApp.mediaOverlay.videoInit();
                    guxApp.mediaOverlay.hideDetails();
                    guxApp.mediaOverlay.sharePanelInit();
                    guxApp.mediaOverlay.closeOverlay();
                });

            } else {                

                var groupArr    = [],
                    requests    = [],
                    link        = elem.attr("href"),
                    thisSlide,
                    i;

                // create an array of URL's for each slides content
                if (overlayGroup !== null) {
                    thisSlide = $("." + overlayGroup.toString()).index(elem);
                    
                    elem.parents(".gallery-category").find("." + overlayGroup.toString()).each(function (i, e) {
                        groupArr.push($(e).attr("href"));
                    });
                } else {
                    thisSlide = 0;
                    groupArr.push(link);
                }    

                for (i = 0; i < groupArr.length; i++) {
                    var getURL = groupArr[i].toString();
                    requests.push( $.ajax({url: getURL}) );
                }

                $.when.apply(undefined, requests).then(function() {

                    var slideImg,
                        slideContent,
                        j;

                    if (requests.length > 1) {
                        for (j = 0; j < arguments.length; j++){
                            slideImg        = $(".carousel-slide", arguments[j][0]).parent();
                            slideContent    = $(".content", arguments[j][0]).parent();

                            $(".media-overlay .carousel-main .slides").append(slideImg);
                            $(".media-overlay .carousel-fader .slides").append(slideContent);

                        }
                    } else {
                            slideImg        = $(".carousel-slide", arguments[0]).parent();
                            slideContent    = $(".content", arguments[0]).parent();

                        $(".media-overlay .carousel-main .slides").append(slideImg);
                        $(".media-overlay .carousel-fader .slides").append(slideContent);
                    }
                    
                    // when the slides are populated, do the following...

                    // re-initialise flexslider in modal
                    if ($(".media-overlay .flexslider").length) {                   
                        guxApp.billboardCarousel.init();
                    }

                    // add "single-slide" class
                    if ($(".media-overlay .carousel-main li").length === 1) {
                        $(".modal .modal-body").addClass("single-slide");
                    }

                    if ($(".modal .modal-content").hasClass("video")) {
                        guxApp.mediaOverlay.videoInit();
                    } else {
                        guxApp.mediaOverlay.imagesInit(thisSlide);
                    }

                    if (guxApp.mediaOverlay.hideDetailsClick === false) {
                        guxApp.mediaOverlay.hideDetails();
                    }
                    guxApp.mediaOverlay.sharePanelInit();
                    guxApp.mediaOverlay.closeOverlay();
                });

            }
            
        },

        centerOverlay: function() {
            if (guxApp.viewport.view === "tablet") {
                var screenH = $(window).height(),
                    overlayH = 760;

                $(".modal-dialog").css({"top": (screenH - overlayH) / 2});
            } else {
                $(".modal-dialog").css({"top": ""});
            }
        },

        videoInit: function() {
            $(".containing-block").attr("tabindex", 1).css("outline","none");

            // extra focus for iOS
            $(".modal-body").click(function() {
                $(".containing-block").focus();
            });
        },

        imagesInit: function(thisSlide) {
            // jump to image/description in sliders the user initially clicked on
            if ($(".media-overlay .flexslider").data("flexslider") !== undefined) {

                var slider1         = $(".media-overlay .carousel-main.flexslider").data("flexslider"),
                    slider2         = $(".media-overlay .carousel-fader.flexslider").data("flexslider"),
                    animationSpeed  = slider1.vars.animationSpeed = guxApp.viewport.view === "mobile" ? 300 : 600;

                slider1.vars.animationSpeed = 0;
                slider2.vars.animationSpeed = 0;
                slider1.flexAnimate(thisSlide);
                slider2.flexAnimate(thisSlide);
                slider1.vars.animationSpeed = animationSpeed;
                slider2.vars.animationSpeed = 0;

                $(".media-overlay .mobile-buttons").prepend("<span class='slide-count'></span>");
                $(".media-overlay .title .large-9").append("<span class='slide-count'></span>");

                guxApp.mediaOverlay.updateSlideCount();
                
                slider1.vars.after = function() {
                    // update slide counter ("1 of 3") after slide change event
                    guxApp.mediaOverlay.updateSlideCount();
                    guxApp.mediaOverlay.sharePanelInit();
                    
                    // update hash
                    guxApp.mediaOverlay.currentElem();
                    guxApp.mediaOverlay.appendAssetID($(".open-media-overlay.active-overlay"));

                    // update share panel with latest URL
                    $(".share-panel.cloned input").val(location.href);
                };
            }

            guxApp.mediaOverlay.expandedView();     
        },

        currentElem: function() {
            var currSlide   = $(".media-overlay .carousel-main.flexslider li:has(.flex-active)").index(".media-overlay .flex-control-nav li"),
                reg             = /overlay-[^\s$]+/,
                overlayGroup    = $(".active-overlay").attr("class").match(reg);

            $(".active-overlay").parent().parent().find($("." + overlayGroup.toString())).removeClass("active-overlay").eq(currSlide).addClass("active-overlay");           
        },

        updateSlideCount: function() {
            var currSlide   = $(".media-overlay .carousel-main.flexslider li:has(.flex-active)").index(".media-overlay .flex-control-nav li") + 1,
                totalSlides = $(".media-overlay .carousel-main.flexslider .flex-control-nav li").length,
                slideText = guxApp.mediaOverlay.slideText;

            if($('body').hasClass('rtl')){
                $(".media-overlay .slide-count").html((((totalSlides) - currSlide) + 1) + " " + slideText.slider_count + " " + totalSlides);
            } else {
                $(".media-overlay .slide-count").html(currSlide + " " + slideText.slider_count + " " + totalSlides);
            }    
        },

        checkVisible: function(elm, evalType) {
            evalType = evalType || "visible";

            var vpH = $(window).height(),
                st  = $(window).scrollTop(),
                y   = $(elm).offset().top,
                elementHeight = $(elm).height();

            if (evalType === "visible") return ((y < (vpH + st)) && (y > (st - elementHeight)));
            if (evalType === "above") return ((y < (vpH + st)));             
        },

        closeOverlay: function() {
            $(".modal").on("click", ".icon-close", function(e) {
                e.preventDefault();    

                $(".modal .loading-overlay").remove();

                $(".modal-body").removeClass("loading-video");    

                // move modal close icon back to original position
                $(".modal .icon-close").prependTo(".modal-content");

                $("#modalWrap.media-overlay").modal("hide").removeClass("expanded media-overlay").find(".modal-dialog").css("max-width","");
                $(".modal .modal-body").html("").append(guxApp.mediaOverlay.overlayHTML).removeClass("single-slide");
                $(".modal .modal-content").removeClass("video");
                $("#modalWrap").removeClass().addClass("modal");

                $(".open-media-overlay").removeClass("active-overlay");

                $(".modal").attr("itemtype", "http://schema.org/ImageGallery");

                if (Modernizr.history) {
                    window.history.pushState(null, null, "#");
                } else {
                    window.location.hash="#";
                }

                // reset variables
                guxApp.mediaOverlay.hideDetailsClick = false;
                guxApp.mediaOverlay.overlayOpen = false;

                $(".modal").off("click", ".icon-close");
            });

            $(".modal .modal-content").mouseup(function (e) {
                if (e.which != 1) return false; // Stops all non-left-clicks
                $(this).focus();
            });

            $(document).keydown(function(e) {
                if(e.keyCode == 27 && $("#video-inner").css("position") !== "fixed") {
                    if (guxApp.mediaOverlay.checkVisible($(".modal"))) {
                        $(".modal .icon-close").trigger("click");
                    }
                } else {
                    $(".modal .icon-close").show();
                }
            });
        },

        hideDetails: function() {
            guxApp.mediaOverlay.hideDetailsClick = true;

            var hideDetailsBtn  = $(".hide-details-btn"),
                hideHTMLText    = hideDetailsBtn.data("hidedetailstext"),
                showHTMLText    = hideDetailsBtn.data("showdetailstext"),
                arrowHTML       = "<span class='icon arrow'></span>";

            // set text Details toggle button
            hideDetailsBtn.html(showHTMLText).append(arrowHTML);

            $(".hide-details-btn").on("click", function(e) {
                e.preventDefault();

                if ($(this).parent().hasClass("active")) {
                    $(this).html(showHTMLText).append(arrowHTML).parent().removeClass("active");
                    $(this).parents(".content").find(".details").removeClass("show").addClass("hide");
                } else {
                    $(this).html(hideHTMLText).append(arrowHTML).parent().addClass("active");
                    $(this).parents(".content").find(".details").removeClass("hide").addClass("show");
                    guxApp.mediaOverlay.scrollToTop();
                }
            });
        },

        sharePanelInit: function() {
            var carouselWidth = $(".image-carousel").width();

            this.cloneSharePanel();

            if (guxApp.viewport.view === "mobile") {
                guxApp.mediaOverlay.mobileShareEvents();
                guxApp.mediaOverlay.initShareBtn();
            } else {            
                guxApp.mediaOverlay.desktopShareEvents();
                guxApp.mediaOverlay.initShareBtn();
            }

            $(window).on("resize", function () {

                var newCarouselWidth = $(window).width();

                if (newCarouselWidth !== carouselWidth) {

                    if ($(".media-overlay")[0]) {
                        if (guxApp.viewport.view === "mobile") {
                            guxApp.mediaOverlay.initShareBtn();
                        } else {
                            // move modal close icon back to original position
                            $(".modal .icon-close").prependTo(".modal-content");
                            guxApp.mediaOverlay.initShareBtn();
                        }

                    }

                }

                carouselWidth = $(window).width();
                    
            });
        },

        cloneSharePanel: function() {
            var shareHTML;

            if ($(".media-overlay .flexslider").data("flexslider") !== undefined) {
                shareHTML = $(".media-overlay .flex-active-slide .share-panel");
            } else {
                shareHTML = $(".media-overlay .carousel-fader .share-panel");
            }

            $(".media-overlay .share-panel.cloned").remove();
            shareHTML.clone().prependTo(".media-overlay .image-carousel").addClass("cloned");
        },      

        mobileSharePosition: function() {
            var screenH = $(window).height(),
                topMargin = (screenH / 2) - 100;

            if (!$(".share-bg").length) {
                $("<div class='share-bg' />").insertBefore(".media-overlay .share-panel.cloned");
            }

            $(".media-overlay .share-panel.cloned").css({"top": topMargin});
        },

        mobileShareEvents: function() {
            $(".media-overlay .mobile-buttons").on("click", ".share-btn", function(e) {
                e.stopPropagation();
                e.preventDefault();
                guxApp.mediaOverlay.mobileSharePosition();
                $(".media-overlay .share-panel.cloned").show();
                $(".share-bg").show();
                
                // move modal close icon otherwise it'll be above the share BG
                $(".modal .icon-close").prependTo(".image-carousel > .row");
            });

            $(".media-overlay .share-panel.cloned").on("click", ".close", function(e) {
                e.stopPropagation();
                e.preventDefault();
                $(this).parents(".share-panel.cloned").hide();
                $(".share-bg").hide();

                // move modal close icon back to original position
                $(".modal .icon-close").prependTo(".modal-content");
            });

            $(".media-overlay .share-panel.cloned").on("click", function(e){
                e.stopPropagation();
            });
            
            //This should trigger omniture which uses .live click listener for share buttons
            $(".media-overlay .share-panel.cloned").on("click", ".trackable", function(e){
                e.stopPropagation();
                
                $(document).triggerHandler({ 
                   type:   'click',
                   target: $(this)[0]
                });
            });

            $(".media-overlay .mobile-buttons").on("click", ".download-btn", function(e) {
                e.stopPropagation();
                
                //This should trigger omniture which uses .live click listener for download button
                $(document).triggerHandler({ 
                   type:   'click',
                   target: $(this)[0]
                });
            });
        },

        desktopShareEvents: function() {
            $(".media-overlay .desktop-buttons .share-btn").on("click", function(e) {
                e.preventDefault();
                e.stopPropagation();
                guxApp.mediaOverlay.desktopSharePosition();
                $(".media-overlay .share-panel.cloned").show();
            });

            $(".media-overlay .share-panel.cloned").on("click", ".close", function(e) {
                e.preventDefault();
                e.stopPropagation();
                $(this).parents(".share-panel.cloned").hide();
            });
        },

        desktopSharePosition: function() {
            var topPos      = $(".modal .carousel-fader").position().top,
                leftOffset  = $(".modal .modal-body").offset().left,
                leftPos     = $(".modal .flex-active-slide").length > 0 ? $(".modal .flex-active-slide .desktop-buttons .share-btn").offset().left : $(".modal .desktop-buttons .share-btn").offset().left,
                panelOffset = $(".media-overlay .share-panel.cloned").width() - (($(".modal .flex-active-slide").length > 0 ? $(".modal .flex-active-slide .desktop-buttons .share-btn").width() : $(".modal .desktop-buttons .share-btn").width()) / 2);

            if ($(".modal").hasClass("expanded")) {
                $(".media-overlay .share-panel.cloned").css({"top": topPos - 202, "left": (leftPos - leftOffset) - panelOffset});
            } else {
                $(".media-overlay .share-panel.cloned").css({"top": topPos - 90, "left": (leftPos - leftOffset) - panelOffset});
            }
        },

        initShareBtn: function() {
            guxApp.shareWidget.init(".media-overlay .share-panel.cloned");
        },

        checkOrientation: function() {
            var currW = $(".modal").width(),
                currH = $(".modal").height();

            if (currW > currH) {
                return "landscape";
            } else {
                return "portrait";
            }
        },

        expandedView: function() {

            function openExpandedView() {
            
                $(".image-carousel").resize();

                var viewportH   = Math.max(document.documentElement.clientHeight, window.innerHeight || 0),
                    currentW    = $(".modal-dialog").width(),
                    currentH    = $(".modal-dialog").height(),
                    ratio       = currentW / currentH,
                    slider1     = $(".media-overlay .carousel-main.flexslider").data("flexslider");
            
                $(".expanded .modal-dialog").css("max-width", ratio * viewportH);

                if ($(".media-overlay .flexslider").data("flexslider") !== undefined) {
                    slider1.resize();

                    // this is required to fix ipad resize issues
                    slider1.vars.after = function() {
                        slider1.resize();
                        guxApp.mediaOverlay.updateSlideCount();

                        // update hash
                        guxApp.mediaOverlay.currentElem();
                        guxApp.mediaOverlay.appendAssetID($(".open-media-overlay.active-overlay"));

                        // update share panel with latest URL
                        $(".share-panel.cloned input").val(location.href);
                    };
                }

                if (guxApp.viewport.view === "mobile") {
                    $(".expanded .carousel-main").css({"margin-top": -($(".carousel-slide").height() / 2)}).parent().css({"height": $(window).height()});
                } else {
                    $(".expanded .carousel-main").css({"margin-top": ""}).parent().css({"height": ""});
                }
            }

            function hideUiEvent(firstClick) {
                
                if (guxApp.viewport.view === "mobile") {
                    $(".modal .image-carousel").on("click", function() {
                        if (firstClick) {
                            firstClick = false;
                        } else {

                            var imgCarousel = $(".modal .image-carousel");
                            
                            if (imgCarousel.hasClass("hide-ui")) {
                                imgCarousel.removeClass("hide-ui");
                            } else {
                                imgCarousel.addClass("hide-ui");
                            }
                        }
                    });

                } else {
                    $(".modal .image-carousel").off("click");
                }       
                
            }

            $(".modal .icon-expand").on("click", function(){
                $(".modal").addClass("expanded");
                $(".modal .image-carousel").removeClass("hide-ui");
                $(".media-overlay .share-panel.cloned").hide();

                guxApp.mediaOverlay.zoomImage();

                openExpandedView();
                hideUiEvent(true);

                $(".modal").off("click", ".icon-close");
                $(document).off("keydown");

                $(window).on("resize", function() {
                    if (guxApp.viewport.view === "mobile") {
                        $(".expanded .carousel-main").css({"margin-top": -($(".carousel-slide").height() / 2)}).parent().css({"height": $(window).height()});
                    } else {
                        $(".expanded .carousel-main").css({"margin-top": ""}).parent().css({"height": ""});
                    }
                });
                
                guxApp.mediaOverlay.closeExpandedView();
            });
        },

        closeExpandedView: function() {
            $(".modal.expanded").on("click", ".icon-close", function(e) {
                e.preventDefault();

                // reset inline syles
                $(".modal .modal-dialog").css("max-width","");
                $(".expanded .carousel-main").css({"margin-top": ""}).parent().css({"height": ""});
                
                $(".media-overlay .share-panel.cloned").hide();
                $(".modal .carousel-main article").removeClass("zoomedin").css({"height": "", "width":""});
                $(".image-carousel").find(".loading, img.large-image").remove().end().find(".carousel-slide img").show();

                $(".modal").removeClass("expanded");

                $(".modal .title, .modal .mobile-buttons").css({"height": ""});

                $(".modal .icon-zoom").off("click");

                $(".modal .image-carousel").off("click").resize();

                guxApp.mediaOverlay.closeOverlay();
            });

            $(document).keydown(function(e) {
                if(e.keyCode == 27) {
                    $(".media-overlay .share-panel.cloned").hide();
                    $(".modal.expanded .icon-close").trigger("click");
                } 
            });
        },

        zoomImage: function() {         

            if (guxApp.viewport.view === "tablet") {

                $(".modal .icon-zoom").on("click", function() {

                    var imageParent     = $(this).parent(),
                        zoomedImage     = imageParent.find("img").data("zoom-src"),
                        containerH      = imageParent.parent().height(),
                        containerW      = imageParent.parent().width(),
                        slider          = $(".media-overlay .carousel-main.flexslider").data("flexslider"),
                        imageCarousel   = $(".image-carousel");

                    if ($(".media-overlay .flexslider").data("flexslider") !== undefined) {
                        slider.vars.after = function() {
                            $(".modal .carousel-main article").removeClass("zoomedin").css({"height": "", "width":""});
                            imageCarousel.find(".loading").remove();
                            imageCarousel.find("img.large-image").remove();
                            imageParent.find("img").show();
                            guxApp.mediaOverlay.updateSlideCount();
                        };
                    }

                    if (imageParent.hasClass("zoomedin")) {

                        imageParent.removeClass("zoomedin").css({"height": "", width: ""});
                        imageCarousel.find(".loading").remove();
                        imageCarousel.find("img.large-image").remove();
                        imageParent.find("img").css("display", "block");
                        $(".modal .carousel-slide").unbind("mousedown mousemove mouseleave");

                    } else {

                        imageParent.addClass("zoomedin").css({"height": containerH, "width": containerW});
                        $(this).after("<span class='loading'></span><img src='' alt='' class='large-image' />");

                        imageCarousel.find(".large-image").attr("src", zoomedImage);

                        $(".large-image").imagesLoaded( function() {
                            setTimeout(function() {

                                var zoomedImageH = imageCarousel.find(".large-image").height(),
                                    zoomedImageW = imageCarousel.find(".large-image").width(),
                                    differenceH  = (zoomedImageH - containerH) / 2,
                                    differenceW  = (zoomedImageW - containerW) / 2;

                                imageCarousel.find(".large-image").css({"height":zoomedImageH, "width":zoomedImageW}).siblings("img").hide();
                                imageParent.find(".loading").hide();

                                $(".modal .zoomedin").scrollLeft(differenceW);
                                $(".modal .zoomedin").scrollTop(differenceH);

                                guxApp.mediaOverlay.dragImage();
                            },200);
                            
                        });
                    }

                });

            }

        },

        dragImage: function() {
            var clicking = false,
                previousX,
                previousY;

            $(".modal .zoomedin").mousedown(function(e) {
                e.preventDefault();
                previousX = e.clientX;
                previousY = e.clientY;
                clicking = true;
            });

            $(document).mouseup(function() {
                clicking = false;
            });

            $(".modal .zoomedin").mousemove(function(e) {
                if (clicking) {
                    e.preventDefault();

                    $(".modal .zoomedin").scrollLeft($(".modal .zoomedin").scrollLeft() + (previousX - e.clientX));
                    $(".modal .zoomedin").scrollTop($(".modal .zoomedin").scrollTop() + (previousY - e.clientY));
                    previousX = e.clientX;
                    previousY = e.clientY;
                }
            });

            $(".modal .zoomedin").mouseleave(function() {
                clicking = false;
            });
        },

        scrollToTop: function() {
            var topPosition = ($(".hide-details").length) ? $(".hide-details").offset().top : 0;

            setTimeout(function() {
                $(".modal").animate({
                    scrollTop:topPosition
                },800);
            }, 150);
        }
    };


    $(function() {
        // if "Owner" user is logged in the mediaOverlay.init will be executed in the component-know-vehicle.js file
        // otherwise run mediaOverlay.init
        if ($.cookie("dfy.u") && $(".showroom.personalisation").length) {
            return;
        } else {
            guxApp.mediaOverlay.init();
        }
    });

})(jQuery);



Date.CultureInfo={name:"en-US",englishName:"English (United States)",nativeName:"English (United States)",dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],abbreviatedDayNames:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],shortestDayNames:["Su","Mo","Tu","We","Th","Fr","Sa"],firstLetterDayNames:["S","M","T","W","T","F","S"],monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],abbreviatedMonthNames:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],amDesignator:"AM",pmDesignator:"PM",firstDayOfWeek:0,twoDigitYearMax:2029,dateElementOrder:"mdy",formatPatterns:{shortDate:"M/d/yyyy",longDate:"dddd, MMMM dd, yyyy",shortTime:"h:mm tt",longTime:"h:mm:ss tt",fullDateTime:"dddd, MMMM dd, yyyy h:mm:ss tt",sortableDateTime:"yyyy-MM-ddTHH:mm:ss",universalSortableDateTime:"yyyy-MM-dd HH:mm:ssZ",rfc1123:"ddd, dd MMM yyyy HH:mm:ss GMT",monthDay:"MMMM dd",yearMonth:"MMMM, yyyy"},regexPatterns:{jan:/^jan(uary)?/i,feb:/^feb(ruary)?/i,mar:/^mar(ch)?/i,apr:/^apr(il)?/i,may:/^may/i,jun:/^jun(e)?/i,jul:/^jul(y)?/i,aug:/^aug(ust)?/i,sep:/^sep(t(ember)?)?/i,oct:/^oct(ober)?/i,nov:/^nov(ember)?/i,dec:/^dec(ember)?/i,sun:/^su(n(day)?)?/i,mon:/^mo(n(day)?)?/i,tue:/^tu(e(s(day)?)?)?/i,wed:/^we(d(nesday)?)?/i,thu:/^th(u(r(s(day)?)?)?)?/i,fri:/^fr(i(day)?)?/i,sat:/^sa(t(urday)?)?/i,future:/^next/i,past:/^last|past|prev(ious)?/i,add:/^(\+|aft(er)?|from|hence)/i,subtract:/^(\-|bef(ore)?|ago)/i,yesterday:/^yes(terday)?/i,today:/^t(od(ay)?)?/i,tomorrow:/^tom(orrow)?/i,now:/^n(ow)?/i,millisecond:/^ms|milli(second)?s?/i,second:/^sec(ond)?s?/i,minute:/^mn|min(ute)?s?/i,hour:/^h(our)?s?/i,week:/^w(eek)?s?/i,month:/^m(onth)?s?/i,day:/^d(ay)?s?/i,year:/^y(ear)?s?/i,shortMeridian:/^(a|p)/i,longMeridian:/^(a\.?m?\.?|p\.?m?\.?)/i,timezone:/^((e(s|d)t|c(s|d)t|m(s|d)t|p(s|d)t)|((gmt)?\s*(\+|\-)\s*\d\d\d\d?)|gmt|utc)/i,ordinalSuffix:/^\s*(st|nd|rd|th)/i,timeContext:/^\s*(\:|a(?!u|p)|p)/i},timezones:[{name:"UTC",offset:"-000"},{name:"GMT",offset:"-000"},{name:"EST",offset:"-0500"},{name:"EDT",offset:"-0400"},{name:"CST",offset:"-0600"},{name:"CDT",offset:"-0500"},{name:"MST",offset:"-0700"},{name:"MDT",offset:"-0600"},{name:"PST",offset:"-0800"},{name:"PDT",offset:"-0700"}]};
(function(){var $D=Date,$P=$D.prototype,$C=$D.CultureInfo,p=function(s,l){if(!l){l=2;}
return("000"+s).slice(l*-1);};$P.clearTime=function(){this.setHours(0);this.setMinutes(0);this.setSeconds(0);this.setMilliseconds(0);return this;};$P.setTimeToNow=function(){var n=new Date();this.setHours(n.getHours());this.setMinutes(n.getMinutes());this.setSeconds(n.getSeconds());this.setMilliseconds(n.getMilliseconds());return this;};$D.today=function(){return new Date().clearTime();};$D.compare=function(date1,date2){if(isNaN(date1)||isNaN(date2)){throw new Error(date1+" - "+date2);}else if(date1 instanceof Date&&date2 instanceof Date){return(date1<date2)?-1:(date1>date2)?1:0;}else{throw new TypeError(date1+" - "+date2);}};$D.equals=function(date1,date2){return(date1.compareTo(date2)===0);};$D.getDayNumberFromName=function(name){var n=$C.dayNames,m=$C.abbreviatedDayNames,o=$C.shortestDayNames,s=name.toLowerCase();for(var i=0;i<n.length;i++){if(n[i].toLowerCase()==s||m[i].toLowerCase()==s||o[i].toLowerCase()==s){return i;}}
return-1;};$D.getMonthNumberFromName=function(name){var n=$C.monthNames,m=$C.abbreviatedMonthNames,s=name.toLowerCase();for(var i=0;i<n.length;i++){if(n[i].toLowerCase()==s||m[i].toLowerCase()==s){return i;}}
return-1;};$D.isLeapYear=function(year){return((year%4===0&&year%100!==0)||year%400===0);};$D.getDaysInMonth=function(year,month){return[31,($D.isLeapYear(year)?29:28),31,30,31,30,31,31,30,31,30,31][month];};$D.getTimezoneAbbreviation=function(offset){var z=$C.timezones,p;for(var i=0;i<z.length;i++){if(z[i].offset===offset){return z[i].name;}}
return null;};$D.getTimezoneOffset=function(name){var z=$C.timezones,p;for(var i=0;i<z.length;i++){if(z[i].name===name.toUpperCase()){return z[i].offset;}}
return null;};$P.clone=function(){return new Date(this.getTime());};$P.compareTo=function(date){return Date.compare(this,date);};$P.equals=function(date){return Date.equals(this,date||new Date());};$P.between=function(start,end){return this.getTime()>=start.getTime()&&this.getTime()<=end.getTime();};$P.isAfter=function(date){return this.compareTo(date||new Date())===1;};$P.isBefore=function(date){return(this.compareTo(date||new Date())===-1);};$P.isToday=function(){return this.isSameDay(new Date());};$P.isSameDay=function(date){return this.clone().clearTime().equals(date.clone().clearTime());};$P.addMilliseconds=function(value){this.setMilliseconds(this.getMilliseconds()+value);return this;};$P.addSeconds=function(value){return this.addMilliseconds(value*1000);};$P.addMinutes=function(value){return this.addMilliseconds(value*60000);};$P.addHours=function(value){return this.addMilliseconds(value*3600000);};$P.addDays=function(value){this.setDate(this.getDate()+value);return this;};$P.addWeeks=function(value){return this.addDays(value*7);};$P.addMonths=function(value){var n=this.getDate();this.setDate(1);this.setMonth(this.getMonth()+value);this.setDate(Math.min(n,$D.getDaysInMonth(this.getFullYear(),this.getMonth())));return this;};$P.addYears=function(value){return this.addMonths(value*12);};$P.add=function(config){if(typeof config=="number"){this._orient=config;return this;}
var x=config;if(x.milliseconds){this.addMilliseconds(x.milliseconds);}
if(x.seconds){this.addSeconds(x.seconds);}
if(x.minutes){this.addMinutes(x.minutes);}
if(x.hours){this.addHours(x.hours);}
if(x.weeks){this.addWeeks(x.weeks);}
if(x.months){this.addMonths(x.months);}
if(x.years){this.addYears(x.years);}
if(x.days){this.addDays(x.days);}
return this;};var $y,$m,$d;$P.getWeek=function(){var a,b,c,d,e,f,g,n,s,w;$y=(!$y)?this.getFullYear():$y;$m=(!$m)?this.getMonth()+1:$m;$d=(!$d)?this.getDate():$d;if($m<=2){a=$y-1;b=(a/4|0)-(a/100|0)+(a/400|0);c=((a-1)/4|0)-((a-1)/100|0)+((a-1)/400|0);s=b-c;e=0;f=$d-1+(31*($m-1));}else{a=$y;b=(a/4|0)-(a/100|0)+(a/400|0);c=((a-1)/4|0)-((a-1)/100|0)+((a-1)/400|0);s=b-c;e=s+1;f=$d+((153*($m-3)+2)/5)+58+s;}
g=(a+b)%7;d=(f+g-e)%7;n=(f+3-d)|0;if(n<0){w=53-((g-s)/5|0);}else if(n>364+s){w=1;}else{w=(n/7|0)+1;}
$y=$m=$d=null;return w;};$P.getISOWeek=function(){$y=this.getUTCFullYear();$m=this.getUTCMonth()+1;$d=this.getUTCDate();return p(this.getWeek());};$P.setWeek=function(n){return this.moveToDayOfWeek(1).addWeeks(n-this.getWeek());};$D._validate=function(n,min,max,name){if(typeof n=="undefined"){return false;}else if(typeof n!="number"){throw new TypeError(n+" is not a Number.");}else if(n<min||n>max){throw new RangeError(n+" is not a valid value for "+name+".");}
return true;};$D.validateMillisecond=function(value){return $D._validate(value,0,999,"millisecond");};$D.validateSecond=function(value){return $D._validate(value,0,59,"second");};$D.validateMinute=function(value){return $D._validate(value,0,59,"minute");};$D.validateHour=function(value){return $D._validate(value,0,23,"hour");};$D.validateDay=function(value,year,month){return $D._validate(value,1,$D.getDaysInMonth(year,month),"day");};$D.validateMonth=function(value){return $D._validate(value,0,11,"month");};$D.validateYear=function(value){return $D._validate(value,0,9999,"year");};$P.set=function(config){if($D.validateMillisecond(config.millisecond)){this.addMilliseconds(config.millisecond-this.getMilliseconds());}
if($D.validateSecond(config.second)){this.addSeconds(config.second-this.getSeconds());}
if($D.validateMinute(config.minute)){this.addMinutes(config.minute-this.getMinutes());}
if($D.validateHour(config.hour)){this.addHours(config.hour-this.getHours());}
if($D.validateMonth(config.month)){this.addMonths(config.month-this.getMonth());}
if($D.validateYear(config.year)){this.addYears(config.year-this.getFullYear());}
if($D.validateDay(config.day,this.getFullYear(),this.getMonth())){this.addDays(config.day-this.getDate());}
if(config.timezone){this.setTimezone(config.timezone);}
if(config.timezoneOffset){this.setTimezoneOffset(config.timezoneOffset);}
if(config.week&&$D._validate(config.week,0,53,"week")){this.setWeek(config.week);}
return this;};$P.moveToFirstDayOfMonth=function(){return this.set({day:1});};$P.moveToLastDayOfMonth=function(){return this.set({day:$D.getDaysInMonth(this.getFullYear(),this.getMonth())});};$P.moveToNthOccurrence=function(dayOfWeek,occurrence){var shift=0;if(occurrence>0){shift=occurrence-1;}
else if(occurrence===-1){this.moveToLastDayOfMonth();if(this.getDay()!==dayOfWeek){this.moveToDayOfWeek(dayOfWeek,-1);}
return this;}
return this.moveToFirstDayOfMonth().addDays(-1).moveToDayOfWeek(dayOfWeek,+1).addWeeks(shift);};$P.moveToDayOfWeek=function(dayOfWeek,orient){var diff=(dayOfWeek-this.getDay()+7*(orient||+1))%7;return this.addDays((diff===0)?diff+=7*(orient||+1):diff);};$P.moveToMonth=function(month,orient){var diff=(month-this.getMonth()+12*(orient||+1))%12;return this.addMonths((diff===0)?diff+=12*(orient||+1):diff);};$P.getOrdinalNumber=function(){return Math.ceil((this.clone().clearTime()-new Date(this.getFullYear(),0,1))/86400000)+1;};$P.getTimezone=function(){return $D.getTimezoneAbbreviation(this.getUTCOffset());};$P.setTimezoneOffset=function(offset){var here=this.getTimezoneOffset(),there=Number(offset)*-6/10;return this.addMinutes(there-here);};$P.setTimezone=function(offset){return this.setTimezoneOffset($D.getTimezoneOffset(offset));};$P.hasDaylightSavingTime=function(){return(Date.today().set({month:0,day:1}).getTimezoneOffset()!==Date.today().set({month:6,day:1}).getTimezoneOffset());};$P.isDaylightSavingTime=function(){return(this.hasDaylightSavingTime()&&new Date().getTimezoneOffset()===Date.today().set({month:6,day:1}).getTimezoneOffset());};$P.getUTCOffset=function(){var n=this.getTimezoneOffset()*-10/6,r;if(n<0){r=(n-10000).toString();return r.charAt(0)+r.substr(2);}else{r=(n+10000).toString();return"+"+r.substr(1);}};$P.getElapsed=function(date){return(date||new Date())-this;};if(!$P.toISOString){$P.toISOString=function(){function f(n){return n<10?'0'+n:n;}
return'"'+this.getUTCFullYear()+'-'+
f(this.getUTCMonth()+1)+'-'+
f(this.getUTCDate())+'T'+
f(this.getUTCHours())+':'+
f(this.getUTCMinutes())+':'+
f(this.getUTCSeconds())+'Z"';};}
$P._toString=$P.toString;$P.toString=function(format){var x=this;if(format&&format.length==1){var c=$C.formatPatterns;x.t=x.toString;switch(format){case"d":return x.t(c.shortDate);case"D":return x.t(c.longDate);case"F":return x.t(c.fullDateTime);case"m":return x.t(c.monthDay);case"r":return x.t(c.rfc1123);case"s":return x.t(c.sortableDateTime);case"t":return x.t(c.shortTime);case"T":return x.t(c.longTime);case"u":return x.t(c.universalSortableDateTime);case"y":return x.t(c.yearMonth);}}
var ord=function(n){switch(n*1){case 1:case 21:case 31:return"st";case 2:case 22:return"nd";case 3:case 23:return"rd";default:return"th";}};return format?format.replace(/(\\)?(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|S)/g,function(m){if(m.charAt(0)==="\\"){return m.replace("\\","");}
x.h=x.getHours;switch(m){case"hh":return p(x.h()<13?(x.h()===0?12:x.h()):(x.h()-12));case"h":return x.h()<13?(x.h()===0?12:x.h()):(x.h()-12);case"HH":return p(x.h());case"H":return x.h();case"mm":return p(x.getMinutes());case"m":return x.getMinutes();case"ss":return p(x.getSeconds());case"s":return x.getSeconds();case"yyyy":return p(x.getFullYear(),4);case"yy":return p(x.getFullYear());case"dddd":return $C.dayNames[x.getDay()];case"ddd":return $C.abbreviatedDayNames[x.getDay()];case"dd":return p(x.getDate());case"d":return x.getDate();case"MMMM":return $C.monthNames[x.getMonth()];case"MMM":return $C.abbreviatedMonthNames[x.getMonth()];case"MM":return p((x.getMonth()+1));case"M":return x.getMonth()+1;case"t":return x.h()<12?$C.amDesignator.substring(0,1):$C.pmDesignator.substring(0,1);case"tt":return x.h()<12?$C.amDesignator:$C.pmDesignator;case"S":return ord(x.getDate());default:return m;}}):this._toString();};}());
(function(){var $D=Date,$P=$D.prototype,$C=$D.CultureInfo,$N=Number.prototype;$P._orient=+1;$P._nth=null;$P._is=false;$P._same=false;$P._isSecond=false;$N._dateElement="day";$P.next=function(){this._orient=+1;return this;};$D.next=function(){return $D.today().next();};$P.last=$P.prev=$P.previous=function(){this._orient=-1;return this;};$D.last=$D.prev=$D.previous=function(){return $D.today().last();};$P.is=function(){this._is=true;return this;};$P.same=function(){this._same=true;this._isSecond=false;return this;};$P.today=function(){return this.same().day();};$P.weekday=function(){if(this._is){this._is=false;return(!this.is().sat()&&!this.is().sun());}
return false;};$P.at=function(time){return(typeof time==="string")?$D.parse(this.toString("d")+" "+time):this.set(time);};$N.fromNow=$N.after=function(date){var c={};c[this._dateElement]=this;return((!date)?new Date():date.clone()).add(c);};$N.ago=$N.before=function(date){var c={};c[this._dateElement]=this*-1;return((!date)?new Date():date.clone()).add(c);};var dx=("sunday monday tuesday wednesday thursday friday saturday").split(/\s/),mx=("january february march april may june july august september october november december").split(/\s/),px=("Millisecond Second Minute Hour Day Week Month Year").split(/\s/),pxf=("Milliseconds Seconds Minutes Hours Date Week Month FullYear").split(/\s/),nth=("final first second third fourth fifth").split(/\s/),de;$P.toObject=function(){var o={};for(var i=0;i<px.length;i++){o[px[i].toLowerCase()]=this["get"+pxf[i]]();}
return o;};$D.fromObject=function(config){config.week=null;return Date.today().set(config);};var df=function(n){return function(){if(this._is){this._is=false;return this.getDay()==n;}
if(this._nth!==null){if(this._isSecond){this.addSeconds(this._orient*-1);}
this._isSecond=false;var ntemp=this._nth;this._nth=null;var temp=this.clone().moveToLastDayOfMonth();this.moveToNthOccurrence(n,ntemp);if(this>temp){throw new RangeError($D.getDayName(n)+" does not occur "+ntemp+" times in the month of "+$D.getMonthName(temp.getMonth())+" "+temp.getFullYear()+".");}
return this;}
return this.moveToDayOfWeek(n,this._orient);};};var sdf=function(n){return function(){var t=$D.today(),shift=n-t.getDay();if(n===0&&$C.firstDayOfWeek===1&&t.getDay()!==0){shift=shift+7;}
return t.addDays(shift);};};for(var i=0;i<dx.length;i++){$D[dx[i].toUpperCase()]=$D[dx[i].toUpperCase().substring(0,3)]=i;$D[dx[i]]=$D[dx[i].substring(0,3)]=sdf(i);$P[dx[i]]=$P[dx[i].substring(0,3)]=df(i);}
var mf=function(n){return function(){if(this._is){this._is=false;return this.getMonth()===n;}
return this.moveToMonth(n,this._orient);};};var smf=function(n){return function(){return $D.today().set({month:n,day:1});};};for(var j=0;j<mx.length;j++){$D[mx[j].toUpperCase()]=$D[mx[j].toUpperCase().substring(0,3)]=j;$D[mx[j]]=$D[mx[j].substring(0,3)]=smf(j);$P[mx[j]]=$P[mx[j].substring(0,3)]=mf(j);}
var ef=function(j){return function(){if(this._isSecond){this._isSecond=false;return this;}
if(this._same){this._same=this._is=false;var o1=this.toObject(),o2=(arguments[0]||new Date()).toObject(),v="",k=j.toLowerCase();for(var m=(px.length-1);m>-1;m--){v=px[m].toLowerCase();if(o1[v]!=o2[v]){return false;}
if(k==v){break;}}
return true;}
if(j.substring(j.length-1)!="s"){j+="s";}
return this["add"+j](this._orient);};};var nf=function(n){return function(){this._dateElement=n;return this;};};for(var k=0;k<px.length;k++){de=px[k].toLowerCase();$P[de]=$P[de+"s"]=ef(px[k]);$N[de]=$N[de+"s"]=nf(de);}
$P._ss=ef("Second");var nthfn=function(n){return function(dayOfWeek){if(this._same){return this._ss(arguments[0]);}
if(dayOfWeek||dayOfWeek===0){return this.moveToNthOccurrence(dayOfWeek,n);}
this._nth=n;if(n===2&&(dayOfWeek===undefined||dayOfWeek===null)){this._isSecond=true;return this.addSeconds(this._orient);}
return this;};};for(var l=0;l<nth.length;l++){$P[nth[l]]=(l===0)?nthfn(-1):nthfn(l);}}());
(function(){Date.Parsing={Exception:function(s){this.message="Parse error at '"+s.substring(0,10)+" ...'";}};var $P=Date.Parsing;var _=$P.Operators={rtoken:function(r){return function(s){var mx=s.match(r);if(mx){return([mx[0],s.substring(mx[0].length)]);}else{throw new $P.Exception(s);}};},token:function(s){return function(s){return _.rtoken(new RegExp("^\s*"+s+"\s*"))(s);};},stoken:function(s){return _.rtoken(new RegExp("^"+s));},until:function(p){return function(s){var qx=[],rx=null;while(s.length){try{rx=p.call(this,s);}catch(e){qx.push(rx[0]);s=rx[1];continue;}
break;}
return[qx,s];};},many:function(p){return function(s){var rx=[],r=null;while(s.length){try{r=p.call(this,s);}catch(e){return[rx,s];}
rx.push(r[0]);s=r[1];}
return[rx,s];};},optional:function(p){return function(s){var r=null;try{r=p.call(this,s);}catch(e){return[null,s];}
return[r[0],r[1]];};},not:function(p){return function(s){try{p.call(this,s);}catch(e){return[null,s];}
throw new $P.Exception(s);};},ignore:function(p){return p?function(s){var r=null;r=p.call(this,s);return[null,r[1]];}:null;},product:function(){var px=arguments[0],qx=Array.prototype.slice.call(arguments,1),rx=[];for(var i=0;i<px.length;i++){rx.push(_.each(px[i],qx));}
return rx;},cache:function(rule){var cache={},r=null;return function(s){try{r=cache[s]=(cache[s]||rule.call(this,s));}catch(e){r=cache[s]=e;}
if(r instanceof $P.Exception){throw r;}else{return r;}};},any:function(){var px=arguments;return function(s){var r=null;for(var i=0;i<px.length;i++){if(px[i]==null){continue;}
try{r=(px[i].call(this,s));}catch(e){r=null;}
if(r){return r;}}
throw new $P.Exception(s);};},each:function(){var px=arguments;return function(s){var rx=[],r=null;for(var i=0;i<px.length;i++){if(px[i]==null){continue;}
try{r=(px[i].call(this,s));}catch(e){throw new $P.Exception(s);}
rx.push(r[0]);s=r[1];}
return[rx,s];};},all:function(){var px=arguments,_=_;return _.each(_.optional(px));},sequence:function(px,d,c){d=d||_.rtoken(/^\s*/);c=c||null;if(px.length==1){return px[0];}
return function(s){var r=null,q=null;var rx=[];for(var i=0;i<px.length;i++){try{r=px[i].call(this,s);}catch(e){break;}
rx.push(r[0]);try{q=d.call(this,r[1]);}catch(ex){q=null;break;}
s=q[1];}
if(!r){throw new $P.Exception(s);}
if(q){throw new $P.Exception(q[1]);}
if(c){try{r=c.call(this,r[1]);}catch(ey){throw new $P.Exception(r[1]);}}
return[rx,(r?r[1]:s)];};},between:function(d1,p,d2){d2=d2||d1;var _fn=_.each(_.ignore(d1),p,_.ignore(d2));return function(s){var rx=_fn.call(this,s);return[[rx[0][0],r[0][2]],rx[1]];};},list:function(p,d,c){d=d||_.rtoken(/^\s*/);c=c||null;return(p instanceof Array?_.each(_.product(p.slice(0,-1),_.ignore(d)),p.slice(-1),_.ignore(c)):_.each(_.many(_.each(p,_.ignore(d))),px,_.ignore(c)));},set:function(px,d,c){d=d||_.rtoken(/^\s*/);c=c||null;return function(s){var r=null,p=null,q=null,rx=null,best=[[],s],last=false;for(var i=0;i<px.length;i++){q=null;p=null;r=null;last=(px.length==1);try{r=px[i].call(this,s);}catch(e){continue;}
rx=[[r[0]],r[1]];if(r[1].length>0&&!last){try{q=d.call(this,r[1]);}catch(ex){last=true;}}else{last=true;}
if(!last&&q[1].length===0){last=true;}
if(!last){var qx=[];for(var j=0;j<px.length;j++){if(i!=j){qx.push(px[j]);}}
p=_.set(qx,d).call(this,q[1]);if(p[0].length>0){rx[0]=rx[0].concat(p[0]);rx[1]=p[1];}}
if(rx[1].length<best[1].length){best=rx;}
if(best[1].length===0){break;}}
if(best[0].length===0){return best;}
if(c){try{q=c.call(this,best[1]);}catch(ey){throw new $P.Exception(best[1]);}
best[1]=q[1];}
return best;};},forward:function(gr,fname){return function(s){return gr[fname].call(this,s);};},replace:function(rule,repl){return function(s){var r=rule.call(this,s);return[repl,r[1]];};},process:function(rule,fn){return function(s){var r=rule.call(this,s);return[fn.call(this,r[0]),r[1]];};},min:function(min,rule){return function(s){var rx=rule.call(this,s);if(rx[0].length<min){throw new $P.Exception(s);}
return rx;};}};var _generator=function(op){return function(){var args=null,rx=[];if(arguments.length>1){args=Array.prototype.slice.call(arguments);}else if(arguments[0]instanceof Array){args=arguments[0];}
if(args){for(var i=0,px=args.shift();i<px.length;i++){args.unshift(px[i]);rx.push(op.apply(null,args));args.shift();return rx;}}else{return op.apply(null,arguments);}};};var gx="optional not ignore cache".split(/\s/);for(var i=0;i<gx.length;i++){_[gx[i]]=_generator(_[gx[i]]);}
var _vector=function(op){return function(){if(arguments[0]instanceof Array){return op.apply(null,arguments[0]);}else{return op.apply(null,arguments);}};};var vx="each any all".split(/\s/);for(var j=0;j<vx.length;j++){_[vx[j]]=_vector(_[vx[j]]);}}());(function(){var $D=Date,$P=$D.prototype,$C=$D.CultureInfo;var flattenAndCompact=function(ax){var rx=[];for(var i=0;i<ax.length;i++){if(ax[i]instanceof Array){rx=rx.concat(flattenAndCompact(ax[i]));}else{if(ax[i]){rx.push(ax[i]);}}}
return rx;};$D.Grammar={};$D.Translator={hour:function(s){return function(){this.hour=Number(s);};},minute:function(s){return function(){this.minute=Number(s);};},second:function(s){return function(){this.second=Number(s);};},meridian:function(s){return function(){this.meridian=s.slice(0,1).toLowerCase();};},timezone:function(s){return function(){var n=s.replace(/[^\d\+\-]/g,"");if(n.length){this.timezoneOffset=Number(n);}else{this.timezone=s.toLowerCase();}};},day:function(x){var s=x[0];return function(){this.day=Number(s.match(/\d+/)[0]);};},month:function(s){return function(){this.month=(s.length==3)?"jan feb mar apr may jun jul aug sep oct nov dec".indexOf(s)/4:Number(s)-1;};},year:function(s){return function(){var n=Number(s);this.year=((s.length>2)?n:(n+(((n+2000)<$C.twoDigitYearMax)?2000:1900)));};},rday:function(s){return function(){switch(s){case"yesterday":this.days=-1;break;case"tomorrow":this.days=1;break;case"today":this.days=0;break;case"now":this.days=0;this.now=true;break;}};},finishExact:function(x){x=(x instanceof Array)?x:[x];for(var i=0;i<x.length;i++){if(x[i]){x[i].call(this);}}
var now=new Date();if((this.hour||this.minute)&&(!this.month&&!this.year&&!this.day)){this.day=now.getDate();}
if(!this.year){this.year=now.getFullYear();}
if(!this.month&&this.month!==0){this.month=now.getMonth();}
if(!this.day){this.day=1;}
if(!this.hour){this.hour=0;}
if(!this.minute){this.minute=0;}
if(!this.second){this.second=0;}
if(this.meridian&&this.hour){if(this.meridian=="p"&&this.hour<12){this.hour=this.hour+12;}else if(this.meridian=="a"&&this.hour==12){this.hour=0;}}
if(this.day>$D.getDaysInMonth(this.year,this.month)){throw new RangeError(this.day+" is not a valid value for days.");}
var r=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second);if(this.timezone){r.set({timezone:this.timezone});}else if(this.timezoneOffset){r.set({timezoneOffset:this.timezoneOffset});}
return r;},finish:function(x){x=(x instanceof Array)?flattenAndCompact(x):[x];if(x.length===0){return null;}
for(var i=0;i<x.length;i++){if(typeof x[i]=="function"){x[i].call(this);}}
var today=$D.today();if(this.now&&!this.unit&&!this.operator){return new Date();}else if(this.now){today=new Date();}
var expression=!!(this.days&&this.days!==null||this.orient||this.operator);var gap,mod,orient;orient=((this.orient=="past"||this.operator=="subtract")?-1:1);if(!this.now&&"hour minute second".indexOf(this.unit)!=-1){today.setTimeToNow();}
if(this.month||this.month===0){if("year day hour minute second".indexOf(this.unit)!=-1){this.value=this.month+1;this.month=null;expression=true;}}
if(!expression&&this.weekday&&!this.day&&!this.days){var temp=Date[this.weekday]();this.day=temp.getDate();if(!this.month){this.month=temp.getMonth();}
this.year=temp.getFullYear();}
if(expression&&this.weekday&&this.unit!="month"){this.unit="day";gap=($D.getDayNumberFromName(this.weekday)-today.getDay());mod=7;this.days=gap?((gap+(orient*mod))%mod):(orient*mod);}
if(this.month&&this.unit=="day"&&this.operator){this.value=(this.month+1);this.month=null;}
if(this.value!=null&&this.month!=null&&this.year!=null){this.day=this.value*1;}
if(this.month&&!this.day&&this.value){today.set({day:this.value*1});if(!expression){this.day=this.value*1;}}
if(!this.month&&this.value&&this.unit=="month"&&!this.now){this.month=this.value;expression=true;}
if(expression&&(this.month||this.month===0)&&this.unit!="year"){this.unit="month";gap=(this.month-today.getMonth());mod=12;this.months=gap?((gap+(orient*mod))%mod):(orient*mod);this.month=null;}
if(!this.unit){this.unit="day";}
if(!this.value&&this.operator&&this.operator!==null&&this[this.unit+"s"]&&this[this.unit+"s"]!==null){this[this.unit+"s"]=this[this.unit+"s"]+((this.operator=="add")?1:-1)+(this.value||0)*orient;}else if(this[this.unit+"s"]==null||this.operator!=null){if(!this.value){this.value=1;}
this[this.unit+"s"]=this.value*orient;}
if(this.meridian&&this.hour){if(this.meridian=="p"&&this.hour<12){this.hour=this.hour+12;}else if(this.meridian=="a"&&this.hour==12){this.hour=0;}}
if(this.weekday&&!this.day&&!this.days){var temp=Date[this.weekday]();this.day=temp.getDate();if(temp.getMonth()!==today.getMonth()){this.month=temp.getMonth();}}
if((this.month||this.month===0)&&!this.day){this.day=1;}
if(!this.orient&&!this.operator&&this.unit=="week"&&this.value&&!this.day&&!this.month){return Date.today().setWeek(this.value);}
if(expression&&this.timezone&&this.day&&this.days){this.day=this.days;}
return(expression)?today.add(this):today.set(this);}};var _=$D.Parsing.Operators,g=$D.Grammar,t=$D.Translator,_fn;g.datePartDelimiter=_.rtoken(/^([\s\-\.\,\/\x27]+)/);g.timePartDelimiter=_.stoken(":");g.whiteSpace=_.rtoken(/^\s*/);g.generalDelimiter=_.rtoken(/^(([\s\,]|at|@|on)+)/);var _C={};g.ctoken=function(keys){var fn=_C[keys];if(!fn){var c=$C.regexPatterns;var kx=keys.split(/\s+/),px=[];for(var i=0;i<kx.length;i++){px.push(_.replace(_.rtoken(c[kx[i]]),kx[i]));}
fn=_C[keys]=_.any.apply(null,px);}
return fn;};g.ctoken2=function(key){return _.rtoken($C.regexPatterns[key]);};g.h=_.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2]|[1-9])/),t.hour));g.hh=_.cache(_.process(_.rtoken(/^(0[0-9]|1[0-2])/),t.hour));g.H=_.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3]|[0-9])/),t.hour));g.HH=_.cache(_.process(_.rtoken(/^([0-1][0-9]|2[0-3])/),t.hour));g.m=_.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/),t.minute));g.mm=_.cache(_.process(_.rtoken(/^[0-5][0-9]/),t.minute));g.s=_.cache(_.process(_.rtoken(/^([0-5][0-9]|[0-9])/),t.second));g.ss=_.cache(_.process(_.rtoken(/^[0-5][0-9]/),t.second));g.hms=_.cache(_.sequence([g.H,g.m,g.s],g.timePartDelimiter));g.t=_.cache(_.process(g.ctoken2("shortMeridian"),t.meridian));g.tt=_.cache(_.process(g.ctoken2("longMeridian"),t.meridian));g.z=_.cache(_.process(_.rtoken(/^((\+|\-)\s*\d\d\d\d)|((\+|\-)\d\d\:?\d\d)/),t.timezone));g.zz=_.cache(_.process(_.rtoken(/^((\+|\-)\s*\d\d\d\d)|((\+|\-)\d\d\:?\d\d)/),t.timezone));g.zzz=_.cache(_.process(g.ctoken2("timezone"),t.timezone));g.timeSuffix=_.each(_.ignore(g.whiteSpace),_.set([g.tt,g.zzz]));g.time=_.each(_.optional(_.ignore(_.stoken("T"))),g.hms,g.timeSuffix);g.d=_.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1]|\d)/),_.optional(g.ctoken2("ordinalSuffix"))),t.day));g.dd=_.cache(_.process(_.each(_.rtoken(/^([0-2]\d|3[0-1])/),_.optional(g.ctoken2("ordinalSuffix"))),t.day));g.ddd=g.dddd=_.cache(_.process(g.ctoken("sun mon tue wed thu fri sat"),function(s){return function(){this.weekday=s;};}));g.M=_.cache(_.process(_.rtoken(/^(1[0-2]|0\d|\d)/),t.month));g.MM=_.cache(_.process(_.rtoken(/^(1[0-2]|0\d)/),t.month));g.MMM=g.MMMM=_.cache(_.process(g.ctoken("jan feb mar apr may jun jul aug sep oct nov dec"),t.month));g.y=_.cache(_.process(_.rtoken(/^(\d\d?)/),t.year));g.yy=_.cache(_.process(_.rtoken(/^(\d\d)/),t.year));g.yyy=_.cache(_.process(_.rtoken(/^(\d\d?\d?\d?)/),t.year));g.yyyy=_.cache(_.process(_.rtoken(/^(\d\d\d\d)/),t.year));_fn=function(){return _.each(_.any.apply(null,arguments),_.not(g.ctoken2("timeContext")));};g.day=_fn(g.d,g.dd);g.month=_fn(g.M,g.MMM);g.year=_fn(g.yyyy,g.yy);g.orientation=_.process(g.ctoken("past future"),function(s){return function(){this.orient=s;};});g.operator=_.process(g.ctoken("add subtract"),function(s){return function(){this.operator=s;};});g.rday=_.process(g.ctoken("yesterday tomorrow today now"),t.rday);g.unit=_.process(g.ctoken("second minute hour day week month year"),function(s){return function(){this.unit=s;};});g.value=_.process(_.rtoken(/^\d\d?(st|nd|rd|th)?/),function(s){return function(){this.value=s.replace(/\D/g,"");};});g.expression=_.set([g.rday,g.operator,g.value,g.unit,g.orientation,g.ddd,g.MMM]);_fn=function(){return _.set(arguments,g.datePartDelimiter);};g.mdy=_fn(g.ddd,g.month,g.day,g.year);g.ymd=_fn(g.ddd,g.year,g.month,g.day);g.dmy=_fn(g.ddd,g.day,g.month,g.year);g.date=function(s){return((g[$C.dateElementOrder]||g.mdy).call(this,s));};g.format=_.process(_.many(_.any(_.process(_.rtoken(/^(dd?d?d?|MM?M?M?|yy?y?y?|hh?|HH?|mm?|ss?|tt?|zz?z?)/),function(fmt){if(g[fmt]){return g[fmt];}else{throw $D.Parsing.Exception(fmt);}}),_.process(_.rtoken(/^[^dMyhHmstz]+/),function(s){return _.ignore(_.stoken(s));}))),function(rules){return _.process(_.each.apply(null,rules),t.finishExact);});var _F={};var _get=function(f){return _F[f]=(_F[f]||g.format(f)[0]);};g.formats=function(fx){if(fx instanceof Array){var rx=[];for(var i=0;i<fx.length;i++){rx.push(_get(fx[i]));}
return _.any.apply(null,rx);}else{return _get(fx);}};g._formats=g.formats(["\"yyyy-MM-ddTHH:mm:ssZ\"","yyyy-MM-ddTHH:mm:ssZ","yyyy-MM-ddTHH:mm:ssz","yyyy-MM-ddTHH:mm:ss","yyyy-MM-ddTHH:mmZ","yyyy-MM-ddTHH:mmz","yyyy-MM-ddTHH:mm","ddd, MMM dd, yyyy H:mm:ss tt","ddd MMM d yyyy HH:mm:ss zzz","MMddyyyy","ddMMyyyy","Mddyyyy","ddMyyyy","Mdyyyy","dMyyyy","yyyy","Mdyy","dMyy","d"]);g._start=_.process(_.set([g.date,g.time,g.expression],g.generalDelimiter,g.whiteSpace),t.finish);g.start=function(s){try{var r=g._formats.call({},s);if(r[1].length===0){return r;}}catch(e){}
return g._start.call({},s);};$D._parse=$D.parse;$D.parse=function(s){var r=null;if(!s){return null;}
if(s instanceof Date){return s;}
try{r=$D.Grammar.start.call({},s.replace(/^\s*(\S*(\s+\S+)*)\s*$/,"$1"));}catch(e){return null;}
return((r[1].length===0)?r[0]:null);};$D.getParseFunction=function(fx){var fn=$D.Grammar.formats(fx);return function(s){var r=null;try{r=fn.call({},s);}catch(e){return null;}
return((r[1].length===0)?r[0]:null);};};$D.parseExact=function(s,fx){return $D.getParseFunction(fx)(s);};}());


/*
Author: 		Brett
File name: 		guxRadioButtons.js
Description: 	Function to replace radio buttons with GUX-style buttons
Dependencies: 	jQuery 
Usage: 			HTML...
				<input class="usage first replace-radio-btn" type="radio" id="usage-personal" name="usage" value="p" checked />
				<label class="token" for="usage-personal" title="Personal">
					<a class="button">Residential</a>
				</label>

				JS Function to run...
				guxApp.radioButtons.init();
*/
var guxApp = guxApp || {};

(function($){
	guxApp.radioButtons = {
		init: function(){
			setTimeout(function() {
				$('.replace-radio-btn').each(function() {
					if($(this).is(':checked')) { 
						$(this).next().find('.button').addClass('active');
					}

				});
			},100);

			$('.replace-radio-btn').next().on('click', function() {
				$('.replace-radio-btn').next().find('.button').removeClass('active');
				$('.replace-radio-btn').attr('checked', false);

				$(this).prev().attr('checked', true);
				$(this).find('.button').addClass('active');
			});
		}
	};

})(jQuery);


//Ford chooses to use jQuery tmpl and its associated components under the MIT License.
(function(a){var r=a.fn.domManip,d="_tmplitem",q=/^[^<]*(<[\w\W]+>)[^>]*$|\{\{\! /,b={},f={},e,p={key:0,data:{}},h=0,c=0,l=[];function g(e,d,g,i){var c={data:i||(d?d.data:{}),_wrap:d?d._wrap:null,tmpl:null,parent:d||null,nodes:[],calls:u,nest:w,wrap:x,html:v,update:t};e&&a.extend(c,e,{nodes:[],parent:d});if(g){c.tmpl=g;c._ctnt=c._ctnt||c.tmpl(a,c);c.key=++h;(l.length?f:b)[h]=c}return c}a.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(f,d){a.fn[f]=function(n){var g=[],i=a(n),k,h,m,l,j=this.length===1&&this[0].parentNode;e=b||{};if(j&&j.nodeType===11&&j.childNodes.length===1&&i.length===1){i[d](this[0]);g=this}else{for(h=0,m=i.length;h<m;h++){c=h;k=(h>0?this.clone(true):this).get();a.fn[d].apply(a(i[h]),k);g=g.concat(k)}c=0;g=this.pushStack(g,f,i.selector)}l=e;e=null;a.tmpl.complete(l);return g}});a.fn.extend({tmpl:function(d,c,b){return a.tmpl(this[0],d,c,b)},tmplItem:function(){return a.tmplItem(this[0])},template:function(b){return a.template(b,this[0])},domManip:function(d,l,j){if(d[0]&&d[0].nodeType){var f=a.makeArray(arguments),g=d.length,i=0,h;while(i<g&&!(h=a.data(d[i++],"tmplItem")));if(g>1)f[0]=[a.makeArray(d)];if(h&&c)f[2]=function(b){a.tmpl.afterManip(this,b,j)};r.apply(this,f)}else r.apply(this,arguments);c=0;!e&&a.tmpl.complete(b);return this}});a.extend({tmpl:function(d,h,e,c){var j,k=!c;if(k){c=p;d=a.template[d]||a.template(null,d);f={}}else if(!d){d=c.tmpl;b[c.key]=c;c.nodes=[];c.wrapped&&n(c,c.wrapped);return a(i(c,null,c.tmpl(a,c)))}if(!d)return[];if(typeof h==="function")h=h.call(c||{});e&&e.wrapped&&n(e,e.wrapped);j=a.isArray(h)?a.map(h,function(a){return a?g(e,c,d,a):null}):[g(e,c,d,h)];return k?a(i(c,null,j)):j},tmplItem:function(b){var c;if(b instanceof a)b=b[0];while(b&&b.nodeType===1&&!(c=a.data(b,"tmplItem"))&&(b=b.parentNode));return c||p},template:function(c,b){if(b){if(typeof b==="string")b=o(b);else if(b instanceof a)b=b[0]||{};if(b.nodeType)b=a.data(b,"tmpl")||a.data(b,"tmpl",o(b.innerHTML));return typeof c==="string"?(a.template[c]=b):b}return c?typeof c!=="string"?a.template(null,c):a.template[c]||a.template(null,q.test(c)?c:a(c)):null},encode:function(a){return(""+a).split("<").join("&lt;").split(">").join("&gt;").split('"').join("&#34;").split("'").join("&#39;")}});a.extend(a.tmpl,{tag:{tmpl:{_default:{$2:"null"},open:"if($notnull_1){_=_.concat($item.nest($1,$2));}"},wrap:{_default:{$2:"null"},open:"$item.calls(_,$1,$2);_=[];",close:"call=$item.calls();_=call._.concat($item.wrap(call,_));"},each:{_default:{$2:"$index, $value"},open:"if($notnull_1){$.each($1a,function($2){with(this){",close:"}});}"},"if":{open:"if(($notnull_1) && $1a){",close:"}"},"else":{_default:{$1:"true"},open:"}else if(($notnull_1) && $1a){"},html:{open:"if($notnull_1){_.push($1a);}"},"=":{_default:{$1:"$data"},open:"if($notnull_1){_.push($.encode($1a));}"},"!":{open:""}},complete:function(){b={}},afterManip:function(f,b,d){var e=b.nodeType===11?a.makeArray(b.childNodes):b.nodeType===1?[b]:[];d.call(f,b);m(e);c++}});function i(e,g,f){var b,c=f?a.map(f,function(a){return typeof a==="string"?e.key?a.replace(/(<\w+)(?=[\s>])(?![^>]*_tmplitem)([^>]*)/g,"$1 "+d+'="'+e.key+'" $2'):a:i(a,e,a._ctnt)}):e;if(g)return c;c=c.join("");c.replace(/^\s*([^<\s][^<]*)?(<[\w\W]+>)([^>]*[^>\s])?\s*$/,function(f,c,e,d){b=a(e).get();m(b);if(c)b=j(c).concat(b);if(d)b=b.concat(j(d))});return b?b:j(c)}function j(c){var b=document.createElement("div");b.innerHTML=c;return a.makeArray(b.childNodes)}function o(b){return new Function("jQuery","$item","var $=jQuery,call,_=[],$data=$item.data;with($data){_.push('"+a.trim(b).replace(/([\\'])/g,"\\$1").replace(/[\r\t\n]/g," ").replace(/\$\{([^\}]*)\}/g,"{{= $1}}").replace(/\{\{(\/?)(\w+|.)(?:\(((?:[^\}]|\}(?!\}))*?)?\))?(?:\s+(.*?)?)?(\(((?:[^\}]|\}(?!\}))*?)\))?\s*\}\}/g,function(m,l,j,d,b,c,e){var i=a.tmpl.tag[j],h,f,g;h=i._default||[];if(c&&!/\w$/.test(b)){b+=c;c=""}if(b){b=k(b);e=e?","+k(e)+")":c?")":"";f=c?b.indexOf(".")>-1?b+c:"("+b+").call($item"+e:b;g=c?f:"(typeof("+b+")==='function'?("+b+").call($item):("+b+"))"}else g=f=h.$1||"null";d=k(d);return"');"+i[l?"close":"open"].split("$notnull_1").join(b?"typeof("+b+")!=='undefined' && ("+b+")!=null":"true").split("$1a").join(g).split("$1").join(f).split("$2").join(d?d.replace(/\s*([^\(]+)\s*(\((.*?)\))?/g,function(d,c,b,a){a=a?","+a+")":b?")":"";return a?"("+c+").call($item"+a:d}):h.$2||"")+"_.push('"})+"');}return _;")}function n(c,b){c._wrap=i(c,true,a.isArray(b)?b:[q.test(b)?b:a(b).html()]).join("")}function k(a){return a?a.replace(/\\'/g,"'").replace(/\\\\/g,"\\"):null}function s(b){var a=document.createElement("div");a.appendChild(b.cloneNode(true));return a.innerHTML}function m(o){var n="_"+c,k,j,l={},e,p,i;for(e=0,p=o.length;e<p;e++){if((k=o[e]).nodeType!==1)continue;j=k.getElementsByTagName("*");for(i=j.length-1;i>=0;i--)m(j[i]);m(k)}function m(j){var p,i=j,k,e,m;if(m=j.getAttribute(d)){while(i.parentNode&&(i=i.parentNode).nodeType===1&&!(p=i.getAttribute(d)));if(p!==m){i=i.parentNode?i.nodeType===11?0:i.getAttribute(d)||0:0;if(!(e=b[m])){e=f[m];e=g(e,b[i]||f[i],null,true);e.key=++h;b[h]=e}c&&o(m)}j.removeAttribute(d)}else if(c&&(e=a.data(j,"tmplItem"))){o(e.key);b[e.key]=e;i=a.data(j.parentNode,"tmplItem");i=i?i.key:0}if(e){k=e;while(k&&k.key!=i){k.nodes.push(j);k=k.parent}delete e._ctnt;delete e._wrap;a.data(j,"tmplItem",e)}function o(a){a=a+n;e=l[a]=l[a]||g(e,b[e.parent.key+n]||e.parent,null,true)}}}function u(a,d,c,b){if(!a)return l.pop();l.push({_:a,tmpl:d,item:this,data:c,options:b})}function w(d,c,b){return a.tmpl(a.template(d),c,b,this)}function x(b,d){var c=b.options||{};c.wrapped=d;return a.tmpl(a.template(b.tmpl),b.data,c,b.item)}function v(d,c){var b=this._wrap;return a.map(a(a.isArray(b)?b.join(""):b).filter(d||"*"),function(a){return c?a.innerText||a.textContent:a.outerHTML||s(a)})}function t(){var b=this.nodes;a.tmpl(null,null,null,this).insertBefore(b[0]);a(b).remove()}})(jQuery);


/**
 * @author: szabetian
 * @project: polk
 * @description: helper methods for ND.calcprice
 * 
 * 
 * getprice.js (ND.calcPrice) uses methods in this file to perform various tasks
 * 
 */

ND.polk = {
	/**
	 * Updates the region in the DOM where vehicle prices are displayed.
	 * That subtle color fadding when a panel updates.
	 * 
	 * @param elem
	 * 
	 */
	showChangeVisually : function(elem) {
//			console.logpubsub("showChangeVisually()");
		
		var time = 1250,
			bgColor = ['#cbe6f2', 'transparent' ];
		
		//Run the animation, start with a solid background colour
		elem.css('backgroundColor', bgColor[0] )
			.delay(time)
			.animate({
					'backgroundColor' : bgColor[1]								
				}, time,  function() {
					$(this).css('backgroundColor', 'transparent');
				});		
	},
	
	bindAdditionalListeners: function() {},
	
	/**
	 * Placeholder callback function after postcode is changed
	 * Do not delete
	 */
	templateUpdated: function() {
		
	}
};


// Requires json2.js 
/*globals window, document, jQuery, ND, SiteConf */
(function($, undefined){

	var // Conf
		config = {},
		
		// Pubsub
		suffix = ".calculateprice.dfy",
		
		// Module exports 
		exports = {},
		exportsAPI = {},
		
		//not to be exposed
		internalAPI = {overlayLaunched : false};
		

		/*
		 * Object: priceUpdater
		 * 
		 * Managers the derivatives on the page that need a price.
		 *
		 * <div class="derivative-price {'derivativeid':'123412341234'}">
		 * 		<span class="price">$$$$$</span>
		 * </div>
		 */
		priceUpdater = exports.PriceUpdater = (function(){

		    var derivatives,
				defaults = {
				    priceClass: '.price',
				    hotDealClass: '.latest-offer',
				    loanCalcClass:'.loan-calc',
				    priceContainer: ".derivative-price",
				    tmpl: "#tmpl-price-main",
				    hotDealTmpl: '#tmpl-price-hotdeal-main',
				    noPriceTmpl: "#tmpl-noprice-main"
				},
                modelId = null;
			
			//Private Function
			//Store the derivative DOM elements for later recall
			function mapDerivatives( elements, priceHTML ){
			    derivatives = {};
				$( elements ).each(function( i, e ){
					var elem = $(e),
						metadata = elem.data('derivativeid');
					    
					//Read meta data and use derivativeid as key for storage
					if( metadata ) {
						derivatives[metadata] = elem;
					}
					if (!modelId && elem.data('modelid')) {
					    modelId = elem.data('modelid');
					}
				});
				return derivatives;
			}
			
			function getPriceFormatter(callback) {
			    if (config.priceformatter !== null) {
			        if (typeof callback !== 'undefined') {

			            if ($.isFunction(callback)) {
			                callback();
			            }
			        }
			    }
			    else {
			        priceUserDataManager.initPriceFormatter();
			        if ($.isFunction(callback)) {
			            callback();
			        }
			    }
			}

			//Return Obj with public methods
			return {
				init:function(elements, options){
					var that = this; 
					
					this.options = options = $.extend({}, defaults, options);
					//Store the derivative DOM elements for later recall
					mapDerivatives(this.options.priceContainer);

					//Compile main price template
					this.tmpl = $(this.options.tmpl).template();
					var $hotdealTemplate = $(this.options.hotDealTmpl);
					if ($hotdealTemplate.length > 0) {
						this.hotDealTmpl = $(this.options.hotDealTmpl).template();
					}
					//Listen to change postcode event
					$.subscribe('userchange' + suffix, function(){
						//Notify the price updater that there is impending change to prices.
						that.notifyChange();
					});
					
				},
				list: function(){
					var ret = [];
					//Create a arr of derivative ids (posted to the server web service eventually)
					$.each(derivatives, function(key, obj){
						ret.push(key);
					});
					return ret;
				},
				update:function(prices, visual){
//					console.log('priceUpdater.update()');
					var that = this;
					
					visual = visual === undefined || visual;
					
					if(derivatives) {
						
						//Just in case
						that.notifyChange();
						
					    //Loop prices returned from web service
						getPriceFormatter(function () {
						    $.each(prices, function (id, derivative) {
						        var housing = derivatives[id],
                                    prevPrice,
                                    hotDealLocationToAppend,
                                    render;

						        //Ensure the id from the prices array matches an id in the derivatives DOM storage 
						        //and that there is a displayPrice to inject
						        if (housing && derivative.displayPrice) {

						            prevPrice = housing.find(that.options.priceClass);

						            //Format price for each derivative for GUX
						            if (typeof guxApp !== 'undefined') {
						            	derivative.price = guxApp.priceFormatter.format(derivative.price);
						            }

						            //Render the template with the price data
						            render = $.tmpl(that.tmpl, derivative);


						            //for mobile we need to render the dom differently.
						            if (typeof ND.polk.renderDerivative !== 'undefined') {

						                var $liParent = housing.parents('li').filter(':visible');
						                if ($liParent != null && $liParent.length > 0) {
						                    hotDealLocationToAppend = $($liParent[0]);
						                } else {
						                    hotDealLocationToAppend = housing.parent().parent();
						                }
						                renderHotdeals = $.tmpl(that.hotDealTmpl, derivative);
						                ND.polk.renderDerivative(housing, prevPrice, hotDealLocationToAppend, render, renderHotdeals, that.options.hotDealClass);

						                if (typeof ND.polk.registerLoanBtn !== 'undefined') {
						                    ND.polk.registerLoanBtn(hotDealLocationToAppend, derivative.price, config.priceformatter, priceUserDataManager.locationValue());
						                }

						            } else {

						                //Either replace or inject a new price
						                if (prevPrice.size()) {
						                    prevPrice.replaceWith(render);
						                } else {
						                    if (housing.find('style').length>0) {
						                        housing.find('style').remove();
						                    }
						                    if (housing.find(that.options.loanCalcClass).length > 0) {
						                        housing.find(that.options.loanCalcClass).parent().remove();
						                    }
						                    housing.prepend(render);
						                }

						                $(that.options.loanCalcClass, housing).off('click').on('click', function (e) {
						                    e.preventDefault();
						                    $(this).loanCalculatorOverlay({
						                        price: derivative.price,
						                        priceformatter: config.priceformatter,
						                        location: priceUserDataManager.locationValue()
						                    });
						                });
						            }

						            if (visual) {
						                //console.log('init-> ND.polk.showChangeVisually');
						                ND.polk.showChangeVisually(housing.find(that.options.priceClass));
						            }
						            
						        }
						    });

						    if ($(that.options.noPriceTmpl).length) {
						        var nopricerender = $(that.options.noPriceTmpl).html();
						        $('.body.derivative-price').each(function (i, de) {
						            if ($(de).find('.price').length === 0) {
						                $(de).prepend(nopricerender);
						            }
						        });
						    }
							//latest offer img be publishable in model enhance detail page
							var container = $(".model-enhance .attribute-bar"),
									urls=$('#price-urls').embeddedData();
							if(container.length&&$("a.offers", container).length&&urls&&urls['latest-offer-backimg']) {
								$("a.offers", container).attr("style","background-image:url("+urls['latest-offer-backimg']+")");							
							}
							//extent model content if hot deal exists
							if($(".model-content.body.derivative-price").length && $(".model-content.body.derivative-price a.offers").length) {
								$(".model-content.body.derivative-price").addClass("extend");
							}

						});
						
					} else {
						$.publish('error' + suffix, "ND.PriceUpdater: Could not update Dom");
					}			
				},
				notifyChange: function() {
					var that = this;
					
					if( derivatives ) {
						//OMG get them prices down incase there is a timeout or an error or sometrihngf.asd fasdf !!!!! ARGH!.
					    $.each(derivatives, function (id, housing) {
					        if (typeof ND.polk.notifyChange !== 'undefined') {
					            ND.polk.notifyChange(housing);
					        }
					        else {
					            housing.find(that.options.priceClass).remove();
					            housing.find(that.options.loanCalcClass).parent().remove();
					        }
						});
					}
				},
				modelId: function () {
				    return modelId;
				}
			};
		}()),
		
		/*
		 * Object: priceUserDataManager
		 * 
		 * Managers the overlay and events around the user entering there postcode to get prices.
		 *
		 * <div class="derivative-price {'derivativeid':'123412341234'}">
		 * 		<span class="price">$$$$$</span>
		 * </div>
		 */
		priceUserDataManager = exports.userDataManager = (function(){
			
			//Private Variables
			var userData,
				defaults,			
				derivativeList,
                regionalPriceData,
				formError,
				$form = null,
				defaultFormErrorMsg = null,
				fromCookie;
		
			//Module defaults
			defaults = {
			    formid: '#calc-price-user',
			    regionformid:'#regional-price-user',
				needprice:'.need-price',
				getpostcodeusage:'.get-postcode-usage',
				tmpl:'#tmpl-price-links'
			};
			
			//Private Functions
			
			//Get Prices from web service
			function getPrices() {
				var payload = $.extend( userData, { "derivatives": derivativeList } );
				$.publish('userchange' + suffix, { "payload": payload });				
			}
			
			//Check for persistant user userData, this function is only used on page Load.
			function checkData() {
				userData = loadData();
				
				if (userData && (userData.postcode || userData.pricezone) && userData.usage) {
					fromCookie = true;
					getPrices();
				} else {
					userData = null;
				}
				return userData;
			}

			//Clear for persistant user userData (usaually because of an error)
			function clearData() {
				$.publish( "shopping.pref.clear" );
				userData = null;
			}
			
			function storeData() {
				$.publish( "shopping.pref.save", userData );
			}
			
			function loadData() {
				function userDataPubSubHandler(e, retrieveData) {
					userData = retrieveData;
				}
				// Right now
				$.publish( "shopping.pref.retrieve", userDataPubSubHandler); 
				
				return userData;
			}
			
			//Function to get and set the user userData
			function getterSetterData(postcode, usage, usageLabel, pricezone,pricezoneLabel,priceformatData) {
				if(arguments.length >= 2) {
					userData = {
						"postcode":postcode,
						"usage":usage,
						"usageLabel": usageLabel,
						"pricezone": pricezone,
						"pricezoneLabel": pricezoneLabel,
						"priceformatData": priceformatData
					};
				}
				return userData;
			}
			
			function overlaySuccessPopulateForm(options) {
			    var form = $(options.formid);
			    if (config.isPricezone) {
			        if (!regionalPriceData) {
			            var regiondata = $('#regional-price-json');
			            if (regiondata.length > 0) {
			                regionalPriceData = regiondata.embeddedData();
			            }
			        }
			        //console.log(regionalPriceData);

				    if (form.size() && typeof userData !== 'undefined' && userData != null &&
                        userData.pricezone != null && userData.pricezone !== '' && userData.usage != null && userData.usage !== '') {


				        //form.find('select[name=pricezone]').val(userData.pricezoneLabel).select();
				        for (var regionName in regionalPriceData) {
				            if (regionName && regionalPriceData[regionName]) {
				                var gotRegion = false;
				                $.each(regionalPriceData[regionName], function (i, region) {
				                    if (region.id === userData.pricezone) {
				                        form.find('select[name=pricezone]').val(regionName).select();
				                        gotRegion = true;
				                        return false;
				                    }
				                });
				                if (gotRegion) {
				                    break;
				                }
				            }
				        }
				        
				        var $usage = form.find('input[name=usage]');
				        if ($usage.length) {
				            $usage.filter('[value=' + userData.usage + ']')[0].checked = true;
				        }

				        if ($.mobile) {
				            form.find('select[name=pricezone]').selectmenu('refresh');
				            $usage.checkboxradio('refresh');
				        }
				    }				    
				}
				else {				    
				    if (form.size() && typeof userData !== 'undefined' && userData != null &&
                        userData.postcode != null && userData.postcode !== '' && userData.usage != null && userData.usage !== '') {
				        form.find('input[name=postcode]').val(userData.postcode).select();
				        var $usage = form.find('input[name=usage]');
				        if ($usage.length) {
				            $usage.filter('[value=' + userData.usage + ']')[0].checked = true;
				        }


				    }
				}
			}
            			
			//Function to get and set the user userData
			function asyncUserData(options, change) {
				var userDataChangeEvent = 'userchangesuccess' + suffix,
					userCancelOverlay = 'overlay.usercancel',
					callbacks = [],
					doneCallback;						
				
				//This function is called during events other than page load.
				fromCookie = false;
				
				//Special for Flash
				if( $.isPlainObject( options ) ) {  
					
					if( $.isFunction( options.complete ) ) {
						callbacks.push(options.complete);					
					}
					
					//isFlash implied
					if( options.flashid ) {
										
						callbacks.push(function() {
							//Line of code mutated original from jQuery.swfobject
							var toSend, elem = $('#'+options.flashid).find('object').andSelf().filter('object').get(0);
							
							try {
								//Use External JavaScript API which should be exposed by the Flash Application
								toSend = $.extend({}, userData);
								if( toSend.derivatives ) {
									delete toSend.derivatives;
								}
								elem.message('postcode', JSON.stringify(toSend));							
							} catch( e ) {
								//console.log( "Error messaging flash id = " + options.flashid );						
							}
						});
						
					}
				}

				if ((config.formURL || config.regionformURL) && (change || !userData)) {
					
					//Complete
					doneCallback = function() {
						$.unsubscribe(userDataChangeEvent, doneCallback);
						$.unsubscribe(userCancelOverlay, doneCallback);
						$.each(callbacks, function(i, fn) {
							fn.apply(fn, [loadData()]);
						});
					};				
					$.subscribe(userDataChangeEvent, doneCallback);
					$.subscribe(userCancelOverlay, doneCallback);
						
					//Launch overlay for GUX
					if (typeof guxApp !== 'undefined') {
						$.publish('overlay.launchgux', {
						    url: config.isPricezone?config.regionformURL:config.formURL,
							positionType:'window',
							name: "POLK Select Postcode", 
							success : function() {
								internalAPI.overlayLaunched = true;
							}
						});
					} else {
						$.publish('overlay.launch', {
						    url: config.isPricezone?config.regionformURL:config.formURL,
							positionType:'window',
							name: "POLK Select Postcode", 
							success : function() {
								internalAPI.overlayLaunched = true;
							}
						});
					}
					
				} else {
					$.each(callbacks, function(i, fn) {
						fn.apply(fn, [loadData()]);
					});
				}
				
			}
			
			/* Expose API method to Flash
			 * 
			 * Default usage 
			 * requestChangePriceUserData( {
			 * 		flashid:'flashid',
			 * 		complete: function() { .. }
			 * );
			 * 
			 * From Flash
			 * requestChangePriceUserData( 'flashid', true, function() { .. })
			 */
			exportsAPI.requestPriceUserData = function(optionsOrString, isFlash, complete, change) {
				
				if( isFlash && typeof optionsOrString == "string" ) {
					optionsOrString = {"flashid":optionsOrString};
					optionsOrString.complete = complete;
				}
				
				asyncUserData(optionsOrString, change);
			};

			/*
			 * Add some curry, Expose another API method to Flash
			 */
			exportsAPI.requestChangePriceUserData = function(optionsOrString, isFlash, complete) {
				exportsAPI.requestPriceUserData(optionsOrString, isFlash, complete, true);
			};
			
			/*
			 * Sohrab: Add some soup, Expose another API method for build and price
			 * 
			 * must pass a callback function as options.complete to handle result
			 */
			exportsAPI.requestChangePriceBuildAndPrice = function(options, change) {
				exportsAPI.isBuildAndPrice = ND.API.isBuildAndPrice = true;
				config.isPricezone=false;
				asyncUserData(options, change);
			};
			
			/*
			 * Sohrab: Ask the service to read the cookie and return the values
			 * 
			 */
			exportsAPI.requestCookieValuesBuildAndPrice = function(options) {
				if (options.complete) {
					$.publish( "shopping.pref.retrieve", function(e, userData) {
						options.complete.apply(options.complete, [userData]);
					}); 
				}
			};
			
			function listenForm(form){
				
				ND.polk.bindAdditionalListeners(form);
				
				//Listen for form events
				$( document ).off( 'submit', form).on( 'submit', form,  function(e) {

					var $form = $(this), postcode, usage, jUsage, usageLabel, pricezone, pricezoneLabel, pricezoneValue;
					
					working = false;
					e.preventDefault();
					//console.log('listenForm-> form submit');
					//grab local 
					postcode = $form.find('[name=postcode]').val();
					jUsage = $form.find('[name=usage]:checked');
					usage = jUsage.val();
					pricezoneValue = $form.find('[name=pricezone]').val();
					pricezoneLabel = $form.find('[name=pricezone]').find('option:selected').text();

					
				    //Validate Form
					if (config.isPricezone) {
					    if ($.trim(pricezoneValue).length > 0 && usage && regionalPriceData && regionalPriceData[pricezoneValue]) {
					        var priceformatData;
					        $.each(regionalPriceData[pricezoneValue], function (i, region) {
					            if (region.type === usage) {
					                pricezone = region.id;
					                config.priceformatter = ND.PriceFormatter;
					                config.priceformatter.initialise({
					                    data: region.priceFormat,
					                    formatString: region.currencySymbol,
					                    centsSeparator: region.monetaryDecimalSeparator,
					                    thousandsSeparator: region.groupingSeparator
					                });
					                priceformatData = region.priceFormat + "|" + region.currencySymbol + "|" + region.monetaryDecimalSeparator + "|" + region.groupingSeparator;
					                return false;
					            }
					        });
					        usageLabel = $("[for=" + jUsage.attr("id") + "]").attr('title');
					        getterSetterData(postcode, usage, usageLabel, pricezone, pricezoneLabel,priceformatData);
					        getPrices();
					    } else {
					        $.publish('usererror' + suffix);
					    }
					}
					else {
					    if ($.trim(postcode).length === 4 && !isNaN(postcode) && usage) {


					        usageLabel = $("[for=" + jUsage.attr("id") + "]").attr('title');

					        getterSetterData(postcode, usage, usageLabel);
					        getPrices();

					    } else {
					        $.publish('usererror' + suffix);
					    }
					}


					return false;
				});
				
				
			}
			
			
			//Clear for persistant user userData on error
			//$.subscribe('error' + suffix, clearData);
			
			
			//Return Obj with public methods
			return {
				init:function(dlist, options){
					var that = this;
					
					userData = null;
				
					that.options = options = $.extend({}, defaults, options, { formid: config.isPricezone ? defaults.regionformid : defaults.formid });
					
					//The housing for Need Price
					that.needprice = $(options.needprice);
					
					//Setup click events
					that.needprice.on( 'click', options.getpostcodeusage, function(e){
						e.preventDefault();
						asyncUserData(null, true);
					});
					
					//Store derivative array
					derivativeList = dlist;
					
					
					//Enable listening to the form submit events
					listenForm( options.formid );
					
					//Compile main price template
					that.tmpl = $(options.tmpl).template();

					//Listen to change postcode event
					$.subscribe('userchange' + suffix, function(event, data){
						//Notify the price updater that there is impending change to prices.
//						console.log('load in progress');
//						that.update({
//							loading:'true'
//						});
					});
			
						
					//Listening for the if the form is existing, the data will popup
					$.subscribe('overlay.success', function(){
						//overlaySuccessPopulateForm(options.formid);
						overlaySuccessPopulateForm(options);
						ND.polk.bindAdditionalListeners(options.formid);
					});
					
					//used for mobile to unsubscribe events and remove listeners
					$.subscribe('destroy' + suffix, function() {
						//console.log('ND.CalcPrice.destroy');
						for( var channel in that.pubsub ) {
							$.unsubscribe( channel + suffix, that.pubsub[channel] );
						}
						
						$( document ).off('submit', $(that.options.formid));
						that.needprice.off( 'click', that.options.getpostcodeusage);
						that.needprice.empty();
						
					});
					
					
					if (derivativeList.length === 0) {
						return;
					}
					//Check if the page load data exists
					if(!checkData()) {
						//There was no data so initialise the "Want to see prices"
						that.update();
					}

			
				},
				initPriceFormatter: function () {
				    if (userData && userData.priceformatData && config && !config.priceformatter && ND.PriceFormatter) {
				        var pfdata = userData.priceformatData.split('|');
				        if (pfdata.length === 4) {
				            config.priceformatter = ND.PriceFormatter;
				            config.priceformatter.initialise({
				                data: pfdata[0],
				                formatString: pfdata[1],
				                centsSeparator: pfdata[2],
				                thousandsSeparator: pfdata[3]
				            });
				        }
				    }
				},

				update:function(otherData, visual){
//					console.log('priceUserDataManager.update()');
					var that = this, render,
						//Use the error data or the postcode data in the tmpl
						tmplData = otherData || userData;
					
					if( that.needprice ) {
						
						//Render the tempalte with user data
						render = $.tmpl(that.tmpl, tmplData);
						
						if( that.previousLinks && that.previousLinks.length ) {

							//Replace It (had an issue with $.fn.replaceWith function)
							that.previousLinks.remove();
							that.needprice.append(render);
							that.previousLinks = render;
							
						} else {
							
							//Inject a new element
							if (typeof guxApp !== 'undefined') {
								that.needprice.html(render);
							} else {
								that.needprice.append(render);
							}
							that.previousLinks = render;
							
						}
						
						if( visual && !fromCookie) {
							// Was getting the following error. "Error: uncaught exception: [Exception... "Could not convert JavaScript argument arg 0 [nsIDOMViewCSS.getComputedStyle]"  nsresult: "0x80570009 (NS_ERROR_XPC_BAD_CONVERT_JS)"  location: "JS frame :: http://ftd-trunk-carve.local/themes/ftd/js/live/dev.debug.js :: anonymous :: line 5491"  data: no]"
							// So I get the element in a new jQuery selection
							ND.polk.showChangeVisually($(that.previousLinks.get(0)));
						}
						
						ND.polk.templateUpdated(that.needprice);
					}				
				},
				visualUpdate: function( otherData ) {
//					console.log('priceUserDataManager.visualUpdate()');
					this.update( otherData, true );
				},
				fromCookie: function() {
					return !!fromCookie;
				},
				//error validation
				displayMsg: function(msg) {
					$form = $(priceUserDataManager.options.formid);
					formError = $form.find('.error');
					

					
					
					if (defaultFormErrorMsg == null) {
						defaultFormErrorMsg = $form.find('#standard-error').text();
					}
					formError.text(msg ? msg : defaultFormErrorMsg);
					formError.filter(":hidden").slideDown('fast');
				},
				loading: function(show) {
					$form = $(priceUserDataManager.options.formid);
					if (show) {
						$form.find('.error').hide();
						$form.find('.loading').filter(":hidden").slideDown('fast');
						$form.find('button[type=submit]').attr('disabled', true);
					} else {
						$form.find('.loading').hide();
						$form.find('button[type=submit]').removeAttr('disabled');
					}
					
				},
				locationValue: function () {
				    if (userData) {
				        if (config.isPricezone) {
				            return userData.pricezoneLabel + ' ' + userData.usageLabel;
				        }
				        else {
				            return userData.postcode + ' ' + userData.usageLabel;
				        }
				    }
				    return '';
				},
				getData: loadData,
				setData: storeData
			};
		
		}()),	// end priceUserDataManager
		
	
		/*
		 * Global Pubsub channels for this module
		 */
		pubsub = {
		
			/* Subscribe
			 * @input Object - {"postcode": "3000","usage": "p"}
			 * eg. $.publish('userchange.calculateprice.dfy', {"postcode": "3000","usage": "p"});
			 */	
			userchange: function(event, data){
				
				//Integritry Check
			    if (!config.dataURL && !config.isPricezone) {
					$.publish('error' + suffix, 'There was a problem.');
					//console.log("Missing config.dataURL");
					return;
				}
				
				
				function error( text ) {
					$.publish('change' + suffix, {error:true, errorMessage:'System error.'});
					$.publish('error' + suffix, text);
				}

				
				if( data && data.payload ) {
					priceUserDataManager.loading(true);
					//If there is no derivatives on the page. Skip the AJAX call
//					if ( data.payload.derivatives && data.payload.derivatives.length ) {
				    //We have enough information to calculate the prices

					if (config.isPricezone) {
					    
					    if ($('#rest-services').length > 0) {
					        var dataURL = $('#rest-services').embeddedData()['pricezone.derivatives'];
					        if (dataURL) {
					            $.ajax({
					                type: 'GET',
					                url: dataURL.replace('{site}', config.site).replace('{pricezoneId}', data.payload.pricezone).replace('{modelId}', priceUpdater.modelId()),
					                dataType: 'json',
					                complete: function (xhr, text) {
					                    $.publish('get' + suffix, text);
					                },
					                success: function (data) {
					                    var results = {};
					                    if (data && data.length > 0) {
					                        if (!config.priceformatter) {
					                            priceUserDataManager.initPriceFormatter();
					                        }
					                        var list = $.map(data, function (d) {
					                            if (!d.displayPrice) {
					                                if (config.priceformatter) {
					                                    d.displayPrice = config.priceformatter.format(d.price);
					                                }
					                            }
					                            return d;
					                        });
					                        results.error = false;
					                        results.derivatives = list;
					                    }
					                    else {
					                        results.error = true;
					                        results.errorMessage = $('form.calc-price-user p.error').html();
					                    }
					                    $.publish('change' + suffix, results);
					                },
					                error: function (xhr, text) {
					                    error(text);
					                }
					            });
					        }
					    }
					}
					else {

					    $.ajax({
					        type: 'POST',
					        url: config.dataURL,
					        cache: false,
					        headers: {
						        'Cache-Control': 'no-cache'
						    },
					        data: {
					            "data": JSON.stringify(data.payload)
					        },
					        complete: function (xhr, text) {
					            $.publish('get' + suffix, text);
					        },
					        success: function (data) {
					            $.publish('change' + suffix, data);
					        },
					        error: function (xhr, text) {
					            error(text);
					        },
					        dataType: 'json'
					    });
					}


//					} else {
//						$.publish('change' + suffix);
//					}
			
				} else {
					error("no payload");
				}
			},
			
			/*
			 * Subscribe Price changes
			 */
			change: function(event, data){
				data = data || {};
				priceUserDataManager.loading(false);
				//Data Integrity check
				if( !data.error ) {
					
					$.publish('userchangesuccess' + suffix, data);

					//hide the overlay only if polk overlay is open.
					if (internalAPI.overlayLaunched) {
						//Hide overlay for GUX
						if (typeof guxApp !== 'undefined') {
							$.publish('overlay.hidegux');
						} else {
							$.publish('overlay.hide');
						}
					}
					
				} else {
					
					//Update with the error data (Normalise the error).
					//priceUserDataManager.visualUpdate({error:data.errorMessage});
					//priceUpdater.notifyChange();
					$.publish('usererror' + suffix, data.errorMessage || 'Error');
				}
				
			},
			
			userchangesuccess: function(event, data) {
				//Normalise the prices object for ND.priceUpdater
				var prices = {};
				$.each(data.derivatives || [], function(i, obj){
					prices[obj.id] = obj;
				});
				
				//Update the disclaimer links
				priceUserDataManager.visualUpdate();
				
				//Update the prices on the page
				priceUpdater.update(prices, !priceUserDataManager.fromCookie());
				priceUserDataManager.setData();
			},
			
			usererror: function(event, data){
				//console.log('usererror: ' + data);
				priceUserDataManager.displayMsg(data );
				
			},
			
			loading: function(event, data) {
				//console.log('loading: show: ' + data);
				priceUserDataManager.loading(data);
			}
			
		};			

	// Initalise pubsub!
	for( var channel in pubsub ) {
		$.subscribe( channel + suffix, pubsub[channel] );
	}
	
	// Dynamic confi URLs
	exports.conf = function(obj) {
		var urls = obj || $('#price-urls').embeddedData();
		config.dataURL = urls['xhr-calcprice-data'] || config.dataURL;
		config.formURL = urls['xhr-calcprice-form'] || config.formURL;

		config.regionformURL = urls['xhr-regionalprice-form'] || config.regionformURL;
		config.isPricezone = (config.regionformURL && config.regionformURL.length > 0);

		config.site = $('#common-config').embeddedData().site;
		config.priceformatter = null;
	};
	
	// Constructor of sorts
	exports.init = function() {
		//console.log('ND.CalcPrice.init()');
		this.conf();
		// Init Dynamic URLs AND (Check make sure not in test suite);
		if ((!config.isPricezone && !config.dataURL && !config.formURL) || (config.isPricezone && !config.regionformURL)) {
			return; 
		}
		
		//Objects are singleton (single-use-only)
		priceUpdater.init();
		var derivativeList = priceUpdater.list();
		priceUserDataManager.init(derivativeList);
	};
	
	/* end */
	
	//Expose Price Calculator
	ND.CalcPrice = exports;

	//Expose Price Calculator API methods
	ND.API = $.extend(ND.API, exportsAPI);
	
}(jQuery));


/*
Author:         Brett Chaney
File name:      gux-polk.js
Description:    GUX specific code for FoA Polk pricing
				Includes Polk price change overlay launch
Dependencies:   jQuery, getprice.js, bootstrap.modal.js, guxRadioButtons.js
*/
var guxApp = guxApp || {};

(function($) {

guxApp.polk = {
	init: function() {
		$.subscribe('overlay.launchgux', function(event, options){
			if (!guxApp.polk.launched) {
				guxApp.polk.launchOverlay(options);
			}			
		});

		$.subscribe('overlay.hidegux', guxApp.polk.hideOverlay);

		guxApp.polk.closeOverlay();
		guxApp.polk.inputLength();

		$.subscribe('userchangesuccess.calculateprice.dfy', function(event, data) {
			$('#compareContainer .body.derivative-price').css('width','');			

			if ($('.model-walk')[0]) {
				guxApp.ModelWalk.fetchDate();
				guxApp.polk.startingPrice(event, data);
			}

			if ($('.model-compare')[0]) {
				guxApp.polk.appendZero(true);
				guxApp.polk.modelCompareOffers();
			} else {
				guxApp.polk.appendZero();
			}

			if($('.model-display')[0]) {
				guxApp.polk.compareVehicleOffers();
			}

			if ($('.section-cars')[0]) {
				guxApp.polk.showroomPrices(event, data);
			}
		});

		$.subscribe('shopping.pref.retrieve', function() {
			if ($('#compareContainer .body.derivative-price:empty')) {
		    	$('#compareContainer .body.derivative-price').attr('style','width:0 !important');
		    } else {
		    	$('#compareContainer .body.derivative-price').css('width','');
		    }
		});

		guxApp.innerPopup.init();
	},

	appendZero: function(compare) {
		var postcodeLength;

		// Fixes IE issue that removes '0' from postcodes that start with a '0' i.e. 0800
		if (compare) {
			postcodeLength = $('.calc-price-overlay')[0] ? $('.calc-price-overlay .pc-input').val().length : $('.model-compare .need-price .prices-shown .postcode').html().length;
		} else {
			postcodeLength = $('.calc-price-overlay')[0] ? $('.calc-price-overlay .pc-input').val().length : $('.need-price .prices-shown .postcode').html().length;
		}

		if (postcodeLength === 3) {
			if ($('.calc-price-overlay')[0]) {
				var valuePC = $('.calc-price-overlay .pc-input').val(),
					addedZero = 0 + valuePC;
				
				$('.calc-price-overlay .pc-input').val(addedZero);
			} else {
				$('.need-price .prices-shown .postcode').prepend('0');
			}	
		}
	},

	showroomPrices: function(event, data) {
		var displayPrice,
			price;

		$.each(data.derivatives, function(i, obj) {
			displayPrice = obj.price;
			price = parseInt(displayPrice.replace(/[^0-9.]/g, ''));

			$('.derivative-price[data-derivativeid="' + obj.id + '"]').parents('.vehicle-data').attr('data-price',price);
		});
	},

	startingPrice: function(event, data) {
	    var prices = [],
			displayPrice,
			lowestPrice,
			formattedPrice;

		function sortNumber(num1, num2) {
	        return num1 - num2;
	    }

	    function numberWithCommas(x) {
		    return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
		}

		var priceList;

		$.each(data.derivatives, function(i, obj) {
			displayPrice = obj.price;
			prices.push(parseInt(displayPrice.replace(/[^0-9.]/g, '')));
			if (priceList !== undefined) {
				priceList = priceList + "\n" + 'Price: ' + displayPrice + '  ID: ' + obj.id;
			} else {
				priceList = 'Price: ' + displayPrice + '  ID: ' + obj.id;
			}
		});

	    lowestPrice = prices.sort(sortNumber)[0];
	    formattedPrice = numberWithCommas(lowestPrice);
	},

	modelCompareOffers: function() {

		// Move Latest Offers link below the Vehicle details on Modal Compare page
	    $('.model-compare .model-hero .derivative-price').each(function() {
	    	var elem = $(this);

	    	elem.parent().append('<li />');
	    	elem.find('.offers').appendTo(elem.parent().find('li:last-child'));
	    	elem.parent().find('.offers').parent().css('marginRight', 0);

	    	// Remove all remaining empty <li>'s
	    	elem.parent().find('li:empty').remove();

	    	if (elem.parent().find('.offers').length > 1) {

	    		// Remove duplicated 'latest offers'
	    		elem.parent().find('.offers').eq(0).parent().remove();
	    	}
	    });

	    // Reset equal element heights for H2 and UL
	    $('.model-compare .mw-content .model-hero .model-container .model-data .model-content ul').removeAttr( 'style' );
	    $('.model-compare section.model-hero .model-container h2').removeAttr( 'style' );

	    guxApp.ModelCompare._equalizeElemHeight($('.model-compare .mw-content .model-hero .model-container .model-data .model-content ul'));
	    guxApp.ModelCompare._equalizeElemHeight($('.model-compare section.model-hero .model-container h2'));
	},

	compareVehicleOffers: function() {

		// Move Latest Offers link below the Vehicle details on Compare Module
	    $('.model-display .derivative-price').each(function() {
	    	$(this).find('.price').siblings('.offers').remove();
	    	$(this).find('.offers').appendTo($(this));
	    });
	},
	
	hideOverlay: function () {

		// Hide modal and then remove content
		$('#modalWrap').modal('hide').removeClass('polk-modal').find('.modal-body').html('');

		guxApp.polk.launched = false;
	},

	launchOverlay: function(options) {

		guxApp.polk.launched = true;

		// Launch Bootstrap modal
		$('#modalWrap').addClass('polk-modal').modal({
			"backdrop" : false,
			"keyboard" : false
		});

		// Inject content into modal
		$('.polk-modal .modal-body').load(options.url, function() {
			options.success.call();

			// Initiate radio buttons GUX-style method
			guxApp.radioButtons.init();
			
			setTimeout(function(){
				guxApp.polk.appendZero();
			},250);
		
			// Publish
			$.publish('overlay.success');
		});
	},

	closeOverlay: function() {
		$('#modalWrap').on('click', '.icon-close, .close-overlay', function(e) {
			e.preventDefault();
			$.publish('overlay.usercancel');
			guxApp.polk.hideOverlay();
		});

		$(document).keydown(function(e) {

			// ESC key pressed
			if (e.keyCode == 27) {
				$.publish('overlay.usercancel');
				guxApp.polk.hideOverlay();
			}
		});
	},

	inputLength:function() {
		$('.modal').on('input keyup', '.pc-input', function() {
			if ($(this).val().length > 4) {
				$(this).val($(this).val().slice(0,4));
			}
		});
	}
};

$(function() {
	if ($('.need-price')[0]) {

		// getprice.js
		ND.CalcPrice.init();
		guxApp.polk.init();
	}
});

})(jQuery);


/*
 Author: jbao, gdelmundo
 File name: moduleModalWalk.js
 Description:
 control the first page of modal walk, use moduleModalCompare.js to render the second page.

 Useful Functions:
    guxApp.ModelWalk.resetVehicleSelection()
     - This will reset all the vehicle selection and unbind all the ModelWalk Events.
    guxApp.ModelWalk.registerListeners()
     - This will bind all the event listeners used in modelwalk.
    
 */

var guxApp = guxApp || {};

(function($){
    $(function(){
        var configInfo = guxApp.tools.commonConfigData(),
            modelWalkConfig = guxApp.tools.getEmbeddedData('#modelwalk-config'),
            site = (configInfo != null && configInfo.site) ? configInfo.site : null,
            formattedDate = (modelWalkConfig != null && modelWalkConfig.formattedDate) ? modelWalkConfig.formattedDate : null,
            modelData = (modelWalkConfig != null && modelWalkConfig.modelData) ? modelWalkConfig.modelData : null,
            imageUrl = (modelWalkConfig != null && modelWalkConfig.imageUrl)? modelWalkConfig.imageUrl : null,
            selectMsg = (modelWalkConfig != null && modelWalkConfig.selectMsg)? modelWalkConfig.selectMsg : null,
            compareMsg = (modelWalkConfig != null && modelWalkConfig.compareMsg)? modelWalkConfig.compareMsg : null,
            derivativeUrl = (modelWalkConfig != null && modelWalkConfig.derivativeUrl)? modelWalkConfig.derivativeUrl : null,
            overlayUrl = (modelWalkConfig != null && modelWalkConfig.overlayUrl)? modelWalkConfig.overlayUrl : null;

        var getFormattedDate = function(){
            var today = new Date(),
                yyyy = today.getFullYear(),
                mm = ('0' + (today.getMonth() + 1)).slice(-2),
                dd = ('0' + today.getDate()).slice(-2);
            return yyyy + mm + dd;
        };

        guxApp.ModelWalk = {
            init: function(){
                var container = $(".model-walk");
                if (!container.length) {return;}

                this.equalizeModelHeight();
                this.initConfig();
                this.initDetails(container);
                this.modifySize();
                this.fetchDate();
                this.preSelectModel();
                this.resizeModelHandler();
                this.showCheckbox();
                this.initState();
                this.setAllowModelMsg();
                this.initPriceFormat();
            },
            initState: function(){
                if($('section.model-walk').length > 0 && $('section.model-walk.model-enhance').length === 0){
                    window.onpopstate = undefined;
                    $.bbq.pushState({
                        "step": 1
                    })
                }
            },
            initPriceFormat: function(){
                if ($('#mpz-config').length && modelWalkConfig){
                    var priceFormatOptions = $('#mpz-config').embeddedData();

                    guxApp.priceFormatter.initialise({
                        data: priceFormatOptions.priceFormat,
                        formatString: modelWalkConfig.formattedPrice,
                        centsSeparator: priceFormatOptions.monetaryDecimalSeparator,
                        thousandsSeparator: priceFormatOptions.groupingSeparator
                    });
                }
            },
            preSelectModel: function(){
				var parameters=window.location.search.substr(1).match(/(^|&)itemid=([^&]*)(&|$)/i);
                var itemId = !!parameters&&parameters.length>2?parameters[2]:'';
                var $checkBox = $('.model-walk .model-select input[data-modelnum="'+itemId+'"]');
                $checkBox.click();
            },
            modifySize: function(){
                var width = $(window).width();
                if(width >= 768){
                    this.config.allowedModels = 3;
                } else{
                    this.config.allowedModels = 2;
                }
            },
            fetchDate: function(){
                if(formattedDate != null) {
                    formattedDate = formattedDate.replace('{site}', guxApp.tools.encode(site));
                    formattedDate = formattedDate.replace('{yyyyMMdd}', getFormattedDate());
                    var self = this;
                    $.ajax({
                        url: formattedDate,
                        type: "GET",
                        dataType: "json"
                    }).done(function (data) {
                        self.config.formattedDate = data['formatted-date'];
                        $('.priceDate').html(self.config.formattedDate);
                    }).fail(function(xhr, textStatus){
                        if(textStatus == "timeout"){
                            throw new Error(textStatus, "Fetch Date timeout");
                        } else if (xhr.status == 500){
                            throw new Error(xhr.status, "Server error when fetching Date");
                        }
                    });
                }
            },
            initConfig: function(){
                var totalModelNum = $('.model-walk .uniform .model-container').length;
                this.config = {
                    site: site,
                    formattedDate: formattedDate,
                    derivativeUrl: derivativeUrl,
                    modelData: modelData,
                    imageUrl: imageUrl,
                    selectedModels: [],
                    allowedModels: 3,
                    selectMsg: selectMsg,
                    totalModelNum: totalModelNum,
                    overlayUrl: overlayUrl
                };
            },
            registerListeners: function(){
                var self = this,
                    eventHandler = guxApp.tools.isIOS()?'click tap':'click';
                    
                $(window).resize(function(){
                    self.modifySize.call(self);
                });


                $(window).unbind('hashchange').bind('hashchange', function(){
                    var step = $.bbq.getState("step");
                    if(step === '1'){
                        guxApp.ModelCompare.clearModel();
                        guxApp.ModelWalk.resetVehicleSelection();
                        //Reattach Events after Pressing Back
                        self.registerListeners();
                    }else if(step === '2'){
                        $('.model-walk').hide();
                        guxApp.ModelCompare.init(self.config);
                    }
                });
                $('#modalModel .model-data,.model-walk .model-data').on(eventHandler,function(event){
                    if($(this).hasClass('selected') && $(this).closest('#modalModel').length > 0){
                        return false;
                    }else if(!$(event.target).data('disclosure') && ($(event.target).closest('.inner-popup.active').length === 0) ){
                        $(this).find('input[type="checkbox"]').click();
                    }

                });
                $('.select-models button').click(function(){
                    $('.model-walk').hide();

                    $.bbq.pushState({
                        "step": 2
                    });
                });
                $('.model-select input').on('click.modelwalk',function(event){
                    event.stopPropagation();
                    var $modelModalElem = $(this).closest('#modalModel');
                    var $modelContainer = $(this).closest('.model-container .model-data');
                    if($(this).prop('checked') === true){
                        $modelContainer.addClass('selected');
                    }else{
                        $modelContainer.removeClass('selected');
                    }
                    


                    var model = $(this).data('modelnum');
                    if($modelModalElem.length > 0 && $modelModalElem.hasClass('change')){
                        var originId = $modelModalElem.data('originid');
                        self.changeModel(originId, model);
                    }else if (self.config.selectedModels.indexOf(model) != -1){
                        self.removeModel($(this), model);
                    } else {
                        if (self.config.selectedModels.indexOf(model) != -1 && self.config.selectedModels.length > self.config.allowedModels){
                            self.removeModel($(this), model);
                        } else {
                            if (self.config.selectedModels.length < self.config.allowedModels){
                                self.addModel(model);
                            }
                        }
                    }

                    //Override !important Styling for Select Models
                    if(self.config.selectedModels.length == 0){
                        $('.allowed-models').addClass('ready');
                    } else {
                        $('.allowed-models').removeClass('ready');
                    }
                });

            },
            resetVehicleSelection: function(){
                var self = this;

                guxApp.ModelCompare.clearModel();
                $('.model-walk').show();
                $('.compareContent').children().remove();
                $(window).unbind('scroll', guxApp.ModelCompare.compareStickyHeader);
                $(window).unbind('scroll', guxApp.ModelCompare.stickyHeaderListener);  
                $(window).unbind('resize', guxApp.ModelCompare.resizeModelHandler);
                
                var selectedModels = self.config.selectedModels.slice(0);
                self.config.selectedModels = [];
                var checkbox = $('.model-walk form.uniform .model-select input');
                checkbox.prop('checked', false);
                checkbox.removeAttr('disabled');
                checkbox.closest('.model-select').removeClass('disabled');
                $('.model-walk .model-container .model-data').removeClass('selected');
                $(".model-walk .model-container .model-data span[class='checked']").removeClass('checked');
                $('.model-walk form.uniform .model-container').show();

                for(var index = 0; index < selectedModels.length; index++){
                    var model_id = selectedModels[index];
                    $('.model-walk .model-container .model-select input[data-modelnum="'+model_id+'"]').click();
                }
                //Retriggering fix for IOS devices; This will retrigger click for the first index of selectedModels
                if(guxApp.tools.isIOS()){
                    $('.model-walk .model-container .model-select input[data-modelnum="'+selectedModels[0]+'"]').click();
                }

                //Remove Event Listeners
                // $(window).unbind('hashchange');
                $('#modalModel .model-data,.model-walk .model-data').off('click tap');
                $('.select-models button').off('click');
                $('.model-select input').off('click.modelwalk');
            },
            changeModel: function(originId, newId){
                var index = this.config.selectedModels.indexOf(originId);
                this.config.selectedModels.splice(index, 1, newId);
                guxApp.ModelCompare.updateCompareModels(this.config.selectedModels);
            },
            removeModel: function($elem, model){
                var index = this.config.selectedModels.indexOf(model);
                this.config.selectedModels.splice(index, 1);
                this.setAllowModelMsg();
                guxApp.ModelCompare.updateCompareModels(this.config.selectedModels);

                var selectedModels = $elem.closest('.model-data');
                for(var i = 0; i < selectedModels.length; i++){
                    var modelContainer = $(selectedModels[i]);
                    modelContainer.removeClass('selected');
                    modelContainer.find("span[class='checked']").removeClass('checked');
                }
                if(this.config.selectedModels.length < 2){
                    $('.select-models button').removeClass('ready').attr("disabled","disabled");
                    $('.select-models .mobile-button .ui-btn').addClass('ui-disabled');
                }
                if(this.config.selectedModels.length === (this.config.allowedModels - 1)){
                    var uncheckedItem = $('form.uniform .model-select input:not(:checked)');
                    uncheckedItem.removeAttr('disabled');
                    uncheckedItem.removeData("disabled");
                    uncheckedItem.closest('.model-select').removeClass('disabled');
                }
            },
            addModel: function(model){
                this.config.selectedModels.push(model);
                guxApp.ModelCompare.updateCompareModels(this.config.selectedModels);
                this.setAllowModelMsg();
                if(this.config.selectedModels.length >= 2){
                    $('.select-models button').addClass('ready').removeAttr('disabled').removeData("disabled");
                    $('.select-models .mobile-button .ui-btn').removeClass('ui-disabled');
                }
                if(this.config.selectedModels.length === this.config.allowedModels){
                    var uncheckedItem = $('form.uniform .model-select input:not(:checked)');
                    uncheckedItem.attr('disabled','disabled');
                    uncheckedItem.closest('.model-select').addClass('disabled');
                }
            },
            setAllowModelMsg: function(){
               // if (!selectMsg.length) return;

                var $allowMsgElem = $('.allowed-models');
                var $pluralMsgElem = $('.pluralize-models');
                var $compBtnLabel = $('.select-models .mw-compare-sticky h3');
                var msg = '';
                
                if(this.config.selectedModels.length === 0){
                    msg = this.config.allowedModels;
                    if(this.config.totalModelNum < this.config.allowedModels){
                        msg = this.config.totalModelNum;
                    }
                    $pluralMsgElem.hide();
                    $allowMsgElem.show().find('span').html(msg);
                    msg = selectMsg["other"].replace(/{}/, msg);
                    $compBtnLabel.html($allowMsgElem.html());
                }else{
                    var numToSelect = this.config.allowedModels - this.config.selectedModels.length;
                    if(this.config.totalModelNum < this.config.allowedModels){
                        numToSelect = this.config.totalModelNum - this.config.selectedModels.length;
                    }
                    switch(numToSelect){
                        case 0:
                            msg = selectMsg["zero"];
                            break;
                        case 1:
                            msg = selectMsg["one"];
                            break;
                        default:
                            msg = selectMsg["other"];
                            msg = msg.replace(/{}/, numToSelect);
                            break;
                    }
                    $allowMsgElem.hide();
                    $pluralMsgElem.html(msg).show();
                    $compBtnLabel.html(msg);
                }
                if(guxApp.viewport.view === "mobile"){
                    if($('.mw-compare-sticky .hide-for-large-up .ui-btn-text').length > 0){
                        $('.mw-compare-sticky .hide-for-large-up .ui-btn-text').html(msg);
                    }else{
                        $('.mw-compare-sticky .hide-for-large-up button').html(msg);
                    }
                }
            },
            showCheckbox: function(){
                $('input[type="checkbox"]').css('visibility','visible');
            },
            equalizeModelHeight: function(){
                var addedRow = $('.model-walk .added-row');

                if($(addedRow)){
                    addedRow.contents().unwrap();
                }

                var width = $(window).width(),
                    modelElem = $('.model-walk .mw-content .select-models .model-container');

                if(width >= 980){
                    guxApp.ModelWalk.addRowPerGroup(modelElem,4);
                } else if(width >= 750) {
                    guxApp.ModelWalk.addRowPerGroup(modelElem,3);
                }
            },
            addRowPerGroup: function(elem,numOfDivs){
                for(var i = 0; i < elem.length; i+=numOfDivs) {
                  elem.slice(i, i+numOfDivs).wrapAll("<div class='row added-row'></div>");
                }
            },
            resizeModelHandler: function(){
                $(window).on('resize',this.equalizeModelHeight);
                
            },
            //Initialize Model Details Function in the Model Walk if the 'alt' is published
            initDetails: function(container){
                //Cache the mostly used elements
                var self = this,
                    ready = true,
                    smobCompare = $('.mw-wrapper .smob-compare-init',container),
                    smobCancel = $('.mw-wrapper .smob-compare-cancel',container),
                    compareInit = $('.mw-wrapper .compare-init',container),
                    allowedModelsElem = $('.mw-wrapper .allowed-models',container);

                //Register Button Events if 'alt' class is published. If not, skip the unecessary events.
                if(container.hasClass('alt')){
                    container.find('.model-data').addClass('ready');
                    $('.mw-wrapper .compare-init,.mw-wrapper .smob-compare-init',container).click(function(e){
                        var elem = this;
                        
                        allowedModelsElem.toggleClass('ready');
                        // Toggle Ready and Selection State; 
                        if(ready){
                            self.toggleModelDetails(container,elem);
                            self.registerListeners();
                            // Change state of mobile controls
                            smobCancel.show();
                            smobCompare.hide();
                        } else {
                            self.resetVehicleSelection();
                            self.resetVehicleSelection();
                            self.resetVehicleSelection();
                            self.toggleModelDetails(container,elem);
                            $('.select-models button').removeClass('ready').attr("disabled","disabled");
                            $('.select-models .mobile-button .ui-btn').addClass('ui-disabled');                            
                            // Change state of mobile controls
                            smobCompare.show();
                            smobCancel.hide();
                            // Hide Allowed Model Message
                            $('.allowed-models').hide().removeClass('ready');
                            $('.pluralize-models').hide();
                        }

                        ready = !ready;
                    });

                    //Added an event that prevents the clicking to transfer in model detail page
                    $('.select-models .model-select a, .select-models .model-placeholder a',container).click(function(e){
                        if(!ready){
                            e.preventDefault();
                        }
                    });

                    //Added Event Listeners to mobile buttons
                    smobCompare.click(function(){
                        $(this).hide();
                        $('.mw-wrapper .smob-compare-cancel',container).show();
                        //Change State of LargeUp Compare Button
                        compareInit.toggleClass('alt');
                        $('span',compareInit).toggle();
                    });

                    smobCancel.click(function(e){
                        $(this).hide();
                        $('.smob-compare-init',container).show();
                        self.resetVehicleSelection();
                        self.resetVehicleSelection();
                        self.resetVehicleSelection();
                        self.toggleModelDetails(container);
                        $('.select-models button').removeClass('ready').attr("disabled","disabled");
                        $('.select-models .mobile-button .ui-btn').addClass('ui-disabled');
                        //Change State of LargeUp Compare Button
                        compareInit.toggleClass('alt');
                        $('span',compareInit).toggle();

                        // Hide Allowed Model Message
                        $('.allowed-models').hide().removeClass('ready');
                        $('.pluralize-models').hide();

                        ready = !ready;
                    });

                } else {
                    $('.smob-compare-init, .smob-compare-cancel, .compare-init').attr('style', 'display: none !important');
                    this.registerListeners();
                }

                

            },
            //Toggle the elements to Ready|Selection state
            toggleModelDetails: function(container,elem){
                 var vehicleSelection = container.find('.model-data');
                        
                    vehicleSelection.toggleClass('ready');
                    //Hide the standard features and paragraphs for every model tile
                    vehicleSelection.find('.model-content p:not(".price"),.standard-features').slideToggle();
                    if(guxApp.viewport.view == "tablet"){
                        $(elem).toggleClass('alt');
                        $('span',elem).toggle();
                    }

                    $('.mw-wrapper .mw-compare-sticky',container).toggle();
            }
        }
        guxApp.ModelWalk.init();
    });

})(jQuery);


/*
 Author: jbao
 File name: moduleModalCompare.js
 Description:
 This is the second view of model walk page, controlled by moduleModalWalk.js
 */
var guxApp = guxApp || {};



(function($){

    guxApp.ModelCompare = {
        init: function(config){
            this._initial = true;
            this._isDifferencesChecked = false;
            this.initModel(config);
            this.fetchModel();
            this.registerListeners();
            this.recalcSticky();
            this.equalizeModelHeight();
            this.resizeModelHandler();
        },
        registerListeners: function(){
            this.compareByDiffListener();
            this.popupDlgListener();
            this.closeOverlayListener();
            this.stickyHeaderListener();
            this.accordionTabListener();
            this.removeModelListener();
            this.addBackBtnListener();
        },
        addBackBtnListener: function(){
            var self = this;

            $('.model-back').live('click',function(){
                $('.need-price').html('');
                guxApp.polk.launched = false;
                $.bbq.pushState({"step": 1});
                guxApp.ModelWalk.fetchDate();
            });
        },
        clearModel: function(){
            this.config = undefined;
        },
        removeModelListener: function(){
            var self = this;
            $('.model-hero .icon-remove').live('click',function(){
                self._initial = false;
                var model = $(this).data("derivativeid");
                var index = self.config.selectedModels.indexOf(model);
                if(index > -1){
                    self.config.selectedModels.splice(index, 1);    
                }
                self.fetchModel();
            });
        },
        updateCompareModels: function(selectedModels){
            $('#modalModel .cancelDlg').click();
            if(this.config){
                this.config.selectedModels = selectedModels;
                this.fetchModel();
            }
        },
        renderHtml: function(){
            var $elem = $('.compareContent');
            var compareHtml = $('#compareTmpl');
            var template = _.template(compareHtml.html());
            var compiledHtml = template({
                site: this.config.site,
                selectedModels: this.config.selectedModels,
                formattedDate: this.config.formattedDate,
                compareModels: this.config.compareModels,
                imageUrl: this.config.imageUrl,
                derivativeUrl: this.config.derivativeUrl,
                groups: this.config.groups,
                allowedModels: this.config.allowedModels,
                totalModelNum: this.config.totalModelNum,
                displayFeature: this.displayFeature,
                overlayUrl: this.config.overlayUrl
            });
            $elem.html(compiledHtml);
            Foundation.libs.equalizer.init();
            
            // re-initiate polk pricing
            ND.CalcPrice.init();
            guxApp.mediaOverlay.init();

            //this._equalizeElemHeight($('.model-compare .mw-content .model-hero .model-container .model-data .model-content ul li').filter(':eq(2), :eq(5), :eq(8)'));
            this._equalizeElemHeight($('.model-compare .mw-content .model-hero .model-container .model-data .model-content ul li'));
            this._equalizeElemHeight($('.model-compare .mw-content .model-hero .model-container .model-data .model-content ul'));
            this._equalizeElemHeight($('.model-compare section.model-hero .model-container h2'));
            this._equalizeElemHeight($('.model-compare section.model-hero .model-container .kba-buttons'));
            this._equalizeElemHeight($('.model-hero .model-container h2'),$('.selected-sticky .model-hero .model-container h2'));

            if(guxApp.viewport.view === "mobile"){
                this._equalizeElemWidth($('.model-compare .selected-sticky h2'));
                this._alignMiddle($('.model-compare .smob-back'), $('.model-compare .mw-header'));
            }
            // remove sticky title temporarily for performance
           if(guxApp.viewport.view !== "mobile"){
               guxApp.accordion.stickyTitle();
           }
           this.zebraStyling();
           guxApp.ModelWalk.fetchDate();
        },
        _alignMiddle: function(elem, parent){
           var parentHeight = parent.height();
           var elemHeight = elem.height();
           var topHeight = (parentHeight - elemHeight)/2 + 'px';
           elem.css('top', topHeight);
        },
        _equalizeElemHeight: function(equalHeightElems, assignHeight){
            var maxHeight = 0;
            assignHeight = typeof assignHeight !== 'undefined' ? assignHeight : equalHeightElems;

            $(equalHeightElems).each(function(){
                maxHeight = ($(this).height() > maxHeight)?$(this).height():maxHeight;
            });
            $(assignHeight).height(maxHeight);
        },
        _equalizeElemWidth: function(equalWidthElems){
            var minWidth = equalWidthElems.width();
            $(equalWidthElems).each(function(){
                minWidth = ($(this).width() < minWidth)?$(this).width():minWidth;
            });
            $(equalWidthElems).width(minWidth);
        },
        initModel: function(config){
            this.config = {
                groups : {},
                compareModels: undefined,
                selectedModels: config.selectedModels,
                formattedDate: config.formattedDate,
                imageUrl: config.imageUrl,
                modelData: config.modelData,
                site: config.site,
                allowedModels: config.allowedModels,
                selectMsg: config.selectMsg,
                totalModelNum: config.totalModelNum,
                overlayUrl: config.overlayUrl
            }
        },
        setDifferencesRecord: function(){
            var $differenceCheckboxElem = $('.uniform .tab-item input:first');
            this._isDifferencesChecked  = ($differenceCheckboxElem.length > 0)?$differenceCheckboxElem.prop('checked'):false;
        },
        restoreDifferencesSetting: function(){
            if(this._isDifferencesChecked){
                $('.uniform .tab-item input:first').click();
            }
        },
        fetchModel: function(){
            if(this.config.modelData != null) {

                var compareModels = [];

                // Build the REST URL for Model Walk Derivatives
                var modelData = this.config.modelData;

                modelData = modelData.replace('{site}', guxApp.tools.encode(this.config.site));
                modelData = modelData.replace('{modelIds}', this.config.selectedModels.toString());

                var self = this;

                $('html,body').animate({scrollTop: 0},200);
                $('.loading').show();
                $('.model-compare').hide();

                this.setDifferencesRecord();

                $.ajax({
                    url: modelData,
                    type: "GET",
                    dataType: "json"
                })
                .done(function(data){

                     _.forEach(self.config.selectedModels, function(selected) {

                        // Loop to Derivatives
                        _.forEach(data.derivatives, function(derivative) {
                            // Push Only Derivative Id's that Matched Selected Item Id's
                            if(derivative.derivativeId == selected) {

                                compareModels.push(derivative);

                            }

                        });

                     // Base for Group & Category name/title
                     self.config.groups = compareModels[0].groups;

                     // Order by selection sequence
                     compareModels.slice().reverse();
                     self.config.compareModels = compareModels;
                    });
                    self.renderHtml();
                    $('.loading').hide();
                    $('.errorPadding').hide();
                    $('.model-compare').show();
                    // omniture: initial  to fire the tag
                    if(self._initial){
                    	if (window._da && window._da.om && ND && ND.omniture) {
						_da.pname = 'vehicle:models:compare';	
						ND.analyticsTag.trackOmniturePage();
                    	}
                    }
                    self.restoreDifferencesSetting();
                }).fail(function(xhr, textStatus){
                    $('.loading').hide();
                    $('.errorPadding').show();
                });;

            };
        },
        populateDlgHeader: function($header, isAdd){
            var headerText = '';
            if(isAdd){
                var numToSelect = this.config.allowedModels - this.config.selectedModels.length;
                switch(numToSelect){
                    case 0:
                        headerText = this.config.selectMsg['zero'];
                        break;
                    case 1:
                        headerText = this.config.selectMsg['one'];
                        break;
                    default:
                        headerText = this.config.selectMsg['other'];
                        headerText = headerText.replace(/{}/, numToSelect);
                        break;
                }
            }else{
                headerText = this.config.selectMsg['one'];
            }
            $header.find('span').html(headerText);
        },
        popupDlgListener: function(){
            var self = this;
            var modal = $("#modalModel");

            $('.model-hero a.button, .selected-sticky .model-hero a').live('click',function(event){
                $('.model-hero').hide();
                $(".title-holder").trigger("sticky_kit:detach");
                self._initial = false;
                var isAdd = $(this).hasClass('addmodel');
                var isChange = $(this).hasClass('changemodel');
                if(isAdd){
                    $('#modalModel .model-container').removeAttr('style').addClass('block').removeClass('none end');
                    modal.removeClass('change').addClass('add');
                    modal.removeData('originid');
                }else if(isChange){
                    var originId = '';
                    $('#modalModel .model-container').removeAttr('style').addClass('block').removeClass('none end');
                    if(guxApp.viewport.view !== "mobile") {
                        originId = $(this).closest('.model-data').find('.icon-remove').data('derivativeid');
                    }else{
                        originId = $(this).data('derivativeid');
                    }
                    modal.removeClass('add').addClass('change');
                    modal.data('originid', originId);
                }
                $('.model-data', modal).removeClass('selected');
                var modelAction = $(this).data('revealfix');
                var $modalHeader = undefined;
                if(self.config.allowedModels === 3){
                    $('#select-two-models').hide();
                    $modalHeader = $('#select-three-models');
                    $modalHeader.show();
                }else if(self.config.allowedModels === 2){
                    $('#select-three-models').hide();
                    $modalHeader = $('#select-two-models');
                    $modalHeader.show();
                }

                self.populateDlgHeader($modalHeader, isAdd);

                // Disable Checkbox When you Select Items > Allowed Items
                // if(self.config.selectedModels.length >= self.config.allowedModels && modelAction !== 'change') {
                //     $(".model-data").find('input[type="checkbox"]:not(:checked)').attr('disabled', 'disabled');
                // } else {
                    $(".model-data").find('input[type="checkbox"]:not(:checked)').removeAttr('disabled').closest('.model-select').removeClass('disabled');
                //}



                // Add .selected class on selectedModels
                for (var i = self.config.selectedModels.length - 1; i >= 0; i--) {
                    var selectedModel = $('[data-modelnum="' + self.config.selectedModels[i] + '"]').closest('.model-data');
                    selectedModel.addClass('selected');
                    // Change visibility of all selectedModels
                    if(isChange){
                        selectedModel.closest('.model-container').css('display','none');
                    }
                };

                

                if(isChange){
                    $('[data-modelnum="' + originId + '"]').closest('.model-container').removeAttr('style').addClass('block').removeClass('none');
                }

                 $(".title-holder").trigger("sticky_kit:detach");

                if(modal){
                    if(event.preventDefault) { event.preventDefault(); }
                    modal.foundation('reveal', 'open');
                    $('.vehicle-modal').find('.model-content').addClass('body derivative-price');

                    ND.CalcPrice.init();
                }

                self.equalizeModelHeight();
            });
        },
        closeOverlayListener: function(){
            var modal = $("#modalModel"),
                vModel = $('.vehicle-modal .added-row');
            modal.find('.cancelDlg').live('click', function() {
                modal.find('.checked').removeClass();
                modal.foundation('reveal', 'close');
                $('.vehicle-modal').find('.model-content').removeClass('body derivative-price');

                if(guxApp.viewport.view !== "mobile"){
                   guxApp.accordion.stickyTitle();
               }
               $('.model-hero').show();
               
               ND.CalcPrice.init();
               vModel.contents().unwrap();
            });

           $(document).on('click', '.reveal-modal-bg', function() {
                ND.CalcPrice.init();
               vModel.contents().unwrap();
            });

            $(document).on('close.fndtn.reveal', '[data-reveal]', function () {
              var modal = $(this);
              $('.model-hero').show();
              vModel.contents().unwrap();
            });
        },
        compareByDiffListener: function(){
            $('form.uniform .tab-data input[type="checkbox"]').live('click',function(){
                var tabItems = $('form.uniform .tab-item');
                var $diffCheckbox = tabItems.find('.tab-data input[type="checkbox"]')
                var isChecked = $(this).prop('checked');
                $diffCheckbox.prop('checked', isChecked);
                if(isChecked){
                    $diffCheckbox.parent().addClass('custom-checked');
                    $diffCheckbox.closest('.checker').addClass('checker-selected');
                    $(document.body).trigger("sticky_kit:recalc");
                }else{
                    $diffCheckbox.parent().removeClass('custom-checked');
                    $diffCheckbox.closest('.checker').removeClass('checker-selected');
                    $(document.body).trigger("sticky_kit:recalc");
                }

                for(var itemIndex = 0; itemIndex < tabItems.length; itemIndex++){
                    var categories = $(tabItems[itemIndex]).find('.tab-contents .title-waypoint');
                    for(var idx = 0; idx < categories.length; idx++){
                        var features = $(categories[idx]).find('tr');
                        for(var jdx = 0; jdx < features.length; jdx++){
                            if(isChecked){
                                var featureArr = [];
                                var featureColumns = $(features[jdx]).find('td');
                                for(var kdx = 0; kdx < featureColumns.length; kdx++){
                                    var featureName = $(featureColumns[kdx]).find('p').html();
                                    if($.inArray(featureName, featureArr) === -1) {
                                        featureArr.push(featureName);
                                    }
                                }
                                if(featureArr.length === 1){
                                    $(features[jdx]).hide();
                                }
                            }else{
                                $(features[jdx]).show();
                            }
                        }
                    }
                }
            });
        },
        compareStickyHeader: function(){

            var startPointSecondNav = 70;

            if(guxApp.viewport.view !== "mobile") {
                var startPointModelHeader = 140;
            }else{
                var startPointModelHeader = 290;
            }

            var $stickyHeaderElem = $('.selected-sticky');
            var $stickyHeaderElem = $stickyHeaderElem?$stickyHeaderElem:$('.selected-sticky');
            var $sNav = $('.secondarynav');
            var scroll = $(window).scrollTop();

            if(guxApp.tools.isIE(8)) {
                if ($(window).width() < 1440){
                    $sNav.removeClass('aligned');
                }
            }

            if(scroll < startPointSecondNav){
                $sNav.removeClass('fullwidth');
            } else {
                $sNav.addClass('fullwidth');     
            }

            if (scroll <= startPointModelHeader) {
                $stickyHeaderElem.removeClass('fixed');
            } else if(scroll >= startPointModelHeader) {
                $stickyHeaderElem.addClass('fixed');
            }
        },
        stickyHeaderListener: function(){
            var self = this;

            $(window).on('scroll', self.compareStickyHeader);
            
            var debouncedScroll = _.debounce(function() {
                var elem = $('.selected-sticky.fixed .model-hero .model-container h2');
                elem.height('auto');
                self._equalizeElemHeight(elem);
            },500);
            
            $(window).on('scroll',debouncedScroll);
            $(window).on('resize',debouncedScroll);
        },
        accordionTabListener: function(){
            $('.accordion-block .tab-nav').die().live('click', function(){
                $(".title-holder").trigger("sticky_kit:detach");
                var self = $(this);
                $('.title-text').removeClass('fixed-title absolute-title').css({'top':'auto','width':'auto'});
                if(!self.hasClass('open')) {
                    guxApp.accordion.toggleAnimate($('.tab-nav.open').removeClass('open'));
                    self.toggleClass('open');
                    guxApp.accordion.toggleAnimate(self);

                    //Fix for accordion scrolling bottom.
                    $(":animated").promise().done(function() {
                        $('.selected-sticky').addClass('fixed');
                        var offsetTop = $('.tab-nav.open').offset().top - $('.selected-sticky').outerHeight() - 50;
                        $('html,body').animate({scrollTop: offsetTop},200);
                        if(guxApp.viewport.view !== "mobile"){
                           guxApp.accordion.stickyTitle();
                           //reflow Foundation Equalizer
                           $(document).foundation('equalizer', 'reflow');
                       }
                    });

                } else {
                    guxApp.accordion.toggleAnimate(self.removeClass('open'));
                }
            });
        },
        displayFeature: function(featureValue, featureName){
            var displayValue = '';
            if(featureValue === '' || !featureValue){
                return featureName;
            }
            switch(featureValue){
                case "S":
                case "X":
                    displayValue = featureName;
                    break;
                case "-":
                    displayValue = '-';
                    break;
                default:
                    displayValue = featureName + ' ' + '<b>'+featureValue+'</b>';
                    break;
            }
            return displayValue;
        },
        recalcSticky: function(){
            var debouncedCalc = _.debounce(function() {
                $(".title-holder").trigger("sticky_kit:detach");
                if(guxApp.viewport.view !== "mobile"){
                    guxApp.accordion.stickyTitle();
                }
            },300);

            $(window).on('resize', debouncedCalc);            
        },
        zebraStyling: function(){
            //this is for accordion table styling for ie8
            var accordion = $('.accordion-block');
            
            if (!$(accordion).length) {return;}
            
            if(guxApp.tools.isIE(8)) {
                $('.accordion-block .table-holder > table tr:odd').addClass('odd');
            }
        },
        equalizeModelHeight: function(modelElem){
            var addedRow = $('.vehicle-modal .added-row'),
                elemHolder;

            if($(addedRow).length){
                addedRow.contents().unwrap();
            }


            var width = $(window).width();

            modelElem = typeof modelElem !== 'undefined' ? modelElem :$('.modal-content .select-models .model-container').filter(function() { return $(this).css("display") == "block" });

            if(width >= 980){
                guxApp.ModelWalk.addRowPerGroup(modelElem,4);
            } else if(width >= 750) {
                guxApp.ModelWalk.addRowPerGroup(modelElem,3);
            }

            $('.added-row .model-container:last-child').addClass('end');
        },
        addRowPerGroup: function(elem,numOfDivs){
           for(var i = 0; i < elem.length; i+=numOfDivs) {
              elem.slice(i, i+numOfDivs).wrapAll("<div class='row added-row'></div>");
            }
        },
        resizeModelHandler: function(){
            $(window).on('resize',this.equalizeModelHeight);
            
        }
    }
})(jQuery);


/*
Author:         Brett Chaney
File name:      gux-locale.js
Description:    GUX localisation select overlay and code for FTD template backwards compatibility
Dependencies:   jQuery, bootstrap.modal.js, jquery.uniform, overlay.js, jquery.tinypubsub.js
*/
var guxApp = guxApp || {};

(function($) {

guxApp.locale = {

	init: function() {
		if (!$('#locale-data').length){return;}
		var self = this,
			json = $('#locale-data').embeddedData(),
			commonConfig = $("#common-config").embeddedData();
			
		guxApp.locale.url = json['locale-overlay'];
		guxApp.locale.domain = json.domain;
		guxApp.locale.fromLink = false;
		guxApp.locale.isGUX = $("#gux-footer").length;
		guxApp.locale.cookieDomain = commonConfig.cookieDomain;
		guxApp.locale.locale = commonConfig.locale;

		// set ND.rtl to true if RTL page
		// a condition that needs to be set for overlay.js when opening an overlay on FTD template RTL pages
		ND.rtl = $('body').hasClass('rtl');

		// attach the on click event that launches the locale overlay
		self.launchOverlayEvent();

		self.checkLocale();

		// check locale cookie on page load
		// this is to decide if the locale overlay needs to be launched if no region is confirmed
		if (!guxApp.locale.isGUX) {
			self.checkCookie();
			self.initMenu();
		}
	},

	checkLocale: function(){
		var self = this;
		var url = window.location.href;
		var locale = [];

		if ($.cookie(self.COOKIEKEY)){
			locale = $.cookie(self.COOKIEKEY).split('-');

			if (url.indexOf(locale[1]) < 0){
				self.clearFPSinfo();
				
				self.setGTUID();
			}
			
			if (url.indexOf(locale[2]) === "1"){
				// true: locale confirmed
				self.updateCookie(url,true);
			}
			else {
				self.updateCookie(url,false);
			}
			
		}
		else {
			// false: locale not confirmed
			self.updateCookie(url,false);
		}

	},

	launchOverlayEvent: function() {

		var self = this;

		$('.locale-select').on('click', function(e) {
			e.preventDefault();
			$('body').addClass('modal-open');
			guxApp.locale.fromLink = true;
			self.commonLocaleOverlay();
			self.removeBodyClass();
			self.launchOverlay();
		});

	},

	removeBodyClass:function(){
		$('.close-reveal-modal', '.reveal-modal').on('click',function(e){
			e.preventDefault();
			$('body').removeClass('modal-open');
		})
	},

	launchOverlay: function() {

		var self = this;

		// // launch Bootstrap modal
		// $('#modalWrap').addClass('locale-modal').modal({
		// 	"backdrop" : false,
		// 	"keyboard" : false
		// });

		// inject HTML from cache if previously loaded
		if (self.cache) {
			$('.locale-modal .modal-body').html(self.cache);
			self.commonLocaleOverlay();
		} else {

			$.get(self.url, function( data ) {

				// inject content into modal
				$('.locale-modal .modal-body').html(data);

			  	self.cache = data;
				self.closeOverlayEvent();

				self.commonLocaleOverlay();

			});

		}

	},

	commonLocaleOverlay: function() {

		// the following are functions/methods that are run
		// each time the GUX locale overlay is launched
		
		var self = this;

		// enable uniform js ui styles
		// subscribe on the on-success publish in revealmodal.js
		$.subscribe('foundation-reveal-modal-open', function(){
			if($('.reveal-modal .uniform')){
        		$('.uniform select', '.reveal-modal').uniform({selectClass: 'dropdown', selectAutoWidth: false});
			}
			self.reinitInnerPopup();
		});

		// self.reinitInnerPopup();

		// $('.locale-wrap').on('click', '.close-popup', function() {
		// 	// re-init inner popup
		// 	self.reinitInnerPopup();
		// });

		// self.realignInnerPopup();
		
		if (guxApp.locale.fromLink) {
			// this is run when the user clicks the overlay from the link in the footer
			self.checkCookie();
		}

		self.bindOverlay();

	},

	localeArr: [],

	COUNTRY: 1,
	
	CONFIRMED: 2,

	COOKIEKEY: "dfy.fme.locale",

	checkCookie: function() {
		var self = this,
			cookieVal = $.cookie(self.COOKIEKEY);
		
		if (cookieVal) {
			self.localeArr = cookieVal.split('-');
		}
		//if the locale is confirmed, will not popup overlay.
		if(self.localeArr[self.CONFIRMED] == '1'){
			return;
		}

		if (guxApp.locale.url && !guxApp.locale.fromLink) {
			// this is run when the cookie on page load is not confirmed
			if (guxApp.locale.isGUX) {
				self.launchOverlay();
			} else {
				window.setTimeout(function(){
					$.publish('overlay.launch', {
						url: guxApp.locale.url,
						success: function() {
							self.bindOverlay();
						}
					});
				}, 1000);
			}

		}

	},

	bindOverlay: function() {

		// bind event to overlay, force redirection and
		// change cookie when user submits the form
		var self = this;

		if ($('#overlay .controls').length){
			$('#overlay .controls').hide();
		}

		$('.country-overlay select').on('change', function() {
			$(this).parents('form').attr({'action': $(this).val()});
		}).trigger('change');	// trigger change event when overlay first launches

		$('.country-overlay form').submit(function(e){

			var $this = $(this),
				value = $('select', $this).val();

			if ($this.attr('action')) {
				$this.attr({'action': value});
			}

			if (value.indexOf(guxApp.locale.locale) < 0){
				self.clearFPSinfo();
			}

			// if current submit data match the current current URL
			// cancel the submit redirection and hide the overlay
			if (!self.updateCookie(value,true)) {
				e.preventDefault();

				if (guxApp.locale.isGUX) {
					self.closeOverlay();
				} else {
					$.publish("overlay.hide");
				}
				
				return false;
			}

		});
		
		var country = self.localeArr[self.COUNTRY];
		if (country) {
			$('.country-overlay select option').each(function() {
				var $options = $(this),
					val = $options.attr('value');

				if (val && val.indexOf(country) > 0) {
					$options.attr({'selected' : 'selected'});
				}
			});
		}

		// re-init uniform selects
		if (guxApp.locale.isGUX) {
			$('.locale-modal select').uniform();
		}

	},

	initMenu: function() {

		var $current = $('.countrytab .current'),
			$anchors = $('.country li a'),
			self = this;

		// update Menu text
		if(self.localeArr[self.CONFIRMED] == '1'){
			// convert ["bh", "ar", "1"] => "bh/ar"
			var key = self.localeArr.slice(0,2).join('/');

			$anchors.each(function(){
				var $this = $(this), 
					href = $this.attr('href');

				if(href.indexOf(key) >-1 ){
					$current.text($this.text());
				}
			});
		}

		// bind event to top menu update cookie when click on the anchors
		$anchors.click(function(e){
			var value = $(this).attr('href');
			
			if (value.indexOf(guxApp.locale.locale) < 0){
				self.clearFPSinfo();
			}

			if(!self.updateCookie(value,true)){
				e.preventDefault();
			}
		});

	},

	updateCookie: function(value,confirmed) {

		// update locale cookie: convert url "/en/irq/homeXXX#**" => en-irq-1
		// return 0 means selected locale match the current url
		var self = this;

		if (value) {

			// remove the host name, get the relative path, etc "/en/irq/xxx"
			var host = location.host, i = value.indexOf(host);
			value = i > 0 ? value.substr(i + host.length) : value;
			// remove the first '/' if nessary.
			value = value.charAt(0) == '/' ? value.substr(1) : value;

			// get the locale array, like [ "en", "irq", "0" ]
			var localeArr = value.split('/').slice(0,2);

			if (confirmed){
				localeArr[self.CONFIRMED] = '1';
			}
			else {
				localeArr[self.CONFIRMED] = '0';
			}
			

			$.cookie(self.COOKIEKEY, localeArr.join('-'), {
				expires: 365,
				path: '/'
			});

			

			// whether current URL contains something like "/en/irq/"?
			if (location.href.indexOf('/' + localeArr.slice(0,2).join('/')) > 0) {
				return 0;
			}

		}

		return 1;

	},

	reinitInnerPopup: function() {
		// re-init inner popup
		guxApp.innerPopup.init({
			container : ".reveal-modal"
		});
	},

	realignInnerPopup: function() {

		// align popups correctly for GUX locale overlay
		$('.reveal-modal a.citation').on('click', function() {
			$('.reveal-modal > .inner-popup').removeClass('right-popup');
		});

		$('.reveal-modal .right a.citation').on('click', function() {
			$('.reveal-modal > .inner-popup').addClass('right-popup');
		});

	},

	closeOverlayEvent: function() {

		var self = this;

		// close overlay when clicking on close 'X'
		$('#modalWrap.locale-modal').off('click').on('click', '.icon-close', function(e) {
			e.preventDefault();
			self.closeOverlay();
		});

		$(document).keydown(function(e) {

			// close overlay when ESC key is pressed
			if (e.keyCode == 27) {
				self.closeOverlay();
			}
		});

	},

	closeOverlay: function () {

		// hide modal and then remove content
		$('#modalWrap').modal('hide').removeClass('polk-modal').find('.modal-body').html('');

		guxApp.innerPopup.init();
	},

	clearFPSinfo: function(){
	
		if($.cookie('dfy.uuid')){
			$.removeCookie('dfy.uuid', {path:'/', domain:guxApp.locale.cookieDomain});
		}

		if($.cookie('gt_uid')){
			var dmArray = [];
			dmArray = guxApp.locale.cookieDomain.split('.');

			var dmStr = "." + dmArray[dmArray.length - 2] + "." + dmArray[dmArray.length - 1];
			$.removeCookie('gt_uid', {path:'/', domain:dmStr});
		}

		if($.cookie('dfy.p')){
			$.removeCookie('dfy.p', {path:'/', domain:guxApp.locale.cookieDomain});
		}

		if(sessionStorage.getItem("dfy.p") !== null){
			sessionStorage.removeItem("dfy.p");
		}

		// $.publish('FPS-reset');
	},
	setGTUID: function(){
		//gt_uid is the cookie used by FPS to check user status
		var setCookie = function (sKey, sValue, vEnd, sPath, sDomain, bSecure) {
	        if (!sKey || /^(?:expires|max\-age|path|domain|secure)$/i.test(sKey)) { return false; }
	        var sExpires = "";
	        if (vEnd) {
	            switch (vEnd.constructor) {
	                case Number:
	                    sExpires = vEnd === Infinity ? "; expires=Fri, 31 Dec 9999 23:59:59 GMT" : "; max-age=" + vEnd;
	                    break;
	                case String:
	                    sExpires = "; expires=" + vEnd;
	                    break;
	                case Date:
	                    sExpires = "; expires=" + vEnd.toUTCString();
	                    break;
	            }
	        }
	        document.cookie = encodeURIComponent(sKey) + "=" + encodeURIComponent(sValue) + sExpires + (sDomain ? "; domain=" + sDomain : "") + (sPath ? "; path=" + sPath : "") + (bSecure ? "; secure" : "");
	        return true;
	    };
	    var readCookie = function (name) {
	        var nameEQ = name + "=";
	        var ca = document.cookie.split(';');
	        for (var i = 0; i < ca.length; i++) {
	            var c = ca[i];
	            while (c.charAt(0) == ' ') c = c.substring(1, c.length);
	            if (c.indexOf(nameEQ) == 0) return c.substring(nameEQ.length, c.length);
	        }
	        return null;
	    }
		var UUIDV4 = function b(a) { return a ? (a ^ Math.random() * 16 >> a / 4).toString(16) : ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, b) };
	    var uid = readCookie('gt_uid') || UUIDV4();

	    var now = new Date();
	    var domain = (function () {
	        var i = 0, domain = document.domain, p = domain.split('.'), s = '_gd' + now.getTime();
	        while (i < (p.length - 1) && document.cookie.indexOf(s + '=' + s) == -1) {
	            domain = p.slice(-1 - (++i)).join('.');
	            document.cookie = s + "=" + s + ";domain=" + domain + ";";
	        }
	        document.cookie = s + "=;expires=Thu, 01 Jan 1970 00:00:01 GMT;domain=" + domain + ";";
	        return domain;
	    })();
	    setCookie('gt_uid', uid, new Date(now.getTime() + (365 * 86400000)), '/', domain);
	}

};

$(function() {
	// if ($('#locale-data').length) {
	// 	window.setTimeout(function(){
	// 		guxApp.locale.init();
	// 	}, 1000);
	// }
	guxApp.locale.init();
});

})(jQuery);

